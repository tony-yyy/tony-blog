/*
SQLyog Ultimate v12.09 (64 bit)
MySQL - 5.7.27-log : Database - tonyblog
*********************************************************************
*/

/*!40101 SET NAMES utf8 */;

/*!40101 SET SQL_MODE=''*/;

/*!40014 SET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0 */;
/*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */;
/*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE='NO_AUTO_VALUE_ON_ZERO' */;
/*!40111 SET @OLD_SQL_NOTES=@@SQL_NOTES, SQL_NOTES=0 */;
CREATE DATABASE /*!32312 IF NOT EXISTS*/`tonyblog` /*!40100 DEFAULT CHARACTER SET utf8 */;

USE `tonyblog`;

/*Table structure for table `blog` */

DROP TABLE IF EXISTS `blog`;

CREATE TABLE `blog` (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `commentabled` bit(1) NOT NULL DEFAULT b'0',
  `content` longtext,
  `create_time` datetime DEFAULT CURRENT_TIMESTAMP,
  `description` varchar(255) DEFAULT NULL,
  `first_picture` varchar(500) DEFAULT NULL,
  `flag` varchar(255) DEFAULT NULL,
  `published` bit(1) NOT NULL,
  `recommend` bit(1) NOT NULL DEFAULT b'1',
  `share_statement` bit(1) NOT NULL DEFAULT b'0',
  `title` varchar(255) DEFAULT NULL,
  `update_time` datetime DEFAULT CURRENT_TIMESTAMP,
  `views` int(11) DEFAULT '0',
  `type_id` bigint(20) DEFAULT NULL,
  `user_id` bigint(20) DEFAULT NULL,
  `comment_count` int(255) DEFAULT '0',
  PRIMARY KEY (`id`) USING BTREE,
  KEY `FK292449gwg5yf7ocdlmswv9w4j` (`type_id`) USING BTREE,
  KEY `FK8ky5rrsxh01nkhctmo7d48p82` (`user_id`) USING BTREE,
  CONSTRAINT `FK292449gwg5yf7ocdlmswv9w4j` FOREIGN KEY (`type_id`) REFERENCES `type` (`id`) ON DELETE SET NULL ON UPDATE CASCADE,
  CONSTRAINT `FK8ky5rrsxh01nkhctmo7d48p82` FOREIGN KEY (`user_id`) REFERENCES `user` (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=195 DEFAULT CHARSET=utf8 ROW_FORMAT=DYNAMIC;

/*Data for the table `blog` */

insert  into `blog`(`id`,`commentabled`,`content`,`create_time`,`description`,`first_picture`,`flag`,`published`,`recommend`,`share_statement`,`title`,`update_time`,`views`,`type_id`,`user_id`,`comment_count`) values (156,'','# Mybatis-9.28\r\n\r\n环境：\r\n\r\n* JDK1.8\r\n\r\n* Mysql 5.7\r\n* maven 3.6.1\r\n* IDEA\r\n\r\n回顾：\r\n\r\n* JDBC\r\n* Mysql\r\n* java基础\r\n* Maven\r\n* Junit\r\n\r\n框架：都是有配置文件的：最好的学习方式：看官网文档https://mybatis.org/mybatis-3/zh/index.html\r\n\r\n## 1、简介\r\n\r\n### 1.1、什么是\r\n\r\n### mybatis\r\n\r\n* MyBatis 是一款优秀的**持久层框架**\r\n* 它支持自定义 SQL、存储过程以及高级映射。\r\n* MyBatis 免除了几乎所有的 JDBC 代码以及设置参数和获取结果集的工作。MyBatis 可以通过简单的 XML 或注解来配置和映射原始类型、接口和 Java POJO（Plain Old Java Objects，普通老式 Java 对象）为数据库中的记录。\r\n\r\n如何获得Mybatis？\r\n\r\n* maven仓库\r\n\r\n  ```xml\r\n  <dependency>\r\n      <groupId>org.mybatis</groupId>\r\n      <artifactId>mybatis</artifactId>\r\n      <version>3.5.7</version>\r\n  </dependency>\r\n  ```\r\n\r\n  \r\n\r\n* github： https://github.com/mybatis/mybatis-3/releases\r\n\r\n* 中文文档：https://mybatis.org/mybatis-3/zh/index.html\r\n\r\n### 1.2、持久层\r\n\r\n数据库持久化\r\n\r\n* 持久化就是将程序的数据在持久状态和瞬时状态转换的过程\r\n* 内存：**断电即失**\r\n* 数据库（jdbc），io文件持久化。\r\n\r\n为什么需要持久化？\r\n\r\n* 有一些对象，不能让他丢失\r\n\r\n* 内存太贵了\r\n\r\n### 1.3 持久层\r\n\r\nDao层，service层，controller层。。。\r\n\r\n* 完成持久化工作的代码块\r\n* 层界限十分明显。\r\n\r\n### 1.4、为什么需要mybatis？\r\n\r\n* 帮助程序员将数据存入数据库中\r\n\r\n* 方便\r\n* 传统的JDBC代码太复杂了。简化。框架\r\n* 不用mybatis也可以。更容易上手。**技术没有高低之分**\r\n\r\n## 2、第一个Mybatis程序\r\n\r\n思路：搭建环境》导入mybatis》编写代码》测试\r\n\r\n### 2.1、搭建环境\r\n\r\n数据库\r\n\r\n```sql\r\nCREATE DATABASE mybatis;\r\nUSE mybatis;\r\nCREATE TABLE USER(\r\n	id INT(20) AUTO_INCREMENT PRIMARY KEY,\r\n	NAME VARCHAR(30) DEFAULT NULL,\r\n	pwd VARCHAR(30) DEFAULT NULL\r\n)ENGINE=INNODB DEFAULT CHARSET=UTF8;\r\n\r\nINSERT INTO USER (NAME,pwd) VALUES\r\n(\"李四\",\"12343\"),\r\n(\"张三\",\"123\"),\r\n(\"王五\",\"312\")\r\n```\r\n\r\n新建项目\r\n\r\n1. 新建一个普通maven项目\r\n\r\n2. 删除src目录\r\n\r\n3. 导入maven依赖\r\n\r\n   ```xml\r\n     <!--导入依赖-->\r\n     <dependencies>\r\n       <!--mysql驱动-->\r\n       <dependency>\r\n         <groupId>mysql\r\n         </groupId>\r\n         <artifactId>mysql-connector-java</artifactId>\r\n         <version>5.1.26</version>\r\n       </dependency>\r\n       <!--mybatis-->\r\n       <dependency>\r\n         <groupId>org.mybatis</groupId>\r\n         <artifactId>mybatis</artifactId>\r\n         <version>3.5.1</version>\r\n       </dependency>\r\n       <!--junit-->\r\n       <dependency>\r\n         <groupId>junit</groupId>\r\n         <artifactId>junit</artifactId>\r\n         <version>4.11</version>\r\n         <scope>test</scope>\r\n       </dependency>\r\n     </dependencies>\r\n   ```\r\n\r\n   \r\n\r\n4. 创建项目\r\n\r\n### 2.2、创建一个模块\r\n\r\n* 编写mybatis的核心配置文件\r\n\r\n  ```xml\r\n  <?xml version=\"1.0\" encoding=\"UTF-8\" ?>\r\n  <!DOCTYPE configuration\r\n          PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\"\r\n          \"http://mybatis.org/dtd/mybatis-3-config.dtd\">\r\n  <configuration>\r\n      <environments default=\"development\">\r\n          <environment id=\"development\">\r\n              <transactionManager type=\"JDBC\"/>\r\n              <dataSource type=\"POOLED\">\r\n                  <property name=\"driver\" value=\"com.mysql.jdbc.Driver\"/>\r\n                  <property name=\"url\" value=\"jdbc:mysql://localhost:3306/mybatis?useSSL=true&amp;useUnicode=true&amp;charsetEncoding=UTF-8\"/>\r\n                  <property name=\"username\" value=\"root\"/>\r\n                  <property name=\"password\" value=\"123\"/>\r\n              </dataSource>\r\n          </environment>\r\n      </environments>\r\n  </configuration>\r\n  ```\r\n\r\n* 编写mysql工具栏\r\n\r\n  ```java\r\n  package com.tony.utils;\r\n  \r\n  \r\n  import org.apache.ibatis.io.Resources;\r\n  import org.apache.ibatis.session.SqlSession;\r\n  import org.apache.ibatis.session.SqlSessionFactory;\r\n  import org.apache.ibatis.session.SqlSessionFactoryBuilder;\r\n  \r\n  import java.io.IOException;\r\n  import java.io.InputStream;\r\n  \r\n  // sqlSessionFactory --> sqlSession\r\n  public class MybatisUtils {\r\n      public static SqlSessionFactory ssf = null;\r\n      static {\r\n          try {\r\n              // 1. 使用Mybatis获取sqlSessionFactory对象\r\n              String resource = \"mybatis-config.xml\";\r\n              InputStream is = null;\r\n              is = Resources.getResourceAsStream(resource);\r\n              ssf = new SqlSessionFactoryBuilder().build(is);\r\n          } catch (IOException e) {\r\n              e.printStackTrace();\r\n          }\r\n      }\r\n      // 获取SqlSession对象\r\n      // SqlSession 完全包含了面向数据库执行SQL命令所需的所有方法\r\n      public static SqlSession getSqlSession(){\r\n          return ssf.openSession();\r\n      }\r\n  }\r\n  \r\n  ```\r\n\r\n### 2.3、编写代码\r\n\r\n* 实体类\r\n\r\n  ```java\r\n  public class User {\r\n      private int id;\r\n      private String name;\r\n      private String pwd;\r\n  ```\r\n\r\n  \r\n\r\n* Dao接口\r\n\r\n  ```java\r\n  public interface UserDao {\r\n      List<User> getUserList();\r\n  }\r\n  \r\n  ```\r\n\r\n  \r\n\r\n* 接口实现类，由原来的UserDaoImpl转变为Mapper配置文件\r\n\r\n  ```xml\r\n  <?xml version=\"1.0\" encoding=\"UTF-8\" ?>\r\n  <!DOCTYPE mapper\r\n          PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\"\r\n          \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\">\r\n  <!--namespace=绑定一个对应的Dao/Mapper接口-->\r\n  <mapper namespace=\"com.tony.dao.UserDao\">\r\n      <select id=\"getUserList\" resultType=\"com.tony.domain.User\">\r\n          select * from user\r\n      </select>\r\n  </mapper>\r\n  ```\r\n\r\n### 2.4、测试\r\n\r\n注意点1\r\n\r\norg.apache.ibatis.binding.BindingException: Type interface com.tony.dao.UserDao is not known to the MapperRegistry.\r\n\r\nMapperRegistry\r\n\r\n需要在主配置文件中配置\r\n\r\n```xml\r\n    <!--每一个Mapper.xml都需要在Mybatis核心配置文件中注册-->\r\n    <mappers>\r\n        <mapper resource=\"com/tony/dao/UserMapper.xml\"/>\r\n    </mappers>\r\n```\r\n\r\n注意点2\r\n\r\n出现配置文件初始化异常\r\n\r\n原因：maven没有将配置文件一起放入target > classes中\r\n\r\n解决：配置pom文件\r\n\r\n```xml\r\n    <!--在build中配置resources，来防止我们资源导出失败的问题-->\r\n    <resources>\r\n      <resource>\r\n        <directory>src/main/resources</directory>\r\n        <includes>\r\n          <include>**/*.properties</include>\r\n          <include>**/*.xml</include>\r\n        </includes>\r\n        <filtering>true</filtering>\r\n      </resource>\r\n      <resource>\r\n        <directory>src/main/java</directory>\r\n        <includes>\r\n          <include>**/*.properties</include>\r\n          <include>**/*.xml</include>\r\n        </includes>\r\n        <filtering>true</filtering>\r\n      </resource>\r\n    </resources>\r\n  </build>\r\n```\r\n\r\n\r\n\r\n* junit\r\n\r\n  ```java\r\n  public class UserDaoTest {\r\n      @Test\r\n      public void test(){\r\n          // 1. 获取SqlSession对象\r\n          SqlSession sqlSession = MybatisUtils.getSqlSession();\r\n          // 2. 执行SQL\r\n          UserDao userDao = sqlSession.getMapper(UserDao.class);\r\n          List<User> userList = userDao.getUserList();\r\n          System.out.println(userList);\r\n      }\r\n  }\r\n  ```\r\n\r\n可能会遇到的问题：\r\n\r\n1. 配置文件没有注册\r\n2. 绑定接口错误\r\n3. 方法名不对\r\n4. 返回类型不对\r\n5. Maven导出资源问题\r\n\r\n### 作用域（Scope）和生命周期\r\n\r\n理解我们之前讨论过的不同作用域和生命周期类别是至关重要的，因为错误的使用会导致非常严重的并发问题。\r\n\r\n------\r\n\r\n**提示** **对象生命周期和依赖注入框架**\r\n\r\n依赖注入框架可以创建线程安全的、基于事务的 SqlSession 和映射器，并将它们直接注入到你的 bean 中，因此可以直接忽略它们的生命周期。 如果对如何通过依赖注入框架使用 MyBatis 感兴趣，可以研究一下 MyBatis-Spring 或 MyBatis-Guice 两个子项目。\r\n\r\n------\r\n\r\n#### SqlSessionFactoryBuilder\r\n\r\n这个类可以被实例化、使用和丢弃，一旦创建了 SqlSessionFactory，就不再需要它了。 因此 SqlSessionFactoryBuilder 实例的最佳作用域是方法作用域（也就是局部方法变量）。 你可以重用 SqlSessionFactoryBuilder 来创建多个 SqlSessionFactory 实例，但最好还是不要一直保留着它，以保证所有的 XML 解析资源可以被释放给更重要的事情。\r\n\r\n#### SqlSessionFactory\r\n\r\nSqlSessionFactory 一旦被创建就应该在应用的运行期间一直存在，没有任何理由丢弃它或重新创建另一个实例。 使用 SqlSessionFactory 的最佳实践是在应用运行期间不要重复创建多次，多次重建 SqlSessionFactory 被视为一种代码“坏习惯”。因此 SqlSessionFactory 的最佳作用域是应用作用域。 有很多方法可以做到，最简单的就是使用单例模式或者静态单例模式。\r\n\r\n#### SqlSession\r\n\r\n每个线程都应该有它自己的 SqlSession 实例。SqlSession 的实例不是线程安全的，因此是不能被共享的，所以它的最佳的作用域是请求或方法作用域。 绝对不能将 SqlSession 实例的引用放在一个类的静态域，甚至一个类的实例变量也不行。 也绝不能将 SqlSession 实例的引用放在任何类型的托管作用域中，比如 Servlet 框架中的 HttpSession。 如果你现在正在使用一种 Web 框架，考虑将 SqlSession 放在一个和 HTTP 请求相似的作用域中。 换句话说，每次收到 HTTP 请求，就可以打开一个 SqlSession，返回一个响应后，就关闭它。 这个关闭操作很重要，为了确保每次都能执行关闭操作，你应该把这个关闭操作放到 finally 块中。 下面的示例就是一个确保 SqlSession 关闭的标准模式：\r\n\r\n```\r\ntry (SqlSession session = sqlSessionFactory.openSession()) {\r\n  // 你的应用逻辑代码\r\n}\r\n```\r\n\r\n在所有代码中都遵循这种使用模式，可以保证所有数据库资源都能被正确地关闭。\r\n\r\n## 3、CRUD\r\n\r\n### 1、namespace\r\n\r\nnamespace中的包名要和Dao/mapper接口的包名一致\r\n\r\n### 2、select\r\n\r\n选择，查询语句；\r\n\r\n* id：就是对应的namespace中的方法名\r\n* resultType：Sql语句执行的返回值！\r\n* parameterType：参数类型\r\n\r\n1. 编写接口\r\n\r\n   ```java\r\n       // 查询全部用户\r\n       List<User> getUserList();\r\n       // 根据id查询用户\r\n       User getUserById(int id);\r\n   ```\r\n\r\n   \r\n\r\n2. 编写对应的mapper中的sql语句\r\n\r\n   ```xml\r\n       <select id=\"getUserList\" resultType=\"com.tony.domain.User\">\r\n           select * from user\r\n       </select>\r\n       <select id=\"getUserById\" resultType=\"com.tony.domain.User\" parameterType=\"int\">\r\n           select * from user where id = #{id}\r\n       </select>\r\n   ```\r\n\r\n3. 测试\r\n\r\n   ```java\r\n       @Test\r\n       public void test(){\r\n           // 1. 获取SqlSession对象\r\n           SqlSession sqlSession = MybatisUtils.getSqlSession();\r\n           // 2. 执行SQL\r\n           UserMapper userDao = sqlSession.getMapper(UserMapper.class);\r\n           List<User> userList = userDao.getUserList();\r\n           System.out.println(userList);\r\n           sqlSession.close();\r\n       }\r\n       @Test\r\n       public void test2(){\r\n           // 1. 获取SqlSession对象\r\n           SqlSession sqlSession = MybatisUtils.getSqlSession();\r\n           // 2. 执行SQL\r\n           UserMapper mapper = sqlSession.getMapper(UserMapper.class);\r\n           User user = mapper.getUserById(1);\r\n           System.out.println(user);\r\n           sqlSession.close();\r\n       }\r\n   ```\r\n\r\n### 3、insert\r\n\r\n接口\r\n\r\n```java\r\n// 添加用户\r\nvoid addUser(User user);\r\n```\r\n\r\n配置\r\n\r\n```xml\r\n<insert id=\"addUser\" parameterType=\"com.tony.domain.User\">\r\n    insert into user (name, pwd) values(#{name},#{pwd})\r\n</insert>\r\n```\r\n\r\n测试\r\n\r\n```java\r\n@Test\r\npublic void test3(){\r\n    // 1. 获取SqlSession对象\r\n    SqlSession sqlSession = MybatisUtils.getSqlSession();\r\n    // 2. 执行SQL\r\n    UserMapper mapper = sqlSession.getMapper(UserMapper.class);\r\n    User user = new User();\r\n    user.setName(\"tony\");\r\n    user.setPwd(\"123\");\r\n    mapper.addUser(user);\r\n    // 提交事务\r\n    sqlSession.commit();\r\n    sqlSession.close();\r\n}\r\n```\r\n\r\n### 4、update\r\n\r\n接口\r\n\r\n```java\r\n// 更新用户\r\nvoid updateUser(User user);\r\n```\r\n\r\n配置\r\n\r\n```xml\r\n<update id=\"updateUser\" parameterType=\"com.tony.domain.User\">\r\n    update user set name=#{name},pwd=#{pwd} where name=#{name}\r\n</update>\r\n```\r\n\r\n测试\r\n\r\n```java\r\n@Test\r\npublic void test4(){\r\n    // 1. 获取SqlSession对象\r\n    SqlSession sqlSession = MybatisUtils.getSqlSession();\r\n    // 2. 执行SQL\r\n    UserMapper mapper = sqlSession.getMapper(UserMapper.class);\r\n    User user = new User();\r\n    user.setName(\"tony\");\r\n    user.setPwd(\"456\");\r\n    mapper.updateUser(user);\r\n    // 提交事务\r\n    sqlSession.commit();\r\n    sqlSession.close();\r\n}\r\n```\r\n\r\n### 5、delete\r\n\r\n接口\r\n\r\n```java\r\n// 删除用户\r\nvoid deleteUser(User user);\r\n```\r\n\r\n配置\r\n\r\n```xml\r\n<delete id=\"deleteUser\" parameterType=\"com.tony.domain.User\">\r\n    delete from user where name = #{name}\r\n</delete>\r\n```\r\n\r\n测试\r\n\r\n```java\r\n@Test\r\npublic void test5(){\r\n    // 1. 获取SqlSession对象\r\n    SqlSession sqlSession = MybatisUtils.getSqlSession();\r\n    // 2. 执行SQL\r\n    UserMapper mapper = sqlSession.getMapper(UserMapper.class);\r\n    User user = new User();\r\n    user.setName(\"tony\");\r\n    mapper.deleteUser(user);\r\n    // 提交事务\r\n    sqlSession.commit();\r\n    sqlSession.close();\r\n}\r\n```\r\n\r\n### 6、分析错误\r\n\r\n* 标签不要匹配错误\r\n* resource绑定mapper，需要使用路径\r\n* 程序配置文件必须符合规范\r\n* NulPointerException，没有注册到资源\r\n* 输出的xml文件中存在中文乱码问题\r\n* maven资源没有导出问题\r\n\r\n\r\n\r\n### 6、万能Map\r\n\r\n假如，我们的实体类，或者数据库中的表，字段或者参数过多，我们应当考虑使用Map\r\n\r\n```java\r\n// 万能的Map\r\nvoid addUser2(Map<String, Object> map);\r\n```\r\n\r\n```xml\r\n    <insert id=\"addUser2\" parameterType=\"map\">\r\n        insert into user (name, pwd) values(#{username},#{password})\r\n    </insert>\r\n```\r\n\r\n```java\r\n@Test\r\npublic void test6(){\r\n    // 1. 获取SqlSession对象\r\n    SqlSession sqlSession = MybatisUtils.getSqlSession();\r\n    // 2. 执行SQL\r\n    UserMapper mapper = sqlSession.getMapper(UserMapper.class);\r\n    Map<String, Object> map =  new HashMap<String,Object>();\r\n    map.put(\"username\",5);\r\n    map.put(\"password\",\"1231234\");\r\n    mapper.addUser2(map);\r\n    sqlSession.commit();\r\n    sqlSession.close();\r\n}\r\n```\r\n\r\nMap传递参数，直接再sql中取出key即可  【parameterType=\"map\"】\r\n\r\n对象传递参数，直接再sql中取出对象的属性即可 【parameterType=\"Object\"】\r\n\r\n只有一个基本类型参数的情况下，可以直接再sql中取到\r\n\r\n多个参数用Map，**或者注解**\r\n\r\n### 8、思考题\r\n\r\n模糊查询怎么写？\r\n\r\n1. java代码执行的时候，传递通配符 % %\r\n\r\n   ```java\r\n   List<User> userList = mapper.getUserLike(\"%李%\");\r\n   ```\r\n\r\n2. 在sql拼接中使用通配符\r\n\r\n   ```xml\r\n   select * from user wherer name like \"%\"#{value}\"%\"\r\n   ```\r\n\r\n## 4、配置解析\r\n\r\n### 1、核心配置文件\r\n\r\n* mybatis-config.xml\r\n* MyBatis 的配置文件包含了会深深影响mybatis行为的设置和属性信息\r\n\r\n```\r\nconfiguration（配置）\r\nproperties（属性）\r\nsettings（设置）\r\ntypeAliases（类型别名）\r\ntypeHandlers（类型处理器）\r\nobjectFactory（对象工厂）\r\nplugins（插件）\r\nenvironments（环境配置）\r\nenvironment（环境变量）\r\ntransactionManager（事务管理器）\r\ndataSource（数据源）\r\ndatabaseIdProvider（数据库厂商标识）\r\nmappers（映射器）\r\n```\r\n\r\n### 2、环境配置（environments）\r\n\r\nmybatis 可以配置成适应多种环境\r\n\r\n**不过要记住：景观可以配置多个环境，但每个sqlsessionFatory实例只能选择一种环境**\r\n\r\n学会使用配置多个环境\r\n\r\nmubatis默认的事务管理器就是JDBC，连接池：POOLED\r\n\r\n### 3、属性（proterties）\r\n\r\n我们可以通过properties属性来实现引用配置文件\r\n\r\n这些属性都是可以外部配置且可动态替换的，既可以在典型的java属性文件中配置，也可以通过properties元素的子元素来传递。【db.properties】\r\n\r\n编写一个配置文件\r\n\r\ndb.properties\r\n\r\n```properties\r\ndriver=com.mysql.jdbc.Driver\r\nurl=jdbc:mysql://localhost:3306/mybatis?useSSL=true&amp;useUnicode=true&amp;charsetEncoding=UTF-8\"\r\npassword=123\r\nusername=root\r\n```\r\n\r\n在核心配置文件中引入\r\n\r\n```xml\r\n    <!--引入外部配置文件-->\r\n    <properties resource=\"db.properties\">\r\n        <property name=\"username\" value=\"root\"/>\r\n    </properties>\r\n```\r\n\r\n* 可以直接引入外部文件\r\n* 可以在其中增加一些属性配置\r\n* 如果两个文件有同一个字段，优先使用外部配置文件\r\n\r\n### 4、类型别名（typeAliases）\r\n\r\n* 类型别名是java类型设置一个短的名字\r\n* 存在的意义仅在于用来减少类完全限定名的冗余\r\n\r\n```xml\r\n    <!--可以给实体类起别名-->\r\n    <typeAliases>\r\n        <typeAlias type=\"com.tony.domain.User\" alias=\"User\"/>\r\n    </typeAliases>\r\n```\r\n\r\n也可以指定一个包名，MyBatis会在包名下面搜索需要的Java Bean，比如：\r\n\r\n扫描实体类的包，它的默认别名就是这个类的类名，首字母小写\r\n\r\n```xml\r\n    <typeAliases>\r\n        <package name=\"com.tony.domain\"/>\r\n    </typeAliases>\r\n```\r\n\r\n在实体类比较少的时候，使用第一种方式\r\n\r\n如果实体类十分多，建议使用第二种\r\n\r\n第一种可以DIY别名，第二种则不行，需要在实体上增加注解\r\n\r\n```java\r\n@Alias(\"User\")\r\npublic class User {\r\n```\r\n\r\n### 5、设置\r\n\r\n这是Mybatis中极为重要的调整设置，它们会改变Mybatis的运行时行为\r\n\r\n![image-20211027223946780](cloudDisk/markdown/mybatis笔记.assets/image-20211027223946780.png)\r\n\r\n### 6、其他配置\r\n\r\n- [typeHandlers（类型处理器）](https://mybatis.org/mybatis-3/zh/configuration.html#typeHandlers)\r\n- [objectFactory（对象工厂）](https://mybatis.org/mybatis-3/zh/configuration.html#objectFactory)\r\n- [plugins（插件）](https://mybatis.org/mybatis-3/zh/configuration.html#plugins)\r\n  - mybatis-generator-core\r\n  - mybatis-plus\r\n  - 通用mapper\r\n\r\n### 7、映射器（mappers）\r\n\r\nMapperRegistry: 注册绑定我们的Mapper文件；\r\n\r\n方式1：【推荐使用】\r\n\r\n```xml\r\n    <mappers>\r\n        <mapper resource=\"com/tony/dao/UserMapper.xml\"/>\r\n    </mappers>\r\n```\r\n\r\n方式2：使用class文件绑定注册\r\n\r\n```xml\r\n    <mappers>\r\n        <mapper class=\"com.tony.dao.UserMapper\"/>\r\n    </mappers>\r\n```\r\n\r\n注意点：\r\n\r\n* 接口和它的Mapper配置文件必须同名\r\n* 接口和它的Mapper配置文件必须在同一包下\r\n\r\n方式3：使用扫描包进行注入绑定\r\n\r\n```xml\r\n    <mappers>\r\n        <package name=\"com.tony.dao\"/>\r\n    </mappers>\r\n```\r\n\r\n注意点：\r\n\r\n* 接口和它的Mapper配置文件必须同名\r\n* 接口和它的Mapper配置文件必须在同一包下\r\n\r\n### 8、生命周期和作用域\r\n\r\n生命周期，和作用域，是至关重要的，因为错误的使用会导致非常严重的**并发问题**\r\n\r\nSqlSessionFatoryBuilder:\r\n\r\n* 一旦创建了 SqlSessionFactory：\r\n* 局部变量\r\n\r\nSqlSessionFatory:\r\n\r\n* 就是数据库连接池\r\n* SqlSessionFatory一旦被创建就应该在应用的运行期间一致存在，没有任何理由丢弃和重建创建另一个实例\r\n* SqlSessionFatory：的最佳作用域就是应用作用域\r\n\r\n## 5、 属性名和字段名不一致的问题\r\n\r\n### 1、问题\r\n\r\n属性名\r\n\r\n```java\r\n@Alias(\"User\")\r\npublic class User {\r\n    private int id;\r\n    private String name;\r\n    private String password;\r\n```\r\n\r\n字段名\r\n\r\n![image-20211028220740834](cloudDisk/markdown/mybatis笔记.assets/image-20211028220740834.png)\r\n\r\n```java\r\n    @Test\r\n    public void test(){\r\n        // 1. 获取SqlSession对象\r\n        SqlSession sqlSession = MybatisUtils.getSqlSession();\r\n        // 2. 执行SQL\r\n        UserMapper userDao = sqlSession.getMapper(UserMapper.class);\r\n        List<User> userList = userDao.getUserList();\r\n        System.out.println(userList);\r\n        sqlSession.close();\r\n    }\r\n```\r\n\r\n![image-20211028220912676](cloudDisk/markdown/mybatis笔记.assets/image-20211028220912676.png)\r\n\r\n\r\n\r\n解决方法：\r\n\r\n```java\r\n    <select id=\"getUserList\" resultType=\"User\">\r\n        select id, name, pwd as password  from user\r\n    </select>\r\n```\r\n\r\n![image-20211028220955978](cloudDisk/markdown/mybatis笔记.assets/image-20211028220955978.png)\r\n\r\n### 2、resultMap\r\n\r\n结果集映射\r\n\r\n```\r\nid name pwd\r\nid name password\r\n```\r\n\r\n```xml\r\n<!--结果集映射-->\r\n<resultMap id=\"UserMap\" type=\"User\">\r\n    <!--column数据库中的字段，property实体类中的属性-->\r\n    <result column=\"id\" property=\"id\"/>\r\n    <result column=\"name\" property=\"name\"/>\r\n    <result column=\"pwd\" property=\"password\"/>\r\n</resultMap>\r\n\r\n<select id=\"getUserList\" resultType=\"User\" resultMap=\"UserMap\">\r\n    select * from user\r\n</select>\r\n```\r\n\r\n* resultMap 元素是 MyBatis中最重要最强大的元素\r\n\r\n* ResultMap的设计思想是，对于简单的语句根本不需要配置显式的结果映射，而对于复杂点的语句只需要描述他们的关系就行了\r\n\r\n* ResulrMap 最优秀的地方在于，虽然你已经对它相当了解了，但是根本就不要显示地用到它们\r\n\r\n  \r\n\r\n## 6、日志\r\n\r\n### 6.1、日志工厂\r\n\r\n如果一个数据库操作，出现了异常，需要我们排错，日志是最好的帮手\r\n\r\n曾经：sout、debug\r\n\r\n现在：日志工厂！\r\n\r\n- SLF4J\r\n- Apache Commons Logging\r\n- Log4j 2\r\n- Log4j\r\n- JDK logging\r\n\r\n#### STDOUT_LOGGING标准日志输出\r\n\r\n在mybatis核心配置文件中\r\n\r\n```xml\r\n<configuration>\r\n    <!--引入外部配置文件-->\r\n    <properties resource=\"db.properties\">\r\n        <property name=\"username\" value=\"root\"/>\r\n    </properties>\r\n\r\n    <settings>\r\n        <setting name=\"logImpl\" value=\"STDOUT_LOGGING\"/>\r\n    </settings>\r\n```\r\n\r\n![image-20211213150756073](cloudDisk/markdown/mybatis笔记.assets/image-20211213150756073.png)\r\n\r\n### 6.2、Log4j\r\n\r\n什么是Log4j？\r\n\r\n* Log4j是[Apache](https://baike.baidu.com/item/Apache/8512995)的一个开源项目，通过使用Log4j，我们可以控制日志信息输送的目的地是[控制台](https://baike.baidu.com/item/控制台/2438626)、文件、[GUI](https://baike.baidu.com/item/GUI)组件\r\n* 我们也可以控制每一条日志的输出格式\r\n* 通过定义每一条日志信息的级别，我们能够更加细致地控制日志的生成过程\r\n* 通过一个[配置文件](https://baike.baidu.com/item/配置文件/286550)来灵活地进行配置，而不需要修改应用的代码。\r\n\r\n![image-20211213163057700](cloudDisk/markdown/mybatis笔记.assets/image-20211213163057700.png)\r\n\r\n1. 导包\r\n\r\n   ```cml\r\n                 <dependency>\r\n                       <groupId>log4j</groupId>\r\n                       <artifactId>log4j</artifactId>\r\n                       <version>1.2.17</version>\r\n                   </dependency>\r\n   ```\r\n\r\n2. Log4j配置文件\r\n\r\n   ```properties\r\n   #将等级为DEBUG的日志信息输出到console和file这两个目的地，console和file的定义在下面的代码\r\n   log4j.rootLogger=DEBUG,console,file\r\n   \r\n   #控制台输出的相关设置\r\n   log4j.appender.console = org.apache.log4j.ConsoleAppender\r\n   log4j.appender.console.Target = System.out\r\n   log4j.appender.console.Threshold=DEBUG\r\n   log4j.appender.console.layout = org.apache.log4j.PatternLayout\r\n   log4j.appender.console.layout.ConversionPattern=【%c】-%m%n\r\n   \r\n   #文件输出的相关设置\r\n   log4j.appender.file = org.apache.log4j.RollingFileAppender\r\n   log4j.appender.file.File=./log/kuang.log\r\n   log4j.appender.file.MaxFileSize=10mb\r\n   log4j.appender.file.Threshold=DEBUG\r\n   log4j.appender.file.layout=org.apache.log4j.PatternLayout\r\n   log4j.appender.file.layout.ConversionPattern=【%p】【%d{yy-MM-dd}】【%c】%m%n\r\n   \r\n   #日志输出级别\r\n   log4j.logger.org.mybatis=DEBUG\r\n   log4j.logger.java.sql=DEBUG\r\n   log4j.logger.java.sql.Statement=DEBUG\r\n   log4j.logger.java.sql.ResultSet=DEBUG\r\n   log4j.logger.java.sql.PreparedStatement=DEBUG\r\n   ```\r\n\r\n   or\r\n\r\n   ```properties\r\n   ### 配置根 ###\r\n   #log4j.rootLogger = debug,console ,fileAppender,dailyRollingFile,ROLLING_FILE,MAIL,DATABASE\r\n   log4j.rootLogger = debug,console ,fileAppender,dailyRollingFile,ROLLING_FILE\r\n   \r\n   ### 设置输出sql的级别，其中logger后面的内容全部为jar包中所包含的包名 ###\r\n   log4j.logger.org.apache=dubug\r\n   log4j.logger.java.sql.Connection=dubug\r\n   log4j.logger.java.sql.Statement=dubug\r\n   log4j.logger.java.sql.PreparedStatement=dubug\r\n   log4j.logger.java.sql.ResultSet=dubug\r\n   \r\n   ### 配置输出到控制台 ###\r\n   log4j.appender.console = org.apache.log4j.ConsoleAppender\r\n   log4j.appender.console.Target = System.out\r\n   log4j.appender.console.layout = org.apache.log4j.PatternLayout\r\n   log4j.appender.console.layout.ConversionPattern =  %d{ABSOLUTE} %5p %c{1}:%L - %m%n\r\n   \r\n   ### 配置输出到文件 ###\r\n   log4j.appender.fileAppender = org.apache.log4j.FileAppender\r\n   log4j.appender.fileAppender.File = logs/log.log\r\n   log4j.appender.fileAppender.Append = true\r\n   log4j.appender.fileAppender.Threshold = DEBUG\r\n   log4j.appender.fileAppender.layout = org.apache.log4j.PatternLayout\r\n   log4j.appender.fileAppender.layout.ConversionPattern = %-d{yyyy-MM-dd HH:mm:ss}  [ %t:%r ] - [ %p ]  %m%n\r\n   \r\n   ### 配置输出到文件，并且每天都创建一个文件 ###\r\n   log4j.appender.dailyRollingFile = org.apache.log4j.DailyRollingFileAppender\r\n   log4j.appender.dailyRollingFile.File = logs/log.log\r\n   log4j.appender.dailyRollingFile.Append = true\r\n   log4j.appender.dailyRollingFile.Threshold = DEBUG\r\n   log4j.appender.dailyRollingFile.layout = org.apache.log4j.PatternLayout\r\n   log4j.appender.dailyRollingFile.layout.ConversionPattern = %-d{yyyy-MM-dd HH:mm:ss}  [ %t:%r ] - [ %p ]  %m%n\r\n   \r\n   ### 配置输出到文件，且大小到达指定尺寸的时候产生一个新的文件 ###\r\n   log4j.appender.ROLLING_FILE=org.apache.log4j.RollingFileAppender \r\n   log4j.appender.ROLLING_FILE.Threshold=ERROR \r\n   log4j.appender.ROLLING_FILE.File=rolling.log \r\n   log4j.appender.ROLLING_FILE.Append=true \r\n   log4j.appender.ROLLING_FILE.MaxFileSize=10KB \r\n   log4j.appender.ROLLING_FILE.MaxBackupIndex=1 \r\n   log4j.appender.ROLLING_FILE.layout=org.apache.log4j.PatternLayout \r\n   log4j.appender.ROLLING_FILE.layout.ConversionPattern=[framework] %d - %c -%-4r [%t] %-5p %c %x - %m%n\r\n   \r\n   ### 配置输出到邮件 ###\r\n   #log4j.appender.MAIL=org.apache.log4j.net.SMTPAppender\r\n   #log4j.appender.MAIL.Threshold=FATAL\r\n   #log4j.appender.MAIL.BufferSize=10\r\n   #log4j.appender.MAIL.From=chenyl@yeqiangwei.com\r\n   #log4j.appender.MAIL.SMTPHost=mail.hollycrm.com\r\n   #log4j.appender.MAIL.Subject=Log4J Message\r\n   #log4j.appender.MAIL.To=chenyl@yeqiangwei.com\r\n   #log4j.appender.MAIL.layout=org.apache.log4j.PatternLayout\r\n   #log4j.appender.MAIL.layout.ConversionPattern=[framework] %d - %c -%-4r [%t] %-5p %c %x - %m%n\r\n   \r\n   ### 配置输出到数据库 ###\r\n   #log4j.appender.DATABASE=org.apache.log4j.jdbc.JDBCAppender\r\n   #log4j.appender.DATABASE.URL=jdbc:mysql://localhost:3306/test\r\n   #log4j.appender.DATABASE.driver=com.mysql.jdbc.Driver\r\n   #log4j.appender.DATABASE.user=root\r\n   #log4j.appender.DATABASE.password=123\r\n   #log4j.appender.DATABASE.sql=INSERT INTO LOG4J (Message) VALUES (\'[framework] %d - %c -%-4r [%t] %-5p %c %x - %m%n\')\r\n   #log4j.appender.DATABASE.layout=org.apache.log4j.PatternLayout\r\n   #log4j.appender.DATABASE.layout.ConversionPattern=[framework] %d - %c -%-4r [%t] %-5p %c %x - %m%n\r\n   #log4j.appender.A1=org.apache.log4j.DailyRollingFileAppender\r\n   #log4j.appender.A1.File=SampleMessages.log4j\r\n   #log4j.appender.A1.DatePattern=yyyyMMdd-HH\'.log4j\'\r\n   #log4j.appender.A1.layout=org.apache.log4j.xml.XMLLayout\r\n   ```\r\n\r\n   \r\n\r\n3. 配置log4j为日志的实现\r\n\r\n   ```xml\r\n       <settings>\r\n           <!--标准日志-->\r\n   <!--        <setting name=\"logImpl\" value=\"STDOUT_LOGGING\"/>-->\r\n           <!--log4j-->\r\n           <setting name=\"logImpl\" value=\"LOG4J\"/>\r\n       </settings>\r\n   ```\r\n\r\n4. ![image-20211213152307806](cloudDisk/markdown/mybatis笔记.assets/image-20211213152307806.png)\r\n\r\n#### 简单使用\r\n\r\n1. 导包：\r\n\r\n   ```java\r\n   import org.apache.log4j.Logger;\r\n   ```\r\n\r\n2. 日志对象，参数为当前的class\r\n\r\n   ```java\r\n   static Logger logger = Logger.getLogger(UserDaoTest.class);\r\n   ```\r\n\r\n3. 日志级别\r\n\r\n   ```java\r\n   logger.info(\"info:进入了testLog4j\");\r\n   logger.debug(\"debug:进入了testLog4j\");\r\n   logger.error(\"error:进入了testLog4j\");\r\n   ```\r\n\r\n   \r\n\r\n## 7、分页\r\n\r\n思考：为什么分页？\r\n\r\n* 减少数据的处理量\r\n\r\n### 7.1、使用Limit分页\r\n\r\n```sql\r\n语法：select * from user limit startIndex, pageSize;\r\nSELECT * FROM user lmit 3; #[0, n]\r\n```\r\n\r\n### 7.2、使用Mybatis实现分类\r\n\r\n1. 接口\r\n\r\n   ```xml\r\n   List<User> getUserByLimit(Map<String, Integer> map);\r\n   ```\r\n\r\n   \r\n\r\n2. Mapper.xml\r\n\r\n   ```xml\r\n       <select id=\"getUserByLimit\" parameterType=\"map\" resultType=\"User\" resultMap=\"UserMap\">\r\n           select * from mybatis.user limit #{startIndex}, #{pageSize}\r\n       </select>\r\n   ```\r\n\r\n   \r\n\r\n3. 测试\r\n\r\n   ```java\r\n       @Test\r\n       public void test03(){\r\n           SqlSession sqlSession = MybatisUtils.getSqlSession();\r\n           UserMapper mapper = sqlSession.getMapper(UserMapper.class);\r\n           Map<String, Integer> map = new HashMap<>();\r\n           map.put(\"pageSize\", 2);\r\n           map.put(\"startIndex\", 0);\r\n           List<User> userByLimit = mapper.getUserByLimit(map);\r\n           System.out.println(userByLimit);\r\n           sqlSession.close();\r\n       }\r\n   ```\r\n\r\n   ![image-20211213160625529](cloudDisk/markdown/mybatis笔记.assets/image-20211213160625529.png)\r\n\r\n### 7.3、RowBounds分页\r\n\r\n不再使用SQL实现分页\r\n\r\n1. 接口\r\n\r\n   ```java\r\n    List<User> getUserByBounds();\r\n   ```\r\n\r\n   \r\n\r\n2. mapper.xml\r\n\r\n   ```xml\r\n   <select id=\"getUserByBounds\" resultMap=\"UserMap\">\r\n       select * from mybatis.user\r\n   </select>\r\n   ```\r\n\r\n   \r\n\r\n3. 测试\r\n\r\n   ```java\r\n       @Test\r\n       public void test03(){\r\n           SqlSession sqlSession = MybatisUtils.getSqlSession();\r\n           RowBounds rowBounds = new RowBounds(2, 2);\r\n           List<User> users = sqlSession.selectList(\"com.tony.dao.UserMapper.getUserByBounds\", null, rowBounds);\r\n           System.out.println(users);\r\n   \r\n           sqlSession.close();\r\n       }\r\n   ```\r\n\r\n### 7.4、分页插件\r\n\r\n![image-20211213162616517](cloudDisk/markdown/mybatis笔记.assets/image-20211213162616517.png)\r\n\r\n了解即可，万一以后架构师，说要使用，知道这个东西即可\r\n\r\n## 8、使用注解开发\r\n\r\n### 8.1、面向接口编程\r\n\r\n解耦合\r\n\r\n### 8.2、使用注解开发\r\n\r\n1. 注解在接口上实现\r\n\r\n   ```java\r\n   public interface UserMapper {\r\n       @Select(\"select * from user\")\r\n       List<User> getUserList();\r\n   ```\r\n\r\n2. 需要在核心配置文件中绑定接口\r\n\r\n   ```xml\r\n   <mappers>\r\n       <mapper class=\"com.tony.dao.UserMapper\"/>\r\n   </mappers>\r\n   ```\r\n\r\n3. 测试\r\n\r\n本质：反射机制实现\r\n\r\n底层：动态代理\r\n\r\n![image-20211213164322690](cloudDisk/markdown/mybatis笔记.assets/image-20211213164322690.png)\r\n\r\n**Mybatis执行流程**\r\n\r\n1. Resources 获取加载全局配置文件\r\n\r\n2. 实例化SqlSessionFactoryBuilder构造器\r\n3. 机械配置文件流XMLConfigBuilder\r\n4. Configuration所有的配置信息\r\n5. sqlSessionFactory实例化\r\n6. transaction事物管理\r\n7. 创建executor执行器\r\n8. 创建sqlSession\r\n9. 实现CRUD\r\n   * 事物回滚：跳到6\r\n10. 查看是否执行成功\r\n    * 成功：往下走\r\n    * 失败：跳到6\r\n11. 提交事物\r\n12. 关闭\r\n\r\n### 8.3、CRUD\r\n\r\n#### select\r\n\r\n```java\r\n@Select(\"select * from user where id = #{id}\")\r\nUser getUserById(@Param(\"id\") int id);\r\n```\r\n\r\n```java\r\n@Test\r\npublic void test01(){\r\n    SqlSession sqlSession = MybatisUtils.getSqlSession();\r\n    UserMapper mapper = sqlSession.getMapper(UserMapper.class);\r\n    User user = mapper.getUserById(1);\r\n    System.out.println(user);\r\n\r\n    sqlSession.close();\r\n}\r\n```\r\n\r\n![image-20211213165959769](cloudDisk/markdown/mybatis笔记.assets/image-20211213165959769.png)\r\n\r\n#### insert\r\n\r\n```java\r\n@Insert(\"insert into user(id, name, pwd) values (#{id}, #{name}, #{password})\")\r\nvoid addUser(User user);\r\n```\r\n\r\n```java\r\n@Test\r\npublic void test01(){\r\nSqlSession sqlSession = MybatisUtils.getSqlSession();\r\nUserMapper mapper = sqlSession.getMapper(UserMapper.class);\r\nmapper.addUser( new User(5, \"hello\", \"456123\"));\r\n\r\nsqlSession.close();\r\n}\r\n```\r\n\r\n![image-20211213170419078](cloudDisk/markdown/mybatis笔记.assets/image-20211213170419078.png)\r\n\r\n#### update\r\n\r\n```java\r\n    @Update(\"update user set name=#{name}, pwd=#{password} where id = #{id}\")\r\n    void updateUser(User user);\r\n```\r\n\r\n```java、\r\n    @Test\r\n    public void test01(){\r\n        SqlSession sqlSession = MybatisUtils.getSqlSession();\r\n        UserMapper mapper = sqlSession.getMapper(UserMapper.class);\r\n        mapper.updateUser(new User(5, \"yangwei\", \"1516\"));\r\n\r\n        sqlSession.close();\r\n    }\r\n```\r\n\r\n![image-20211213170640304](cloudDisk/markdown/mybatis笔记.assets/image-20211213170640304.png)\r\n\r\n#### delete\r\n\r\n```java\r\n    @Delete(\"delete from user where id = #{uid}\")\r\n    void deleteUser(@Param(\"uid\") int id);\r\n```\r\n\r\n```java\r\n@Test\r\npublic void test01(){\r\n    SqlSession sqlSession = MybatisUtils.getSqlSession();\r\n    UserMapper mapper = sqlSession.getMapper(UserMapper.class);\r\n    mapper.deleteUser(5);\r\n    sqlSession.close();\r\n}\r\n```\r\n\r\n![image-20211213170848588](cloudDisk/markdown/mybatis笔记.assets/image-20211213170848588.png)\r\n\r\n\r\n\r\n#### 总结：\r\n\r\n编写接口\r\n\r\n```java\r\npublic interface UserMapper {\r\n    @Select(\"select * from user\")\r\n    List<User> getUserList();\r\n\r\n    @Select(\"select * from user where id = #{id}\")\r\n    User getUserById(@Param(\"id\") int id);\r\n\r\n    @Insert(\"insert into user(id, name, pwd) values (#{id}, #{name}, #{password})\")\r\n    void addUser(User user);\r\n\r\n    @Update(\"update user set name=#{name}, pwd=#{password} where id = #{id}\")\r\n    void updateUser(User user);\r\n\r\n    @Delete(\"delete from user where id = #{uid}\")\r\n    void deleteUser(@Param(\"uid\") int id);\r\n```\r\n\r\n测试类\r\n\r\n【注意：我们必须要将接口注册绑定到核心配置文件中】\r\n\r\n#### 关于@Param()注解\r\n\r\n* 基本类型的参数或者String类型，需要加上\r\n* 引用类型不需要加\r\n* 如果只有一个基本数据类型的话，可以忽略，但是建议还是加上！\r\n* 我们在SQL中引用的就是我们这里的@Param()中设定的属性名\r\n\r\n\r\n\r\n#### #{} ${}区别\r\n\r\n#{} 预编译防止sql注入\r\n\r\n## 9、Lombok\r\n\r\n```\r\nProject Lombok is a java library that automatically plugs into your editor and build tools, spicing up your java.\r\nNever write another getter or equals method again, with one annotation your class has a fully featured builder, Automate your logging variables, and much more.\r\n```\r\n\r\n使用步骤：\r\n\r\n1. 在IDEA中安装Lombok依赖插件\r\n\r\n   \r\n\r\n2. 在项目中导入lombok的jar包\r\n\r\n   ```xml\r\n       <dependency>\r\n         <groupId>org.projectlombok</groupId>\r\n         <artifactId>lombok</artifactId>\r\n         <version>1.18.22</version>\r\n       </dependency>\r\n   ```\r\n\r\n   \r\n\r\n```\r\n@Getter and @Setter\r\n@FieldNameConstants\r\n@ToString\r\n@EqualsAndHashCode\r\n@AllArgsConstructor, @RequiredArgsConstructor and @NoArgsConstructor\r\n@Log, @Log4j, @Log4j2, @Slf4j, @XSlf4j, @CommonsLog, @JBossLog, @Flogger, @CustomLog\r\n@Data\r\n@Builder\r\n@SuperBuilder\r\n@Singular\r\n@Delegate\r\n@Value\r\n@Accessors\r\n@Wither\r\n@With\r\n@SneakyThrows\r\n@val\r\n@var\r\nexperimental @var\r\n@UtilityClass\r\n@ExtensionMethod (Experimental, activate manually in plugin settings)\r\nLombok config system\r\n```\r\n\r\n## 10、多对一处理\r\n\r\n多对一：\r\n\r\n![image-20211213173031767](cloudDisk/markdown/mybatis笔记.assets/image-20211213173031767.png)\r\n\r\n* 多个学生，对应一个老手\r\n* 对于学生而言，关联。。。多个学生，关联一个老师【多对一】\r\n* 对于老师而言\r\n\r\n### 测试环境搭建\r\n\r\n1. 导入lombok\r\n2. 新建实体类：Teacher，Student\r\n3. 简历Mapper接口\r\n4. 简历Mapper.xml文件\r\n5. 在核心配置文件中绑定我们的Mapper接口或者文件\r\n\r\n```sql\r\nCREATE TABLE student(\r\n	id INT(20) AUTO_INCREMENT PRIMARY KEY,\r\n	NAME VARCHAR(30) DEFAULT NULL,\r\n	tid INT(20) DEFAULT NULL\r\n)ENGINE=INNODB DEFAULT CHARSET=UTF8;\r\n\r\nCREATE TABLE teacher(\r\n	id INT(20) AUTO_INCREMENT PRIMARY KEY,\r\n	NAME VARCHAR(30) DEFAULT NULL\r\n)ENGINE=INNODB DEFAULT CHARSET=UTF8;\r\n\r\nINSERT INTO student (NAME, tid) VALUES (\"张三\", 1);\r\nINSERT INTO student (NAME, tid) VALUES (\"李四\", 1);\r\nINSERT INTO student (NAME, tid) VALUES (\"王五\", 1);\r\nINSERT INTO student (NAME, tid) VALUES (\"牛二\", 1);\r\nSELECT * FROM student;\r\n\r\n\r\n```\r\n\r\n\r\n\r\n### 按照查询嵌套处理\r\n\r\nStudent类：\r\n\r\n```java\r\n@Data\r\npublic class Student {\r\n    private int id;\r\n    private String name;\r\n    private Teacher teacher;\r\n}\r\n```\r\n\r\nTeacher类：\r\n\r\n```java\r\n@Data\r\npublic class Teacher {\r\n    private int id;\r\n    private String name;\r\n    private List<Student> students;\r\n}\r\n\r\n```\r\n\r\nStudentMapper：\r\n\r\n```java\r\npublic interface StudentMapper {\r\n    // 查找所有学生\r\n    List<Student> getStudents();\r\n}\r\n```\r\n\r\n\r\n\r\n**子查询**\r\n\r\n![image-20211213182557869](cloudDisk/markdown/mybatis笔记.assets/image-20211213182557869.png)\r\n\r\n**按照结果嵌套查询**\r\n\r\nStudentMapper.xml:\r\n\r\n```xml\r\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\r\n<!DOCTYPE mapper\r\n        PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\"\r\n        \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\">\r\n<!--namespace=绑定一个对应的Dao/Mapper接口-->\r\n<mapper namespace=\"com.tony.dao.StudentMapper\">\r\n    <select id=\"getStudents\" resultMap=\"studentTeacherMap\">\r\n        SELECT s.id, s.name, t.name tname\r\n        FROM student s, teacher t\r\n        WHERE s.tid = t.id\r\n    </select>\r\n    <!-- 结果集映射，映射类型：Student -->\r\n    <resultMap id=\"studentTeacherMap\" type=\"com.tony.domain.Student\">\r\n        <result property=\"id\" column=\"id\"/>\r\n        <result property=\"name\" column=\"name\"/>\r\n        <association property=\"teacher\" javaType=\"Teacher\">\r\n            <result property=\"name\" column=\"tname\"/>\r\n        </association>\r\n    </resultMap>\r\n</mapper>\r\n```\r\n\r\n测试：\r\n\r\n```java\r\n@Test\r\npublic void test01(){\r\n    SqlSession sqlSession = MybatisUtils.getSqlSession();\r\n    StudentMapper mapper = sqlSession.getMapper(StudentMapper.class);\r\n    List<Student> students = mapper.getStudents();\r\n    for (Student student : students) {\r\n        System.out.println(student);\r\n    }\r\n    sqlSession.close();\r\n}\r\n```\r\n\r\n![image-20211213212715737](cloudDisk/markdown/mybatis笔记.assets/image-20211213212715737.png)\r\n\r\n回顾MySQL多对一查询方式\r\n\r\n* 子查询\r\n* 联表查询\r\n\r\n## 11、一对多处理\r\n\r\n比如：一个老师拥有多个学生\r\n\r\n对老师而言，是一对多\r\n\r\nTeacherMapper：\r\n\r\n```java\r\npublic interface TeacherMapper {\r\n    // 根据id查找老师\r\n    Teacher getTeacherById(int id);\r\n}\r\n```\r\n\r\n### 按照结果嵌套处理\r\n\r\n```xml\r\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\r\n<!DOCTYPE mapper\r\n        PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\"\r\n        \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\">\r\n<!--namespace=绑定一个对应的Dao/Mapper接口-->\r\n<mapper namespace=\"com.tony.dao.TeacherMapper\">\r\n    <select id=\"getTeacherById\" parameterType=\"int\" resultMap=\"teacherStudentMap\">\r\n        SELECT s.id sid, s.name sname, t.name tname, t.id tid FROM student s, teacher t\r\n        WHERE t.`id` = s.`tid` AND t.`id` = #{id}\r\n    </select>\r\n    <resultMap id=\"teacherStudentMap\" type=\"Teacher\">\r\n        <result property=\"id\" column=\"tid\"/>\r\n        <result property=\"name\" column=\"tname\"/>\r\n        <collection property=\"students\" ofType=\"Student\">\r\n            <result property=\"id\" column=\"sid\"/>\r\n            <result property=\"name\" column=\"tname\"/>\r\n        </collection>\r\n    </resultMap>\r\n</mapper>\r\n```\r\n\r\n测试类：\r\n\r\n```java\r\n@Test\r\npublic void test01(){\r\n    SqlSession sqlSession = MybatisUtils.getSqlSession();\r\n    TeacherMapper mapper = sqlSession.getMapper(TeacherMapper.class);\r\n    Teacher teacher = mapper.getTeacherById(1);\r\n    System.out.println(teacher);\r\n    sqlSession.close();\r\n}\r\n```\r\n\r\n![image-20211213215706085](cloudDisk/markdown/mybatis笔记.assets/image-20211213215706085.png)\r\n\r\n\r\n\r\n### 按照查询嵌套处理\r\n\r\n![image-20211213201859594](cloudDisk/markdown/mybatis笔记.assets/image-20211213201859594.png)\r\n\r\n### 小结\r\n\r\n1. 关联 - association 【多对一】\r\n2. 集合 - collection 【一对多】\r\n3. javaType & offType\r\n   1. JavaType 用来指定实体类中属性的类型\r\n   2. offType 用来指定映射到List或者集合中的 pojo 类型，泛型中的约束类型\r\n\r\n注意点：\r\n\r\n* 保证SQL的可读性，尽量保证通俗易懂\r\n* 注意一对多和多对一中，属性名和字段的问题！\r\n* 如果问题不好排查错误，可以使用日志，建议使用Log4j\r\n\r\n面试高频\r\n\r\n* MySQL引擎\r\n* InnoDB底层原理\r\n* 索引\r\n* 索引优化\r\n\r\n## 12、懒加载\r\n\r\nhttps://blog.csdn.net/weixin_43878909/article/details/123532780\r\n\r\n**延迟加载**：也叫做懒加载，就是用到数据时才进行查询加载，不需要用到时不进行加载。\r\n\r\n**优缺点：**\r\n\r\n- 优点：先从单表查询，需要时再从关联表去关联查询，⼤⼤提⾼数据库性能，因为查询单表要⽐关联查询多张表速度要快.\r\n- 缺点：因为只有在用到数据时，才会去查询数据库，这样在大批量的数据查询时，查询工作也会消耗时间，可能造成用户请求响应慢，造成用户等待时间边长，使用户体验感变差。\r\n\r\n**适用场景：**\r\n\r\n- 延迟加载：在一对多、多对多时采用延迟加载；即查询的对象内有集合类型属性\r\n- 立即加载：在一对一、多对一时采用立即加载。\r\n\r\n*延迟加载是基于嵌套查询来实现的。*\r\n\r\n### 实例：查询某个部门的所有员工\r\n\r\n#### 准备工作\r\n\r\n部门表\r\n\r\n```java\r\n@Data\r\n@AllArgsConstructor\r\n@NoArgsConstructor\r\npublic class Dept {\r\n    private Integer id;\r\n    private String name;\r\n    private List<Emp> emps;\r\n}\r\n```\r\n\r\n员工表\r\n\r\n```java\r\n@Data\r\n@AllArgsConstructor\r\n@NoArgsConstructor\r\npublic class Emp {\r\n    private Integer id;\r\n    private String empName;\r\n    private Integer age;\r\n    private Integer sex;\r\n    private String email;\r\n    private Dept dept;\r\n\r\n}\r\n```\r\n\r\nmybatis实现类\r\n\r\n```xml\r\n<resultMap id=\"dept\" type=\"com.tony.pojo.Dept\">\r\n    <result property=\"id\" column=\"did\"></result>\r\n    <result property=\"name\" column=\"dept_name\"></result>\r\n    <collection property=\"emps\" ofType=\"com.tony.pojo.Emp\" javaType=\"list\" column=\"did\" select=\"getEmpsByDeptId\">\r\n    </collection>\r\n</resultMap>\r\n<select id=\"getEmpsByDeptId\" parameterType=\"int\" resultMap=\"empDept\">\r\n    select * from t_emp where did = #{did}\r\n</select>\r\n<select id=\"getDept\" parameterType=\"int\" resultMap=\"dept\">\r\n    select * from t_dept where did = #{id}\r\n</select>\r\n```\r\n\r\n* collection标签中，ofType为List中的泛型，column为参数，作为 select=\"getEmpsByDeptId\"语句的参数！\r\n\r\n#### 测试\r\n\r\n```java\r\n        Dept dept1 = mapper.getDept(1);\r\n        System.out.println(\"部门名：\" + dept1.getName());\r\n        logger.info(\"暂停2秒....\");\r\n        Thread.sleep(2000);\r\n        logger.info(dept1);\r\n```\r\n\r\n1. collection标签参数：默认fetchType=\"eager\"，立即查询\r\n\r\n执行时：![image-20220531143809090](cloudDisk/markdown/mybatis笔记.assets/image-20220531143809090.png)\r\n\r\n2. 当fetchType改为”lazy“\r\n\r\n```xml\r\n<collection property=\"emps\" ofType=\"com.tony.pojo.Emp\" javaType=\"list\" column=\"did\" select=\"getEmpsByDeptId\" fetchType=\"lazy\">\r\n</collection>\r\n```\r\n\r\n![image-20220531144024210](cloudDisk/markdown/mybatis笔记.assets/image-20220531144024210.png)\r\n\r\n## 13、动态 SQL\r\n\r\n什么是动态SQL：动态SQL就是更具不同的条件生成不同的SQL语句\r\n\r\n利用动态SQL这一特性可以彻底摆脱这种痛苦\r\n\r\n动态 SQL 是 MyBatis 的强大特性之一。如果你使用过 JDBC 或其它类似的框架，你应该能理解根据不同条件拼接 SQL 语句有多痛苦，例如拼接时要确保不能忘记添加必要的空格，还要注意去掉列表最后一个列名的逗号。利用动态 SQL，可以彻底摆脱这种痛苦。\r\n\r\n使用动态 SQL 并非一件易事，但借助可用于任何 SQL 映射语句中的强大的动态 SQL 语言，MyBatis 显著地提升了这一特性的易用性。\r\n\r\n如果你之前用过 JSTL 或任何基于类 XML 语言的文本处理器，你对动态 SQL 元素可能会感觉似曾相识。在 MyBatis 之前的版本中，需要花时间了解大量的元素。借助功能强大的基于 OGNL 的表达式，MyBatis 3 替换了之前的大部分元素，大大精简了元素种类，现在要学习的元素种类比原来的一半还要少。\r\n\r\n- if\r\n- choose (when, otherwise)\r\n- trim (where, set)\r\n- foreach\r\n\r\n### 搭建环境\r\n\r\n```sql\r\nCREATE TABLE blog(\r\n  id varchar(50) not null comment \"博客id\",\r\n  title varchar(100) not null comment \"博客标题\",\r\n  author VARCHAR(30) NOT NULL COMMENT \"博客作者\",\r\n  create_time datetime NOT NULL COMMENT \"创建时间\",\r\n  views int(30) NOT NULL COMMENT \"浏览量\"\r\n)ENGINE=INNODB DEFAULT CHARSET=UTF8;\r\n\r\n```\r\n\r\n\r\n\r\n创建几个基础工程\r\n\r\n1. 导包\r\n2. 编写配置文件\r\n3. 编写实体类\r\n4. 编写实体类对应的Mapper接口和Mapper.xml文件\r\n\r\n### if\r\n\r\n应用：实现搜索\r\n\r\n![image-20211213222346483](cloudDisk/markdown/mybatis笔记.assets/image-20211213222346483.png)\r\n\r\n\r\n\r\n### choose\r\n\r\n![image-20211213223404936](cloudDisk/markdown/mybatis笔记.assets/image-20211213223404936.png)\r\n\r\n* when都不成立，才会拼接otherwise\r\n* choose 相当于switch，when相当于带了break的case，otherwise相当于default\r\n\r\n### trim(where, set)\r\n\r\n![image-20211213223417243](cloudDisk/markdown/mybatis笔记.assets/image-20211213223417243.png)\r\n\r\n**所谓的动态SQL，本质还是SQL语句，只是我们可以在SQL层面，去执行一个逻辑代码**\r\n\r\n前面几个例子已经方便地解决了一个臭名昭著的动态 SQL 问题。现在回到之前的 “if” 示例，这次我们将 “state = ‘ACTIVE’” 设置成动态条件，看看会发生什么。\r\n\r\n```\r\n<select id=\"findActiveBlogLike\"\r\n     resultType=\"Blog\">\r\n  SELECT * FROM BLOG\r\n  WHERE\r\n  <if test=\"state != null\">\r\n    state = #{state}\r\n  </if>\r\n  <if test=\"title != null\">\r\n    AND title like #{title}\r\n  </if>\r\n  <if test=\"author != null and author.name != null\">\r\n    AND author_name like #{author.name}\r\n  </if>\r\n</select>\r\n```\r\n\r\n如果没有匹配的条件会怎么样？最终这条 SQL 会变成这样：\r\n\r\n```sql\r\nSELECT * FROM BLOG\r\nWHERE\r\n```\r\n\r\n这会导致查询失败。如果匹配的只是第二个条件又会怎样？这条 SQL 会是这样:\r\n\r\n```sql\r\nSELECT * FROM BLOG\r\nWHERE\r\nAND title like ‘someTitle’\r\n```\r\n\r\n这个查询也会失败。这个问题不能简单地用条件元素来解决。这个问题是如此的难以解决，以至于解决过的人不会再想碰到这种问题。\r\n\r\nMyBatis 有一个简单且适合大多数场景的解决办法。而在其他场景中，可以对其进行自定义以符合需求。而这，只需要一处简单的改动：\r\n\r\n```xml\r\n<select id=\"findActiveBlogLike\"\r\n     resultType=\"Blog\">\r\n  SELECT * FROM BLOG\r\n  <where>\r\n    <if test=\"state != null\">\r\n         state = #{state}\r\n    </if>\r\n    <if test=\"title != null\">\r\n        AND title like #{title}\r\n    </if>\r\n    <if test=\"author != null and author.name != null\">\r\n        AND author_name like #{author.name}\r\n    </if>\r\n  </where>\r\n</select>\r\n```\r\n\r\n*where* 元素只会在子元素返回任何内容的情况下才插入 “WHERE” 子句。而且，若子句的开头为 “AND” 或 “OR”，*where* 元素也会将它们去除。\r\n\r\n如果 *where* 元素与你期望的不太一样，你也可以通过自定义 trim 元素来定制 *where* 元素的功能。比如，和 *where* 元素等价的自定义 trim 元素为：\r\n\r\n```\r\n<trim prefix=\"WHERE\" prefixOverrides=\"AND |OR \">\r\n  ...\r\n</trim>\r\n```\r\n\r\n***prefixOverrides* 属性会忽略通过管道符分隔的文本序列（注意此例中的空格是必要的）。上述例子会移除所有 *prefixOverrides* 属性中指定的内容，并且插入 *prefix* 属性中指定的内容。**\r\n\r\n* 通俗点说就是：\r\n  * 如果where标签执行完，啥内容也没，where不会加上\r\n  * 如果有内容，一定会移除，前缀为prefixOverrides里面的东西！相当于python里的.lstrip()\r\n  * 有内容，必定在前面加上 prefix\r\n\r\n用于动态更新语句的类似解决方案叫做 *set*。*set* 元素可以用于动态包含需要更新的列，忽略其它不更新的列。比如：\r\n\r\n```xml\r\n<update id=\"updateAuthorIfNecessary\">\r\n  update Author\r\n    <set>\r\n      <if test=\"username != null\">username=#{username},</if>\r\n      <if test=\"password != null\">password=#{password},</if>\r\n      <if test=\"email != null\">email=#{email},</if>\r\n      <if test=\"bio != null\">bio=#{bio}</if>\r\n    </set>\r\n  where id=#{id}\r\n</update>\r\n```\r\n\r\n这个例子中，*set* 元素会动态地在行首插入 SET 关键字，并会删掉额外的逗号（这些逗号是在使用条件语句给列赋值时引入的）。\r\n\r\n来看看与 *set* 元素等价的自定义 *trim* 元素吧：\r\n\r\n```xml\r\n<trim prefix=\"SET\" suffixOverrides=\",\">\r\n  ...\r\n</trim>\r\n```\r\n\r\n**注意，我们覆盖了后缀值设置，并且自定义了前缀值。**\r\n\r\nif\r\n\r\nwhere, set, choose, when\r\n\r\n### SQL片段\r\n\r\n有时候，会将一些功能的部分抽取出来，方便复用！\r\n\r\n1. 使用SQL标签抽取公共的部分\r\n\r\n   ![image-20211213231412639](cloudDisk/markdown/mybatis笔记.assets/image-20211213231412639.png)\r\n\r\n2. 在需要使用的地方使用include标签引用即可\r\n\r\n   ![image-20211213231422954](cloudDisk/markdown/mybatis笔记.assets/image-20211213231422954.png)\r\n\r\n注意事项：\r\n\r\n* 最好基于表单来定义SQL片段！\r\n* 不要存在where标签\r\n\r\n### Foreach\r\n\r\n```sql\r\nselect * from user where 1=1 and (id=1 or id=2 or id=3)\r\n```\r\n\r\n![image-20211213232636896](cloudDisk/markdown/mybatis笔记.assets/image-20211213232636896.png)\r\n\r\n![image-20211213232948093](cloudDisk/markdown/mybatis笔记.assets/image-20211213232948093.png)\r\n\r\n**动态SQL就是在拼接SQL语句，我们只要保证SQL的正确性，按照SQL格式，取排列组合就可以了**\r\n\r\n建议：\r\n\r\n* 现在MySQL中写出完整的SQL，再对应去修改成为我们的动态SQL实现通用即可\r\n\r\n## 14、缓存\r\n\r\n### 14.1、简介\r\n\r\n![image-20211213234044864](cloudDisk/markdown/mybatis笔记.assets/image-20211213234044864.png)\r\n\r\n### 14.2、缓存分类\r\n\r\n#### 1.一级缓存\r\n\r\n> 一级缓存是mybatis默认开启的缓存，我们不用自己去开启。它是**SqlSession**级别(一个sql语句中)的缓存也称为本地缓存，当调用SqlSession的修改，添加，删除，commit()，close()，clearCache()等方法时，就会清空一级缓存\r\n\r\n一次查询的结果，给他暂存在缓存(内存)中，我们再去查询相同的数据时候就可以直接走缓存，就不用走数据库了。\r\n\r\n\r\n\r\n```java\r\npublic class MyApp7 {\r\n    //测试查询\r\n    public static void main(String[] args) {\r\n        SqlSession sqlSession = MybatisUtils.getSqlSession();\r\n        StudentDao dao = sqlSession.getMapper(StudentDao.class);\r\n        Student student1 = dao.selectStudentById(1001);\r\n        System.out.println(student1);\r\n        Student student2 = dao.selectStudentById(1001);\r\n        System.out.println(student2);\r\n        System.out.println(student1==student2);\r\n    }\r\n}\r\n```\r\n\r\n**详细执行过程如下图：**\r\n\r\n![在这里插入图片描述](cloudDisk/markdown/mybatis笔记.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ3MjQwOQ==,size_16,color_FFFFFF,t_70.png)\r\n\r\n对比代码如下（示例也就是当我们使用clearCache()清理缓存时再次运行main方法）：\r\n\r\n```java\r\npublic class MyApp7 {\r\n    //测试查询\r\n    public static void main(String[] args) {\r\n    	//MybatisUtils是工具类里面封装了获取SqlSession对象，保证使用统一SqlSession对象\r\n        SqlSession sqlSession = MybatisUtils.getSqlSession();\r\n        StudentDao dao = sqlSession.getMapper(StudentDao.class);\r\n        Student student1 = dao.selectStudentById(1001);\r\n        System.out.println(student1);\r\n        sqlSession.clearCache();//调用清理缓存的方法\r\n        Student student2 = dao.selectStudentById(1001);\r\n        System.out.println(student2);\r\n        System.out.println(student1==student2);\r\n    }\r\n}\r\n```\r\n\r\n执行结果如下：\r\n\r\n![在这里插入图片描述](cloudDisk/markdown/mybatis笔记.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ3MjQwOQ==,size_16,color_FFFFFF,t_70-16539919617313.png)\r\n\r\n#### 2.[二级缓存](https://so.csdn.net/so/search?q=二级缓存&spm=1001.2101.3001.7020)\r\n\r\n二级缓存是**namespace**级别(一个mapper映射文件)的缓存（也就是在同一个mapper下都会生效），需要我们手动开启和配置\r\n注意：二级缓存只有在一级缓存死掉才可以执行\r\n\r\n如何配置二级缓存？（主配置全文件可在主页mybtais文件夹中找到）\r\n\r\n1. 先在mybatis.xml（主配置文件）的settings标签中添加`<setting name=\"cacheEnabled\" value=\"true\"/>`\r\n2. 在mapper.xml（sql映射文件中）的mapper标签中添加`<cache/>` 标签\r\n\r\n如何开启二级缓存？\r\n\r\n在你想用二级缓存的语句标签中添加`useCache=\"true\"`\r\n\r\n```xml\r\n<select id=\"selectStudentById\" resultMap=\"StudentUserMap\" parameterType=\"int\" useCache=\"true\">\r\n        select id,name,email,age from student where id = #{id}\r\n</select>\r\n```\r\n\r\n```java\r\npublic class MyApp7 {\r\n    //测试查询\r\n    public static void main(String[] args) {\r\n        SqlSession sqlSession1 = MybatisUtils.getSqlSession();\r\n        SqlSession sqlSession2 = MybatisUtils.getSqlSession();\r\n        StudentDao dao1 = sqlSession1.getMapper(StudentDao.class);\r\n        StudentDao dao2 = sqlSession2.getMapper(StudentDao.class);\r\n        Student student1 = dao1.selectStudentById(1001);\r\n        System.out.println(student1);\r\n        Student student2 = dao2.selectStudentById(1001);\r\n        System.out.println(student2);\r\n        System.out.println(student1==student2);\r\n        MybatisUtils.closeSqlSession();\r\n    }\r\n}\r\n```\r\n\r\n执行结果如下：\r\n\r\n![在这里插入图片描述](cloudDisk/markdown/mybatis笔记.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ3MjQwOQ==,size_16,color_FFFFFF,t_70-16539920833675.png)\r\n\r\n代码如下（一级缓存关闭才会生效示例）：\r\n\r\n```java\r\npublic class MyApp7 {\r\n    //测试查询\r\n    public static void main(String[] args) {\r\n        SqlSession sqlSession1 = MybatisUtils.getSqlSession();\r\n        SqlSession sqlSession2 = MybatisUtils.getSqlSession();\r\n        StudentDao dao1 = sqlSession1.getMapper(StudentDao.class);\r\n        StudentDao dao2 = sqlSession2.getMapper(StudentDao.class);\r\n        Student student1 = dao1.selectStudentById(1001);\r\n        System.out.println(student1);\r\n        sqlSession1.close();//关闭了一级缓存，并且把一级缓存中的数据丢到了二级缓存中\r\n        Student student2 = dao2.selectStudentById(1001);\r\n        System.out.println(student2);\r\n        System.out.println(student1==student2);\r\n        sqlSession2.close();\r\n    }\r\n}\r\n```\r\n\r\n执行结果如下\r\n\r\n![在这里插入图片描述](cloudDisk/markdown/mybatis笔记.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ3MjQwOQ==,size_16,color_FFFFFF,t_70-16539921088617.png)\r\n\r\n\r\n\r\n\r\n\r\n## 15、实现逆向工程\r\n\r\n由官方提供的一个工程模板，可以根据指定的数据库自动生成针对单表的所有的常规的增删改查的配置及接口。可以极大的方便设计者，不用再去创建大量的配置及书写接口，从而把精力集中到业务逻辑的实现上去，它的[源码](https://so.csdn.net/so/search?q=源码&spm=1001.2101.3001.7020)存放在github上，也提供了相关的具有逆向工程功能的Maven插件。\r\n\r\n![image-20220531171416023](cloudDisk/markdown/mybatis笔记.assets/image-20220531171416023.png)\r\n\r\n\r\n\r\n### 15.1、导入依赖\r\n\r\n```xml\r\n    <dependencies>\r\n        <!-- MyBatis核心依赖包 -->\r\n        <dependency>\r\n            <groupId>org.mybatis</groupId>\r\n            <artifactId>mybatis</artifactId>\r\n            <version>3.5.9</version>\r\n        </dependency>\r\n        <!-- junit测试 -->\r\n        <dependency>\r\n            <groupId>junit</groupId>\r\n            <artifactId>junit</artifactId>\r\n            <version>4.13.2</version>\r\n            <scope>test</scope>\r\n        </dependency>\r\n        <!-- MySQL驱动 -->\r\n        <dependency>\r\n            <groupId>mysql</groupId>\r\n            <artifactId>mysql-connector-java</artifactId>\r\n            <version>8.0.27</version>\r\n        </dependency>\r\n        <!-- log4j日志 -->\r\n        <dependency>\r\n            <groupId>log4j</groupId>\r\n            <artifactId>log4j</artifactId>\r\n            <version>1.2.17</version>\r\n        </dependency>\r\n    </dependencies>\r\n    <!-- 控制Maven在构建过程中相关配置 -->\r\n    <build>\r\n        <!-- 构建过程中用到的插件 -->\r\n        <plugins>\r\n            <!-- 具体插件，逆向工程的操作是以构建过程中插件形式出现的 -->\r\n            <plugin>\r\n                <groupId>org.mybatis.generator</groupId>\r\n                <artifactId>mybatis-generator-maven-plugin</artifactId>\r\n                <version>1.3.0</version>\r\n                <!-- 插件的依赖 -->\r\n                <dependencies>\r\n                    <!-- 逆向工程的核心依赖 -->\r\n                    <dependency>\r\n                        <groupId>org.mybatis.generator</groupId>\r\n                        <artifactId>mybatis-generator-core</artifactId>\r\n                        <version>1.3.2</version>\r\n                    </dependency>\r\n                    <!-- 数据库连接池 -->\r\n                    <dependency>\r\n                        <groupId>com.mchange</groupId>\r\n                        <artifactId>c3p0</artifactId>\r\n                        <version>0.9.2</version>\r\n                    </dependency>\r\n                    <!-- MySQL驱动 -->\r\n                    <dependency>\r\n                        <groupId>mysql</groupId>\r\n                        <artifactId>mysql-connector-java</artifactId>\r\n                        <version>8.0.27</version>\r\n                    </dependency>\r\n                </dependencies>\r\n            </plugin>\r\n        </plugins>\r\n    </build>\r\n```\r\n\r\n\r\n\r\n### 15.2、配置文件 generatorConfig.xml\r\n\r\n必须以generatorConfig.xml命名\r\n\r\n```xml\r\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<!DOCTYPE generatorConfiguration\r\n        PUBLIC \"-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN\"\r\n        \"http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd\">\r\n\r\n<generatorConfiguration>\r\n\r\n    <context id=\"default\" targetRuntime=\"MyBatis3\">\r\n        <!--jdbc的数据库连接 -->\r\n        <jdbcConnection\r\n                driverClass=\"com.mysql.jdbc.Driver\"\r\n                connectionURL=\"jdbc:mysql://localhost:3306/smarthomesystemdatabase\"\r\n                userId=\"root\"\r\n                password=\"123\">\r\n            <!--MySQL 不支持 schema 或者 catalog 所以需要添加这个-->\r\n            <!-- 不然会出现生成器把其他数据库的同名表生成下来的问题 -->\r\n            <!-- 现象就是某个类中出现了数据库表里面没有的字段 -->\r\n            <property name=\"nullCatalogMeansCurrent\" value=\"true\"/>\r\n        </jdbcConnection>\r\n\r\n        <!-- Model模型生成器,用来生成含有主键key的类，记录类 以及查询Example类\r\n            targetPackage     指定生成的model生成所在的包名\r\n            targetProject     指定在该项目下所在的路径\r\n        -->\r\n        <javaModelGenerator targetPackage=\"com.tony.pojo\"\r\n                            targetProject=\"./src/main/java\">\r\n\r\n            <!-- 是否允许子包，即targetPackage.schemaName.tableName -->\r\n            <property name=\"enableSubPackages\" value=\"true\"/>\r\n            <!-- 是否对model添加 构造函数 -->\r\n            <property name=\"constructorBased\" value=\"true\"/>\r\n            <!-- 是否对类CHAR类型的列的数据进行trim操作 -->\r\n            <property name=\"trimStrings\" value=\"true\"/>\r\n            <!-- 建立的Model对象是否 不可改变  即生成的Model对象不会有 setter方法，只有构造方法 -->\r\n            <property name=\"immutable\" value=\"false\"/>\r\n        </javaModelGenerator>\r\n\r\n        <!--Mapper映射文件生成所在的目录 为每一个数据库的表生成对应的SqlMap文件 -->\r\n        <sqlMapGenerator targetPackage=\"com.tony.mapper\"\r\n                         targetProject=\"./src/main/resources\">\r\n            <property name=\"enableSubPackages\" value=\"true\"/>\r\n        </sqlMapGenerator>\r\n\r\n        <!-- 客户端代码，生成易于使用的针对Model对象和XML配置文件 的代码\r\n                type=\"ANNOTATEDMAPPER\",生成Java Model 和基于注解的Mapper对象\r\n                type=\"MIXEDMAPPER\",生成基于注解的Java Model 和相应的Mapper对象\r\n                type=\"XMLMAPPER\",生成SQLMap XML文件和独立的Mapper接口\r\n        -->\r\n        <javaClientGenerator targetPackage=\"com.tony.mapper\"\r\n                             targetProject=\"./src/main/java\" type=\"XMLMAPPER\">\r\n            <property name=\"enableSubPackages\" value=\"true\"/>\r\n        </javaClientGenerator>\r\n\r\n        <!--要执行逆向工程所用到的表-->\r\n        <table tableName=\"deivce\" domainObjectName=\"Device\"/>\r\n        <table tableName=\"deivcetype\" domainObjectName=\"DeviceType\"/>\r\n        <table tableName=\"event\" domainObjectName=\"Event\"/>\r\n        <table tableName=\"eventtriggerstep\" domainObjectName=\"EventTriggerStep\"/>\r\n        <table tableName=\"multistateswitch\" domainObjectName=\"MultiStateSwitch\"/>\r\n        <table tableName=\"room\" domainObjectName=\"Room\"/>\r\n        <table tableName=\"sensordata\" domainObjectName=\"SensorData\"/>\r\n        <table tableName=\"user\" domainObjectName=\"User\"/>\r\n    </context>\r\n</generatorConfiguration>\r\n```\r\n\r\n\r\n\r\n### 15.3、执行插件\r\n\r\n![image-20220531180409384](cloudDisk/markdown/mybatis笔记.assets/image-20220531180409384.png)\r\n\r\n随后：\r\n\r\n![image-20220531180535817](cloudDisk/markdown/mybatis笔记.assets/image-20220531180535817.png)\r\n\r\n\r\n\r\n### 15.4、测试\r\n\r\n#### mybatis配置文件\r\n\r\n```xml\r\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\r\n<!DOCTYPE configuration\r\n        PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\"\r\n        \"http://mybatis.org/dtd/mybatis-3-config.dtd\">\r\n<configuration>\r\n    <environments default=\"development\">\r\n        <environment id=\"development\">\r\n            <transactionManager type=\"JDBC\"/>\r\n            <dataSource type=\"POOLED\">\r\n                <property name=\"driver\" value=\"com.mysql.jdbc.Driver\"/>\r\n                <property name=\"url\" value=\"jdbc:mysql://localhost:3306/smarthomesystemdatabase?useSSL=true&amp;useUnicode=true&amp;charsetEncoding=UTF-8\"/>\r\n                <property name=\"username\" value=\"root\"/>\r\n                <property name=\"password\" value=\"123\"/>\r\n            </dataSource>\r\n        </environment>\r\n    </environments>\r\n\r\n    <mappers>\r\n<!--        <mapper resource=\"com/tony/mapper/UserMapper.xml\"></mapper>-->\r\n        <package name=\"com.tony.mapper\"/>\r\n    </mappers>\r\n</configuration>\r\n```\r\n\r\n#### 测试类\r\n\r\n查询id为8的传感器数据，最新数据排在最前\r\n\r\n```java\r\npublic class Test01 {\r\n    @Test\r\n    public void test() throws IOException {\r\n//        InputStream is = Resources.getResourceAsStream(\"mybatisConfig.xml\");\r\n        InputStream is = Test01.class.getClassLoader().getResourceAsStream(\"mybatisConfig.xml\");\r\n        SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(is);\r\n        SqlSession sqlSession = sqlSessionFactory.openSession(true); // 自动提交事务\r\n        /*UserMapper mapper = sqlSession.getMapper(UserMapper.class);\r\n        User user = mapper.selectByPrimaryKey(1);\r\n        System.out.println(user);*/\r\n        SensorDataMapper mapper = sqlSession.getMapper(SensorDataMapper.class);\r\n        SensorDataExample example = new SensorDataExample();\r\n        example.setOrderByClause(\"samplingtime desc\"); //asc升序,desc降序排列\r\n        example.setDistinct(false); //去除重复,true是选择不重复记录,false反之\r\n        SensorDataExample.Criteria criteria = example.createCriteria();//构造自定义查询条件\r\n        criteria.andSensoridEqualTo(8);\r\n        List<SensorData> sensorData = mapper.selectByExample(example);\r\n        for (SensorData sensorDatum : sensorData) {\r\n            System.out.println(sensorDatum);\r\n        }\r\n    }\r\n}\r\n\r\n```\r\n\r\n#### 运行结果\r\n\r\n![image-20220531180723556](cloudDisk/markdown/mybatis笔记.assets/image-20220531180723556.png)\r\n\r\n\r\n\r\n# 总结\r\n\r\nhttps://www.bilibili.com/video/BV1NE411Q7Nx?p=31\r\n\r\n\r\n\r\n','2022-06-23 09:46:17','MyBatis 是一款优秀的持久层框架，它支持自定义 SQL、存储过程以及高级映射。MyBatis 免除了几乎所有的 JDBC 代码以及设置参数和获取结果集的工作。MyBatis 可以通过简单的 XML 或注解来配置和映射原始类型、接口和 Java POJO（Plain Old Java Objects，普通老式 Java 对象）为数据库中的记录。','/cloudDisk/markdown/屏幕截图 2022-06-23 094524.png','原创','','','\0','MyBatis框架学习笔记','2022-06-23 09:46:17',241,90,NULL,2),(162,'','# MybatisPlus概述\r\n\r\n需要的基础：mybatis、spring、springMVC\r\n\r\n为什么学习他？MybatisPlus可以节省大量时间，所有CRUD代码都可以自动化完成\r\n\r\nJPA、tk-mapper、mybatisPlus\r\n\r\n## 简介\r\n\r\n是什么？mybatis就是简化1jdbc操作的\r\n\r\n官网：https://baomidou.com/  mybatis plus，简化\r\n\r\n![image-20220601094505578](cloudDisk/markdown/mybtisPlus笔记.assets/image-20220601094505578.png)\r\n\r\n![image-20220601094543030](cloudDisk/markdown/mybtisPlus笔记.assets/image-20220601094543030.png)\r\n\r\n## 特性\r\n\r\n- **无侵入**：只做增强不做改变，引入它不会对现有工程产生影响，如丝般顺滑\r\n- **损耗小**：启动即会自动注入基本 CURD，性能基本无损耗，直接面向对象操作，BaseMapper\r\n- **强大的 CRUD 操作**：内置通用 Mapper、通用 Service，仅仅通过少量配置即可实现单表大部分 CRUD 操作，更有强大的条件构造器，满足各类使用需求，简单的crud操作，不用自己编写了\r\n- **支持 Lambda 形式调用**：通过 Lambda 表达式，方便的编写各类查询条件，无需再担心字段写错\r\n- **支持主键自动生成**：支持多达 4 种主键策略（内含分布式唯一 ID 生成器 - Sequence），可自由配置，完美解决主键问题\r\n- **支持 ActiveRecord 模式**：支持 ActiveRecord 形式调用，实体类只需继承 Model 类即可进行强大的 CRUD 操作\r\n- **支持自定义全局通用操作**：支持全局通用方法注入（ Write once, use anywhere ）\r\n- **内置代码生成器**：采用代码或者 Maven 插件可快速生成 Mapper 、 Model 、 Service 、 Controller 层代码，支持模板引擎，更有超多自定义配置等您来使用（自动生成代码）\r\n- **内置分页插件**：基于 MyBatis 物理分页，开发者无需关心具体操作，配置好插件之后，写分页等同于普通 List 查询\r\n- **分页插件支持多种数据库**：支持 MySQL、MariaDB、Oracle、DB2、H2、HSQL、SQLite、Postgre、SQLServer 等多种数据库\r\n- **内置性能分析插件**：可输出 SQL 语句以及其执行时间，建议开发测试时启用该功能，能快速揪出慢查询\r\n- **内置全局拦截插件**：提供全表 delete 、 update 操作智能分析阻断，也可自定义拦截规则，预防误操作\r\n\r\n\r\n\r\n# 快速入门\r\n\r\n地址：https://baomidou.com/pages/226c21/#%E5%88%9D%E5%A7%8B%E5%8C%96%E5%B7%A5%E7%A8%8B\r\n\r\n使用第三方组件：\r\n\r\n1. 导入对应依赖\r\n2. 研究依赖如何配置\r\n3. 代码如何编写\r\n4. 提高扩展技术能力\r\n\r\n\r\n\r\n## 步骤\r\n\r\n### 1、创建数据库 `mybatis_plus`\r\n\r\n### 2、创建user表\r\n\r\n```sql\r\nDROP TABLE IF EXISTS user;\r\n\r\nCREATE TABLE user\r\n(\r\n    id BIGINT(20) NOT NULL COMMENT \'主键ID\',\r\n    name VARCHAR(30) NULL DEFAULT NULL COMMENT \'姓名\',\r\n    age INT(11) NULL DEFAULT NULL COMMENT \'年龄\',\r\n    email VARCHAR(50) NULL DEFAULT NULL COMMENT \'邮箱\',\r\n    PRIMARY KEY (id)\r\n);\r\n-- 真实开发中，version（乐观锁）、deleted（逻辑删除）、gmt_create、gmt_modified\r\n\r\nINSERT INTO user (id, name, age, email) VALUES\r\n(1, \'Jone\', 18, \'test1@baomidou.com\'),\r\n(2, \'Jack\', 20, \'test2@baomidou.com\'),\r\n(3, \'Tom\', 28, \'test3@baomidou.com\'),\r\n(4, \'Sandy\', 21, \'test4@baomidou.com\'),\r\n(5, \'Billie\', 24, \'test5@baomidou.com\');\r\n```\r\n\r\n### 3、编写项目，初始化项目！springboot初始化\r\n\r\n### 4、依赖\r\n\r\n```xml\r\n		<!--数据库驱动-->\r\n		<dependency>\r\n			<groupId>mysql</groupId>\r\n			<artifactId>mysql-connector-java</artifactId>\r\n		</dependency>\r\n		<!--lombok-->\r\n		<dependency>\r\n			<groupId>org.projectlombok</groupId>\r\n			<artifactId>lombok</artifactId>\r\n		</dependency>\r\n		<!--mybatisPlus-->\r\n		<!--mybatisPlus 是自己开发的，并非官方的-->\r\n		<dependency>\r\n			<groupId>com.baomidou</groupId>\r\n			<artifactId>mybatis-plus-boot-starter</artifactId>\r\n			<version>3.0.5</version>\r\n		</dependency>\r\n```\r\n\r\n说明：我们使用mybatis-plus可以节省大量代码，尽量不要同时导入mybatis 和 mybatis-plus！版本差异\r\n\r\n### 5、连接数据库\r\n\r\n```properties\r\n# mysql 5 驱动不同\r\nspring.datasource.url=jdbc:mysql://localhost:3306/mybatis_plus?useSSL=false&useUnicode=true&characterEncoding=utf-8&serverTimezone=Asia/Shanghai\r\nspring.datasource.username=root\r\nspring.datasource.password=123\r\nspring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver\r\n\r\n# mysql 8 驱动不同、需要增加时区配置 serverTimezone=Asia/Shanghai\r\n\r\n```\r\n\r\n### 6、传统方式pojo-dao（连接mysql，配置mapper.xml） -server-controller\r\n\r\n### 6、使用了mybatis-plus之后\r\n\r\n* pojo\r\n\r\n  ```java\r\n  @Data\r\n  @AllArgsConstructor\r\n  @NoArgsConstructor\r\n  public class User {\r\n      private Long id;\r\n      private String name;\r\n      private Integer age;\r\n      private String email;\r\n  }\r\n  ```\r\n\r\n  \r\n\r\n* mapper接口\r\n\r\n  ```java\r\n  // 在对应的Mapper上，实现基本接口 BaseMapper\r\n  @Repository\r\n  public interface UserMapper extends BaseMapper<User> {\r\n  }\r\n  \r\n  ```\r\n\r\n  注意点：我们需要在主启动类扫描mapper下所有接口，扫描包\r\n\r\n  ```java\r\n  @MapperScan(\"com.tony.mapper\")\r\n  @SpringBootApplication\r\n  public class DemoApplication {\r\n  \r\n      public static void main(String[] args) {\r\n          SpringApplication.run(DemoApplication.class, args);\r\n      }\r\n  \r\n  }\r\n  ```\r\n\r\n* 使用\r\n\r\n  ```java\r\n      @Autowired\r\n      UserMapper userMapper;\r\n      @Test\r\n      void contextLoads() {\r\n          // 参数是一个Wrapper，条件构造器，这里先不用，写成null\r\n          // 查询全部用户\r\n  		List<User> users = userMapper.selectList(null);\r\n  		System.out.println(users);\r\n      }\r\n  ```\r\n\r\n* ![image-20220601111804352](cloudDisk/markdown/mybtisPlus笔记.assets/image-20220601111804352.png)\r\n\r\n\r\n\r\n\r\n\r\n### 思考问题？\r\n\r\n1、SQL谁帮我们写的\r\n\r\nmybatis\r\n\r\n2、方法哪里来的？\r\n\r\nmybatis 都写好了\r\n\r\n\r\n\r\n## 配置日志\r\n\r\n我们所有的sql现在都是不可见的，我们希望知道是如何执行的，所以配置日志\r\n\r\n```properties\r\n# 配置日志\r\nmybatis-plus.configuration.log-impl=org.apache.ibatis.logging.stdout.StdOutImpl\r\n```\r\n\r\n\r\n\r\n![image-20220601112314996](cloudDisk/markdown/mybtisPlus笔记.assets/image-20220601112314996.png)\r\n\r\n\r\n\r\n## CRUD扩展\r\n\r\n### insert\r\n\r\n```java\r\n    // 测试插入\r\n    @Test\r\n    void testInsert(){\r\n        User user = new User();\r\n        user.setName(\"tony\");\r\n        user.setAge(22);\r\n        user.setEmail(\"1605337475@qq.com\");\r\n        int insert = userMapper.insert(user); // 帮我们自动生成id\r\n        System.out.println(insert); // 受影响的行数\r\n        System.out.println(user);\r\n    }\r\n```\r\n\r\n![image-20220601193921890](cloudDisk/markdown/mybtisPlus笔记.assets/image-20220601193921890.png)\r\n\r\n数据库插入的id的默认值为：全局的唯一id\r\n\r\n### 主键生成策略\r\n\r\n分布式系统唯一id生成：https://blog.csdn.net/HelenAndLi/article/details/118030151\r\n\r\n#### 雪花算法：\r\n\r\nTwitter内部分布式项目采用的ID生成算法，开源后广受好评，基于该算法，又发展了各种分布式ID生成器。虽然现在[推特Git仓库已经把它归档了](https://github.com/twitter-archive/snowflake)\r\n\r\n生成一个Long型ID，而Long占8个字节，1个字节是8bit，也就是说一个Long占64bit。\r\n\r\nID组成：\r\nx - xxxxxxxxxx xxxxxxxxxx xxxxxxxxxx xxxxxxxxxx x - xxxxx - xxxxx - xxxxxxxxxxxx\r\n    正位数（1bit）+[时间戳](https://so.csdn.net/so/search?q=时间戳&spm=1001.2101.3001.7020)（41bit）+数据中心（5bit）+机器ID（5bit）+自增值（12bit）\r\n\r\n- 正位数：Long的最高位正数为0，负数为1，一般ID都正数，所以默认是0。\r\n- 时间戳：毫秒级，不建议直接存当前时间戳，而是用当前时间戳-固定开始时间戳（这个固定时间戳，一般就是我们这套东西最开始用的时刻，这样差值下来，差不多就是从0开始了）的差值，这样可以使得ID从更小的值开始，可以存放更多值，41位时间戳就是2199023255551毫秒，也就是可以用69年了。\r\n- 机器ID：workId，可以灵活配置的，比如机房、机器号组合都可。\r\n- 序列号：自增，同一毫秒内同一节点可生成4096个ID。\r\n  这篇写得不错，可以参考下，有源码的：[Twitter的分布式自增ID算法snowflake (Java版)](https://www.cnblogs.com/relucent/p/4955340.html)\r\n\r\n\r\n\r\n#### 主键自增\r\n\r\n我们需要配置主键自增\r\n\r\n1、实体类字段上 @TableId(type = IdType.AUTO)\r\n\r\n```JAVA\r\n    @TableId(type = IdType.AUTO)\r\n    private Long id;\r\n```\r\n\r\n2、数据库一定也是自增的\r\n\r\n![image-20220601195612081](cloudDisk/markdown/mybtisPlus笔记.assets/image-20220601195612081.png)\r\n\r\n\r\n\r\n3、再次测试插入即可！\r\n\r\n\r\n\r\n#### 其他的源码解释\r\n\r\n```java\r\npublic enum IdType {\r\n    AUTO(0), // 数据库id自增\r\n    NONE(1), // 未设置主键\r\n    INPUT(2), // 手动输入 // 如果设置就需要手动输入id了\r\n    ID_WORKER(3), // 默认全局唯一id\r\n    UUID(4), // 全局唯一id uuid\r\n    ID_WORKER_STR(5); // 字符串表示法\r\n\r\n}\r\n```\r\n\r\n\r\n\r\n### update更新操作\r\n\r\n```java\r\n    // 测试更新\r\n    @Test\r\n    public void testUpdate(){\r\n        User user = new User();\r\n        user.setId(5L);\r\n        user.setName(\"张三\");\r\n        userMapper.updateById(user);\r\n    }\r\n```\r\n\r\n![image-20220601200913890](cloudDisk/markdown/mybtisPlus笔记.assets/image-20220601200913890.png)\r\n\r\n![image-20220601200847936](cloudDisk/markdown/mybtisPlus笔记.assets/image-20220601200847936.png)\r\n\r\n\r\n\r\n所有的sql都是自动动态配置的！\r\n\r\n\r\n\r\n### 自动填充\r\n\r\n创建时间、修改时间！这些操作一般都是自动化完成的，我们不希望手动更新！\r\n\r\n阿里巴巴开发手册：所有的数据库表：gmt_create、gmt_modified 几乎所有的表都要配置上！需要自动化\r\n\r\n#### 方式一：数据库级别（工作中不允许修改数据库的）\r\n\r\n1、在表中新增字段 create_time、update_time\r\n\r\n![image-20220601201535868](cloudDisk/markdown/mybtisPlus笔记.assets/image-20220601201535868.png)\r\n\r\n2、再次测试插入方法，实体类同步！\r\n\r\n```java\r\nprivate Date createTime;\r\nprivate Date updateTime;\r\n```\r\n\r\n3、再次更新\r\n\r\n![image-20220601201835254](cloudDisk/markdown/mybtisPlus笔记.assets/image-20220601201835254.png)\r\n\r\n\r\n\r\n#### 方式二：代码级别\r\n\r\n1、删除数据的默认值，更新操作！\r\n\r\n![image-20220601201934836](cloudDisk/markdown/mybtisPlus笔记.assets/image-20220601201934836.png)\r\n\r\n2、实体类字段上增加注解\r\n\r\n```java\r\n	// 字段添加填充内容\r\n    @TableField(fill = FieldFill.INSERT)\r\n    private Date createTime;\r\n\r\n    @TableField(fill = FieldFill.INSERT_UPDATE)\r\n    private Date updateTime;\r\n```\r\n\r\n3、编写处理器来处理这个注解即可！\r\n\r\ncom.tony.handler.MyObjectHandler\r\n\r\n```java\r\n@Slf4j\r\n@Component // 一定把处理器加到IOC容器中\r\npublic class MyObjectHandler implements MetaObjectHandler {\r\n\r\n    // 插入时的填充策略\r\n    @Override\r\n    public void insertFill(MetaObject metaObject) {\r\n        log.info(\"start insert fill...\");\r\n        this.setFieldValByName(\"createTime\", new Date(), metaObject);\r\n        this.setFieldValByName(\"updateTime\", new Date(), metaObject);\r\n    }\r\n\r\n    // 更新时的填充策略\r\n    @Override\r\n    public void updateFill(MetaObject metaObject) {\r\n        log.info(\"start update fill...\");\r\n        this.setFieldValByName(\"updateTime\", new Date(), metaObject);\r\n    }\r\n}\r\n```\r\n\r\n4、测试插入\r\n\r\n![image-20220601203736595](cloudDisk/markdown/mybtisPlus笔记.assets/image-20220601203736595.png)\r\n\r\n![image-20220601203749417](cloudDisk/markdown/mybtisPlus笔记.assets/image-20220601203749417.png)\r\n\r\n5、测试更新，观察时间即可！\r\n\r\n\r\n\r\n## 乐观锁\r\n\r\n在面试过程中，我们经常会被问到乐观锁！对应悲观锁！其实非常简单！\r\n\r\n\r\n\r\n**乐观锁**：顾名思义十分乐观，他总认为是不出现问题，无论干什么都不上锁！如果出现问题，再次更新值测试\r\n\r\n**悲观锁**：顾名思义十分悲观，他总认为是会出现问题，无论干什么都会上锁！再去操作\r\n\r\n\r\n\r\n这里主要讲**乐观锁**机制\r\n\r\n乐观锁实现方式：\r\n\r\n> - 取出记录时，获取当前 version\r\n> - 更新时，带上这个 version\r\n> - 执行更新时， set version = newVersion where version = oldVersion\r\n> - 如果 version 不对，就更新失败\r\n\r\n\r\n\r\n```sql\r\n乐观锁：1、先查询，获取版本号 version = 1\r\n\r\n-- A 线程\r\nupdate user set name = \"tony\", version = version + 1\r\nwhere id = 2 and verion = 1\r\n\r\n-- B 线程 抢先完成，这个时候 version = 2，会导致 A 修改失败\r\nupdate user set name = \"tony\", version = version + 1\r\nwhere id = 2 and verion = 1\r\n```\r\n\r\n\r\n\r\n### 测试一下 MP 的乐观锁插件\r\n\r\n1、添加sql字段\r\n\r\n![image-20220601204724504](cloudDisk/markdown/mybtisPlus笔记.assets/image-20220601204724504.png)\r\n\r\n2、实体类加对应变量\r\n\r\n```java\r\n@Version // 乐观锁注解\r\nprivate Integer version;\r\n```\r\n\r\n3、注册组件\r\n\r\n```java\r\n@MapperScan(\"com.tony.mapper\") // 扫描mapper文件\r\n@EnableTransactionManagement // 开启事务管理，也是默认开启的\r\n@Configuration // 代表配置类\r\npublic class MybatisPlusConfig {\r\n\r\n    // 注册乐观锁插件\r\n    @Bean\r\n    public OptimisticLockerInterceptor optimisticLockerInterceptor() {\r\n        return new OptimisticLockerInterceptor();\r\n    }\r\n    \r\n}\r\n```\r\n\r\n4、测试一下\r\n\r\n```java\r\n    // 测试乐观锁成功！\r\n    @Test\r\n    public void testOptimisticLockerInterceptor(){\r\n        // 1. 查询用户信息\r\n        User user = userMapper.selectById(1L);\r\n        // 2. 修改用户信息\r\n        user.setName(\"tony\");\r\n        user.setEmail(\"12312@gmail.com\");\r\n        // 3. 执行更新操作\r\n        userMapper.updateById(user);\r\n    }\r\n\r\n    // 测试乐观锁失败！\r\n    @Test\r\n    public void testOptimisticLockerInterceptor2(){\r\n        // 线程1\r\n        User user = userMapper.selectById(1L);\r\n        user.setName(\"tony1111\");\r\n        user.setEmail(\"12312@gmail.com\");\r\n\r\n        // 模拟另外线程更新执行了插队操作\r\n        User user2 = userMapper.selectById(1L);\r\n        user2.setName(\"tony2222222\");\r\n        user2.setEmail(\"12322212@gmail.com\");\r\n        userMapper.updateById(user2);\r\n\r\n        // 自旋锁来多次尝试提交\r\n        userMapper.updateById(user); // 如果没有乐观锁，就会覆盖插队线程的值！\r\n    }\r\n```\r\n\r\n\r\n\r\n![image-20220601210048564](cloudDisk/markdown/mybtisPlus笔记.assets/image-20220601210048564.png)\r\n\r\n\r\n\r\n## 查询操作\r\n\r\n```java\r\n// 1、测试查询\r\n@Test\r\npublic void testSelectById(){\r\n    User user = userMapper.selectById(1);\r\n    System.out.println(user);\r\n}\r\n\r\n// 2、测试批量查询\r\n@Test\r\npublic void testSelectBatchIds(){\r\n    List<User> users = userMapper.selectBatchIds(Arrays.asList(1, 2, 3));\r\n    users.forEach(System.out::println);\r\n}\r\n\r\n// 3、条按条件 查询 - 使用map操作\r\n@Test\r\npublic void testSelectByMap(){\r\n    HashMap<String, Object> map = new HashMap<>();\r\n    // 自定义查询条件\r\n    map.put(\"name\", \"tony\");\r\n    map.put(\"age\", 22);\r\n    List<User> users = userMapper.selectByMap(map);\r\n    users.forEach(System.out::println);\r\n}\r\n```\r\n\r\n1. ![image-20220601211104624](cloudDisk/markdown/mybtisPlus笔记.assets/image-20220601211104624.png)\r\n2. ![image-20220601211157107](cloudDisk/markdown/mybtisPlus笔记.assets/image-20220601211157107.png)\r\n3. ![image-20220601211227654](cloudDisk/markdown/mybtisPlus笔记.assets/image-20220601211227654.png)\r\n\r\n\r\n\r\n## 分页查询\r\n\r\n1、原始的 limit 进行分页\r\n\r\n2、pageHelper 第三方插件\r\n\r\n3、MP 其实内置了分页插件\r\n\r\n### 如何使用！\r\n\r\n1、配置拦截器组件即可\r\n\r\n```java\r\n    // 分页插件\r\n    @Bean\r\n    public PaginationInterceptor paginationInterceptor(){\r\n        return new PaginationInterceptor();\r\n    }\r\n```\r\n\r\n2、直接使用page对象即可！\r\n\r\n```java\r\n    //  测试分页插件\r\n    @Test\r\n    public void testPage(){\r\n        // 参数一：当前页\r\n        // 参数二：页面大小\r\n        // 使用了分页插件后，所有的分页插件后，所有都变得简单了\r\n        Page<User> page = new Page<>(1, 5);\r\n        userMapper.selectPage(page, null);\r\n        page.getRecords().forEach(System.out::println);\r\n        System.out.println(page.getTotal());\r\n    }\r\n```\r\n\r\n![image-20220601214238559](cloudDisk/markdown/mybtisPlus笔记.assets/image-20220601214238559.png)\r\n\r\n\r\n\r\n## 删除操作\r\n\r\n```java\r\npublic void testDeleteById(){\r\n    // 1、指定id删除\r\n    userMapper.deleteById(1L);\r\n\r\n    // 2、批量删除\r\n    userMapper.deleteBatchIds(Arrays.asList(1531916583243386882L,1531916583243386887L));\r\n\r\n    // 3、条件删除\r\n    HashMap<String, Object> map = new HashMap<>();\r\n    map.put(\"name\", \"10\"); // name 为 10 的\r\n    userMapper.deleteByMap(map);  // 条件删除\r\n\r\n}\r\n```\r\n\r\n1. 指定id删除\r\n\r\n   ![image-20220601214945850](cloudDisk/markdown/mybtisPlus笔记.assets/image-20220601214945850.png)\r\n\r\n2. 批量删除\r\n\r\n   ![image-20220601215038760](cloudDisk/markdown/mybtisPlus笔记.assets/image-20220601215038760.png)\r\n\r\n3. 条件删除\r\n\r\n   ![image-20220601215104940](cloudDisk/markdown/mybtisPlus笔记.assets/image-20220601215104940.png)\r\n\r\n\r\n\r\n## 逻辑删除\r\n\r\n**物理删除**：从数据库中直接移除\r\n\r\n**逻辑删除**：数据库中没有被移除，而是通过变量让它失效！deleted = 0   =>   deleted = 1\r\n\r\n管理员可以查看被删除的记录！防止数据丢失，类似回收站！\r\n\r\n### 测试一下\r\n\r\n1、在数据表中，加入deleted字段\r\n\r\n![image-20220601215356210](cloudDisk/markdown/mybtisPlus笔记.assets/image-20220601215356210.png)\r\n\r\n2、实体类中，增加变量\r\n\r\n```java\r\n@TableLogic\r\nprivate Integer deleted;\r\n```\r\n\r\n3、配置\r\n\r\n```java\r\n// 逻辑删除组件\r\n@Bean\r\npublic ISqlInjector sqlInjector(){\r\n    return new LogicSqlInjector();\r\n}\r\n```\r\n\r\n```properties\r\n# 配置逻辑删除\r\nmybatis-plus.global-config.db-config.logic-delete-value=1\r\nmybatis-plus.global-config.db-config.logic-not-delete-value=0\r\n```\r\n\r\n4、测试\r\n\r\n```java\r\n// 测试删除\r\n@Test\r\npublic void testDelete(){\r\n    userMapper.deleteById(2L);\r\n}\r\n```\r\n\r\n![image-20220601220737633](cloudDisk/markdown/mybtisPlus笔记.assets/image-20220601220737633.png)\r\n\r\n![image-20220601220749092](cloudDisk/markdown/mybtisPlus笔记.assets/image-20220601220749092.png)\r\n\r\n实际走的是更新操作\r\n\r\n记录依旧在数据库，但值变换了\r\n\r\n\r\n\r\n当查询时id=2时：\r\n\r\n```java\r\n// 测试查询\r\n@Test\r\npublic void testSelectById(){\r\n    User user = userMapper.selectById(2L);\r\n    System.out.println(user);\r\n}\r\n```\r\n\r\n![image-20220601220942832](cloudDisk/markdown/mybtisPlus笔记.assets/image-20220601220942832.png)\r\n\r\n过滤了逻辑被删除的\r\n\r\n\r\n\r\n## 性能分析插件\r\n\r\n遇到慢sql，测试！druid\r\n\r\nMP也提供了分析插件\r\n\r\n### 测试使用\r\n\r\n1、导入插件\r\n\r\n```java\r\n    @Bean\r\n    @Profile({\"dev\", \"test\"}) // 设置dev test 环境开启，保证效率\r\n    public PerformanceInterceptor performanceInterceptor(){\r\n        PerformanceInterceptor performanceInterceptor = new PerformanceInterceptor();\r\n        // 在工作中，不允许用户等待\r\n        performanceInterceptor.setMaxTime(100); // 设置sql执行的最大时间，如果超过，不执行\r\n        performanceInterceptor.setFormat(true);\r\n        return performanceInterceptor;\r\n    }\r\n```\r\n\r\n指定dev环境\r\n\r\n```properties\r\nspring.profiles.active=dev\r\n```\r\n\r\n2、测试\r\n\r\n![image-20220601223735474](cloudDisk/markdown/mybtisPlus笔记.assets/image-20220601223735474.png)\r\n\r\n* 只要超过setMaxTime设置的时间就会抛异常\r\n\r\n使用新能分析插件，能提高效率\r\n\r\n\r\n\r\n## 条件构造器\r\n\r\n![image-20220601224348492](cloudDisk/markdown/mybtisPlus笔记.assets/image-20220601224348492.png)\r\n\r\n\r\n\r\n1、测试一\r\n\r\n```java\r\n    @Test\r\n    void contextLoader(){\r\n        // 查询name不为空、邮箱不为空、年龄大于5\r\n        QueryWrapper<User> wrapper = new QueryWrapper<>();\r\n        wrapper\r\n                .isNotNull(\"name\")\r\n                .isNotNull(\"email\")\r\n                .ge(\"age\", 5);\r\n        userMapper.selectList(wrapper);\r\n    }\r\n```\r\n\r\n![image-20220602104235803](cloudDisk/markdown/mybtisPlus笔记.assets/image-20220602104235803.png)\r\n\r\n\r\n\r\n2、测试二\r\n\r\n```java\r\n@Test\r\nvoid test2(){\r\n    // 查询名字为Tom的\r\n    QueryWrapper<User> wrapper = new QueryWrapper<>();\r\n    wrapper.eq(\"name\", \"Tom\");\r\n    User user = userMapper.selectOne(wrapper);\r\n    System.out.println(user);\r\n}\r\n```\r\n\r\n![image-20220602104538088](cloudDisk/markdown/mybtisPlus笔记.assets/image-20220602104538088.png)\r\n\r\n\r\n\r\n3、测试三\r\n\r\n```java\r\n@Test\r\nvoid test3(){\r\n    // 查询 年龄在 10 ~ 20 的用户\r\n    QueryWrapper<User> wrapper = new QueryWrapper<>();\r\n    wrapper.between(\"age\", 10, 20);\r\n    Integer count = userMapper.selectCount(wrapper);\r\n    System.out.println(count);\r\n}\r\n```\r\n\r\n![image-20220602104850760](cloudDisk/markdown/mybtisPlus笔记.assets/image-20220602104850760.png)\r\n\r\n\r\n\r\n4、测试四，查看输出的sql，进行分析\r\n\r\n```java\r\n// 模糊查询\r\n@Test\r\nvoid test4(){\r\n    QueryWrapper<User> wrapper = new QueryWrapper<>();\r\n    wrapper\r\n            .notLike(\"name\", \"e\") // %e%\r\n            .likeRight(\"email\", \"t\"); // t%\r\n\r\n    List<Map<String, Object>> maps = userMapper.selectMaps(wrapper);\r\n    maps.forEach(System.out::println);\r\n}\r\n```\r\n\r\n![image-20220602105512896](cloudDisk/markdown/mybtisPlus笔记.assets/image-20220602105512896.png)\r\n\r\n5、测试五（）\r\n\r\n```java\r\n@Test\r\nvoid test5(){\r\n    QueryWrapper<User> wrapper = new QueryWrapper<>();\r\n    // id 在子查询中查出来\r\n    wrapper.inSql(\"id\", \"select id from user where id < 3\");\r\n\r\n    List<Object> objects = userMapper.selectObjs(wrapper);\r\n    objects.forEach(System.out::println);\r\n}\r\n```\r\n\r\n![image-20220602164929610](cloudDisk/markdown/mybtisPlus笔记.assets/image-20220602164929610.png)\r\n\r\n6、测试六\r\n\r\n```java\r\n@Test\r\nvoid test6(){\r\n    QueryWrapper<User> wrapper = new QueryWrapper<>();\r\n    // 通过id进行排序\r\n    wrapper.orderByDesc(\"id\");\r\n\r\n    List<User> users = userMapper.selectList(wrapper);\r\n    users.forEach(System.out::println);\r\n}\r\n```\r\n\r\n![image-20220602165218238](cloudDisk/markdown/mybtisPlus笔记.assets/image-20220602165218238.png)\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n## 代码自动生成器\r\n\r\ndao、pojo、service、controller\r\n\r\nAutoGenerator 是 MyBatis-Plus 的代码生成器，通过 AutoGenerator 可以快速生成 Entity、Mapper、Mapper XML、Service、Controller 等各个模块的代码，极大的提升了开发效率。\r\n就是帮助我们快速生成代码，使我们更加便捷的开发项目\r\n\r\n### 使用\r\n\r\n#### 1、创建项目\r\n\r\n![image-20220602181506032](cloudDisk/markdown/mybtisPlus笔记.assets/image-20220602181506032.png)\r\n\r\n#### 2、导入依赖\r\n\r\n```xml\r\n<!-- swagger 可以帮助我们生成swagger文档 -->\r\n<dependency>\r\n    <groupId>io.springfox</groupId>\r\n    <artifactId>springfox-swagger2</artifactId>\r\n    <version>2.9.2</version>\r\n</dependency>\r\n<!-- 模板引擎 -->\r\n<dependency>\r\n    <groupId>org.apache.velocity</groupId>\r\n    <artifactId>velocity-engine-core</artifactId>\r\n    <version>2.0</version>\r\n</dependency>\r\n<!-- 引入 mybatis-plus 依赖 -->\r\n<dependency>\r\n    <groupId>com.baomidou</groupId>\r\n    <artifactId>mybatis-plus-boot-starter</artifactId>\r\n    <version>3.0.5</version>\r\n</dependency>\r\n<!-- 引入 代码生成器 依赖 -->\r\n<dependency>\r\n    <groupId>com.baomidou</groupId>\r\n    <artifactId>mybatis-plus-generator</artifactId>\r\n    <version>3.4.1</version>\r\n</dependency>\r\n<dependency>\r\n    <groupId>mysql</groupId>\r\n    <artifactId>mysql-connector-java</artifactId>\r\n</dependency>\r\n```\r\n\r\n\r\n\r\n#### 4、创建生成方法\r\n\r\n```java\r\npackage com.tony.auto_generator_code;\r\nimport com.baomidou.mybatisplus.annotation.DbType;\r\nimport com.baomidou.mybatisplus.annotation.FieldFill;\r\nimport com.baomidou.mybatisplus.annotation.IdType;\r\nimport com.baomidou.mybatisplus.generator.AutoGenerator;\r\nimport com.baomidou.mybatisplus.generator.config.DataSourceConfig;\r\nimport com.baomidou.mybatisplus.generator.config.GlobalConfig;\r\nimport com.baomidou.mybatisplus.generator.config.PackageConfig;\r\nimport com.baomidou.mybatisplus.generator.config.StrategyConfig;\r\nimport com.baomidou.mybatisplus.generator.config.po.TableFill;\r\nimport com.baomidou.mybatisplus.generator.config.rules.DateType;\r\nimport com.baomidou.mybatisplus.generator.config.rules.NamingStrategy;\r\n\r\npublic class TonyCode {\r\n    public static void main(String[] args) {\r\n        // 需要构建一个 代码自动生成器 对象\r\n        AutoGenerator mpg = new AutoGenerator();\r\n        // 配置策略\r\n        // 1、全局配置\r\n        GlobalConfig gc = new GlobalConfig();\r\n        // 获取当前项目目录\r\n        String projectPath = System.getProperty(\"user.dir\");\r\n        // 设置生成代码的位置\r\n        gc.setOutputDir(projectPath+\"/src/main/java\");\r\n        // 作者\r\n        gc.setAuthor(\"tony\");\r\n        gc.setOpen(false); // 是否打开文件管理器\r\n        gc.setFileOverride(false); // 是否覆盖\r\n        gc.setServiceName(\"%sService\"); // 去 service的 I 前缀\r\n        gc.setIdType(IdType.ID_WORKER); // id 默认是初始算法\r\n        gc.setDateType(DateType.ONLY_DATE); // 日期类型\r\n        gc.setSwagger2(true); // 是否生成swagger\r\n        mpg.setGlobalConfig(gc);\r\n\r\n        // 2、设置数据源\r\n        DataSourceConfig dsc= new DataSourceConfig();\r\n        dsc.setUrl(\"jdbc:mysql://localhost:3306/smarthomesystemdatabase?useUnicode=true&useSSL=false&characterEncoding=utf8&serverTimezone=Asia/Shanghai\");\r\n        dsc.setDriverName(\"com.mysql.jdbc.Driver\");\r\n        dsc.setUsername(\"root\");\r\n        dsc.setPassword(\"123\");\r\n        dsc.setDbType(DbType.MYSQL); // 数据库类型 mysql\r\n        mpg.setDataSource(dsc);\r\n\r\n        // 3、包的配置\r\n        PackageConfig pc = new PackageConfig();\r\n         pc.setModuleName(\"auto_generator_code\"); // 生成到指定模块中\r\n        pc.setParent(\"com.tony\");\r\n        pc.setEntity(\"entity\");\r\n        pc.setMapper(\"mapper\");\r\n        pc.setService(\"service\");\r\n        pc.setController(\"controller\");\r\n        mpg.setPackageInfo(pc);\r\n\r\n        // 4、策略配置\r\n        StrategyConfig strategy = new StrategyConfig();\r\n        // 设置要映射的表名（重要，需要修改的地方）\r\n        strategy.setInclude(\"device\", \"devicetype\", \"EVENT\", \"eventtriggerstep\", \"multistateswitch\", \"room\", \"sensordata\", \"user\");\r\n        strategy.setNaming(NamingStrategy.underline_to_camel); // 自动转换表名的驼峰命名法\r\n        strategy.setColumnNaming(NamingStrategy.underline_to_camel); // 自动转换列名的驼峰命名法\r\n        strategy.setEntityLombokModel(true); // 是否使用lombox\r\n//        strategy.setLogicDeleteFieldName(\"deleted\"); // 配置逻辑删除字段\r\n        // 自动填充策略\r\n//        TableFill gmtCreate =  new TableFill(\"create\", FieldFill.INSERT);\r\n//        TableFill gmtModified =  new TableFill(\"updated\", FieldFill.INSERT);\r\n//        ArrayList<TableFill> tableFills = new ArrayList<>();\r\n//        tableFills.add(gmtCreate);\r\n//        tableFills.add(gmtModified);\r\n//        strategy.setTableFillList(tableFills);\r\n        // 乐观锁\r\n        strategy.setVersionFieldName(\"version\");\r\n\r\n        mpg.setStrategy(strategy);\r\n        mpg.execute(); // 执行\r\n    }\r\n}\r\n```\r\n\r\n\r\n\r\n#### 5、执行\r\n\r\n![image-20220602182235237](cloudDisk/markdown/mybtisPlus笔记.assets/image-20220602182235237.png)\r\n\r\n![image-20220602182220654](cloudDisk/markdown/mybtisPlus笔记.assets/image-20220602182220654.png)\r\n\r\n\r\n\r\n\r\n\r\n### 测试\r\n\r\n1、配置\r\n\r\n```properties\r\nspring.datasource.url=jdbc:mysql://localhost:3306/smarthomesystemdatabase?useUnicode=true&useSSL=false&characterEncoding=utf8&serverTimezone=Asia/Shanghai\r\nspring.datasource.username=root\r\nspring.datasource.password=123\r\nspring.datasource.driver-class-name=com.mysql.jdbc.Driver\r\n\r\nmybatis-plus.configuration.log-impl=org.apache.ibatis.logging.stdout.StdOutImpl\r\n```\r\n\r\n2、启动类\r\n\r\n```java\r\n@MapperScan(\"com.tony.auto_generator_code.mapper\")\r\n@SpringBootApplication\r\npublic class AutoGeneratorCodeApplication {\r\n\r\n    public static void main(String[] args) {\r\n        SpringApplication.run(AutoGeneratorCodeApplication.class, args);\r\n    }\r\n\r\n}\r\n\r\n```\r\n\r\n\r\n\r\n3、测试类\r\n\r\n```java\r\n    @Autowired\r\n    UserMapper userMapper;\r\n\r\n    @Autowired\r\n    UserService userService;\r\n\r\n    @Test\r\n    void contextLoads() {\r\n        List<User> users = userMapper.selectList(new QueryWrapper<>());\r\n        users.forEach(System.out::println);\r\n    }\r\n\r\n    @Test\r\n    void test(){\r\n        User byId = userService.getById(1);\r\n        System.out.println(byId);\r\n    }\r\n```\r\n\r\n![image-20220602190512930](cloudDisk/markdown/mybtisPlus笔记.assets/image-20220602190512930.png)\r\n\r\n![image-20220602190727500](cloudDisk/markdown/mybtisPlus笔记.assets/image-20220602190727500.png)\r\n\r\n\r\n\r\n### 注意点 *Mapperxml文件在包目录下面，配置mybatis映射文件位置\r\n\r\n#### 1、编写UserMapper映射文件\r\n\r\n```xml\r\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\">\r\n<mapper namespace=\"com.tony.auto_generator_code.mapper.UserMapper\">\r\n    <select id=\"getUsers\" resultType=\"User\">\r\n        select * from user\r\n    </select>\r\n\r\n</mapper>\r\n```\r\n\r\n#### 2、配置pom.xml，编译也将包下的*.xml输出\r\n\r\n```xml\r\n<resources>\r\n    <resource>\r\n        <directory>src/main/java</directory>\r\n        <includes>\r\n            <include>**/*.xml</include>\r\n        </includes>\r\n    </resource>\r\n    <resource>\r\n        <directory>src/main/resources</directory>\r\n    </resource>\r\n</resources>\r\n```\r\n\r\n![image-20220602193858084](cloudDisk/markdown/mybtisPlus笔记.assets/image-20220602193858084.png)\r\n\r\n![image-20220602193843482](cloudDisk/markdown/mybtisPlus笔记.assets/image-20220602193843482.png)\r\n\r\n\r\n\r\n#### 3、配置映射文件所在位置\r\n\r\n```properties\r\nmybatis-plus.type-aliases-package=com.tony.auto_generator_code.entity\r\nmybatis-plus.mapper-locations: classpath*:com/tony/auto_generator_code/mapper/xml/*.xml\r\n```\r\n\r\n#### 4、测试\r\n\r\n```java\r\n@Test\r\nvoid test(){\r\n    List<User> users = userMapper.getUsers();\r\n    users.forEach(System.out::println);\r\n}\r\n```\r\n\r\n![image-20220602194233880](cloudDisk/markdown/mybtisPlus笔记.assets/image-20220602194233880.png)\r\n\r\n\r\n\r\n### 或将xml包下的 *Mapper.xml映射文件剪切到resources/mapper目录下\r\n\r\n![image-20220602194618307](cloudDisk/markdown/mybtisPlus笔记.assets/image-20220602194618307.png)\r\n\r\n#### 1、配置文件\r\n\r\n```properties\r\nmybatis-plus.type-aliases-package=com.tony.auto_generator_code.entity\r\nmybatis-plus.mapper-locations: classpath:mapper/*.xml\r\n```\r\n\r\n#### 2、测试\r\n\r\n![image-20220602194631235](cloudDisk/markdown/mybtisPlus笔记.assets/image-20220602194631235.png)\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n','2022-06-23 21:00:35','MyBatis-Plus (opens new window)（简称 MP）是一个 MyBatis (opens new window)的增强工具，在 MyBatis 的基础上只做增强不做改变，为简化开发、提高效率而生。','cloudDisk/markdown/mybtisPlus笔记.assets/image-20220601094505578.png','原创','','','\0','MyBatis Plus 笔记','2022-06-23 21:00:35',13,90,NULL,2),(163,'','# Git\r\n\r\n## 版本控制\r\n\r\n版本控制（Revision control）是一种在开发的过程中用于管理我们对文件、目录或工程等内容的修改历史，方便查看更改历史记录，备份以便恢复以前的版本的软件工程技术。\r\n\r\n- 实现跨区域多人协同开发\r\n- 追踪和记载一个或者多个文件的历史记录\r\n- 组织和保护你的源代码和文档\r\n- 统计工作量\r\n- 并行开发、提高开发效率\r\n- 跟踪记录整个软件的开发过程\r\n- 减轻开发人员的负担，节省时间，同时降低人为错误\r\n\r\n简单说就是用于管理多人协同开发项目的技术。\r\n\r\n没有进行版本控制或者版本控制本身缺乏正确的流程管理，在软件开发过程中将会引入很多问题，如软件代码的一致性、软件内容的冗余、软件过程的事物性、软件开发过程中的并发性、软件源代码的安全性，以及软件的整合等问题。\r\n\r\n无论是工作还是学习，或者是自己做笔记，都经历过这样一个阶段！我们就迫切需要一个版本控制工具！\r\n\r\n<img src=\"cloudDisk/markdown/Git笔记.assets/format,png.jpeg\" alt=\"img\" style=\"zoom: 50%;\" />\r\n\r\n\r\n\r\n多人开发就必须要使用版本控制！\r\n\r\n## 常见的版本控制工具\r\n\r\n我们学习的东西，一定是当下最流行的！\r\n\r\n主流的版本控制器有如下这些：\r\n\r\n- **Git**\r\n- **SVN**（Subversion）\r\n- **CVS**（Concurrent Versions System）\r\n- **VSS**（Micorosoft Visual SourceSafe）\r\n- **TFS**（Team Foundation Server）\r\n- Visual Studio Online\r\n\r\n版本控制产品非常的多（Perforce、Rational ClearCase、RCS（GNU Revision Control System）、Serena Dimention、SVK、BitKeeper、Monotone、Bazaar、Mercurial、SourceGear Vault），现在影响力最大且使用最广泛的是Git与SVN\r\n\r\n\r\n\r\n## 版本控制分类\r\n\r\n### **1、本地版本控制**\r\n\r\n记录文件每次的更新，可以对每个版本做一个快照，或是记录补丁文件，适合个人用，如RCS。\r\n\r\n![img](cloudDisk/markdown/Git笔记.assets/format,png-16540156292012.png)\r\n\r\n### **2、集中版本控制  SVN**\r\n\r\n所有的版本数据都保存在服务器上，协同开发者从服务器上同步更新或上传自己的修改\r\n\r\n![img](cloudDisk/markdown/Git笔记.assets/format,png-16540156510034.png)\r\n\r\n所有的版本数据都存在服务器上，用户的本地只有自己以前所同步的版本，如果不连网的话，用户就看不到历史版本，也无法切换版本验证问题，或在不同分支工作。而且，所有数据都保存在单一的服务器上，有很大的风险这个服务器会损坏，这样就会丢失所有的数据，当然可以定期备份。代表产品：SVN、CVS、VSS\r\n\r\n### **3、分布式版本控制 Git**\r\n\r\n每个人都拥有全部的代码！安全隐患！\r\n\r\n所有版本信息仓库全部同步到本地的每个用户，这样就可以在本地查看所有版本历史，可以离线在本地提交，只需在连网时push到相应的服务器或其他用户那里。由于每个用户那里保存的都是所有的版本数据，只要有一个用户的设备没有问题就可以恢复所有的数据，但这增加了本地存储空间的占用。\r\n\r\n**不会因为服务器损坏或者网络问题，造成不能工作的情况！**\r\n\r\n![img](cloudDisk/markdown/Git笔记.assets/format,png-16540157636516.png)\r\n\r\n\r\n\r\n### Git与SVN的主要区别\r\n\r\n**SVN是集中式版本控制系统**，版本库是集中放在中央服务器的，而工作的时候，用的都是自己的电脑，所以首先要从中央服务器得到最新的版本，然后工作，完成工作后，需要把自己做完的活推送到中央服务器。集中式版本控制系统是必须联网才能工作，对网络带宽要求较高。\r\n\r\n![img](cloudDisk/markdown/Git笔记.assets/format,png-16540158740368.png)\r\n\r\n**Git是分布式版本控制系统**，没有中央服务器，每个人的电脑就是一个完整的版本库，工作的时候不需要联网了，因为版本都在自己电脑上。协同的方法是这样的：比如说自己在电脑上改了文件A，其他人也在电脑上改了文件A，这时，你们两之间只需把各自的修改推送给对方，就可以互相看到对方的修改了。Git可以直接看到更新了哪些代码和文件！\r\n\r\n**Git是目前世界上最先进的分布式版本控制系统。**\r\n\r\n\r\n\r\n## 聊聊Git的历史\r\n\r\n同生活中的许多伟大事物一样，Git 诞生于一个极富纷争大举创新的年代。\r\n\r\nLinux 内核开源项目有着为数众广的参与者。绝大多数的 Linux 内核维护工作都花在了提交补丁和保存归档的繁琐事务上(1991－2002年间)。到 2002 年，整个项目组开始启用一个专有的分布式版本控制系统 BitKeeper 来管理和维护代码。\r\n\r\nLinux社区中存在很多的大佬！破解研究 BitKeeper ！\r\n\r\n到了 2005 年，开发 BitKeeper 的商业公司同 Linux 内核开源社区的合作关系结束，他们收回了 Linux 内核社区免费使用 BitKeeper 的权力。这就迫使 Linux 开源社区(特别是 Linux 的缔造者 Linus Torvalds)基于使用 BitKeeper 时的经验教训，开发出自己的版本系统。（2周左右！） 也就是后来的 Git！\r\n\r\n**Git是目前世界上最先进的分布式版本控制系统。**\r\n\r\nGit是免费、开源的，最初Git是为辅助 Linux 内核开发的，来替代 BitKeeper！\r\n\r\n![img](cloudDisk/markdown/Git笔记.assets/format,png-165401603348510.png)\r\n\r\nLinux和Git之父李纳斯·托沃兹（Linus Benedic Torvalds）1969、芬兰\r\n\r\nGit环境配置\r\n\r\n## 软件下载\r\n\r\n打开 [git官网] https://git-scm.com/，下载git对应操作系统的版本。\r\n\r\n所有东西下载慢的话就可以去找镜像！\r\n\r\n官网下载太慢，我们可以使用淘宝镜像下载：http://npm.taobao.org/mirrors/git-for-windows/\r\n\r\n![img](cloudDisk/markdown/Git笔记.assets/format,png-165401606934712.png)\r\n\r\n下载对应的版本即可安装！\r\n\r\n安装：无脑下一步即可！安装完毕就可以使用了！\r\n\r\n## 启动Git\r\n\r\n安装成功后在开始菜单中会有Git项，菜单下有3个程序：任意文件夹下右键也可以看到对应的程序！\r\n\r\n![img](cloudDisk/markdown/Git笔记.assets/format,png-165401638544714.png)\r\n\r\n**Git Bash：**Unix与Linux风格的命令行，使用最多，推荐最多\r\n\r\n**Git CMD：**Windows风格的命令行\r\n\r\n**Git GUI**：图形界面的Git，不建议初学者使用，尽量先熟悉常用命令\r\n\r\n## 常用的Linux命令\r\n\r\n平时一定要多使用这些基础的命令！\r\n\r\n1）、cd : 改变目录。\r\n\r\n2）、cd . . 回退到上一个目录，直接cd进入默认目录\r\n\r\n3）、pwd : 显示当前所在的目录路径。\r\n\r\n4）、ls(ll):  都是列出当前目录中的所有文件，只不过ll(两个ll)列出的内容更为详细。\r\n\r\n5）、touch : 新建一个文件 如 touch index.js 就会在当前目录下新建一个index.js文件。\r\n\r\n6）、rm:  删除一个文件, rm index.js 就会把index.js文件删除。\r\n\r\n7）、mkdir:  新建一个目录,就是新建一个文件夹。\r\n\r\n8）、rm -r :  删除一个文件夹, rm -r src 删除src目录\r\n\r\n```\r\nrm -rf /  切勿在Linux中尝试！删除电脑中全部文件！\r\n```\r\n\r\n9）、mv 移动文件, mv index.html src index.html 是我们要移动的文件, src 是目标文件夹,当然, 这样写,必须保证文件和目标文件夹在同一目录下。\r\n\r\n10）、reset 重新初始化终端/清屏。\r\n\r\n11）、clear 清屏。\r\n\r\n12）、history 查看命令历史。\r\n\r\n13）、help 帮助。\r\n\r\n14）、exit 退出。\r\n\r\n15）、#表示注释\r\n\r\n## Git配置\r\n\r\n所有的配置文件，其实都保存在本地！\r\n\r\n查看配置 git config -l\r\n\r\n![img](cloudDisk/markdown/Git笔记.assets/format,png-165401670956216.png)\r\n\r\n查看不同级别的配置文件：\r\n\r\n```\r\n#查看系统config\r\ngit config --system --list\r\n　　\r\n#查看当前用户（global）配置\r\ngit config --global  --list\r\n```\r\n\r\n\r\n\r\n### **Git相关的配置文件：**\r\n\r\n1）、Git\\etc\\gitconfig  ：Git 安装目录下的 gitconfig   --system 系统级\r\n\r\n2）、C:\\Users\\Administrator\\ .gitconfig   只适用于当前登录用户的配置  --global 全局\r\n\r\n![img](cloudDisk/markdown/Git笔记.assets/format,png-165401688780418.png)\r\n\r\n这里可以直接编辑配置文件，通过命令设置后会响应到这里。\r\n\r\n### 设置用户名与邮箱（用户标识，必要）\r\n\r\n当你安装Git后首先要做的事情是设置你的用户名称和e-mail地址。这是非常重要的，因为每次Git提交都会使用该信息。它被永远的嵌入到了你的提交中：\r\n\r\n```\r\ngit config --global user.name \"kuangshen\"  #名称\r\ngit config --global user.email 24736743@qq.com   #邮箱\r\n```\r\n\r\n只需要做一次这个设置，如果你传递了--global 选项，因为Git将总是会使用该信息来处理你在系统中所做的一切操作。如果你希望在一个特定的项目中使用不同的名称或e-mail地址，你可以在该项目中运行该命令而不要--global选项。总之--global为全局配置，不加为某个项目的特定配置。\r\n\r\n![img](cloudDisk/markdown/Git笔记.assets/format,png-165401714430220.png)\r\n\r\nGit基本理论（重要）\r\n\r\n\r\n\r\n## 三个区域\r\n\r\nGit本地有三个工作区域：**工作目录**（Working Directory）、**暂存区**(Stage/Index)、**资源库**(Repository或Git Directory)。如果在加上远程的git仓库(Remote Directory)就可以分为四个工作区域。文件在这四个区域之间的转换关系如下：\r\n\r\n![img](cloudDisk/markdown/Git笔记.assets/format,png-165401719550722.png)\r\n\r\n- Workspace：工作区，就是你平时存放项目代码的地方\r\n- Index / Stage：暂存区，用于临时存放你的改动，事实上它只是一个文件，保存即将提交到文件列表信息\r\n- Repository：仓库区（或本地仓库），就是安全存放数据的位置，这里面有你提交到所有版本的数据。其中HEAD指向最新放入仓库的版本\r\n- Remote：远程仓库，托管代码的服务器，可以简单的认为是你项目组中的一台电脑用于远程数据交换\r\n\r\n本地的三个区域确切的说应该是git仓库中HEAD指向的版本：\r\n\r\n![img](cloudDisk/markdown/Git笔记.assets/format,png-165401720422624.png)\r\n\r\n- Directory：使用Git管理的一个目录，也就是一个仓库，包含我们的工作空间和Git的管理空间。\r\n- WorkSpace：需要通过Git进行版本控制的目录和文件，这些目录和文件组成了工作空间。\r\n- .git：存放Git管理信息的目录，初始化仓库的时候自动创建。\r\n- Index/Stage：暂存区，或者叫待提交更新区，在提交进入repo之前，我们可以把所有的更新放在暂存区。\r\n- Local Repo：本地仓库，一个存放在本地的版本库；HEAD会只是当前的开发分支（branch）。\r\n- Stash：隐藏，是一个工作状态保存栈，用于保存/恢复WorkSpace中的临时状态。\r\n\r\n## 工作流程\r\n\r\ngit的工作流程一般是这样的：\r\n\r\n１、在工作目录中添加、修改文件；\r\n\r\n２、将需要进行版本管理的文件放入暂存区域；\r\n\r\n３、将暂存区域的文件提交到git仓库。\r\n\r\n因此，git管理的文件有三种状态：已修改（modified）,已暂存（staged）,已提交(committed)\r\n\r\n![img](cloudDisk/markdown/Git笔记.assets/format,png-165401742667126.png)\r\n\r\nGit项目搭建\r\n\r\n## 创建工作目录与常用指令\r\n\r\n工作目录（WorkSpace)一般就是你希望Git帮助你管理的文件夹，可以是你项目的目录，也可以是一个空目录，建议不要有中文。\r\n\r\n日常使用只要记住下图6个命令：\r\n\r\n![img](cloudDisk/markdown/Git笔记.assets/format,png-165401748298028.png)\r\n\r\n\r\n\r\n## 本地仓库搭建\r\n\r\n创建本地仓库的方法有两种：一种是创建全新的仓库，另一种是克隆远程仓库。\r\n\r\n1、创建全新的仓库，需要用GIT管理的项目的根目录执行：\r\n\r\n```\r\n# 在当前目录新建一个Git代码库\r\n$ git init\r\n```\r\n\r\n2、执行后可以看到，仅仅在项目目录多出了一个.git目录，关于版本等的所有信息都在这个目录里面。\r\n\r\n\r\n\r\n## 克隆远程仓库\r\n\r\n1、另一种方式是克隆远程目录，由于是将远程服务器上的仓库完全镜像一份至本地！\r\n\r\n```\r\n# 克隆一个项目和它的整个代码历史(版本信息)\r\n$ git clone [url]  # https://gitee.com/kuangstudy/openclass.git\r\n```\r\n\r\n2、去 gitee 或者 github 上克隆一个测试！\r\n\r\n\r\n\r\n![image-20220601012218041](cloudDisk/markdown/Git笔记.assets/image-20220601012218041.png)\r\n\r\n![image-20220601012227819](cloudDisk/markdown/Git笔记.assets/image-20220601012227819.png)\r\n\r\n## Git文件操作\r\n\r\n### 文件的四种状态\r\n\r\n版本控制就是对文件的版本控制，要对文件进行修改、提交等操作，首先要知道文件当前在什么状态，不然可能会提交了现在还不想提交的文件，或者要提交的文件没提交上。\r\n\r\n- Untracked: 未跟踪, 此文件在文件夹中, 但并没有加入到git库, 不参与版本控制. 通过g==it add== 状态变为==Staged==.\r\n- Unmodify: 文件已经入库, 未修改, 即版本库中的文件快照内容与文件夹中完全一致. 这种类型的文件有两种去处, 如果它被修改, 而变为==Modified==. 如果使用==git rm==移出版本库, 则成为==Untracked==文件\r\n- Modified: 文件已修改, 仅仅是修改, 并没有进行其他的操作. 这个文件也有两个去处, 通过==git add==可进入暂存==staged==状态, 使用==git checkout==则丢弃修改过, 返回到==unmodify==状态, 这个==git checkout==即从库中取出文件, 覆盖当前修改 !\r\n- Staged: 暂存状态. 执行==git commit==则将修改同步到库中, 这时库中的文件和本地文件又变为一致, 文件为==Unmodify==状态. 执行==git reset HEAD filename==取消暂存, 文件状态为==Modified==\r\n\r\n\r\n\r\n## 查看文件状态\r\n\r\n上面说文件有4种状态，通过如下命令可以查看到文件的状态：\r\n\r\n```\r\n#查看指定文件状态\r\ngit status [filename]\r\n \r\n \r\n#查看所有文件状态\r\ngit status\r\n \r\n \r\n# git add .                  添加所有文件到暂存区\r\n# git commit -m \"消息内容\"    提交暂存区中的内容到本地仓库 -m 提交信息\r\n```\r\n\r\n## 忽略文件\r\n\r\n有些时候我们不想把某些文件纳入版本控制中，比如数据库文件，临时文件，设计文件等\r\n\r\n在主目录下建立\".gitignore\"文件，此文件有如下规则：\r\n\r\n1. 忽略文件中的空行或以井号（#）开始的行将会被忽略。\r\n2. 可以使用Linux通配符。例如：星号（*）代表任意多个字符，问号（？）代表一个字符，方括号（[abc]）代表可选字符范围，大括号（{string1,string2,...}）代表可选的字符串等。\r\n3. 如果名称的最前面有一个感叹号（!），表示例外规则，将不被忽略。\r\n4. 如果名称的最前面是一个路径分隔符（/），表示要忽略的文件在此目录下，而子目录中的文件不忽略。\r\n5. 如果名称的最后面是一个路径分隔符（/），表示要忽略的是此目录下该名称的子目录，而非文件（默认文件或目录都忽略）。\r\n\r\n```\r\n#为注释\r\n*.txt        #忽略所有 .txt结尾的文件,这样的话上传就不会被选中！\r\n!lib.txt     #但lib.txt除外\r\n/temp        #仅忽略项目根目录下的TODO文件,不包括其它目录temp\r\nbuild/       #忽略build/目录下的所有文件\r\ndoc/*.txt    #会忽略 doc/notes.txt 但不包括 doc/server/arch.txt\r\n```\r\n\r\n使用码云\r\n\r\n## github 是有墙的，比较慢，在国内的话，我们一般使用 gitee ，公司中有时候会搭建自己的gitlab服务器\r\n\r\n这个其实可以作为大家未来找工作的一个重要信息！\r\n\r\n1、注册登录码云，完善个人信息\r\n\r\n![img](cloudDisk/markdown/Git笔记.assets/format,png.png)\r\n\r\n\r\n\r\n2、设置本机绑定SSH公钥，实现免密码登录！（免密码登录，这一步挺重要的，码云是远程仓库，我们是平时工作在本地仓库！)\r\n\r\n```\r\n# 进入 C:\\Users\\Administrator\\.ssh 目录\r\n# 生成公钥\r\nssh-keygen\r\n```\r\n\r\n![img](cloudDisk/markdown/Git笔记.assets/format,png-16540186777892.png)\r\n\r\n3、将公钥信息public key 添加到码云账户中即可！\r\n\r\n![img](cloudDisk/markdown/Git笔记.assets/format,png-16540192606574.png)\r\n\r\n4、使用码云创建一个自己的仓库！\r\n\r\n![img](cloudDisk/markdown/Git笔记.assets/format,png-16540192714466.png)\r\n\r\n许可证：开源是否可以随意转载，开源但是不能商业使用，不能转载，...  限制！\r\n\r\n![img](cloudDisk/markdown/Git笔记.assets/format,png-16540192792528.png)\r\n\r\n\r\n\r\n克隆到本地！\r\n\r\n![img](cloudDisk/markdown/Git笔记.assets/format,png-165401928685910.png)\r\n\r\n\r\n\r\nIDEA中集成Git\r\n\r\n1、新建项目，绑定git。\r\n\r\n![img](cloudDisk/markdown/Git笔记.assets/format,png-165401943386912.png)\r\n\r\n注意观察idea中的变化\r\n\r\n![img](cloudDisk/markdown/Git笔记.assets/format,png-165401943969814.png)\r\n\r\n\r\n\r\n2、修改文件，使用IDEA操作git。\r\n\r\n- 添加到暂存区\r\n- commit 提交\r\n- push到远程仓库\r\n\r\n3、提交测试\r\n\r\n![img](cloudDisk/markdown/Git笔记.assets/format,png-165402085388016.png)\r\n\r\n这些都是单个人的操作！\r\n\r\n学习的方式最重要！学会学习！我上课的更多时候都是在教大家去学习一种理念和思想（学习方式）\r\n\r\n有道无术、术尚可求。有术无道、止于术！\r\n\r\n真正的教学，授人以渔！\r\n\r\n\r\n\r\n## 说明：GIT分支\r\n\r\n分支在GIT中相对较难，分支就是科幻电影里面的平行宇宙，如果两个平行宇宙互不干扰，那对现在的你也没啥影响。不过，在某个时间点，两个平行宇宙合并了，我们就需要处理一些问题了！\r\n\r\n![img](cloudDisk/markdown/Git笔记.assets/format,png-165402087736718.png)\r\n\r\n![img](cloudDisk/markdown/Git笔记.assets/format,png-165402088454420.png)\r\n\r\ngit分支中常用指令：\r\n\r\n```\r\n# 列出所有本地分支\r\ngit branch\r\n \r\n \r\n# 列出所有远程分支\r\ngit branch -r\r\n \r\n \r\n# 新建一个分支，但依然停留在当前分支\r\ngit branch [branch-name]\r\n \r\n \r\n# 新建一个分支，并切换到该分支\r\ngit checkout -b [branch]\r\n \r\n \r\n# 合并指定分支到当前分支\r\n$ git merge [branch]\r\n \r\n \r\n# 删除分支\r\n$ git branch -d [branch-name]\r\n \r\n \r\n# 删除远程分支\r\n$ git push origin --delete [branch-name]\r\n$ git branch -dr [remote/branch]\r\n```\r\n\r\nIDEA中操作\r\n\r\n![img](cloudDisk/markdown/Git笔记.assets/format,png-165402090196422.png)\r\n\r\n如果同一个文件在合并分支时都被修改了则会引起冲突：解决的办法是我们可以修改冲突文件后重新提交！选择要保留他的代码还是你的代码！\r\n\r\nmaster主分支应该非常稳定，用来发布新版本，一般情况下不允许在上面工作，工作一般情况下在新建的dev分支上工作，工作完后，比如上要发布，或者说dev分支代码稳定后可以合并到主分支master上来。\r\n\r\n作业练习：找一个小伙伴，一起搭建一个远程仓库，来练习Git！\r\n\r\n1、不要把Git想的很难，工作中多练习使用就自然而然的会了！\r\n\r\n2、Git的学习也十分多，看完我的Git教程之后，可以多去思考，总结到自己博客！\r\n\r\n','2022-06-23 21:04:39','Git is a free and open source distributed version control system designed to handle everything from small to very large projects with speed and efficiency.\r\n\r\nGit is easy to learn and has a tiny footpri','cloudDisk\\markdown\\屏幕截图 2022-06-23 210412.png','原创','','','\0','Git 使用学习','2022-06-23 21:04:39',23,96,NULL,5),(164,'','# 一、开发环境配置\r\n\r\n## 1、安装vscode插件\r\n\r\n![image-20211123133955064](cloudDisk/markdown/Esp32笔记.assets/image-20211123133955064.png)\r\n\r\n## 2、新建工程\r\n\r\n![image-20211123134133825](cloudDisk/markdown/Esp32笔记.assets/image-20211123134133825.png)\r\n\r\n![image-20211123134209333](cloudDisk/markdown/Esp32笔记.assets/image-20211123134209333.png)\r\n\r\n## 3、主函数\r\n\r\n![image-20211123134240417](cloudDisk/markdown/Esp32笔记.assets/image-20211123134240417.png)\r\n\r\n```cpp\r\n#include <Arduino.h>\r\n\r\nvoid setup() {\r\n  // put your setup code here, to run once:\r\n  pinMode(0, OUTPUT);\r\n}\r\n\r\nvoid loop() {\r\n  // put your main code here, to run repeatedly:\r\n  digitalWrite(0, HIGH);\r\n  delay(1000);\r\n  digitalWrite(0, LOW);\r\n  delay(1000);\r\n}\r\n```\r\n\r\n## 4、编译\r\n\r\n![image-20211123134307765](cloudDisk/markdown/Esp32笔记.assets/image-20211123134307765.png)\r\n\r\n![image-20211123134312636](cloudDisk/markdown/Esp32笔记.assets/image-20211123134312636.png)\r\n\r\n## 5、下载\r\n\r\n![image-20211123134325956](cloudDisk/markdown/Esp32笔记.assets/image-20211123134325956.png)\r\n\r\n## 6、调试\r\n\r\n![image-20211123134453080](cloudDisk/markdown/Esp32笔记.assets/image-20211123134453080.png)\r\n\r\n# 二、开发板介绍\r\n\r\n![image-20211123135758664](cloudDisk/markdown/Esp32笔记.assets/image-20211123135758664.png)\r\n\r\n![image-20211123135840850](cloudDisk/markdown/Esp32笔记.assets/image-20211123135840850.png)\r\n\r\n![image-20211123135951313](cloudDisk/markdown/Esp32笔记.assets/image-20211123135951313.png)\r\n\r\n![image-20211123140418490](cloudDisk/markdown/Esp32笔记.assets/image-20211123140418490.png)\r\n\r\n\r\n\r\n## 1、初始化GPIO\r\n\r\n* pinMode(pin, mode)\r\n\r\n作用：设置一个引脚（pin）作为GPIO时的I/O模式。\r\n\r\n参数：\r\n\r\npin：引脚编号\r\n\r\nmode：GPIO的I/O模式，取值有3种\r\n\r\nINPUT ：作为数字输入\r\n\r\nOUTPUT ：作为数字输出\r\n\r\nINPUT_PULLUP：作为数字输入，且使能引脚的内部上拉电阻\r\n\r\n* 注意：\r\n  * a、引脚作为PWM输出时，无需先前使用pinMode配置其模式，因为PWM本身就代表了输出的意思。且官方库源代码中可以发现，它已经帮我们配置为输出了。\r\n  * b、模拟引脚也可以作为数字引脚使用，完全OK。这在数字引脚不够用的情况下非常有用。\r\n\r\n## 2、GPIO数字输出\r\n\r\n* digitalWrite(pin,value)\r\n\r\n作用：设置一个数字输出引脚的输出电平值，HIGH或者LOW。\r\n\r\n参数：\r\n\r\npin：引脚编号。此引脚必须在之前使用pinMode设置为OUTPUT模式。\r\n\r\nvalue：2个值\r\n\r\nLOW：输出低电平\r\n\r\nHIGH：输出高电平\r\n\r\n## 3、GPIO数字输入\r\n\r\n* int digitalRead(pin)\r\n\r\n作用：读取一个数字输入引脚的电平值。\r\n\r\n返回：HIGH（高电平）或者LOW（低电平）。\r\n\r\n参数：\r\n\r\npin：引脚编号。\r\n\r\n示例 : 按键控制灯亮灭\r\n\r\n```c\r\nvoid setup()\r\n{\r\n  pinMode(2,OUTPUT);\r\n  pinMode(0,INPUT_PULLUP);\r\n}\r\n \r\nvoid loop()\r\n{\r\n  if(digitalRead(0))\r\n  {\r\n    while(digitalRead(0));\r\n    digitalWrite(2,!digitalRead(2));\r\n  }\r\n}\r\n```\r\n\r\n## 4、GPIO模拟输入:analogRead(pin)\r\n\r\n注意 : 模拟输入是通过PWM实现的, 所以不需要初始化PIN\r\n\r\nanalogRead(4)\r\n\r\n## 5、模拟信号输入分辨率: analogSetWidth(bit);\r\n\r\n| bit的值    | 范围   |\r\n| ---------- | ------ |\r\n| 9          | 0~511  |\r\n| 10         | 0~1023 |\r\n| 11         | 0~2047 |\r\n| 12（默认） | 0~4095 |\r\n\r\n\r\n\r\n## 6、模拟信号输出 (基于LEDC)\r\n\r\nLEDC是基于PWM调制实现模拟输出的.\r\n与arduino uno主板不同, ESP32的PWM模拟是一个个通道 共16个, 通道可以映射到引脚上. 引脚就可以输出PWM信号了.\r\n\r\n![image-20211127102027989](cloudDisk/markdown/Esp32笔记.assets/image-20211127102027989.png)\r\n\r\n### 6.1 设置通道 ledcSetup(channel,freq,bit_num)\r\n\r\n参数:\r\n\r\nchannel : LEDC的PWM通道参数,可选0~15\r\nfreq : 10Hz到40MHz , 但较高的频率精确度低\r\nbit_num: 占空比分辨率(可选1~16), 比如bit_num=8 则范围 0~2的8次方 , 也就是0~255\r\n推荐的配置:\r\n\r\n![image-20211127102048799](cloudDisk/markdown/Esp32笔记.assets/image-20211127102048799.png)\r\n\r\nledcSetup(1,1200,16);\r\n\r\n### 6.2 通道与引脚映射 ledcAttachPin(pin,channel)\r\n\r\nledcAttachPin(5,1);\r\n注意: 一个通道可以同时映射多个引脚\r\n\r\n### 6.3 取消引脚的PWM映射 ledcDetachPin(pin)\r\n\r\nledcDetachPin(5);\r\n\r\n### 6.4 向指定通道写入占空比 ledcWrite(channel,duty)\r\n\r\n例: 呼吸灯\r\n\r\n```c\r\nbool add_status = true;\r\nvoid setup()\r\n{\r\n  pinMode(2,OUTPUT);\r\n  ledcSetup(2,1200,8);\r\n  ledcAttachPin(2,2);\r\n}\r\n \r\nvoid loop()\r\n{\r\n   for(int i = 0 ; i<256; i++)\r\n   {\r\n    if(add_status)\r\n    {\r\n      ledcWrite(2,i);\r\n    }\r\n    else\r\n    {\r\n      ledcWrite(2,256-i);\r\n    }\r\n    delay(5);\r\n  }\r\n  add_status = !add_status;\r\n}\r\n```\r\n\r\n##### 例子, 全彩呼吸灯\r\n\r\n```c\r\n#include <Arduino.h>\r\n \r\n#define LED_R 27\r\n#define LED_G 33\r\n#define LED_B 32\r\n \r\nvoid setup()\r\n{\r\n  Serial.begin(115200);\r\n  ledcSetup(1, 1200, 8);\r\n  ledcSetup(2, 1200, 8);\r\n  ledcSetup(3, 1200, 8);\r\n \r\n  ledcAttachPin(LED_R, 1);\r\n  ledcAttachPin(LED_G, 2);\r\n  ledcAttachPin(LED_B, 3);\r\n \r\n  ledcWrite(1, 255);\r\n  ledcWrite(2, 255);\r\n  ledcWrite(3, 255);\r\n}\r\n \r\nvoid loop()\r\n{\r\n  for (int i = 0; i < 510; i++)\r\n  {\r\n    if (i >= 0 && i < 255)\r\n      ledcWrite(1, 255 - i);\r\n    if (i >= 255 && i < 510)\r\n      ledcWrite(1, i - 255);\r\n \r\n    if (i >= 0 && i < 170)\r\n      ledcWrite(2, 85 + i);\r\n    if (i >= 170 && i < 425)\r\n      ledcWrite(2, 425 - i);\r\n    if (i >= 425 && i < 510)\r\n      ledcWrite(2, i - 425);\r\n \r\n    if (i >= 0 && i < 85)\r\n      ledcWrite(3, 85 - i);\r\n    if (i >= 85 && i < 340)\r\n      ledcWrite(3, i - 85);\r\n    if (i >= 340 && i < 510)\r\n      ledcWrite(3, 595 - i);\r\n    delay(10);\r\n  }\r\n}\r\n```\r\n\r\n6.5 向指定通道输出指定频率的音符信号 ledcWriteTone(channel, freq)\r\n6.6 向指定通道输出指定的音符和音阶 ledcWriteNote(channel,note,octava)\r\n参数\r\n\r\nnote : 音符 可选(NOTE_C, NOTE_Cs, NOTE_D, NOTE_Eb, NOTE_C......)\r\noctava : 音阶 , 可选0~7\r\n\r\n### 7、模拟信号输出函数 (基于DAC)\r\n\r\nESP32提供了两个DAC通道, 对应引脚25 , 26. 精度为8位.\r\n\r\ndacWrite(pin,value);\r\n\r\n- value取值: 0~255\r\n\r\n```c\r\nvoid setup()\r\n{\r\n \r\n}\r\n \r\nvoid loop()\r\n{\r\n   for(int i = 0 ; i<256; i++)\r\n   {\r\n    dacWrite(25,i);\r\n    delay(10);\r\n  }\r\n}\r\n```\r\n\r\n# 三、串口打印 UART\r\n\r\nESP32共有3个UART端口, 其中UART1用于Flash读/写.\r\n\r\n![image-20211127102241090](cloudDisk/markdown/Esp32笔记.assets/image-20211127102241090.png)\r\n\r\n\r\n\r\n## 1、串口初始化\r\n\r\nSerial.begin(speed, config)\r\n\r\n参数：\r\nspeed：波特率，一般取值9600,115200等。\r\nconfig：设置数据位、校验位和停止位。默认SERIAL_8N1表示8个数据位，无校验位，1个停止位。\r\n返回值：无。\r\n\r\n## 2、关闭串口\r\n\r\nSerial.end()\r\n\r\n描述：禁止串口传输。此时串口Rx和Tx可以作为数字IO引脚使用。\r\n原型：Serial.end()\r\n参数：无。\r\n返回值：无。\r\n\r\n## 3、串口打印\r\n\r\nSerial.print()\r\n\r\n描述：串口输出数据，写入字符数据到串口。\r\n原型：\r\nSerial.print(val)\r\nSerial.print(val, format)\r\n参数：\r\nval：打印的值，任意数据类型。\r\nconfig：输出的数据格式。BIN(二进制)、OCT(八进制)、DEC(十进制)、HEX(十六进制)。对于浮点数，此参数指定要使用的小数位数。\r\n\r\n## 4、串口输出数据并换行 println() 和 printf()\r\n\r\nSerial.println()\r\nSerial.printf()\r\n\r\n描述：串口输出数据并换行。\r\n原型：\r\nSerial.println(val)\r\nSerial.println(val, format)\r\n参数：\r\nval：打印的值，任意数据类型。\r\nconfig：输出的数据格式。\r\n返回值：返回写入的字节数。\r\n附: 常用格式字符及转义字符\r\n\r\n![image-20211127102304961](cloudDisk/markdown/Esp32笔记.assets/image-20211127102304961.png)\r\n\r\n## 5、将二进制数写入串口\r\n\r\n* Serial.write()\r\n\r\n描述\r\n将二进制数据写入串行端口。该数据以字节或一系列字节的形式发送；要发送代表数字数字的字符，请改用print（）函数。\r\n句法\r\n*Serial*.write(val)\r\n*Serial*.write(str)\r\n*Serial*.write(buf, len)\r\n参量\r\n*Serial*：串行端口对象。请参阅“ 串行”主页上每个板的可用串行端口列表。\r\nval：要作为单个字节发送的值。\r\nstr：作为一系列字节发送的字符串。\r\nbuf：要作为一系列字节发送的数组。\r\nlen：要从数组发送的字节数。\r\n退货\r\nwrite()将返回写入的字节数，尽管读取该数字是可选的。资料类型：size_t。\r\n\r\n## 6、判断串口缓冲区的状态\r\n\r\n* Serial.available()\r\n\r\n描述：判断串口缓冲区的状态，返回从串口缓冲区读取的字节数。\r\n原型：Serial.available()\r\n参数：无。\r\n返回值：可读取的字节数。\r\n\r\n## 7、读取串口数据\r\n\r\n* **Serial.read()**\r\n\r\n描述：读取串口数据，一次读一个字符，读完后删除已读数据。\r\n\r\n原型：Serial.read()\r\n参数：无。\r\n返回值：返回串口缓存中第一个可读字节，当没有可读数据时返回-1，整数类型。\r\n\r\n```c\r\n#include<stdio.h>\r\n#include<stdlib.h>\r\nchar rev;\r\nvoid setup() {\r\n  Serial.begin(115200);\r\n}\r\n \r\nvoid loop() {\r\n  if(Serial.available())\r\n  {\r\n    rev=Serial.read();\r\n    Serial.print(\"rev=\");\r\n    Serial.println(rev);\r\n    }\r\n}\r\n```\r\n\r\n* **Serial.readBytes()**\r\n\r\n描述：从串口读取指定长度的字符到缓存数组。\r\n原型：Serial.readBytes(buffer, length)\r\n参数：\r\nbuffer：缓存变量。\r\nlength：设定的读取长度。\r\n返回值：返回存入缓存的字符数。\r\n\r\n* **Serial.readString（）**\r\n\r\n描述\r\n\r\nSerial.readString()从串行缓冲区读取字符到字符串。如果超时，该函数将终止。\r\n\r\nSerial.readString()从Stream实用程序类继承。\r\n\r\n句法\r\n\r\n*Serial*.readString()\r\n\r\n参量\r\n\r\n*Serial*：串行端口对象。请参阅“ 串行”主页上每个板的可用串行端口列表。\r\n\r\n返回值\r\n\r\n一个String从串行读缓冲器\r\n\r\n* **Serial.readStringUntil（）**\r\n\r\n描述\r\nreadStringUntil()从串行缓冲区读取字符到字符串。如果超时，该函数将终止（请参见setTimeout（））。\r\nSerial.readStringUntil()从Stream实用程序类继承。\r\n句法\r\n*Serial*.readStringUntil(terminator)\r\n参量\r\n*Serial*：串行端口对象。请参阅“ 串行”主页上每个板的可用串行端口列表。\r\nterminator：要搜索的字符。允许的数据类型：char。\r\n返回值\r\nString从串行缓冲区的整个读取，直到终止符\r\n\r\n注意和警告\r\n终止符将从串行缓冲区中丢弃。\r\n\r\n* **Serial.find（）**\r\n\r\n描述\r\nSerial.find()从串行缓冲区读取数据，直到找到目标为止。true如果找到目标，函数将返回false超时。\r\nSerial.find()从流实用程序类继承。\r\n句法\r\n*Serial*.find(target)\r\n*Serial*.find(target, length)\r\n参量\r\n*Serial*：串行端口对象。请参阅“ 串行”主页上每个板的可用串行端口列表。\r\ntarget：要搜索的字符串。允许的数据类型：char。\r\nlength：目标的长度。允许的数据类型：size_t。\r\n返回值\r\n资料类型：bool。\r\n\r\n* **Serial.findUntil（）**\r\n\r\n描述\r\nSerial.findUntil() 从串行缓冲区读取数据，直到找到给定长度的目标字符串或终止符字符串。\r\n如果找到目标字符串，则该函数返回true；如果超时，则返回false。\r\nSerial.findUntil()从Stream实用程序类继承。\r\n句法\r\n*Serial*.findUntil(target, terminal)\r\n参量\r\n*Serial*：串行端口对象。请参阅“ 串行”主页上每个板的可用串行端口列表。\r\ntarget：要搜索的字符串。允许的数据类型：char。\r\nterminal：搜索中的终端字符串。允许的数据类型：char。\r\n返回值\r\n资料类型：bool。\r\n\r\n* **Serial.parseFloat（）**\r\n\r\n描述\r\nSerial.parseFloat()从串行缓冲区返回第一个有效的浮点数。parseFloat()以不是浮点数的第一个字符终止。如果超时，该函数将终止（请参见Serial.setTimeout（））。\r\nSerial.parseFloat()从Stream实用程序类继承。\r\n句法\r\n*Serial*.parseFloat()\r\n*Serial*.parseFloat(lookahead)\r\n*Serial*.parseFloat(lookahead, ignore)\r\n参量\r\n*Serial*：串行端口对象。请参阅“ 串行”主页上每个板的可用串行端口列表。\r\nlookahead：用于在流中向前查询浮点数的模式。允许的数据类型：LookaheadMode。允许lookahead值：\r\n\r\nSKIP_ALL：扫描流中的浮点数时，除负号，小数点或数字以外的所有字符都将被忽略。这是默认模式。\r\nSKIP_NONE：任何内容都不会被跳过，除非第一个等待的字符有效，否则流不会被触摸。\r\nSKIP_WHITESPACE：仅跳过制表符，空格，换行符和回车符。\r\nignore：用于跳过搜索中指示的字符。例如，用于跳过数千个分频器。允许的数据类型：char\r\n返回值：\r\n类型：float。\r\n\r\n* Serial.parseInt（）\r\n\r\n描述\r\n在输入的序列中查找下一个有效整数。如果超时，该函数将终止（请参见Serial.setTimeout（））。\r\nSerial.parseInt()从Stream实用程序类继承。\r\n尤其是：\r\n\r\n如果没有读取到可配置的超时值的字符，或者读取了非数字，则分析停止。\r\n如果在发生超时（请参见Serial.setTimeout（））时未读取到有效数字，则返回0；否则返回0。\r\n句法\r\n*Serial*.parseInt()\r\n*Serial*.parseInt(lookahead)\r\n*Serial*.parseInt(lookahead, ignore)\r\n参量\r\n*Serial*：串行端口对象。请参阅“ 串行”主页上每个板的可用串行端口列表。\r\nlookahead：用于在流中向前搜索整数的模式。允许的数据类型：LookaheadMode。允许lookahead值：\r\n\r\nSKIP_ALL：扫描流中的整数时，将忽略数字或减号以外的所有字符。这是默认模式。\r\nSKIP_NONE：任何内容都不会被跳过，除非第一个等待的字符有效，否则流不会被触摸。\r\nSKIP_WHITESPACE：仅跳过制表符，空格，换行符和回车符。\r\nignore：用于跳过搜索中指示的字符。例如，用于跳过数千个分频器。允许的数据类型：char\r\n返回值\r\n下一个有效整数。资料类型：long。\r\n\r\n## 8、判断串口是否就绪 Serial\r\n\r\n描述\r\n\r\n指示指定的串行端口是否已就绪。\r\n\r\n在具有本地USB的板上if (Serial)（或if(SerialUSB)在Due上）指示USB CDC串行连接是否打开。对于所有其他板卡和非USB CDC端口，这将始终返回true。\r\n\r\n这是在Arduino IDE 1.0.1中引入的。\r\n\r\n句法\r\n\r\nif (Serial) while (!Serial) 等等\r\n\r\n参量\r\n\r\n没有\r\n\r\n返回值\r\n\r\n如果指定的串行端口可用，则返回true。如果在准备就绪之前查询Leonardo的USB CDC串行连接，则仅返回false。类型：bool。\r\n\r\n## 9、设置串口超时\r\n\r\n* Serial.setTimeout（）\r\n\r\n描述\r\nSerial.setTimeout()设置等待串行数据的最大毫秒数。默认值为1000毫秒。\r\nSerial.setTimeout()从Stream实用程序类继承。\r\n句法\r\n*Serial*.setTimeout(time)\r\n参量\r\n*Serial*：串行端口对象。请参阅“ 串行”主页上每个板的可用串行端口列表。\r\ntime：超时时间（以毫秒为单位）。允许的数据类型：long。\r\n退货\r\n没有\r\n\r\n注意和警告\r\n使用通过*Serial*.setTimeout()以下方式设置的超时值的串行函数：\r\n\r\n*Serial*.find()\r\n*Serial*.findUntil()\r\n*Serial*.parseInt()\r\n*Serial*.parseFloat()\r\n*Serial*.readBytes()\r\n*Serial*.readBytesUntil()\r\n*Serial*.readString()\r\n*Serial*.readStringUntil()\r\n也可以看看\r\n\r\n```c\r\nvoid setup() {\r\n  //Initialize serial and wait for port to open:\r\n  Serial.begin(9600);\r\n  while (!Serial) {\r\n    ; // wait for serial port to connect. Needed for native USB\r\n  }\r\n}\r\n \r\nvoid loop() {\r\n  //proceed normally\r\n}\r\n```\r\n\r\n```c\r\n/*\r\n   Serial\r\n   串口通讯实验\r\n*/\r\nint incomedate = 0;\r\nvoid setup() {\r\n \r\n  Serial.begin(9600); //设置串口波特率9600\r\n \r\n  Serial.println(78, BIN);// \"1001110\"\r\n  Serial.println(78, OCT);// \"116\"\r\n  Serial.println(78, DEC);// \"78\"\r\n  Serial.println(78, HEX);// \"4E\"\r\n  Serial.println(1.23456, 0);// \"1\"\r\n  Serial.println(1.23456, 2);// \"1.23\"\r\n  Serial.println(1.23456, 4);// \"1.2346\"\r\n  Serial.println(\'N\');// \"N\"\r\n  Serial.println(\"Hello world.\");// \"Hello world.\"\r\n}\r\nvoid loop() {\r\n \r\n  if (Serial.available() > 0)//串口接收到数据\r\n  {\r\n    incomedate = Serial.read();//获取串口接收到的数据\r\n    if (incomedate == \'H\')\r\n    {\r\n      Serial.println(\"Good Job!\");\r\n    }\r\n  }\r\n  delay(1000);\r\n}\r\n```\r\n\r\n使用的串口Serial其实是HardwareSerial类的实例化，实例化过程中传入了串口号，实现过程如下：\r\n\r\n![image-20211127102441017](cloudDisk/markdown/Esp32笔记.assets/image-20211127102441017.png)\r\n\r\n# 四、 电容按键 霍尔传感器 外部中断 延时 脉冲检测\r\n\r\n## 4.1、 电容输入 touchRead(pin) 及电容输入中断touchAttachInterrupt(pin, TSR , threshold)\r\n\r\nESP32专门提供了电容触摸传感器的功能, 共有T0,T2~T9 共 9个touch传感器可用.分别对应引脚4、2、15、13、12、14、27、33、32. 无需设置PinMode\r\n\r\n**touchRead(pin)**\r\n\r\n返回值 0~255. 触摸强度\r\n注意: 摸得越瓷实,数值越小\r\n\r\n```c\r\nvoid setup()\r\n{\r\n  Serial.begin(9600);\r\n}\r\n \r\nvoid loop()\r\n{\r\n   Serial.printf(\"touch:%d\\n\",touchRead(4));\r\n}\r\n```\r\n\r\n**touchAttachInterrupt(pin, TSR , threshold)**\r\n\r\n参数：\r\n\r\n- TSR ：中断回调函数， 不能带参数， 不能有返回值。\r\n- threshold：阈值， 达到该阈值会触发此中断\r\n\r\n```c\r\nvoid TSR()\r\n{\r\n  Serial.printf(\"我被按下了!\\r\\n\");\r\n  }\r\n \r\nvoid setup()\r\n{\r\n  Serial.begin(9600);\r\n  touchAttachInterrupt(4, TSR , 20);\r\n}\r\n \r\nvoid loop()\r\n{\r\n  \r\n}\r\n```\r\n\r\n## 4.2、 霍尔传感器\r\n\r\nESP32自带霍尔传感器 , 当有磁场靠近时,会显示正负值\r\n\r\nhallRead()\r\n\r\n## 4.3、外部中断\r\n\r\n#### 1. 开启外部中断 attachInterrupt(pin,function,mode);\r\n\r\n参数:\r\n\r\n- pin: 外部中断引脚\r\n- function : 外部中断回调函数\r\n- mode : 5种外部中断模式, 见下表:\r\n\r\n![image-20211127104313341](cloudDisk/markdown/Esp32笔记.assets/image-20211127104313341.png)\r\n\r\n```c\r\nvoid func1()\r\n{\r\n  Serial.printf(\"按键中断触发\");\r\n  }\r\nvoid setup()\r\n{\r\n  Serial.begin(9600);\r\n  attachInterrupt(0,func1,FALLING);\r\n}\r\n \r\nvoid loop()\r\n{\r\n  \r\n}\r\n```\r\n\r\n#### 2. 关闭引脚中断 detchInterrupt(pin);\r\n\r\n无返回值\r\n\r\n## 4.4、时间统计函数\r\n\r\n### 1. 开机至今的毫秒数 millis\r\n\r\nmillis() 返回值是unsigned long 类型, 大约50天溢出一次\r\n\r\n### 2. 开机至今的微秒数 micros\r\n\r\nmicros() 返回值是unsigned long 类型, 大约70分钟溢出一次\r\n\r\n## 4.5、阻塞延时\r\n\r\n时间控制函数\r\n    由于我们接下来的实验程序很多都用到延时函数，那么这里就介绍几个：\r\n\r\ndelay() ----- 毫秒级延时\r\ndelayMicroseconds() ----- 微秒级延时\r\n\r\n硬件定时器相关请见第六篇\r\n\r\n## 4.6、引脚脉冲信号检测 pulseIn()\r\n\r\npulseIn(pin,state)\r\npulseIn(pin,state,timeout)\r\n\r\n参数:\r\n\r\n- pin : 引脚\r\n- state : 脉冲类型, 可选高或者低\r\n- timeout : 超时时间, 默认1秒钟. 单位为微秒, 无符号长整型.\r\n\r\n返回值: 脉冲宽度, 单位微秒, 数据类型为无符号长整型. 如果超时返回0\r\n\r\n例: 使用SR04超声波测距\r\n\r\n![image-20211127104835896](cloudDisk/markdown/Esp32笔记.assets/image-20211127104835896.png)\r\n\r\n板上接线方式，VCC、trig（控制端）、 echo（接收端）、 out（空脚）、 GND\r\n\r\n![image-20211127104959094](cloudDisk/markdown/Esp32笔记.assets/image-20211127104959094.png)\r\n\r\n```c\r\n#include <Arduino.h>\r\nint distance = 0;\r\nvoid setup()\r\n{\r\n  Serial.begin(115200);\r\n  pinMode(4, OUTPUT);\r\n  digitalWrite(4, LOW);\r\n}\r\n \r\nvoid loop()\r\n{\r\n  digitalWrite(4, HIGH);\r\n  delayMicroseconds(20);\r\n  digitalWrite(4, LOW);\r\n  distance = pulseIn(18,HIGH)/58;\r\n  Serial.printf(\"当前距离是:%d cm\",distance);\r\n  delay(1000);\r\n}\r\n\r\n```\r\n\r\n# 五、platformIO引入类库 自开发库 串口打印字符串\r\n\r\n以驱动超声波测距器件 HC-SR04为例:\r\n\r\n先进入类库界面,搜索相应的关键字\r\n\r\n![image-20211127105146117](cloudDisk/markdown/Esp32笔记.assets/image-20211127105146117.png)\r\n\r\n搜索完成选取自己需要的结果, 点击进去, 查看并安装\r\n\r\n![image-20211127105209310](cloudDisk/markdown/Esp32笔记.assets/image-20211127105209310.png)\r\n\r\n![image-20211127105221695](cloudDisk/markdown/Esp32笔记.assets/image-20211127105221695.png)\r\n\r\n根据安装说明, 在platformio.ini里写好\r\n\r\n![image-20211127105248813](cloudDisk/markdown/Esp32笔记.assets/image-20211127105248813.png)\r\n\r\n然后可以在用的地方引入头文件了\r\n\r\n![image-20211127105309436](cloudDisk/markdown/Esp32笔记.assets/image-20211127105309436.png)\r\n\r\n然后根据示例用法应用:\r\n\r\n![image-20211127105328023](cloudDisk/markdown/Esp32笔记.assets/image-20211127105328023.png)\r\n\r\n我用的这个库,示例还写错了, 这时候可以打开头文件看一下\r\n\r\n![image-20211127105357671](cloudDisk/markdown/Esp32笔记.assets/image-20211127105357671.png)\r\n\r\n同时,也能在.pio中找到示例\r\n\r\n![image-20211127105434138](cloudDisk/markdown/Esp32笔记.assets/image-20211127105434138.png)\r\n\r\n修改后就可以了\r\n\r\n```c\r\n#include <Arduino.h>\r\n#include \"Ultrasonic.h\"\r\n \r\ndouble voltage = 0;\r\nUltrasonic ultrasonic1(4, 18);\r\n \r\nvoid setup()\r\n{\r\n  Serial.begin(115200);\r\n}\r\n \r\nvoid loop()\r\n{\r\n  Serial.print(\"当前距离是: \");\r\n  Serial.print(ultrasonic1.distanceRead()); // Prints the distance on the default unit (centimeters)\r\n  Serial.println(\"cm\");\r\n  delay(1000);\r\n}\r\n```\r\n\r\n## 如何自己开发库\r\n\r\n首先建立.cpp和.h文件 这点很像C\r\n\r\n然后.h中使用面向对象的思维编写类, 这点很像C++\r\n\r\n```c\r\n/*\r\n * SR04.h\r\n * 这里写说明和版本信息\r\n */\r\n \r\n#ifndef SR04_H\r\n#define SR04_H\r\n \r\n#include <Arduino.h>\r\n \r\nclass SR04\r\n{\r\npublic:\r\n  SR04(int trigPin, int echoPin);\r\n  int getdistance();\r\n \r\nprivate:\r\n  int trig_Pin;\r\n  int echo_Pin;\r\n};\r\n#endif\r\n```\r\n\r\n然后写 .cpp文件,实现功能\r\n\r\n```c\r\n#include \"sr04.h\"\r\n \r\nSR04::SR04(int TP, int EP)\r\n{\r\n  pinMode(TP, OUTPUT);\r\n  pinMode(EP, OUTPUT);\r\n    \r\n  trig_Pin = TP;\r\n  echo_Pin = EP;\r\n}\r\n \r\nfloat SR04::getdistance()\r\n{\r\n  //在这里按照时序方法操作引脚获取并换算成距离返回\r\n  Serial.println(\"haha\");\r\n  return 0.0;\r\n}\r\n```\r\n\r\n关键字高亮\r\n\r\n为了方便a\'r\'duinoIDE用户使用, 建立一个keyword.txt文件, 将自己库的关键字高亮起来\r\n\r\n```c\r\nSR04                KEYWORD1\r\ngetdistance         KEYWORD2\r\n```\r\n\r\n我们看到, 往官方库仓里发自己的库还需要满足 示例\\ 整数\\ 配置 \\README 等要求 这些等需要时再研究吧\r\n\r\n![image-20211127110826689](cloudDisk/markdown/Esp32笔记.assets/image-20211127110826689.png)\r\n\r\n## 串口接收字符串\r\n\r\n```c\r\n#include <Arduino.h>\r\n \r\nvoid setup()\r\n{\r\n  Serial.begin(115200);\r\n}\r\n \r\nvoid loop()\r\n{\r\n  String str = \"\";\r\n  while (Serial.available())\r\n  {\r\n    char tmp = Serial.read();\r\n    str += tmp;\r\n    delay(10);\r\n  }\r\n \r\n  if (str != \"\")\r\n  {\r\n    Serial.println(\"recive: \");\r\n    Serial.println(str);\r\n  }\r\n}\r\n```\r\n\r\n#### 例: 串口通过字符串控制LED\r\n\r\n输入字符串red 控制红灯亮灭 ...\r\n\r\n```c\r\n#include <Arduino.h>\r\n \r\n#define LED_R 27\r\n#define LED_G 33\r\n#define LED_B 32\r\n \r\nString revstr = \"\";\r\nconst String red = \"red\";\r\nconst String green = \"green\";\r\nconst String blue = \"blue\";\r\n \r\nString getStr() //ESP32中, 此函数可以用Serial.readString()代替\r\n{\r\n  String str = \"\";\r\n  while (Serial.available())\r\n  {\r\n    char tmp = Serial.read();\r\n    str += tmp;\r\n    delay(10);\r\n  }\r\n \r\n  if (str != \"\")\r\n  {\r\n    return str;\r\n  }\r\n  return \"\";\r\n}\r\n \r\nvoid strToRGB(String revstr)\r\n{\r\n  if (revstr == red)\r\n  {\r\n    digitalWrite(LED_R, !digitalRead(LED_R));\r\n  }\r\n  else if (revstr == green)\r\n  {\r\n    digitalWrite(LED_G, !digitalRead(LED_G));\r\n  }\r\n  else if (revstr == blue)\r\n  {\r\n    digitalWrite(LED_B, !digitalRead(LED_B));\r\n  }\r\n}\r\n \r\nvoid setup()\r\n{\r\n  Serial.begin(115200);\r\n  pinMode(LED_R, OUTPUT);\r\n  pinMode(LED_G, OUTPUT);\r\n  pinMode(LED_B, OUTPUT);\r\n}\r\n \r\nvoid loop()\r\n{\r\n  revstr = getStr();\r\n  if (revstr != \"\")\r\n  {\r\n    strToRGB(revstr);\r\n  }\r\n}\r\n```\r\n\r\n## 字符串解析 String对象\r\n\r\n都很常规:\r\n\r\n![image-20211127111314267](cloudDisk/markdown/Esp32笔记.assets/image-20211127111314267.png)\r\n\r\n测试程序:\r\n\r\n```c\r\n#include <Arduino.h>\r\nString str = \"\";\r\n \r\nvoid setup()\r\n{\r\n  str = \"11滚滚长江东逝水,浪花淘尽英雄,是非成败转头空,青山依旧在,几度夕阳红123!\";\r\n  Serial.begin(115200);\r\n}\r\n \r\nvoid loop()\r\n{\r\n  Serial.println(str.length());\r\n  Serial.println(str.indexOf(\"水\"));\r\n  Serial.println(str.lastIndexOf(\"山\"));\r\n  Serial.println(str.indexOf(\"山\",20));\r\n  Serial.println(str.substring(21));\r\n  Serial.println(str.substring(21,60));\r\n  Serial.println(str.toInt());\r\n  Serial.println(str.endsWith(\"!\"));\r\n  Serial.println(str.endsWith(\"宏\"));\r\n  delay(5000);\r\n}\r\n```\r\n\r\n# 六、硬件定时器, IIC, SPI\r\n\r\n## 6.1、 硬件定时器\r\n\r\nESP32 芯片包含两个硬件定时器组。每组有两个通用硬件定时器。它们都是基于 16 位预分频器和 64 位自动重载功能的向上/向下计数器的 64 位通用定时器。\r\n\r\n### 1. 初始化定时器 timerBegin\r\n\r\nhw_timer_t * timerBegin(uint8_t num, uint16_t divider, bool countUp){}\r\n\r\n参数:\r\n\r\nnum : 定时器编号\r\ndivider:分频数\r\ncountUp: 是否是累加模式\r\n返回值:\r\n返回一个计时器结构体指针 hw_timer_t * ,我们预定义一个指针接收他\r\n\r\n```c\r\nhw_timer_t*  tim1= NULL;\r\ntim1 = timerBegin(0,80,true);  //80MHZ, ESP32主频80MHz\r\n```\r\n\r\n### 2. 取消初始化定时器 timerEnd\r\n\r\nvoid timerEnd(hw_timer_t *timer)\r\n\r\n参数:\r\n\r\n- *timer : 目标定时器 ( 计时器结构体指针 hw_timer_t * )\r\n\r\n### 3. 配置定时器中断 timerAttachInterrupt\r\n\r\nvoid timerAttachInterrupt(hw_timer_t timer, void (fn)(void), bool edge){}\r\n\r\n参数:\r\n\r\n* *timer : 目标定时器 ( 计时器结构体指针 hw_timer_t * )\r\n* void (*fn)(void) : 中断函数入口地址\r\n* 中断边沿触发 : 是否跳变沿触发中断 定时器中断触发方式有: 电平触发中断(level type) 边缘触发中断(edge type)\r\n\r\n```C\r\ntimerAttachInterrupt(tim1,tim1Interrupt,true);\r\n```\r\n\r\n### 4. 取消定时器中断 timerDetachInterrupt\r\n\r\nvoid timerDetachInterrupt(hw_timer_t *timer)\r\n\r\n### 5. 定时器设置timerAlarmWrite\r\n\r\nvoid timerAlarmWrite(hw_timer_t *timer, uint64_t alarm_value, bool autoreload){}\r\n\r\n参数:\r\n\r\n* *timer : 目标定时器 ( 计时器结构体指针 hw_timer_t * )\r\n* alarm_value : 计数上限值\r\n* autoreload : 是否重装载.\r\n\r\n```C\r\ntimerAlarmWrite(tim1, 100000, true);\r\n```\r\n\r\n### 6. 使能定时器 timerAlarmEnable\r\n\r\nvoid timerAlarmEnable(hw_timer_t *timer){}\r\n\r\n参数:\r\n\r\n*timer : 目标定时器 ( 计时器结构体指针 hw_timer_t * )\r\ntimerAlarmEnable(tim1);\r\n\r\n### 7. 失能定时器 timerAlarmDisable\r\n\r\nvoid timerAlarmDisable(hw_timer_t *timer)\r\n\r\n### 8. 判断定时器是否启动 timerAlarmEnabled\r\n\r\nbool timerAlarmEnabled(hw_timer_t *timer)\r\n\r\nSerial.println(timerAlarmEnabled(tim1));\r\n\r\n### 例子:\r\n\r\n```C\r\n#include <Arduino.h>\r\n \r\nhw_timer_t *tim1 = NULL;\r\nint tim1_IRQ_count = 0;\r\n \r\nvoid tim1Interrupt()\r\n{\r\n  Serial.println(\"haha\");\r\n  tim1_IRQ_count++;\r\n  Serial.println(timerAlarmEnabled(tim1));\r\n}\r\n \r\nvoid setup()\r\n{\r\n  Serial.begin(115200);\r\n  tim1 = timerBegin(0, 80, true); // 计数频率 1MHz\r\n  timerAttachInterrupt(tim1, tim1Interrupt, true);\r\n  timerAlarmWrite(tim1, 100000, true); // 计数满过了0.1s\r\n  timerAlarmEnable(tim1);\r\n}\r\n \r\nvoid loop()\r\n{\r\n  if (tim1_IRQ_count > 10) // 1s打印一次\r\n  {\r\n    Serial.println(\"count trigger\");\r\n    tim1_IRQ_count = 0;\r\n  }\r\n}\r\n```\r\n\r\n## 6.2、IIC (主机)\r\n\r\nESP32有两个I2C控制器（也称为端口），负责处理两条I2C总线上的通信。每个I2C控制器都可以作为主机或从机运行。引脚21 默认的SDA, 引脚22是默认的SCL\r\n\r\nIIC需要引入自带库 Wire.h Wire继承steam类 steam类有的他都有\r\n\r\n```c\r\n#include \"Wire.h\"\r\n```\r\n\r\n### 1. 初始化IIC (以主机身份) begin\r\n\r\n```c\r\nWire.begin();\r\n```\r\n\r\n### 2. 以主机身份像从机请求数据 requestFrom\r\n\r\n```c\r\nvoid requestFrom(uint16_t address, uint8_t size, bool sendStop)\r\n```\r\n\r\n请求完成后 主机可以用 `Wire.available()`和`Wire.read()`等函数等待并获取从机的回答\r\n\r\n参数:\r\n\r\n- address : 从机地址\r\n- size: 请求字节数\r\n- sendStop : 是否发送停止 , 如果为true, 释放IIC总线. 如果为false, 发送一个重新开始的信息, 并继续保持IIC总线的连接.\r\n\r\n```c\r\nWire.requestFrom(adress,10,true);\r\n```\r\n\r\n### 3. 主机开始传输 beginTransmission()\r\n\r\nvoid beginTransmission(int address)\r\n随后, 主机可以使用Wire.write();写数据并使用Wire.endTransmission();结束传输\r\n\r\n参数:\r\n\r\n* address : 从机地址\r\n\r\n```c\r\nWire.beginTransmission(120);\r\n```\r\n\r\n### 4. 结束数据传输 endTransmission()\r\n\r\n结束传输, 并释放IIC\r\n\r\n```c\r\nWire.endTransmission();\r\n```\r\n\r\n### 5. 结束数据传输但不释放IIC占用 endTransmission(false)\r\n\r\n返回值: uint8_t 类型\r\n\r\n![image-20211127135703266](cloudDisk/markdown/Esp32笔记.assets/image-20211127135703266.png)\r\n\r\n```c\r\nWire.endTransmission(false);\r\n```\r\n\r\n### 6. 写 write()\r\n\r\n当作为主机时: 主机将要发送的数据加入发送队列;\r\n当作为从机时: 从机发送的数据给主机;\r\n\r\n参数:\r\n\r\n* Wire.write(value); //单字节发送\r\n* Wire.write(string); //以一系列字节发送\r\n* Wire.write(data,length); //以字节形式发送,指定长度\r\n\r\n返回值: byte类型\r\n输入的字节数\r\n\r\n### 7. 接收数据寄存器有值 available()\r\n\r\n返回接收到的字节数\r\n\r\n返回值: byte类型\r\n\r\n- 可读字节数\r\n\r\n### 8. 读取1byte数据 read()\r\n\r\n**当作为主机时:** 主机使用requestFrom()后 要使用此函数获取数据;\r\n**当作为从机时:** 从机读取主机给的数据;\r\n\r\n返回值: 读到的字节数据 byte\r\n\r\n### 9.读取多个字节的数据 readBytes()\r\n\r\nsize_t readBytes(char *buffer, size_t length)\r\n\r\n参数:\r\n\r\n- buffer: 接收缓冲区, 一个char型指针\r\n- length: 数据长度\r\n\r\n返回值: 数据长度\r\n\r\n### 10. 读取直到遇到某字符\r\n\r\nsize_t readBytesUntil(char terminator, char *buffer, size_t length)\r\n\r\n参数:\r\n\r\n* terminator : 终结字符 char类型\r\n* buffer: 接收缓冲区, 一个char型指针\r\n* length: 数据长度\r\n\r\n返回值: 数据长度\r\n\r\n###  11. 当前IIC忙线中?\r\n\r\nWire.busy();\r\n\r\n返回布尔值\r\n\r\n### 12. 读取字符串 readString() readStringUntil()\r\n\r\n继承自steam类, 个人感觉iic不会用到的\r\n\r\n### 13. 其他\r\n\r\nparseFloat\r\nparseInt\r\nfind\r\nfindUntil\r\nsetTimeout\r\n这些都是steam继承来的 大家灵活应用\r\n\r\n## 6.3、IIC(从机)\r\n\r\n从机有些函数和主机是一样的, 请看上一章节,本章节只有不一样的部分\r\n\r\n### 1. 初始化IIC (以从机身份) begin(adress)\r\n\r\nWire.begin(adress); //adress取值0~127\r\n\r\n```c\r\nWire.begin(120);\r\n```\r\n\r\n### 2. 当从机被请求时触发函数onRequest()\r\n\r\nvoid onRequest(void (*)())\r\n\r\n参数:\r\n\r\n- 回调函数\r\n\r\n### 3. 当从机收到数据时触发函数\r\n\r\nvoid onReceive(void (*)(int))\r\n\r\n参数:\r\n\r\n- 回调函数 (接收一个int类型的参数,代表接收的字节数)\r\n\r\n## 6.4、SPI\r\n\r\nESP32有四个SPI外设，分别为SPI0、SPI1、HSPI和VSPI。\r\n\r\n* SPI0是专用于Flash的缓存，ESP32将连接的SPI Flash设备映射到内存中。\r\n* SPI1和SPI0 使用相同的硬件线，SPI1用于写入flash芯片。\r\n* HSPI和VSPI可以任意使用。\r\n* SPI1、HSPI和VSPI共有三条片选线，因此作为SPI主机允许ESP32 至多驱动三个SPI设备。\r\n\r\n![image-20211127140559654](cloudDisk/markdown/Esp32笔记.assets/image-20211127140559654.png)\r\n\r\n### 1. HSPI和VSPI的接口及引脚\r\n\r\n| SPI名 | MOSI | MISO | SCLK | SS   |\r\n| :---- | :--- | :--- | :--- | :--- |\r\n| VSPI  | 23   | 19   | 18   | 5    |\r\n| HSPI  | 13   | 12   | 14   | 15   |\r\n\r\nSPI通讯流程如下:\r\n\r\n![image-20211127140712603](cloudDisk/markdown/Esp32笔记.assets/image-20211127140712603.png)\r\n\r\n### 2. SPI初始化 SPI.begin()\r\n\r\n```c\r\nSPI.begin();\r\n```\r\n\r\nSPI接口默认VSPI. 接口频率1 000 000, 数据默认采用MSBFIRST(低有效位优先), 时钟模式:SPI_MODE0(SCLK闲置为0, SCLK上升沿采样)\r\n\r\n### 3. 设置数据在SPI上的传输方式 SPI.setBitOrder(bitOrder);\r\n\r\n参数:\r\n\r\n- bitOrder : 传输方式, 可选: LSBFIRST 低有效位先传 ; HSBFIRST 高有效位先传\r\n\r\n```c\r\nSPI.setBitOrder(LSBFIRST);\r\n```\r\n\r\n### 3. 设置SPI频率 SPI.setFrequency(freq)\r\n\r\n参数:\r\n\r\n- freq 频率\r\n\r\n```c\r\nSPI.setFrequency(1000000);\r\n```\r\n\r\n### 4. 设置SPI的时钟模式 SPI.setDataMode(dataMode);\r\n\r\n参数:\r\n\r\n- dataMode: 时钟模式, 可以取以下值\r\n\r\n| 模式      | 说明                              |\r\n| :-------- | :-------------------------------- |\r\n| SPI_MODE0 | SCLK闲置为低电平,上升沿采样(默认) |\r\n| SPI_MODE1 | SCLK闲置为低电平,下降沿采样       |\r\n| SPI_MODE2 | SCLK闲置为高电平,上升沿采样       |\r\n| SPI_MODE3 | SCLK闲置为高电平,下降沿采样       |\r\n\r\n```c\r\nSPI.setDataMode(SPI_MODE0);\r\n```\r\n\r\n### 5. 按照setting的设置启动SPI通信 SPI.beginTransaction(setting);\r\n\r\n采用该函数,可以代替上面三个函数了.\r\n\r\n参数:\r\n\r\n- setting 设置. 是SPISettings类型的对象, 有_bitOrder ,_clock ,_dataMode 这三个属性.\r\n\r\n```c\r\nsetting1._bitOrder = LSBFIRST;\r\nsetting1._clock = 1000000;\r\nsetting1._dataMode = SPI_MODE0;\r\nSPI.beginTransaction(setting1);\r\n```\r\n\r\n### 6. 结束SPI通信 SPI.endTransaction();\r\n\r\n结束SPI通信\r\n\r\n```c\r\nSPI.endTransaction();\r\n```\r\n\r\n### 7. 接收/发送一个字节的数据 SPI.transfer(data);\r\n\r\n参数:\r\n\r\n- data: 要发送的数据\r\n\r\n返回值: 接收到的数据\r\n\r\n```c\r\nuint8_t SPIClass::transfer(uint8_t data)\r\n```\r\n\r\n```c\r\nSPI.transfer(0x01);\r\nSPI.transfer16(0x0102);\r\nSPI.transfer32(0x01020304);\r\n\r\nuint8_t byte1;\r\nuint16_t bytes2;\r\nuint32_t bytes3;\r\nbyte1 = SPI.transfer();\r\nbytes2 = SPI.transfer16();\r\nbytes3 = SPI.transfer32();\r\n```\r\n\r\n# 七、Ticker定时库,base64转换,OTA, SSD1306显示QRcode二维码\r\n\r\n## 7.1、Ticker 定时库\r\n\r\nTicker 是ESP32自带库\r\n\r\n注意: 不建议使用Ticker回调函数来阻塞IO操作（网络、串口、文件）；可以在Ticker回调函数中设置一个标记，在loop函数中检测这个标记；\r\n对于arg，必须是 char, short, int, float, void, char 之一；\r\n\r\n![image-20211127143222307](cloudDisk/markdown/Esp32笔记.assets/image-20211127143222307.png)\r\n\r\n### 1. 定时状态获取 .active();\r\n\r\n```c\r\n/**\r\n * Ticker是否激活状态\r\n * @return bool true表示ticker启用\r\n */\r\nbool active();\r\n```\r\n\r\n### 2. 终止定时器 .detach()\r\n\r\n```c\r\n/**\r\n * 停止Ticker\r\n */\r\nvoid detach();\r\n```\r\n\r\n### 3. once() —— xx秒后只执行一次\r\n\r\n```c\r\n/**\r\n * xx秒后只执行一次\r\n * @param seconds 秒数\r\n * @param callback 回调函数\r\n */\r\nvoid once(float seconds, callback_function_t callback);\r\n \r\n/**\r\n * xx秒后只执行一次\r\n * @param seconds 秒数\r\n * @param callback 回调函数\r\n * @param arg 回调函数的参数\r\n */\r\nvoid once(float seconds, void (*callback)(TArg), TArg arg)\r\n```\r\n\r\n##### 示例: 一个传参,一个不传参\r\n\r\n```c\r\n#include \"Arduino.h\"\r\n#include \"Ticker.h\"\r\n \r\nTicker t1;\r\nTicker t2;\r\n \r\nvoid func1()\r\n{\r\n  Serial.println(\"我是t1的回调,我没参数\");\r\n}\r\nvoid func1(int a)\r\n{\r\n  Serial.print(\"我是t2的回调,我的参数是:\");\r\n  Serial.println(a);\r\n}\r\n \r\nvoid setup()\r\n{\r\n  Serial.begin(115200);\r\n  if (1)\r\n  {\r\n    t1.once(10, func1);\r\n    t2.once(20, func1, 8);\r\n    //t1 t2 方法名都叫func1, 但其实是不同的方法, 这涉及到一个方法重载的概念\r\n  }\r\n}\r\n \r\nvoid loop()\r\n{\r\n  Serial.println(\"我来证明我没被阻塞,也没法阻塞Ticker\");\r\n  delay(2700);\r\n}\r\n```\r\n\r\n![image-20211127143444467](cloudDisk/markdown/Esp32笔记.assets/image-20211127143444467.png)\r\n\r\n### 4. once_ms() —— xx毫秒后只执行一次\r\n\r\n用法同上\r\n\r\n```c\r\n/**\r\n * xx毫秒后只执行一次\r\n * @param seconds 秒数\r\n * @param callback 回调函数\r\n */\r\nvoid once_ms(float seconds, callback_function_t callback)\r\n \r\n/**\r\n * xx毫秒后只执行一次\r\n * @param seconds 秒数\r\n * @param callback 回调函数\r\n * @param arg 回调函数的参数\r\n */\r\nvoid once_ms(uint32_t milliseconds, void (*callback)(TArg), TArg arg);\r\n```\r\n\r\n### 5. attach() —— 每隔xx秒周期性执行\r\n\r\n和上面一样,只是周期性执行, 需要.detach()结束运行\r\n\r\n```c\r\n/**\r\n * 每隔xx秒周期性执行\r\n * @param seconds 秒数\r\n * @param callback 回调函数\r\n */\r\nvoid attach(float seconds, callback_function_t callback);\r\n \r\n/**\r\n * 每隔xx秒周期性执行\r\n * @param seconds 秒数\r\n * @param callback 回调函数\r\n * @param arg 回调函数的参数\r\n */\r\nvoid attach(float seconds, void (*callback)(TArg), TArg arg)\r\n```\r\n\r\n### 6. attach_ms() —— 每隔xx毫秒周期性执行\r\n\r\n```c\r\n/**\r\n * 每隔xx毫秒周期性执行\r\n * @param seconds 秒数\r\n * @param callback 回调函数\r\n */\r\nvoid attach_ms(float seconds, callback_function_t callback);\r\n \r\n/**\r\n * 每隔xx毫秒周期性执行\r\n * @param seconds 秒数\r\n * @param callback 回调函数\r\n * @param arg 回调函数的参数\r\n */\r\nvoid attach_ms(uint32_t milliseconds, void (*callback)(TArg), TArg arg)\r\n```\r\n\r\n## 7.2、转换为base64\r\n\r\n### 1. 什么是base64\r\n\r\nBase64是网络上最常见的用于传输8Bit字节码的编码方式之一，Base64就是一种基于64个可打印字符来表示二进制数据的方法。\r\n\r\n标准的Base64并不适合直接放在URL里传输，因为URL编码器会把标准Base64中的“/”和“+”字符变为形如“%XX”的形式，而这些“%”号在存入数据库时还需要再进行转换，因为ANSI SQL中已将“%”号用作通配符。\r\n\r\n为解决此问题，可采用一种用于URL的改进Base64编码，它在末尾填充\'=\'号，并将标准Base64中的“+”和“/”分别改成了“-”和“_”，这样就免去了在URL编解码和数据库存储时所要作的转换，避免了编码信息长度在此过程中的增加，并统一了数据库、表单等处对象标识符的格式。\r\n\r\nESP32就是采用这种编码方式来将数据转换未base64的\r\n\r\n### 2. ESP32转换base64码\r\n\r\nbase64 是ESP32自带库\r\n\r\n用法非常简单. 只有一个静态方法:\r\n\r\n```c\r\nstatic String base64::encode(const String &text)\r\n还有 1 个重载\r\n \r\nconvert input data to base64\r\n \r\n参数:\r\ntext – const String&\r\n \r\n返回:\r\nString\r\n```\r\n\r\n因为是静态方法, 所以我们访问此方法要用如下方法:\r\n\r\n```c\r\nbase64::encode(testBase64);\r\n```\r\n\r\n完整的举例:\r\n\r\n```c\r\n#include <Arduino.h>\r\n#include \"base64.h\"\r\n \r\nString testBase64 = \"this is a test to base64!\";\r\nString revBase64Reslut;\r\n \r\nvoid setup()\r\n{\r\n  Serial.begin(115200);\r\n  delay(5000);\r\n  Serial.println(\"begin encode the string!\");\r\n  revBase64Reslut = base64::encode(testBase64);\r\n  Serial.println(revBase64Reslut);\r\n}\r\n \r\nvoid loop() {}\r\n```\r\n\r\n![image-20211127143849995](cloudDisk/markdown/Esp32笔记.assets/image-20211127143849995.png)\r\n\r\n我们使用[https://base64.us/](https://links.jianshu.com/go?to=https%3A%2F%2Fbase64.us%2F)来验证一下:\r\n\r\n![image-20211127143909153](cloudDisk/markdown/Esp32笔记.assets/image-20211127143909153.png)\r\n\r\n## 7.3、OTA空中升级\r\n\r\nOTA（空中）**更新是使用 WiFi 连接而不是串行端口将固件加载到 ESP 模块的过程**。\r\n\r\n* Arduino IDE：主要用于软件开发阶段，实现不接线固件烧写\r\n* Web Browser：通过 Web 浏览器手动提供应用程序更新模块\r\n* HTTP Server：自动使用http服务器 - 针对产品应用\r\n* 在三种升级情况下，必须通过串行端口完成第一个固件上传。\r\n\r\nOTA 进程没有强加的安全性，需要确保开发人员只能从合法/受信任的来源获得更新。更新完成后，模块将重新启动，并执行新的代码。开发人员应确保在模块上运行的应用程序以安全的方式关闭并重新启动。\r\n\r\n### 1. ESP32 OTA升级原理\r\n\r\nESP32 连接 HTTP 服务器（可以使本地也可以是云，OTA demo使用本地服务器），发送请求 Get 升级固件；每次读取1KB固件数据，写入Flash。\r\n\r\nESP32 SPI Flash 内有与升级相关的（至少）四个分区：\r\n\r\nOTA data区：决定运行哪个区的App\r\nFactory App区：有出厂时的默认App\r\nOTA_0区：OTA_0 App\r\nOTA_1区：OTA_1 App\r\n首次进行 OTA 升级时，OTA Demo 向 OTA_0 分区烧录目标App，并在烧录完成后，更新 OTA data 分区数据并重启。\r\n\r\n系统重启时获取 OTA data 分区数据进行计算，决定此后加载 OTA_0 分区的App执行（而不是默认的 Factory App 分区内的App），从而实现升级。\r\n\r\n同理，若某次升级后 ESP32 已经在执行 OTA_0 内的App，此时再升级时，OTA Demo 就会向 OTA_1 分区写入目标App。再次启动后，执行 OTA_1 分区实现升级。以此类推，升级的目标App始终在 OTA_0、OTA_1 两个分区之间交互烧录，不会影响到出厂时的 Factory App 固件，如下图状态。\r\n\r\n![image-20211127144206979](cloudDisk/markdown/Esp32笔记.assets/image-20211127144206979.png)\r\n\r\n### 2. OTA升级的安全性\r\n\r\n模块必须以无线方式联网获取新的固件， 这使得模块被强行入侵并加载了其他代码。 为了减少被黑客入侵的可能性，请考虑使用密码保护您的上传，选择某些OTA端口，也可以给bin文件加密等。\r\n\r\n### 3. ESP32 OTA升级流程和说明(服务器是本地PC)\r\n\r\n###### 升级流程\r\n\r\n1. 电脑连上路由器（AP）\r\n2. 电脑运行HTTP服务器（本地）\r\n3. 下载OTA Demo到ESP32开发板\r\n4. ESP32连上路由器（AP）后就会访问HTTP下载新的APP到OTA区\r\n\r\n**升级逻辑**\r\n\r\n![image-20211127144328885](cloudDisk/markdown/Esp32笔记.assets/image-20211127144328885.png)\r\n\r\n这里要补一个 局域网OTA升级的程序\r\n\r\n### 4. ESP32 OTA升级(真正网络环境,真正云服务器)\r\n\r\n这里要补充一个真正的OTA升级程序\r\n\r\n### 4. ESP32无线代码上传(ESP32搭建服务器进行OTA升级)\r\n\r\n流程:\r\n\r\n1. ESP32通过STA模式连接至WIFI\r\n2. ESP32建立局域网WEB服务器, 提供WEB更新界面, 需要使用库 ESP32HTTPUpdateServer\r\n3. 用IDE编译好 .bin文件\r\n4. 通过mDNS功能在浏览器中访问ESP32的服务器页面 ,服务器默认地址: http://esp32.local\r\n5. 通过web界面将本地编译好的程序使用HTTP的POST方法上传到ESP32中\r\n6. 上传完成后, ESP32将固件写入flash\r\n\r\n这里要补充一个esp32作为局域网服务器的  OTA程序\r\n\r\n## 7.4、 SSD1306显示二维码\r\n\r\n这里我们要用到一个库 : ESP8266 QRcode\r\n这个库依赖于库: ESP8266_SSD1306\r\n\r\n![image-20211127144632096](cloudDisk/markdown/Esp32笔记.assets/image-20211127144632096.png)\r\n\r\n这个SSD1306驱动库非常好用,可以了解一下\r\n\r\n```c\r\n#include <Arduino.h>\r\n#include \"SSD1306.h\"\r\n#include \"qrcode.h\"\r\n \r\nSSD1306 display(0x3c, 21, 22);\r\nQRcode qrcode(&display);\r\n \r\nvoid setup()\r\n{\r\n  Serial.begin(115200);\r\n  delay(5000);\r\n  Serial.println(\"\");\r\n  Serial.println(\"Starting...\");\r\n \r\n  display.init();\r\n  display.clear();\r\n  display.display();\r\n \r\n  qrcode.init();\r\n  // create qrcode\r\n  qrcode.create(\"helloworld!.\");\r\n}\r\nvoid loop()\r\n{\r\n}\r\n```\r\n\r\n# 八、U8G2驱动OLED\r\n\r\nOLED驱动芯片:SSD1306\r\n开发平台: vscode+platformIO\r\n开发板:ESP32 Divkit v1\r\n\r\n目前Arduino平台上使用最广泛的OLED库: U8G2\r\ngithub地址: https://github.com/olikraus/u8g2/\r\n\r\n设置和参考手册:https://github.com/olikraus/u8g2/wiki\r\n\r\nU8g2：单色显示器库，版本2\r\n\r\nU8g2是用于嵌入式设备的单色图形库。U8g2支持单色OLED和LCD，包括以下控制器：SSD1305，SSD1306，SSD1309，SSD1322，SSD1325，SSD1327，SSD1329，SSD1606，SSD1607，SH1106，SH1107，SH1108，SH1122，T6963，RA8835，LC7981，PCD8544，PCF8812，HX12 ，UC1601，UC1604，UC1608，UC1610，UC1611，UC1701，ST7565，ST7567，ST7588，ST75256，NT7534，IST3020，ST7920，LD7032，KS0108，SED1520，SBN1661，IL3820，MAX7219（完整列表请参见[此处](https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2Folikraus%2Fu8g2%2Fwiki%2Fu8g2setupcpp)）。\r\n\r\n为什么要运用U8g2库？\r\n\r\n- U8g2库平台支持性好，基本上支持绝大部分Arduino开发板；\r\n- U8g2库显示控制器支持性好，基本上市面上的OLED都完美支持；\r\n- U8g2库 API众多，特别支持了中文，支持了不同字体，这是一个对于开发者俩说不小的福利。\r\n\r\n支持单片机平台:\r\n\r\n![image-20211127144923655](cloudDisk/markdown/Esp32笔记.assets/image-20211127144923655.png)\r\n\r\n## 8.1、u8g2的安装\r\n\r\n![image-20211127144946378](cloudDisk/markdown/Esp32笔记.assets/image-20211127144946378.png)\r\n\r\n![image-20211127144955727](cloudDisk/markdown/Esp32笔记.assets/image-20211127144955727.png)\r\n\r\n再platformIO.ini中配置库\r\n\r\n```c\r\nlib_deps =\r\n  # Using a library name\r\n  U8g2\r\n```\r\n\r\n![image-20211127145017360](cloudDisk/markdown/Esp32笔记.assets/image-20211127145017360.png)\r\n\r\n## 8.2、 u8g2函数库\r\n\r\n![img](cloudDisk/markdown/Esp32笔记.assets/format,png.png)\r\n\r\n方法可以分为四大类：\r\n\r\n- 基本函数\r\n- 绘制相关函数\r\n- 显示配置相关函数\r\n- 缓存相关函数\r\n\r\n## 8.3、U8g2库函数详解\r\n\r\n### 1. 基本函数\r\n\r\n#### ⭐1. u8g2.begin() —— 构造U8G2\r\n\r\n初始化显示器, 清屏, 唤醒屏幕\r\n\r\n```c\r\n/**\r\n * 初始化U8g2库\r\n * @Note 关联方法 initDisplay clearDisplay setPowerSave\r\n */\r\nbool U8G2::begin(void)\r\n```\r\n\r\n#### 2. u8g2.beginSimple() —— 构造U8G2\r\n\r\n只是初始化显示器, 并不清屏, 也不唤醒屏幕\r\n\r\n#### 3. u8g2.initDisplay() —— 初始化显示控制器\r\n\r\n```c\r\n/**\r\n * 初始化显示控制器\r\n */\r\nvoid U8G2::initDisplay(void)\r\n```\r\n\r\n\r\n#### 4. u8g2.clearDisplay() —— 清除屏幕内容\r\n\r\n```c\r\n/**\r\n * 清除屏幕\r\n */\r\nvoid U8G2::clearDisplay(void)\r\n```\r\n\r\n#### ⭐5. u8g2.setPowerSave() —— 是否开启省电模式\r\n\r\n```c\r\n/**\r\n * 清除显示缓冲区\r\n * @param is_enable\r\n *        1 表示启用显示器的省电模式，屏幕上看不到任何东西\r\n *        0 表示禁用省电模式\r\n */\r\nvoid U8G2::setPowerSave(uint8_t is_enable)\r\n```\r\n\r\n#### ⭐6. u8g2.clear() —— 清除操作\r\n\r\n```c\r\n/**\r\n * 清除屏幕显示，清除缓冲区，光标回到左上角原点位置（0，0）\r\n * @Note 关联方法 home clearDisplay clearBuffer\r\n */\r\nvoid U8G2::clear(void)\r\n```\r\n\r\n#### ⭐7. u8g2.clearBuffer() —— 清除缓冲区\r\n\r\n```c\r\n/**\r\n * 清除内存中数据缓冲区\r\n */\r\nvoid U8G2::clearBuffer(void)\r\n```\r\n\r\n#### 8. u8g2.disableUTF8Print() —— 禁用 UTF8打印\r\n\r\n```c\r\n/**\r\n * 禁用Arduino平台下支持输出UTF8字符集，默认是开启\r\n */\r\nvoid U8G2::disableUTF8Print(void)\r\n```\r\n\r\n#### 9. u8g2.enableUTF8Print() —— 启用 UTF8打印\r\n\r\n```c\r\n/**\r\n * 开启Arduino平台下支持输出UTF8字符集\r\n */\r\nvoid U8G2::enableUTF8Print(void)\r\n```\r\n\r\n开启UTF-8后,我们可以使用其UTF-8字库\r\n\r\n```c\r\n#include <Arduino.h>\r\n#include <U8g2lib.h>\r\n \r\nU8G2_SSD1306_128X64_NONAME_F_HW_I2C u8g2(U8G2_R0, /* reset=*/U8X8_PIN_NONE, /* clock=*/22, /* data=*/21); // ESP32 Thing, HW I2C with pin remapping\r\n \r\nvoid setup(void)\r\n{\r\n  u8g2.begin();\r\n  u8g2.enableUTF8Print(); // enable UTF8 support for the Arduino print() function\r\n}\r\nvoid loop(void)\r\n{\r\n  u8g2.setFont(u8g2_font_unifont_t_chinese2); // use chinese2\r\n  u8g2.firstPage();\r\n  do\r\n  {\r\n    u8g2.setCursor(0, 20);\r\n    u8g2.print(\"helloworld\"); // Chinese \"Hello World\"\r\n    u8g2.setCursor(0, 40);\r\n    u8g2.print(\"你好世界\"); // Chinese \"Hello World\"\r\n  } while (u8g2.nextPage());\r\n  delay(1000);\r\n}\r\n```\r\n\r\n#### 10. u8g2.home() —— 重置显示光标的位置\r\n\r\n```c\r\n/**\r\n * 重置显示光标的位置，回到原点（0，0）\r\n * @Note 关联方法 print clear\r\n */\r\nvoid U8G2::home(void)\r\n```\r\n\r\n### 2. 绘制相关函数\r\n\r\n#### 1. u8g2.drawBox() —— 画实心方形\r\n\r\n```c\r\n/**\r\n * 画实心方形，左上角坐标为(x,y),宽度为w，高度为h\r\n * @param x 左上角的x坐标\r\n * @param y 左上角的y坐标\r\n * @param w 方形的宽度\r\n * @param h 方形的高度\r\n * @Note 关联方法 drawFrame setDrawColor\r\n */\r\nvoid U8G2::drawBox(u8g2_uint_t x, u8g2_uint_t y, u8g2_uint_t w, u8g2_uint_t h)\r\n```\r\n\r\n如果支持绘制颜色（也就是不是单色显示器），那么由setDrawColor设置；\r\n\r\n```c\r\n#include <Arduino.h>\r\n#include <U8g2lib.h>\r\n \r\nU8G2_SSD1306_128X64_NONAME_F_HW_I2C u8g2(U8G2_R0, /* reset=*/U8X8_PIN_NONE, /* clock=*/22, /* data=*/21); // ESP32 Thing, HW I2C with pin remapping\r\n \r\nvoid setup(void)\r\n{\r\n  u8g2.begin();\r\n}\r\nvoid loop(void)\r\n{\r\n  u8g2.drawBox(3,7,25,15);\r\n  u8g2.sendBuffer();\r\n  delay(1000);\r\n}\r\n```\r\n\r\n#### 2. u8g2.drawCircle() —— 画空心圆\r\n\r\n```c\r\n/**\r\n * 画空心圆，圆心坐标为(x0,y0),半径为rad\r\n * @param x0 圆点的x坐标\r\n * @param y0 圆点的y坐标\r\n * @param rad 圆形的半径\r\n * @param opt 圆形选项\r\n *        U8G_DRAW_ALL 整个圆\r\n *        U8G2_DRAW_UPPER_RIGHT 右上部分的圆弧\r\n *        U8G2_DRAW_UPPER_LEFT  左上部分的圆弧\r\n *        U8G2_DRAW_LOWER_LEFT  左下部分的圆弧\r\n *        U8G2_DRAW_LOWER_RIGHT 右下部分的圆弧\r\n *        选项可以通过 | 操作符来组合\r\n * @Note 关联方法 drawDisc setDrawColor\r\n */\r\nvoid U8G2::drawCircle(u8g2_uint_t x0, u8g2_uint_t y0, u8g2_uint_t rad, uint8_t opt = U8G2_DRAW_ALL)\r\n```\r\n\r\n- 如果支持绘制颜色（也就是不是单色显示器），那么由setDrawColor设置；\r\n- 直径等于2rad + 1；\r\n\r\n例: 画圆动画 (4帧)\r\n\r\n```c\r\n#include <Arduino.h>\r\n#include <U8g2lib.h>\r\n \r\nU8G2_SSD1306_128X64_NONAME_F_HW_I2C u8g2(U8G2_R0, /* reset=*/U8X8_PIN_NONE, /* clock=*/22, /* data=*/21); // ESP32 Thing, HW I2C with pin remapping\r\n \r\nvoid setup(void)\r\n{\r\n  u8g2.begin();\r\n}\r\nvoid loop(void)\r\n{\r\n  u8g2.clear();\r\n  u8g2.drawCircle(64, 32, 25, U8G2_DRAW_UPPER_RIGHT);\r\n  u8g2.sendBuffer();\r\n  delay(1000);\r\n  u8g2.drawCircle(64, 32, 25, U8G2_DRAW_LOWER_RIGHT);\r\n  u8g2.sendBuffer();\r\n  delay(1000);\r\n  u8g2.drawCircle(64, 32, 25, U8G2_DRAW_LOWER_LEFT);\r\n  u8g2.sendBuffer();\r\n  delay(1000);\r\n  u8g2.drawCircle(64, 32, 25, U8G2_DRAW_UPPER_LEFT);\r\n  u8g2.sendBuffer();\r\n  delay(1000);\r\n}\r\n```\r\n\r\n#### 3. u8g2.drawDisc() —— 画实心圆\r\n\r\n```c\r\n/**\r\n * 画实心圆，圆心坐标为(x0,y0),半径为rad\r\n * @param x0 圆点的x坐标\r\n * @param y0 圆点的y坐标\r\n * @param rad 圆形的半径\r\n * @param opt 圆形选项\r\n *        U8G_DRAW_ALL 整个圆\r\n *        U8G2_DRAW_UPPER_RIGHT 右上部分的圆弧\r\n *        U8G2_DRAW_UPPER_LEFT  左上部分的圆弧\r\n *        U8G2_DRAW_LOWER_LEFT  左下部分的圆弧\r\n *        U8G2_DRAW_LOWER_RIGHT 右下部分的圆弧\r\n *       选项可以通过 | 操作符来组合\r\n * @Note 关联方法 drawCircle setDrawColor\r\n */\r\nvoid U8G2::drawDisc(u8g2_uint_t x0, u8g2_uint_t y0, u8g2_uint_t rad, uint8_t opt = U8G_DRAW_ALL)\r\n```\r\n\r\n- 如果支持绘制颜色（也就是不是单色显示器），那么由setDrawColor设置；\r\n- 直径等于2rad + 1；\r\n\r\n#### 4. u8g2.drawEllipse() —— 画空心椭圆\r\n\r\n```c\r\n/**\r\n * 画空心椭圆，圆心坐标为(x0,y0),半径为rad\r\n * @param x0 圆点的x坐标\r\n * @param y0 圆点的y坐标\r\n * @param rx 椭圆形水平x方向的半径\r\n * @param ry 椭圆形竖直y方向的半径\r\n * @param opt 圆形选项\r\n *        U8G_DRAW_ALL 整个椭圆\r\n *        U8G2_DRAW_UPPER_RIGHT 右上部分的圆弧\r\n *        U8G2_DRAW_UPPER_LEFT  左上部分的圆弧\r\n *        U8G2_DRAW_LOWER_LEFT  左下部分的圆弧\r\n *        U8G2_DRAW_LOWER_RIGHT 右下部分的圆弧\r\n *        选项可以通过 | 操作符来组合\r\n * @Note 关联方法 drawCircle\r\n */\r\nvoid U8G2::drawEllipse(u8g2_uint_t x0, u8g2_uint_t y0, u8g2_uint_t rx, u8g2_uint_t ry, uint8_t opt)\r\n```\r\n\r\n#### 5. u8g2.drawFilledEllipse() —— 画实心椭圆\r\n\r\n```c\r\n/**\r\n * 画实心椭圆，圆心坐标为(x0,y0),半径为rad\r\n * @param x0 圆点的x坐标\r\n * @param y0 圆点的y坐标\r\n * @param rx 椭圆形水平x方向的半径\r\n * @param ry 椭圆形竖直y方向的半径\r\n * @param opt 圆形选项\r\n *        U8G_DRAW_ALL 整个椭圆\r\n *        U8G2_DRAW_UPPER_RIGHT 右上部分的圆弧\r\n *        U8G2_DRAW_UPPER_LEFT  左上部分的圆弧\r\n *        U8G2_DRAW_LOWER_LEFT  左下部分的圆弧\r\n *        U8G2_DRAW_LOWER_RIGHT 右下部分的圆弧\r\n *        选项可以通过 | 操作符来组合\r\n * @Note 关联方法 drawCircle\r\n */\r\nvoid U8G2::drawFilledEllipse(u8g2_uint_t x0, u8g2_uint_t y0, u8g2_uint_t rx, u8g2_uint_t ry, uint8_t opt)\r\n```\r\n\r\n#### 6. u8g2.drawFrame() —— 画空心方形\r\n\r\n```c\r\n/**\r\n * 画空心方形，左上角坐标为(x,y),宽度为w，高度为h\r\n * @param x 左上角的x坐标\r\n * @param y 左上角的y坐标\r\n * @param w 方形的宽度\r\n * @param h 方形的高度\r\n * @Note 关联方法 setDrawColor\r\n */\r\nvoid U8G2::drawFrame(u8g2_uint_t x, u8g2_uint_t y, u8g2_uint_t w, u8g2_uint_t h)\r\n```\r\n\r\n#### 7. u8g2.drawGlyph() —— 绘制字体字集的符号\r\n\r\n```c\r\n/**\r\n * 绘制字体字集里面定义的符号\r\n * @param x 左上角的x坐标\r\n * @param y 左上角的y坐标\r\n * @param encoding 字符的unicode值\r\n * @Note 关联方法 setFont\r\n */\r\nvoid U8G2::drawGlyph(u8g2_uint_t x, u8g2_uint_t y, uint16_t encoding)\r\n```\r\n\r\n#### 8. u8g2.drawHLine() —— 绘制水平线\r\n\r\n```c\r\n/**\r\n * 绘制水平线\r\n * @param x 左上角的x坐标\r\n * @param y 左上角的y坐标\r\n * @param w 水平线的长度\r\n * @Note 关联方法 setDrawColor\r\n */\r\n void U8G2::drawHLine(u8g2_uint_t x, u8g2_uint_t y, u8g2_uint_t w)\r\n```\r\n\r\n#### 9. u8g2.drawLine() —— 两点之间绘制线\r\n\r\n```c\r\n/**\r\n * 绘制线，从坐标(x0,y0) 到(x1,y1)\r\n * @param x0 端点0的x坐标\r\n * @param y0 端点0的y坐标\r\n * @param x1 端点1的x坐标\r\n * @param y1 端点1的y坐标\r\n * @Note 关联方法 setDrawColor\r\n */\r\n void U8G2::drawLine(u8g2_uint_t x0, u8g2_uint_t y0, u8g2_uint_t x1, u8g2_uint_t y1)\r\n```\r\n\r\n#### 10. u8g2.drawPixel() —— 绘制像素点\r\n\r\n```c\r\n/**\r\n * 绘制像素点，坐标(x,y)\r\n * @param x 像素点的x坐标\r\n * @param y 像素点的y坐标\r\n * @Note 关联方法 setDrawColor\r\n */\r\nvoid U8G2::drawPixel(u8g2_uint_t x, u8g2_uint_t y)\r\n```\r\n\r\n- 我们可以利用这个绘制方法自定义自己的图形显示\r\n\r\n#### 11. u8g2.drawRBox() —— 绘制圆角实心方形\r\n\r\n```c\r\n/**\r\n * 绘制圆角实心方形，左上角坐标为(x,y),宽度为w，高度为h，圆角半径为r\r\n * @param x 左上角的x坐标\r\n * @param y 左上角的y坐标\r\n * @param w 方形的宽度\r\n * @param h 方形的高度\r\n * @param r 圆角半径\r\n */\r\nvoid U8G2::drawRBox(u8g2_uint_t x, u8g2_uint_t y, u8g2_uint_t w, u8g2_uint_t h, u8g2_uint_t r)\r\n```\r\n\r\n#### 12. u8g2.drawRFrame() —— 绘制圆角空心方形\r\n\r\n```c\r\n/**\r\n * 绘制圆角空心方形，左上角坐标为(x,y),宽度为w，高度为h，圆角半径为r\r\n * @param x 左上角的x坐标\r\n * @param y 左上角的y坐标\r\n * @param w 方形的宽度\r\n * @param h 方形的高度\r\n * @param r 圆角半径\r\n */\r\nvoid U8G2::drawRFrame(u8g2_uint_t x, u8g2_uint_t y, u8g2_uint_t w, u8g2_uint_t h, u8g2_uint_t r)\r\n```\r\n\r\n#### 13. u8g2.drawStr() —— 绘制字符串\r\n\r\n```c\r\n/**\r\n * 绘制字符串\r\n * @param x 左上角的x坐标\r\n * @param y 左上角的y坐标\r\n * @param s 绘制字符串内容\r\n * @return 字符串的长度\r\n */\r\nu8g2_uint_t U8g2::drawStr(u8g2_uint_t x, u8g2_uint_t y, const char *s)\r\n```\r\n\r\n- 需要先设置字体，调用setFont方法；\r\n- 这个方法不能绘制encoding超过256的，超过256需要用drawUTF8或者drawGlyph；说白了就是一般用来显示英文字符；\r\n- x，y属于字符串左下角的坐标；\r\n\r\n#### 14. u8g2.drawTriangle() —— 绘制实心三角形\r\n\r\n```c\r\n/**\r\n * 绘制实心三角形，定点坐标分别为(x0,y0),(x1,y1),(x2,y2)\r\n */\r\nvoid U8G2::drawTriangle(int16_t x0, int16_t y0, int16_t x1, int16_t y1, int16_t x2, int16_t y2)\r\n```\r\n\r\n#### 15. u8g2.drawUTF8() —— 绘制UTF8编码的字符\r\n\r\n```c\r\n/**\r\n * 绘制UTF8编码的字符串\r\n * @param x 字符串在屏幕上的左下角x坐标\r\n * @param y 字符串在屏幕上的左下角y坐标\r\n * @param s 需要绘制的UTF-8编码字符串\r\n * @return 返回字符串的长度\r\n */\r\nu8g2_uint_t U8g2::drawUTF8(u8g2_uint_t x, u8g2_uint_t y, const char *s)\r\n```\r\n\r\n#### 16. u8g2.drawVLine() —— 绘制竖直线\r\n\r\n```c\r\n/**\r\n * 绘制竖直线\r\n * @param x 左上角坐标x\r\n * @param y 左上角坐标y\r\n * @param h 高度\r\n */\r\nvoid U8G2::drawVLine(u8g2_uint_t x, u8g2_uint_t y, u8g2_uint_t h)\r\n```\r\n\r\n#### ⭐17. u8g2.drawXBM()/drawXBMP() —— 绘制图像\r\n\r\n```c\r\n/**\r\n * 绘制图像\r\n * @param x 左上角坐标x\r\n * @param y 左上角坐标y\r\n * @param w 图形宽度\r\n * @param h 图形高度\r\n * @param bitmap 图形内容\r\n * @Note 关联方法 setBitmapMode\r\n */\r\nvoid U8G2::drawXBM(u8g2_uint_t x, u8g2_uint_t y, u8g2_uint_t w, u8g2_uint_t h, const uint8_t *bitmap)\r\nvoid U8G2::drawXBMP(u8g2_uint_t x, u8g2_uint_t y, u8g2_uint_t w, u8g2_uint_t h, const uint8_t *bitmap)\r\n```\r\n\r\n- drawXBM和drawXBMP区别在于 XBMP支持PROGMEM；\r\n\r\n#### 18. u8g2.firstPage()/nextPage() —— 绘制命令\r\n\r\n```c\r\n/**\r\n * 绘制图像\r\n */\r\nvoid U8G2::firstPage(void)\r\nuint8_t U8G2::nextPage(void)\r\n```\r\n\r\n- firstPage方法会把当前页码位置变成0；\r\n- 修改内容处于firstPage和nextPage之间，每次都是重新渲染所有内容；\r\n- 优势点：该方法消耗的ram空间，比sendBuffer消耗的ram空间要少；\r\n\r\n实例:\r\n\r\n```c\r\nu8g2.firstPage();\r\n  do {\r\n    /* all graphics commands have to appear within the loop body. */    \r\n    u8g2.setFont(u8g2_font_ncenB14_tr);\r\n    u8g2.drawStr(0,20,\"Hello World!\");\r\n  } while ( u8g2.nextPage() );\r\n```\r\n\r\n#### ⭐19. u8g2.print() —— 绘制内容\r\n\r\n```c\r\n/**\r\n * 绘制内容\r\n * @Note 关联方法  setFont setCursor enableUTF8Print\r\n */\r\nvoid U8G2::print(...)\r\n```\r\n\r\n#### ⭐20. u8g2.sendBuffer() —— 绘制缓冲区的内容\r\n\r\n```c\r\n/**\r\n * 绘制缓冲区的内容\r\n * @Note 关联方法  clearBuffer\r\n */\r\nvoid U8G2::sendBuffer(void)\r\n```\r\n\r\n- sendBuffer的RAM占用空间大，需要结合构造器的buffer选项（请继续往下看，先有个概念）使用；\r\n- 不管是fistPage、nextPage还是sendBuffer，都涉及到一个叫做 current page position的概念；\r\n\r\n### 3. 显示配置相关函数\r\n\r\n#### 1. u8g2.getAscent()\r\n\r\n```c\r\n/**\r\n * 获取基准线以上的高度\r\n * @return 返回高度值\r\n * @Note 关联方法  setFont getDescent setFontRefHeightAll\r\n */\r\nint8_t U8G2::getAscent(void)\r\n```\r\n\r\n- 跟字体有关（setFont）\r\n\r\n示例：下面例子，ascent是18\r\n\r\n![image-20211127153656014](cloudDisk/markdown/Esp32笔记.assets/image-20211127153656014.png)\r\n\r\n#### 2. u8g2.getDescent() —— 获取基准线以下的高度\r\n\r\n```c\r\n/**\r\n * 获取基准线以下的高度\r\n * @return 返回高度值\r\n * @Note 关联方法  setFont setFontRefHeightAll\r\n */\r\nint8_t U8G2::getDescent(void)\r\n```\r\n\r\n- 跟字体有关（setFont）；\r\n\r\n示例：下面例子，descent是-5\r\n\r\n![image-20211127153727825](cloudDisk/markdown/Esp32笔记.assets/image-20211127153727825.png)\r\n\r\n#### 3. u8g2.getDisplayHeight() —— 获取显示器的高度\r\n\r\n```c\r\n/**\r\n * 获取显示器的高度\r\n * @return 返回高度值\r\n */\r\nu8g2_uint_t getDisplayHeight(void)\r\n```\r\n\r\n#### 4. u8g2.getDisplayWidth() —— 获取显示器的宽度\r\n\r\n```c\r\n/**\r\n * 获取显示器的宽度\r\n * @return 返回宽度值\r\n */\r\nu8g2_uint_t getDisplayWidth(void)\r\n```\r\n\r\n#### 5. u8g2.getMaxCharHeight() —— 获取当前字体里的最大字符的高度\r\n\r\n```c\r\n/**\r\n * 获取当前字体里的最大字符的高度\r\n * @return 返回高度值\r\n * @Note 关联方法 setFont\r\n */\r\nu8g2_uint_t getMaxCharHeight(void)\r\n```','2022-06-23 21:11:37','ESP32 SoC 芯片支持以下功能：\r\n\r\n2.4 GHz Wi-Fi\r\n\r\n蓝牙\r\n\r\n高性能 Xtensa® 32 位 LX6 双核处理器\r\n\r\n超低功耗协处理器\r\n\r\n多种外设\r\n\r\nESP32 采用 40 nm 工艺制成，具有最佳的功耗性能、射频性能、稳定性、通用性和可靠性，适用于各种应用场景和不同功耗需求。\r\n\r\n乐鑫为用户提供完整的软、硬件资源，进行 ESP32 硬件设备的开发。其中，乐鑫的软件开发环境 ESP','cloudDisk/markdown/Esp32笔记.assets/format,png.png','原创','','','\0','Esp32 单片机学习笔记','2022-06-23 21:11:37',2,97,NULL,0),(165,'','# 一、流水灯程序\r\n\r\n## 1.1 LED连接原理图\r\n\r\n![image-20210729214414001](cloudDisk/markdown/stm32笔记.assets\\image-20210729214414001.png)\r\n\r\n## 1.2 库函数 - 初始化IO工作方式\r\n\r\n1. 使能IO口时钟\r\n\r\n2. 设置IO口的工作方式（共有8个）\r\n\r\n   （1） 浮空输入  类似于电压表	_IN_FLOATING ——浮空输入，可以做 KEY 识别， RX1\r\n   （2）带上拉输入	_IPU——IO 内部上拉电阻输入\r\n   （3）带下拉输入	_IPD—— IO 内部下拉电阻输入\r\n   （4） 模拟输入	_AIN ——应用 ADC 模拟输入，或者低功耗下省电\r\n   （5）开漏输出_，	OUT_OD ——IO 输出 0 接 GND， IO 输出 1，悬空，需要外接上拉电阻，才能实现输出\r\n   高电平。当输出为 1 时， IO 口的状态由上拉电阻拉高电平，但由于是开漏输出模式，这样 IO 口也就可以\r\n   由外部电路改变为低电平或不变。可以读 IO 输入电平变化，实现 C51 的 IO 双向功能\r\n   （6）推挽输出	_OUT_PP ——IO 输出 0-接 GND， IO 输出 1 -接 VCC，读输入值是未知的\r\n   （7）复用功能的推挽输出_	AF_PP ——片内外设功能（I2C 的 SCL,SDA）\r\n   （8）复用功能的开漏输出	_AF_OD——片内外设功能（TX1,MOSI,MISO.SCK.SS）  \r\n\r\n   \r\n\r\n   ![image-20210729213511322](cloudDisk/markdown/stm32笔记.assets\\image-20210729213511322.png)\r\n\r\n   已经定义的 GPIO_Mode 的取值：\r\n\r\n   ```c\r\n   typedef enum\r\n   { \r\n   	GPIO_Mode_AIN = 0x0, //模拟输入\r\n       GPIO_Mode_IN_FLOATING = 0x04, //浮空输入\r\n       GPIO_Mode_IPD = 0x28, //下拉输入\r\n       GPIO_Mode_IPU = 0x48, //上拉输入\r\n       GPIO_Mode_Out_OD = 0x14, //开漏输出\r\n       GPIO_Mode_Out_PP = 0x10, //通用推挽输出\r\n       GPIO_Mode_AF_OD = 0x1C, //复用开漏输出\r\n       GPIO_Mode_AF_PP = 0x18 //复用推挽\r\n   }GPIOMode_TypeDef;\r\n   ```\r\n\r\n3. 设置IO口速度  已经定义的 GPIO_Speed 取值\r\n\r\n   ```C\r\n   typedef enum\r\n   {\r\n       GPIO_Speed_10MHz = 1,\r\n       GPIO_Speed_2MHz,\r\n       GPIO_Speed_50MHz\r\n   }GPIOSpeed_TypeDef;\r\n   ```\r\n\r\n   \r\n\r\n## 1.3 库函数 - IO初始化函数\r\n\r\n```c\r\nvoid LED_Init(void)\r\n{\r\n\r\n GPIO_InitTypeDef  GPIO_InitStructure; // 用来构造GPIO_Init初始化方法的参数\r\n 	\r\n RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB ENABLE);	 //使能PB端口时钟\r\n RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOE ENABLE);	//使能PE端口时钟\r\n\r\n GPIO_InitStructure.GPIO_Pin = GPIO_Pin_5;				 //LED0-->PB.5 端口配置\r\n GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP; 		 //推挽输出\r\n GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;		 //IO口速度为50MHz\r\n GPIO_Init(GPIOB, &GPIO_InitStructure);					 //根据设定参数初始化GPIOB.5\r\n GPIO_SetBits(GPIOB,GPIO_Pin_5);						 //PB.5 输出高\r\n\r\n GPIO_InitStructure.GPIO_Pin = GPIO_Pin_5;	    		 //LED1-->PE.5 端口配置, 推挽输出\r\n GPIO_Init(GPIOE, &GPIO_InitStructure);	  				 //推挽输出 ，IO口速度为50MHz\r\n GPIO_SetBits(GPIOE,GPIO_Pin_5); 						 //PE.5 输出高 \r\n}\r\n```\r\n\r\n## 1.4 库函数 - 流水灯主函数\r\n\r\n```c\r\n#include \"stm32f10x.h\"\r\n#include \"delay.h\"\r\n#include \"led.h\"\r\nint main(void){\r\n	LED_Init();\r\n	delay_init();\r\n	while(1){\r\n		GPIO_ResetBits(GPIOB,GPIO_Pin_5); // GPIOB.5 置0\r\n		GPIO_SetBits(GPIOE,GPIO_Pin_5);	// GPIOE.5 置1\r\n		delay_ms(500);\r\n		\r\n		GPIO_SetBits(GPIOB,GPIO_Pin_5);\r\n		GPIO_ResetBits(GPIOE,GPIO_Pin_5);\r\n		delay_ms(500);\r\n	}\r\n}\r\n```\r\n\r\n## 1.5 操作寄存器方式 - IO初始化函数\r\n\r\n1. 使能时钟\r\n\r\n   ![image-20210729220824483](cloudDisk/markdown/stm32笔记.assets\\image-20210729220824483.png)\r\n\r\n   ```c\r\n   RCC->APB2ENR|=1<<3;  // 参考手册70页\r\n   RCC->APB2ENR|=1<<6;\r\n   ```\r\n\r\n2. 设置IO的工作方式  手册P113\r\n\r\n   (4个bit表示一个IO口，下面这张图是8个低位IO口)（4个bit可以表示一个十六进制位）\r\n\r\n   ![image-20210729221116830](cloudDisk/markdown/stm32笔记.assets\\image-20210729221116830.png)\r\n\r\n   \r\n\r\n   初始化GPIOB.5，设置为通用推挽输出，最大速度50MHZ\r\n\r\n   1. CNFy 设为 00\r\n   2. MODEy 设为 11\r\n   3. 二进制 0011 转为十六进制：3\r\n   4. GPIOB.5 是第6个IO口，对应上表的[20,23]\r\n\r\n   ```c\r\n   GPIOB->CRL = GPIOB->CRL & 0XFF0FFFFF; // 第六个IO口清0\r\n   GPIOB->CRL = GPIOB->CRL | 0X00300000; // 第六个IO口初始化为：推挽输出，最大速度50MHZ\r\n   ```\r\n\r\n```c\r\n#include \"led.h\"\r\n#include \"stm32f10x.h\"\r\nvoid LED_Init(void){\r\n	RCC->APB2ENR|=1<<3;  // 参考手册70页\r\n	RCC->APB2ENR|=1<<6;\r\n	\r\n	// GPIOB.5\r\n	GPIOB->CRL = GPIOB->CRL & 0XFF0FFFFF; //（4个bit可以表示一个十六进制位）\r\n	GPIOB->CRL = GPIOB->CRL | 0X00300000;\r\n	GPIOB->ODR|=1<<5;\r\n	\r\n	//GPIOE.5\r\n	GPIOE->CRL = GPIOE->CRL & 0XFF0FFFFF;\r\n	GPIOE->CRL = GPIOE->CRL | 0X00300000; \r\n	GPIOE->ODR|=1<<5;\r\n\r\n}\r\n```\r\n\r\n\r\n\r\n## 1.5 操作寄存器方式 - 流水灯主函数\r\n\r\n```c\r\n#include \"sys.h\"\r\n#include \"usart.h\"		\r\n#include \"led.h\"\r\n\r\nint main (void){\r\n	LED_Init();\r\n	while(1){\r\n		GPIOB->ODR|= 1<<5;  // 置1\r\n		GPIOE->ODR|= 1<<5;\r\n		delay();\r\n		GPIOB->ODR= GPIOB->ODR & (~(1<<5)); // 置0\r\n		GPIOE->ODR= GPIOE->ODR & (~(1<<5));\r\n		delay();\r\n	}\r\n}\r\n```\r\n\r\n# 二、按键输入\r\n\r\n##### 要求：\r\n\r\nALIENTEK 精英 STM32F103 上载有的 3 个按钮（KEY_UP、 KEY0\r\n和 KEY1），来控制板上的 2 个 LED（DS0 和 DS1）和蜂鸣器，其中 KEY_UP 控制蜂鸣器，按\r\n一次叫，再按一次停； KEY1 控制 DS1，按一次亮，再按一次灭； KEY0 则同时控制 DS0 和 DS1，\r\n按一次，他们的状态就翻转一次。  \r\n\r\n1. ##### 初始化键盘输入\r\n\r\n   ![image-20210731200729619](cloudDisk/markdown/stm32笔记.assets\\image-20210731200729619.png)\r\n\r\n   \r\n\r\n   ```c\r\n   // key0(PE4)、key1(PE3) 按下会检测到低电平\r\n   // key_up(PA0) 按下会检测到高电平\r\n   // 1. 初始化 GPIOE,GPIOA时钟\r\n   // 2. 设置IO口工作方式：上拉/下拉输入模式\r\n   void initInput(void){\r\n   	GPIO_InitTypeDef GPIO_InitStruct;\r\n   	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOE,ENABLE);\r\n   	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA,ENABLE);\r\n   	\r\n   \r\n   	// 初始化 key0(PE4)、key1(PE3) 按下会检测到低电平\r\n   	GPIO_InitStruct.GPIO_Mode = GPIO_Mode_IPU;\r\n   	GPIO_InitStruct.GPIO_Pin = GPIO_Pin_4 | GPIO_Pin_3;\r\n   	GPIO_Init(GPIOE,&GPIO_InitStruct);\r\n   	// 初始化 key_up(PA0) 按下会检测到高电平\r\n   	GPIO_InitStruct.GPIO_Mode = GPIO_Mode_IPD;\r\n   	GPIO_InitStruct.GPIO_Pin = GPIO_Pin_0;\r\n   	GPIO_Init(GPIOA,&GPIO_InitStruct);\r\n   \r\n   }\r\n   ```\r\n\r\n2. 初始化LED\r\n\r\n   ![image-20210731200818801](cloudDisk/markdown/stm32笔记.assets\\image-20210731200818801.png)\r\n\r\n   ```c\r\n   // LED0(PB5),LED1(PE5),推挽输出50MHZ\r\n   void initLED(void){\r\n   	GPIO_InitTypeDef GPIO_InitStruct;\r\n   	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOE,ENABLE);\r\n   	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB,ENABLE);\r\n   	\r\n   \r\n   	GPIO_InitStruct.GPIO_Speed = GPIO_Speed_50MHz;\r\n   	GPIO_InitStruct.GPIO_Mode = GPIO_Mode_Out_PP;\r\n   	GPIO_InitStruct.GPIO_Pin = GPIO_Pin_5;\r\n   	\r\n   	GPIO_Init(GPIOB,&GPIO_InitStruct);\r\n   	GPIO_Init(GPIOE,&GPIO_InitStruct);\r\n   	// 灭灯\r\n   	GPIO_SetBits(GPIOB,GPIO_Pin_5);\r\n   	GPIO_SetBits(GPIOE,GPIO_Pin_5);\r\n   \r\n   }\r\n   ```\r\n\r\n3. ##### 初始化蜂鸣器\r\n\r\n   ![image-20210731200848162](cloudDisk/markdown/stm32笔记.assets\\image-20210731200848162.png)\r\n\r\n   ```c\r\n   // 初始化Beep(PB8) 推挽输出50MHZ\r\n   \r\n      void initBeep(void){\r\n      	GPIO_InitTypeDef GPIO_InitStruct;\r\n      	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB,ENABLE);\r\n      	\r\n   \r\n      	GPIO_InitStruct.GPIO_Speed = GPIO_Speed_50MHz;\r\n      	GPIO_InitStruct.GPIO_Mode = GPIO_Mode_Out_PP;\r\n      	GPIO_InitStruct.GPIO_Pin = GPIO_Pin_8;\r\n      	GPIO_Init(GPIOB,&GPIO_InitStruct);\r\n      	GPIO_ResetBits(GPIOB,GPIO_Pin_8);\r\n   \r\n      }\r\n   \r\n   \r\n   ```\r\n\r\n4. 键盘扫描函数（上升沿触发）\r\n\r\n   ```c\r\n   #include \"stm32f10x.h\"\r\n   #include \"delay.h\"\r\n   #define key0 GPIO_ReadInputDataBit(GPIOE,GPIO_Pin_4)\r\n   #define key1 GPIO_ReadInputDataBit(GPIOE,GPIO_Pin_3)\r\n   #define keyUp GPIO_ReadInputDataBit(GPIOA,GPIO_Pin_0)\r\n   u8 keyScan(u8 mode){ //mode=0上升沿触发  mode=1电平触发\r\n   	static u8 preKey = 1;\r\n   	if(mode)preKey=1; //支持连按\r\n   	if(preKey&&(keyUp==1 || key0==0 || key1==0)){\r\n   		delay_ms(30);\r\n   		preKey = 0;\r\n   		if(keyUp==1 || key0==0 || key1==0){\r\n   			if(key0==0)return 1;\r\n   			else if(key1==0)return 2;\r\n   			else if(keyUp==1)return 3;\r\n   		}\r\n   	}\r\n   	else if(keyUp==0 && key0==1 && key1==1){\r\n   			preKey = 1;	\r\n   	}\r\n   	return 0;\r\n   }\r\n   ```\r\n\r\n5. 实现功能控制的函数\r\n\r\n   ```c\r\n   void setDS0(void){ // 翻转LED0状态\r\n   	static int flag0 = 0;\r\n   	if(flag0){\r\n   		flag0 = 0;\r\n   		GPIO_ResetBits(GPIOB,GPIO_Pin_5);\r\n   	}\r\n   	else{\r\n   		flag0 = 1;\r\n   		GPIO_SetBits(GPIOB,GPIO_Pin_5);\r\n   	}\r\n   }\r\n   \r\n   void setDS1(void){  // 翻转LED1状态\r\n   	static int flag1 = 0;\r\n   	if(flag1){\r\n   		flag1 = 0;\r\n   		GPIO_ResetBits(GPIOE,GPIO_Pin_5);\r\n   	}\r\n   	else{\r\n   		flag1 = 1;\r\n   		GPIO_SetBits(GPIOE,GPIO_Pin_5);\r\n   	}\r\n   }\r\n   \r\n   void setBeep(void){ // 翻转Beep状态\r\n   	static int flag2 = 0;\r\n   	if(flag2){\r\n   		flag2 = 0;\r\n   		GPIO_SetBits(GPIOB,GPIO_Pin_8);\r\n   	}\r\n   	else{\r\n   		flag2 = 1;\r\n   		GPIO_ResetBits(GPIOB,GPIO_Pin_8);\r\n   	}\r\n   	\r\n   }\r\n   ```\r\n\r\n6. 主函数\r\n\r\n   ```c\r\n   int main(void){\r\n      	initInput();\r\n      	initLED();\r\n      	initBeep();\r\n      	delay_init();\r\n      	while(1){\r\n      		switch(keyScan()){\r\n      			case 1:{\r\n      				// KEY0 则同时控制 DS0 和 DS1，按一次，他们的状态就翻转一次。\r\n      				setDS0();\r\n      				setDS1();\r\n      				break;\r\n      			} \r\n      			case 2:{\r\n      				// KEY1 控制 DS1，按一次亮，再按一次灭；\r\n      				setDS0();\r\n      				break;\r\n      			}		\r\n      			case 3:{\r\n      				// KEY_UP 控制蜂鸣器，按一次叫，再按一次停；\r\n      				setBeep();\r\n      				break;\r\n      			}\r\n      		}\r\n      	}\r\n   }\r\n   \r\n   \r\n   ```\r\n\r\n# 时钟\r\n\r\n\r\n\r\n![image-20210801164317150](cloudDisk/markdown/stm32笔记.assets/image-20210801164317150.png)\r\n\r\n![image-20210801164335986](cloudDisk/markdown/stm32笔记.assets/image-20210801164335986.png)\r\n\r\n![image-20210801165405264](cloudDisk/markdown/stm32笔记.assets/image-20210801165405264.png)\r\n\r\n```c\r\n/* #define SYSCLK_FREQ_HSE    HSE_VALUE */\r\n/* #define SYSCLK_FREQ_24MHz  24000000 */ \r\n/* #define SYSCLK_FREQ_36MHz  36000000 */\r\n/* #define SYSCLK_FREQ_48MHz  48000000 */\r\n/* #define SYSCLK_FREQ_56MHz  56000000 */\r\n#define SYSCLK_FREQ_72MHz  72000000 \r\nstatic void SetSysClock(void) // 通过不同的define选择不同的入口\r\n{\r\n#ifdef SYSCLK_FREQ_HSE\r\n  SetSysClockToHSE();\r\n#elif defined SYSCLK_FREQ_24MHz\r\n  SetSysClockTo24();\r\n#elif defined SYSCLK_FREQ_36MHz\r\n  SetSysClockTo36();\r\n#elif defined SYSCLK_FREQ_48MHz\r\n  SetSysClockTo48();\r\n#elif defined SYSCLK_FREQ_56MHz\r\n  SetSysClockTo56();  \r\n#elif defined SYSCLK_FREQ_72MHz\r\n  SetSysClockTo72();\r\n#endif\r\n\r\n /* If none of the define above is enabled, the HSI is used as System clock\r\n    source (default after reset) */ \r\n}\r\n\r\nstatic void SetSysClockTo72(void)\r\n{\r\n  __IO uint32_t StartUpCounter = 0, HSEStatus = 0;\r\n  \r\n  /* SYSCLK, HCLK, PCLK2 and PCLK1 configuration ---------------------------*/    \r\n  /* Enable HSE */    \r\n  RCC->CR |= ((uint32_t)RCC_CR_HSEON); //外部高速时钟使能 (External high-speed clock enable)\r\n \r\n  /* Wait till HSE is ready and if Time out is reached exit */\r\n  do\r\n  {\r\n    HSEStatus = RCC->CR & RCC_CR_HSERDY;\r\n    StartUpCounter++;  \r\n  } while((HSEStatus == 0) && (StartUpCounter != HSE_STARTUP_TIMEOUT));\r\n\r\n  if ((RCC->CR & RCC_CR_HSERDY) != RESET)\r\n  {\r\n    HSEStatus = (uint32_t)0x01;\r\n  }\r\n  else\r\n  {\r\n    HSEStatus = (uint32_t)0x00;\r\n  }  \r\n\r\n  if (HSEStatus == (uint32_t)0x01)\r\n  {\r\n    /* Enable Prefetch Buffer */\r\n    FLASH->ACR |= FLASH_ACR_PRFTBE;\r\n\r\n    /* Flash 2 wait state */\r\n    FLASH->ACR &= (uint32_t)((uint32_t)~FLASH_ACR_LATENCY);\r\n    FLASH->ACR |= (uint32_t)FLASH_ACR_LATENCY_2;    \r\n\r\n \r\n    /* HCLK = SYSCLK */ // AHB预分频 (AHB Prescaler)\r\n    RCC->CFGR |= (uint32_t)RCC_CFGR_HPRE_DIV1;\r\n      \r\n    /* PCLK2 = HCLK */ //高速APB预分频(APB2) //0xx： HCLK不分频\r\n    RCC->CFGR |= (uint32_t)RCC_CFGR_PPRE2_DIV1;\r\n    \r\n    /* PCLK1 = HCLK */ //低速APB预分频(APB1) //100： HCLK 2分频\r\n    RCC->CFGR |= (uint32_t)RCC_CFGR_PPRE1_DIV2;\r\n\r\n#ifdef STM32F10X_CL\r\n    /* Configure PLLs ------------------------------------------------------*/\r\n    /* PLL2 configuration: PLL2CLK = (HSE / 5) * 8 = 40 MHz */\r\n    /* PREDIV1 configuration: PREDIV1CLK = PLL2 / 5 = 8 MHz */\r\n        \r\n    RCC->CFGR2 &= (uint32_t)~(RCC_CFGR2_PREDIV2 | RCC_CFGR2_PLL2MUL |\r\n                              RCC_CFGR2_PREDIV1 | RCC_CFGR2_PREDIV1SRC);\r\n    RCC->CFGR2 |= (uint32_t)(RCC_CFGR2_PREDIV2_DIV5 | RCC_CFGR2_PLL2MUL8 |\r\n                             RCC_CFGR2_PREDIV1SRC_PLL2 | RCC_CFGR2_PREDIV1_DIV5);\r\n  \r\n    /* Enable PLL2 */\r\n    RCC->CR |= RCC_CR_PLL2ON;\r\n    /* Wait till PLL2 is ready */\r\n    while((RCC->CR & RCC_CR_PLL2RDY) == 0)\r\n    {\r\n    }\r\n    \r\n   \r\n    /* PLL configuration: PLLCLK = PREDIV1 * 9 = 72 MHz */ \r\n    RCC->CFGR &= (uint32_t)~(RCC_CFGR_PLLXTPRE | RCC_CFGR_PLLSRC | RCC_CFGR_PLLMULL);\r\n    RCC->CFGR |= (uint32_t)(RCC_CFGR_PLLXTPRE_PREDIV1 | RCC_CFGR_PLLSRC_PREDIV1 | \r\n                            RCC_CFGR_PLLMULL9); \r\n#else    \r\n    /*  PLL configuration: PLLCLK = HSE * 9 = 72 MHz */\r\n    RCC->CFGR &= (uint32_t)((uint32_t)~(RCC_CFGR_PLLSRC | RCC_CFGR_PLLXTPRE |\r\n                                        RCC_CFGR_PLLMULL));\r\n    RCC->CFGR |= (uint32_t)(RCC_CFGR_PLLSRC_HSE | RCC_CFGR_PLLMULL9);\r\n#endif /* STM32F10X_CL */\r\n\r\n    /* Enable PLL */\r\n    RCC->CR |= RCC_CR_PLLON;\r\n\r\n    /* Wait till PLL is ready */\r\n    while((RCC->CR & RCC_CR_PLLRDY) == 0)\r\n    {\r\n    }\r\n    \r\n    /* Select PLL as system clock source */\r\n    RCC->CFGR &= (uint32_t)((uint32_t)~(RCC_CFGR_SW));\r\n    RCC->CFGR |= (uint32_t)RCC_CFGR_SW_PLL;    \r\n\r\n    /* Wait till PLL is used as system clock source */\r\n    while ((RCC->CFGR & (uint32_t)RCC_CFGR_SWS) != (uint32_t)0x08)\r\n    {\r\n    }\r\n  }\r\n  else\r\n  { /* If HSE fails to start-up, the application will have wrong clock \r\n         configuration. User can add here some code to deal with this error */\r\n  }\r\n}\r\n#endif\r\n```\r\n\r\n# 三、串口通信\r\n\r\n## 2.1 串口设置的一般步骤可以总结为如下几个步骤：\r\n\r\n1. 串口时钟使能  \r\n\r\n* RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1)； \r\n\r\n2. 串口复位  \r\n\r\n* USART_DeInit(USART1); //复位串口 1  \r\n\r\n3. 串口参数初始化  \r\n\r\n* USART_InitStructure.USART_BaudRate = bound; //波特率设置;  \r\n* USART_InitStructure.USART_WordLength = USART_WordLength_8b;//字长为 8 位数据格式\r\n* USART_InitStructure.USART_StopBits = USART_StopBits_1;   //一个停止位\r\n* USART_InitStructure.USART_Parity = USART_Parity_No;  //无奇偶校验位\r\n* USART_InitStructure.USART_HardwareFlowControl= USART_HardwareFlowControl_None;  //无硬件数据流控制\r\n* USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;  //收发模式\r\n* USART_Init(USART1, &USART_InitStructure); //初始化串口\r\n\r\n4. 数据发送与接收\r\n   * 发送：\r\n     * void USART_SendData(USART_TypeDef* USARTx, uint16_t Data);  // 通过该函数向串口寄存器 USART_DR 写入一个数据。  \r\n   * 接收：\r\n     * uint16_t USART_ReceiveData(USART_TypeDef* USARTx);  // 通过该函数可以读取串口接受到的数据。  \r\n\r\n5. 串口状态  \r\n   * ![image-20210809222412727](cloudDisk/markdown/stm32笔记.assets/image-20210809222412727.png)\r\n   * RXNE  - 当为1时，说明已经有数据被接收到了。这时我们要去 USART_DR  读数据，读取数据时，RXNE会被清零\r\n   * TC  -  当为1时，说明 USART_DR  内的数据发送完成。如果设置了此位中断，会执行中断。清零方式：1）读 USART_SR，写 USART_DR。 2）直接向该位写 0。  \r\n   * 判断RXNE和TC是1、是0：\r\n     * USART_GetFlagStatus(USART1, USART_FLAG_RXNE);  \r\n     * USART_GetFlagStatus(USART1, USART_FLAG_TC);  \r\n\r\n6. 串口使能 \r\n   * USART_Cmd(USART1, ENABLE);  \r\n\r\n7. 开启串口响应中断\r\n   * void USART_ITConfig(USART_TypeDef* USARTx, uint16_t USART_IT,\r\n     FunctionalState NewState)  \r\n   * 如：\r\n     * 开启数据接收完成中断，即：RXNE 为1\r\n       * USART_ITConfig(USART1, USART_IT_RXNE, ENABLE);//开启中断，接收到数据中断  \r\n     * 开启数据发送完成中断，即：TC  为1\r\n       * USART_ITConfig(USART1， USART_IT_TC， ENABLE);  \r\n\r\n8. 获取相应中断状态\r\n   * 当我们使能了某个中断的时候，当该中断发生了，就会设置状态寄存器中的某个标志位。  \r\n   * 函数为：ITStatus USART_GetITStatus(USART_TypeDef* USARTx, uint16_t USART_IT)  \r\n   * 如：TC被置1即发送完成数据，执行中断处理函数，此时调用了：USART_GetITStatus(USART1, USART_IT_TC)  ,会返回 SET 。又调用了：USART_GetITStatus(USART1, USART_IT_RXNE) ,会返回RESET\r\n\r\n\r\n\r\n## 2.2 硬件设计\r\n\r\n![image-20210809224019612](cloudDisk/markdown/stm32笔记.assets/image-20210809224019612.png)\r\n\r\n## 2.3 软件代码\r\n\r\n1. 串口初始化函数\r\n\r\n```c\r\n//初始化 IO 串口 1\r\n//bound:波特率\r\nvoid uart_init(u32 bound)\r\n{\r\n    GPIO_InitTypeDef GPIO_InitStructure;\r\n    USART_InitTypeDef USART_InitStructure;\r\n    NVIC_InitTypeDef NVIC_InitStructure;\r\n    //①串口时钟使能， GPIO 时钟使能，复用时钟使能\r\n    RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1|\r\n    RCC_APB2Periph_GPIOA, ENABLE); //使能 USART1,GPIOA 时钟\r\n    //②串口复位\r\n    USART_DeInit(USART1); //复位串口 1\r\n    //③GPIO 端口模式设置\r\n    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9; //ISART1_TX PA.9\r\n    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;\r\n    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP; //复用推挽输出\r\n    GPIO_Init(GPIOA, &GPIO_InitStructure); //初始化 GPIOA.9\r\n    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10; //USART1_RX PA.10\r\n    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING; //浮空输入\r\n    GPIO_Init(GPIOA, &GPIO_InitStructure); //初始化 GPIOA.10\r\n    //④串口参数初始化\r\n    USART_InitStructure.USART_BaudRate = bound; //波特率设置\r\n    USART_InitStructure.USART_WordLength = USART_WordLength_8b; //字长为 8 位\r\n    USART_InitStructure.USART_StopBits = USART_StopBits_1; //一个停止位\r\n    USART_InitStructure.USART_Parity = USART_Parity_No; //无奇偶校验位\r\n    USART_InitStructure.USART_HardwareFlowControl\r\n    = USART_HardwareFlowControl_None; //无硬件数据流控制\r\n    USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;//收发模式\r\n    USART_Init(USART1, &USART_InitStructure); //初始化串口\r\n    #if EN_USART1_RX //如果使能了接收\r\n    //⑤初始化 NVIC\r\n    NVIC_InitStructure.NVIC_IRQChannel = USART1_IRQn;\r\n    NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority=3 ; //抢占优先级 3\r\n    NVIC_InitStructure.NVIC_IRQChannelSubPriority = 3; //子优先级 3\r\n    NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE; //IRQ 通道使能\r\n    NVIC_Init(&NVIC_InitStructure); //中断优先级初始化\r\n    //⑤开启中断\r\n    USART_ITConfig(USART1, USART_IT_RXNE, ENABLE); //开启中断\r\n    #endif\r\n    //⑥使能串口\r\n    USART_Cmd(USART1, ENABLE); //使能串口\r\n}\r\n```\r\n\r\n2. 中断服务函数\r\n\r\n   ```c\r\n   void USART1_IRQHandler(void)                	//串口1中断服务程序\r\n   	{\r\n   	u8 Res;\r\n   #if SYSTEM_SUPPORT_OS 		//如果SYSTEM_SUPPORT_OS为真，则需要支持OS.\r\n   	OSIntEnter();    \r\n   #endif\r\n   	if(USART_GetITStatus(USART1, USART_IT_RXNE) != RESET)  //接收中断(接收到的数据必须是0x0d 0x0a结尾)\r\n   		{\r\n   		Res =USART_ReceiveData(USART1);	//读取接收到的数据\r\n   		\r\n   		if((USART_RX_STA&0x8000)==0)//接收未完成\r\n   			{\r\n   			if(USART_RX_STA&0x4000)//接收到了0x0d\r\n   				{\r\n   				if(Res!=0x0a)USART_RX_STA=0;//接收错误,重新开始\r\n   				else USART_RX_STA|=0x8000;	//接收完成了 \r\n   				}\r\n   			else //还没收到0X0D\r\n   				{	\r\n   				if(Res==0x0d)USART_RX_STA|=0x4000;\r\n   				else\r\n   					{\r\n   					USART_RX_BUF[USART_RX_STA&0X3FFF]=Res ;\r\n   					USART_RX_STA++;\r\n   					if(USART_RX_STA>(USART_REC_LEN-1))USART_RX_STA=0;//接收数据错误,重新开始接收	  \r\n   					}		 \r\n   				}\r\n   			}   		 \r\n        } \r\n   #if SYSTEM_SUPPORT_OS 	//如果SYSTEM_SUPPORT_OS为真，则需要支持OS.\r\n   	OSIntExit();  											 \r\n   #endif\r\n   } \r\n   ```\r\n\r\n   * 几个参数\r\n     * u16 USART_RX_STA=0;       //接收状态标记\r\n       * ![image-20210809224720237](cloudDisk/markdown/stm32笔记.assets/image-20210809224720237.png)\r\n       * bit13 - 0 位：程序中接收到一个字符就+1，最终得到的是就收到了多少个字节\r\n       * 当收到回车（回车的表示由 2个字节组成： 0X0D 和 0X0A）的第一个字节 0X0D 时，计数器将不再增加，等待 0X0A 的到来，而如果 0X0A 没有来到，则认为这次接收失败，重新开始下一次接收。如果顺利接收到 0X0A，则标记 USART_RX_STA 的第 15 位，这样完成一次接收，并等待该位被其他程序清除，从而开始下一次的接收，而如果迟迟没有收到 0X0D，那么在接收数据超过 USART_REC_LEN的时候，则会丢弃前面的数据，重新接收。  \r\n     * 接受到的数据会保存到 USART_RX_BUF 数组中\r\n       * u8 USART_RX_BUF[USART_REC_LEN];     //接收缓冲,最大USART_REC_LEN个字节.\r\n       * #define USART_REC_LEN  			200  	//定义最大接收字节数 200\r\n     * 1个字节 = 8个bit     8个bit 可以用两位十六进制表示\r\n     * 0X0D 转化为二进制为： 0000 1101\r\n\r\n3. 主函数\r\n\r\n   ```c\r\n   #include \"led.h\"\r\n   #include \"delay.h\"\r\n   #include \"key.h\"\r\n   #include \"sys.h\"\r\n   #include \"usart.h\"\r\n   int main(void)\r\n   {\r\n       u8 t,len;\r\n       u16 times=0;\r\n       delay_init(); //延时函数初始化\r\n       NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2); // 设 置 NVIC 中 断 分 组 2\r\n       uart_init(115200); //串口初始化波特率为 115200\r\n       LED_Init(); //LED 端口初始化\r\n       KEY_Init(); //初始化与按键连接的硬件接口\r\n   	while(1)\r\n   	{\r\n           if(USART_RX_STA&0x8000) // 循环判断USART_RX_STA的 bit15 是否为1，即：是否接收完成数据\r\n           { \r\n               len=USART_RX_STA&0x3f; //得到此次接收到的数据长度 3f=00111111 ，取 USART_RX_STA bit5 - bit0的值，得到获取到的字节个数\r\n               printf(\"\\r\\n 您发送的消息为:\\r\\n\\r\\n\");\r\n               for(t=0;t<len;t++) // 每次发送一个字节\r\n               { \r\n                   USART_SendData(USART1, USART_RX_BUF[t]); //向串口 1 发送数据\r\n                   while(USART_GetFlagStatus(USART1,USART_FLAG_TC)!=SET);\r\n                   //等待发送结束\r\n               }\r\n               printf(\"\\r\\n\\r\\n\"); //插入换行\r\n               USART_RX_STA=0;\r\n           }\r\n           else\r\n           { \r\n               times++;\r\n               if(times%5000==0)\r\n               { \r\n                   printf(\"\\r\\n 精英 STM32 开发板 串口实验\\r\\n\");\r\n                   printf(\"正点原子@ALIENTEK\\r\\n\\r\\n\");\r\n               }\r\n               if(times%200==0)printf(\"请输入数据,以回车键结束\\n\");\r\n               if(times%30==0)LED0=!LED0; //闪烁 LED,提示系统正在运行.\r\n               delay_ms(10);\r\n            }\r\n   	}\r\n   }\r\n   ```\r\n\r\n   \r\n\r\n# 四、中断\r\n\r\nSTM开发指南 P173 ![image-20210811231842385](cloudDisk/markdown/stm32笔记.assets/image-20210811231842385.png)\r\n\r\n![image-20210811231742968](cloudDisk/markdown/stm32笔记.assets/image-20210811231742968.png)\r\n\r\n![image-20210811231240411](cloudDisk/markdown/stm32笔记.assets/image-20210811231240411.png)\r\n\r\n\r\n\r\n```c\r\nvoid keyInterruptInit(void)\r\n{\r\n	// GPIOE.3 - KEY1 - EXTI3\r\n	// GPIOE.4 - KEY0 - EXTI4\r\n	// GPIOA.0 - KEYUP - EXTI0\r\n	\r\n	EXTI_InitTypeDef EXTI_InitStruct;\r\n 	NVIC_InitTypeDef NVIC_InitStructure;\r\n	\r\n	// 1）初始化 IO 口为输入。\r\n	keyInit();\r\n	\r\n	// 2）开启 AFIO 时钟\r\n	RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO,ENABLE);\r\n	\r\n	// 3） 设置 IO 口与中断线的映射关系。\r\n	GPIO_EXTILineConfig(GPIO_PortSourceGPIOA,GPIO_PinSource0); // GPIOA.0 映射到 外部中断线0\r\n	GPIO_EXTILineConfig(GPIO_PortSourceGPIOE,GPIO_PinSource3); // GPIOE.3 映射到 外部中断线3\r\n	GPIO_EXTILineConfig(GPIO_PortSourceGPIOE,GPIO_PinSource4); // GPIOE.4 映射到 外部中断线4\r\n	\r\n	// 4）初始化线上中断，设置触发条件等。\r\n	EXTI_InitStruct.EXTI_Line = EXTI_Line0; // 初始化外部中断线0、3、4\r\n	EXTI_InitStruct.EXTI_Mode = EXTI_Mode_Interrupt;\r\n	EXTI_InitStruct.EXTI_Trigger = EXTI_Trigger_Rising; // 上升沿触发\r\n	EXTI_Init(&EXTI_InitStruct);\r\n	\r\n	EXTI_InitStruct.EXTI_Mode = EXTI_Mode_Interrupt;\r\n	EXTI_InitStruct.EXTI_Trigger = EXTI_Trigger_Falling; // 下降沿触发\r\n	EXTI_InitStruct.EXTI_Line =EXTI_Line3;\r\n	EXTI_Init(&EXTI_InitStruct);\r\n	\r\n	EXTI_InitStruct.EXTI_Mode = EXTI_Mode_Interrupt;\r\n	EXTI_InitStruct.EXTI_Trigger = EXTI_Trigger_Falling; // 下降沿触发\r\n	EXTI_InitStruct.EXTI_Line =EXTI_Line4;\r\n	EXTI_Init(&EXTI_InitStruct);\r\n	\r\n	// 5）配置中断分组（NVIC），并使能中断。\r\n	// 定义初始化的是哪个中断，这个我们可以在 stm32f10x.h 中找到每个中断对应的名字。例如 EXTI0_IRQn。\r\n	NVIC_InitStructure.NVIC_IRQChannel = EXTI0_IRQn;\r\n	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;\r\n	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0x02; // 设置抢占优先级2\r\n	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0x02; //子优先级 2\r\n	NVIC_Init(&NVIC_InitStructure);\r\n	\r\n	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;\r\n	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0x02; // 设置抢占优先级2\r\n	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0x02; //子优先级 2\r\n	NVIC_InitStructure.NVIC_IRQChannel = EXTI3_IRQn;\r\n	NVIC_Init(&NVIC_InitStructure);\r\n	\r\n	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;\r\n	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0x02; // 设置抢占优先级2\r\n	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0x02; //子优先级 2\r\n	NVIC_InitStructure.NVIC_IRQChannel = EXTI4_IRQn;\r\n	NVIC_Init(&NVIC_InitStructure);\r\n}\r\n```\r\n\r\n```c\r\n// 6）编写中断服务函数。\r\nvoid EXTI0_IRQHandler(void){\r\n	static int flag0 = 0;\r\n	// 去抖动\r\n	delay_ms(20);\r\n	//翻转BEEP\r\n	if(keyUp == 1){\r\n		if(flag0 == 0){\r\n			setBeep;\r\n			flag0 = 1;\r\n		}else{\r\n			resetBeep;\r\n			flag0 = 0;\r\n		}\r\n		testPrint(\"EXTI0\");\r\n	}\r\n	EXTI_ClearITPendingBit(EXTI_Line0); //清除 LINE 上的中断标志位\r\n}\r\n\r\n//外部中断3服务程序\r\nvoid EXTI3_IRQHandler(void)\r\n{		\r\n	static int flag3 = 0;\r\n	// 去抖动\r\n	delay_ms(20);\r\n	//翻转LED0\r\n	if(key1 == 0){\r\n			if(flag3 == 0){\r\n				setLED0;\r\n				flag3 = 1;\r\n		}else{\r\n			resetLED0;\r\n			flag3 = 0;\r\n		}\r\n		testPrint(\"EXTI3\");\r\n	}\r\n	EXTI_ClearITPendingBit(EXTI_Line3);  //清除LINE3上的中断标志位  \r\n}\r\n\r\nvoid EXTI4_IRQHandler(void)\r\n{		\r\n	static int flag4 = 0;\r\n	// 去抖动\r\n	delay_ms(20);\r\n	//翻转LED1\r\n	if(key0 == 0){\r\n		if(flag4 == 0){\r\n			setLED1;\r\n			flag4 = 1;\r\n		}else{\r\n			resetLED1;\r\n			flag4 = 0;\r\n		}\r\n		testPrint(\"EXTI4\");\r\n	}\r\n	EXTI_ClearITPendingBit(EXTI_Line4);  //清除LINE4上的中断标志位  \r\n}\r\n```\r\n\r\n```c\r\n// 初始化LED,BEEP,KEY函数\r\n#include \"stm32f10x.h\"\r\n#include \"delay.h\"\r\n#include \"usart.h\"\r\n#include \"sys.h\" \r\n#define setLED0 GPIO_ResetBits(GPIOB,GPIO_Pin_5)\r\n#define resetLED0 GPIO_SetBits(GPIOB,GPIO_Pin_5)\r\n#define setLED1 GPIO_ResetBits(GPIOE,GPIO_Pin_5)\r\n#define resetLED1 GPIO_SetBits(GPIOE,GPIO_Pin_5)\r\n#define setBeep GPIO_SetBits(GPIOB,GPIO_Pin_8)\r\n#define resetBeep GPIO_ResetBits(GPIOB,GPIO_Pin_8)\r\n#define key0 GPIO_ReadInputDataBit(GPIOE,GPIO_Pin_4)\r\n#define key1 GPIO_ReadInputDataBit(GPIOE,GPIO_Pin_3)\r\n#define keyUp GPIO_ReadInputDataBit(GPIOA,GPIO_Pin_0)\r\nvoid testPrint(char *a){\r\n    delay_init(); //延时函数初始化\r\n    NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2); // 设 置 NVIC 中 断 分 组 2\r\n    uart_init(115200); //串口初始化波特率为 115200\r\n		printf(\"%s\",a);\r\n    delay_ms(10);\r\n}\r\n\r\nvoid ledInit(void){\r\n	// LED1 GPIOE.5初始化\r\n	GPIO_InitTypeDef GPIO_InitStruct;\r\n	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOE|RCC_APB2Periph_GPIOB,ENABLE);\r\n	GPIO_InitStruct.GPIO_Mode = GPIO_Mode_Out_PP;\r\n	GPIO_InitStruct.GPIO_Pin = GPIO_Pin_5;\r\n	GPIO_InitStruct.GPIO_Speed = GPIO_Speed_50MHz;\r\n	GPIO_Init(GPIOE,&GPIO_InitStruct);\r\n	// LED0 GPIOB.5初始化\r\n	GPIO_Init(GPIOB,&GPIO_InitStruct);\r\n}\r\nvoid beepInit(void){\r\n	// BEEP初始化 GPIOB.8\r\n	GPIO_InitTypeDef GPIO_InitStruct;\r\n	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB,ENABLE);\r\n	GPIO_InitStruct.GPIO_Mode = GPIO_Mode_Out_PP;\r\n	GPIO_InitStruct.GPIO_Pin = GPIO_Pin_8;\r\n	GPIO_InitStruct.GPIO_Speed = GPIO_Speed_50MHz;\r\n	GPIO_Init(GPIOB,&GPIO_InitStruct);\r\n}\r\nvoid keyInit(void){\r\n	// key0 key1 keyUp初始化\r\n 	GPIO_InitTypeDef GPIO_InitStructure;\r\n 	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA|RCC_APB2Periph_GPIOE,ENABLE);//使能PORTA,PORTE时钟\r\n	GPIO_InitStructure.GPIO_Pin  = GPIO_Pin_4|GPIO_Pin_3;//KEY0-KEY1\r\n	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU; //设置成上拉输入\r\n 	GPIO_Init(GPIOE, &GPIO_InitStructure);//初始化GPIOE4,3\r\n\r\n	//初始化 WK_UP-->GPIOA.0	  下拉输入\r\n	GPIO_InitStructure.GPIO_Pin  = GPIO_Pin_0;\r\n	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPD; //PA0设置成输入，默认下拉	  \r\n	GPIO_Init(GPIOA, &GPIO_InitStructure);//初始化GPIOA.0\r\n}\r\n```\r\n\r\n主函数：\r\n\r\n```c\r\nint main(void)\r\n {		\r\n	ledInit();\r\n	beepInit();\r\n	delay_init();	    	 //延时函数初始化	  \r\n	NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2); //设置NVIC中断分组2:2位抢占优先级，2位响应优先级 	\r\n	uart_init(115200);\r\n	keyInterruptInit();         	//初始化外部中断输入 \r\n	while(1)\r\n	{	    \r\n		printf(\"OK\\r\\n\");	\r\n		delay_ms(1000);	  \r\n	}	 \r\n}\r\n\r\n```\r\n\r\n# 五、看门狗\r\n\r\n**概念：只要你在规定时间内给看门狗喂食，程序就不会复位**\r\n\r\n在键值寄存器(IWDG_KR)中写入 0xCCCC，开始启用独立看门狗；此时计数器开始从其复位值 0xFFF 递减计数。  \r\n\r\n当计数器计数到末尾 0x000 时，会产生一个复位信号(IWDG_RESET)  。\r\n\r\n只要键寄存器 IWDG_KR 中被写入 0xAAAA， IWDG_RLR 中的值就会被重新加载到计数器中从而避免产生看门狗复位 。  \r\n\r\n#### 1） 取消寄存器写保护（向 IWDG_KR 写入 0X5555）  \r\n\r\nIWDG_WriteAccessCmd(IWDG_WriteAccess_Enable);  \r\n\r\n#### 2） 设置独立看门狗的预分频系数和重装载值  \r\n\r\nvoid IWDG_SetPrescaler(uint8_t IWDG_Prescaler); //设置 IWDG 预分频值  \r\n\r\nvoid IWDG_SetReload(uint16_t Reload); //设置 IWDG 重装载值  \r\n\r\n时间的计算方式为：  Tout=((4× 2^prer) × rlr) /40  \r\n\r\nTout 为看门狗溢出时间（单位为 ms）； prer 为看门狗时钟预分频值（IWDG_PR 值），范围为 0~7； rlr 为看门狗的重装载值（IWDG_RLR 的值）；  \r\n\r\n例：比如我们设定 prer 值为 4， rlr 值为 625，那么就可以得到 Tout=64× 625/40=1000ms，这样，看门狗的溢出时间就是 1s，只要你在一秒钟之内，有一次写入 0XAAAA 到 IWDG_KR，就不会导致看门狗复位（当然写入多次也是可以的）。  \r\n\r\n#### 3） 重载计数值喂狗（向 IWDG_KR 写入 0XAAAA）  \r\n\r\nIWDG_ReloadCounter(); //按照 IWDG 重装载寄存器的值重装载 IWDG 计数器  \r\n\r\n#### 4)  启动看门狗(向 IWDG_KR 写入 0XCCCC)  \r\n\r\nIWDG_Enable(); //使能 IWDG  \r\n\r\n#### 5) 案例: \r\n\r\n在配置看门狗后， DS0 将常亮，如果 WK_UP 按键按下，就喂狗，只要 WK_UP 不停的按，看门狗就一直不会产生复位，保持 DS0 的常亮，一旦超过看门狗定溢出时间（Tout）还没按，那么将会导致程序重启，这将导致 DS0 熄灭一次。  \r\n\r\n```c\r\n#include \"stm32f10x.h\"\r\n#include \"delay.h\"\r\n#include \"sys.h\"\r\n#include \"usart.h\" \r\n#define keyUp GPIO_ReadInputDataBit(GPIOA,GPIO_Pin_0)\r\nvoid LedInit(void){\r\n	GPIO_InitTypeDef GPIO_InitStruct;\r\n	GPIO_InitStruct.GPIO_Mode = GPIO_Mode_Out_PP;\r\n	GPIO_InitStruct.GPIO_Pin = GPIO_Pin_5;\r\n	GPIO_InitStruct.GPIO_Speed = GPIO_Speed_50MHz;\r\n	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOE,ENABLE);\r\n	GPIO_Init(GPIOE,&GPIO_InitStruct);\r\n	GPIO_SetBits(GPIOE,GPIO_Pin_5);\r\n}\r\n\r\n\r\nu8 keyScan(u8 mode){ //mode=0上升沿触发  mode=1电平触发\r\n	static u8 preKey = 1;\r\n	if(mode)preKey=1; //支持连按\r\n	if(preKey&&(keyUp==1)){\r\n		delay_ms(30);\r\n		preKey = 0;\r\n		if(keyUp==1){\r\n			if(keyUp==1)return 1;\r\n		}\r\n	}\r\n	else if(keyUp==0){\r\n			preKey = 1;	\r\n	}\r\n	return 0;\r\n}\r\n\r\nvoid keyUpInit(void){\r\n 	GPIO_InitTypeDef GPIO_InitStructure;\r\n 	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA,ENABLE);//使能PORTA时钟\r\n	//初始化 WK_UP-->GPIOA.0	  下拉输入\r\n	GPIO_InitStructure.GPIO_Pin  = GPIO_Pin_0;\r\n	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPD; //PA0设置成输入，默认下拉	  \r\n	GPIO_Init(GPIOA, &GPIO_InitStructure);//初始化GPIOA.0\r\n}\r\nvoid guardDogInit(void){\r\n	IWDG_WriteAccessCmd(IWDG_WriteAccess_Enable); \r\n	IWDG_SetPrescaler(4); \r\n	IWDG_SetReload(625);\r\n	IWDG_ReloadCounter();\r\n	IWDG_Enable(); //使能 IWDG\r\n}\r\nint main(void){\r\n	delay_init();\r\n	LedInit();\r\n	keyUpInit();\r\n	NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2); 	 //设置NVIC中断分组2:2位抢占优先级，2位响应优先级\r\n	uart_init(115200);	 //串口初始化为115200\r\n	delay_ms(500);   	 //让人看得到灭\r\n	guardDogInit();\r\n	GPIO_ResetBits(GPIOE,GPIO_Pin_5);\r\n	while(1){\r\n		if(keyScan(0)){\r\n			IWDG_ReloadCounter();\r\n			printf(\"ok\");\r\n		}\r\n		printf(\"no\");\r\n		delay_ms(10);\r\n	};\r\n\r\n}\r\n\r\n \r\n```\r\n\r\n\r\n\r\n# 六、窗口看门狗\r\n\r\n![image-20210813221106648](cloudDisk/markdown/stm32笔记.assets/image-20210813221106648.png)\r\n\r\n## 概念：\r\n\r\n当设置好初值后，启动开门狗，计数器开始递减。当减到刷新窗口这段时间内，才允许给计数器赋值（喂狗）。当减到0X40时，会产生一个中断，并会将WWDG_ CFR 寄存器 中的EWI位置1，该中断提醒我们：“需要进行喂狗了，否则将复位！  ”。如若不重新赋初值、清除提前唤醒中断标志位，会将系统复位。\r\n\r\n　　CNT：递减计数器\r\n\r\n　　窗口上限：寄存器设置\r\n\r\n　　窗口下限：0x3F\r\n\r\n　　随时间推移，计数器值递减，经过上窗口W和下窗口\r\n\r\n　　重载值-》上窗口（不允许刷新期间）：这段时间不允许喂狗，如果喂狗会使芯片复位\r\n\r\n　　上窗口-》下窗口（刷新窗口期间）：这段时间允许喂狗，下窗口位固定值（0x3F）\r\n\r\n　　下窗口：进入下窗口会产生复位\r\n\r\n## 刷新窗口期间所需时间计算公式：\r\n\r\n* 刷新窗口期间所需时间的计算公式：Twwdg=(4096× 2^WDGTB× (T[5:0]+1)) /Fpclk1;  \r\n  * Twwdg（刷新窗口期间所需时间）： WWDG 超时时间（单位为 ms）\r\n  * Fpclk1： APB1 的时钟频率（单位为 Khz）\r\n  * WDGTB： WWDG 的预分频系数\r\n  * T[5:0]（窗口值）：窗口看门狗的计数器低 6 位  \r\n  * ![image-20210813223949544](cloudDisk/markdown/stm32笔记.assets/image-20210813223949544.png)\r\n\r\n## 相关寄存器\r\n\r\n### 1. 控制寄存器 WWDG_CR 寄存器各位描述  \r\n\r\n![image-20210813224201947](cloudDisk/markdown/stm32笔记.assets/image-20210813224201947.png)\r\n\r\n直接写WWDG_CR［6:0］实现喂狗\r\n\r\n独立看门狗喂狗：向键值寄存器IWDG_KR写0xAAAA喂狗。将IWDG_RLR寄存器值重新装载到计数器\r\n\r\n### 2. 配置寄存器 WWDG_ CFR 寄存器各位描述 \r\n\r\n地址偏移量：0x04\r\n\r\n复位值：0x7F\r\n\r\n![image-20210813224349246](cloudDisk/markdown/stm32笔记.assets/image-20210813224349246.png)\r\n\r\n### 3. 状态寄存器\r\n\r\n![image-20210813224659071](cloudDisk/markdown/stm32笔记.assets/image-20210813224659071.png)\r\n\r\n## 相关函数\r\n\r\n1） 使能 WWDG 时钟  \r\n\r\nRCC_APB1PeriphClockCmd(RCC_APB1Periph_WWDG, ENABLE); // WWDG 时钟使能  \r\n\r\n2） 设置窗口值和分频数  \r\n\r\nvoid WWDG_SetWindowValue(uint8_t WindowValue)；  // 窗口值  \r\n\r\nvoid WWDG_SetPrescaler(uint32_t WWDG_Prescaler)；  // 分频数  \r\n\r\n4） 设置计数器初始值并使能看门狗  \r\n\r\nvoid WWDG_Enable(uint8_t Counter)；  \r\n\r\n5) 重写中断服务函数\r\n\r\nvoid WWDG_IRQHandler()；\r\n\r\n## 相关配置步骤\r\n\r\n![窗口看门狗的作用是什么？窗口看门狗复位分析](https://imgconvert.csdnimg.cn/aHR0cDovL2ZpbGUuZWxlY2ZhbnMuY29tL3dlYjEvTTAwLzUxLzA0L3BJWUJBRnI5UUN5QU5iV3ZBQUJ6TEt5aTB2WTQ3MC5wbmc?x-oss-process=image/format,png)\r\n\r\n## 案例：通过 DS0 来指示 STM32 是否被复位了，如果被复位了就会点亮 300ms。 DS1 用来指示中断喂狗，每次中断喂狗翻转一次。  \r\n\r\n1. 初始化窗口看门狗函数\r\n\r\n```c\r\n//保存WWDG计数器的设置值,默认为最大. \r\nu8 WWDG_CNT=0x7f; \r\n//初始化窗口看门狗 	\r\n//tr   :T[6:0],计数器值 \r\n//wr   :W[6:0],窗口值 \r\n//fprer:分频系数（WDGTB）,仅最低2位有效 \r\n//Fwwdg=PCLK1/(4096*2^fprer). \r\n\r\nvoid WWDG_Init(u8 tr,u8 wr,u32 fprer)\r\n{ \r\n	RCC_APB1PeriphClockCmd(RCC_APB1Periph_WWDG, ENABLE);  //   WWDG时钟使能\r\n\r\n	WWDG_CNT=tr&WWDG_CNT;   //初始化WWDG_CNT.   \r\n	WWDG_SetPrescaler(fprer);////设置IWDG预分频值\r\n\r\n	WWDG_SetWindowValue(wr);//设置窗口值\r\n\r\n	WWDG_Enable(WWDG_CNT);	 //使能看门狗 ,	设置 counter .                  \r\n\r\n	WWDG_ClearFlag();//清除提前唤醒中断标志位 \r\n\r\n	WWDG_NVIC_Init();//初始化窗口看门狗 NVIC\r\n\r\n	WWDG_EnableIT(); //开启窗口看门狗中断\r\n} \r\nvoid WWDG_NVIC_Init()\r\n{\r\n	NVIC_InitTypeDef NVIC_InitStructure;\r\n	NVIC_InitStructure.NVIC_IRQChannel = WWDG_IRQn;    //WWDG中断\r\n	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 2;   //抢占2，子优先级3，组2	\r\n	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 3;	 //抢占2，子优先级3，组2	\r\n  NVIC_InitStructure.NVIC_IRQChannelCmd=ENABLE; \r\n	NVIC_Init(&NVIC_InitStructure);//NVIC初始化\r\n}\r\n```\r\n\r\n2. 中断函数\r\n\r\n```c\r\nvoid WWDG_IRQHandler(void)\r\n	{\r\n\r\n	WWDG_SetCounter(WWDG_CNT);	  //当禁掉此句后,窗口看门狗将产生复位\r\n\r\n	WWDG_ClearFlag();	  //清除提前唤醒中断标志位\r\n\r\n	LED1=!LED1;		 //LED状态翻转\r\n	}\r\n```\r\n\r\n3. 喂狗（重设置WWDG计数器的值）函数\r\n\r\n```c\r\nvoid WWDG_Set_Counter(u8 cnt)\r\n{\r\n    WWDG_Enable(cnt);//使能看门狗 ,	设置 counter .	 \r\n}\r\n```\r\n\r\n4. 主函数\r\n\r\n```c\r\n#include \"led.h\"\r\n#include \"delay.h\"\r\n#include \"key.h\"\r\n#include \"sys.h\"\r\n#include \"usart.h\"\r\n#include \"wdg.h\"\r\n int main(void)\r\n {		\r\n	delay_init();	    	 //延时函数初始化	  \r\n	NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);//设置中断优先级分组为组2：2位抢占优先级，2位响应优先级\r\n	uart_init(115200);	 //串口初始化为115200\r\n 	LED_Init();\r\n	KEY_Init();          //按键初始化	 \r\n	LED0=0;\r\n	delay_ms(300);	  \r\n	WWDG_Init(0X7F,0X5F,WWDG_Prescaler_8);//计数器值为7f,窗口寄存器为5f,分频数为8	   \r\n 	while(1)\r\n	{\r\n		LED0=1;			  	   \r\n	}   \r\n}\r\n```\r\n\r\n### 我的版本：\r\n\r\n```c\r\n#include \"stm32f10x.h\"\r\n#include \"delay.h\"\r\n#include \"sys.h\"\r\n#include \"usart.h\" \r\nu8 WWDG_CNT=0x7f; //保存WWDG计数器的初值,默认为最大. \r\nvoid LedInit(void){\r\n	GPIO_InitTypeDef GPIO_InitStruct;\r\n	GPIO_InitStruct.GPIO_Mode = GPIO_Mode_Out_PP;\r\n	GPIO_InitStruct.GPIO_Pin = GPIO_Pin_5;\r\n	GPIO_InitStruct.GPIO_Speed = GPIO_Speed_50MHz;\r\n	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOE,ENABLE);\r\n	GPIO_Init(GPIOE,&GPIO_InitStruct);\r\n	GPIO_SetBits(GPIOE,GPIO_Pin_5);\r\n}\r\n\r\nvoid nvicInit(void){\r\n	NVIC_InitTypeDef NVIC_InitStructure;\r\n	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;\r\n	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0x02; // 设置抢占优先级2\r\n	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0x02; //子优先级 2\r\n	NVIC_InitStructure.NVIC_IRQChannel = WWDG_IRQn;\r\n	NVIC_Init(&NVIC_InitStructure);\r\n}\r\n\r\nvoid windowGuardDogInit(void){\r\n	RCC_APB1PeriphClockCmd(RCC_APB1Periph_WWDG, ENABLE); //   WWDG时钟使能\r\n	WWDG_SetWindowValue(0X5F); //设置窗口值\r\n	WWDG_SetPrescaler(WWDG_Prescaler_8); //设置IWDG预分频值\r\n	WWDG_Enable(WWDG_CNT); //使能看门狗 ,	设置 counter\r\n	nvicInit(); //初始化窗口看门狗 NVIC (先进行中断优先级分组)\r\n	WWDG_ClearFlag();  //清除提前唤醒中断标志位\r\n	WWDG_EnableIT(); //开启窗口看门狗中断\r\n	\r\n}\r\nvoid WWDG_IRQHandler(){\r\n	static int flag = 0;\r\n	WWDG_Enable(WWDG_CNT);\r\n	WWDG_ClearFlag();\r\n	if (flag){\r\n		GPIO_ResetBits(GPIOE,GPIO_Pin_5);\r\n		flag = 0;\r\n	}else{\r\n		GPIO_SetBits(GPIOE,GPIO_Pin_5);\r\n		flag = 1;\r\n	}\r\n}\r\n\r\nint main(void){\r\n	delay_init();\r\n	LedInit();\r\n	NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2); 	 //设置NVIC中断分组2:2位抢占优先级，2位响应优先级\r\n	uart_init(115200);	 //串口初始化为115200\r\n	windowGuardDogInit();\r\n\r\n	while(1){};\r\n\r\n}\r\n\r\n \r\n```\r\n\r\n# 七、通用定时器中断\r\n\r\n## 1. STM32的Timer简介\r\n\r\nSTM32中一共有11个定时器，其中2个高级控制定时器，4个普通定时器和2个基本定时器，以及2个看门狗定时器和1个系统嘀嗒定时器。其中系统嘀嗒定时器是前文中所描述的SysTick![img](http://img.mp.itc.cn/upload/20170306/fe7f45cc55be4fde82f96ba298a73878_th.jpeg)\r\n\r\n其中TIM1和TIM8是能够产生3对PWM互补输出的高级登时其，常用于三相电机的驱动，时钟由APB2的输出产生。TIM2-TIM5是普通定时器，TIM6和TIM7是基本定时器，其时钟由APB1输出产生。\r\n\r\n## 2. 普通定时器TIM2-TIM5\r\n\r\n### 2.1 时钟来源\r\n\r\n计数器时钟可以由下列时钟源提供：\r\n\r\n* 内部时钟(CK_INT)\r\n\r\n* 外部时钟模式1：外部输入脚(TIx)\r\n\r\n* 外部时钟模式2：外部触发输入(ETR)\r\n\r\n* 内部触发输入(ITRx)：使用一个定时器作为另一个定时器的预分频器，如可以配置一个定时器Timer1而作为另一个定时器Timer2的预分频器。\r\n\r\nTIM2-TIM5的时钟不是直接来自于APB1，而是来自于输入为APB1的一个倍频器。这个倍频器的作用是：当APB1的预分频系数为1时，这个倍频器不起作用，定时器的时钟频率等于APB1的频率；当APB1的预分频系数为其他数值时（即预分频系数为2、4、8或16），这个倍频器起作用，定时器的时钟频率等于APB1的频率的2倍。\r\n\r\n通过倍频器给定时器时钟的好处是：APB1不但要给TIM2-TIM5提供时钟，还要为其他的外设提供时钟；设置这个倍频器可以保证在其他外设使用较低时钟频率时，TIM2-TIM5仍然可以得到较高的时钟频率。\r\n\r\n### 2.2 计数器模式\r\n\r\nTIM2-TIM5可以由向上计数、向下计数、向上向下双向计数。\r\n\r\n* 向上计数模式中，计数器从0计数到自动加载值(TIMx_ARR计数器内容)，然后重新从0开始计数并且产生一个计数器溢出事件。\r\n* 在向下模式中，计数器从自动装入的值(TIMx_ARR)开始向下计数到0，然后从自动装入的值重新开始，并产生一个计数器向下溢出事件。\r\n* 而中央对齐模式（向上/向下计数）是计数器从0开始计数到自动装入的值减1，产生一个计数器溢出事件，然后向下计数到1并且产生一个计数器溢出事件；然后再从0开始重新计数。\r\n\r\n## 3. 寄存器\r\n\r\n#### 3.1 控制寄存器 1（TIMx_CR1）  \r\n\r\n![image-20210814220636467](cloudDisk/markdown/stm32笔记.assets/image-20210814220636467.png)\r\n\r\n![image-20210814220652101](cloudDisk/markdown/stm32笔记.assets/image-20210814220652101.png)\r\n\r\n![image-20210814220709982](cloudDisk/markdown/stm32笔记.assets/image-20210814220709982.png)\r\n\r\n首先我们来看看 TIMx_CR1 的最低位，也就是计数器使能位，该位必须置 1，才能让定时\r\n器开始计数。 从第 4 位 DIR 可以看出默认的计数方式是向上计数， 同时也可以向下计数，第 5,6\r\n位是设置计数对齐方式的。 从第 8 和第 9 位可以看出，我们还可以设置定时器的时钟分频因子\r\n为 1,2,4。   \r\n\r\n#### 3.2 DMA/中断使能寄存器（TIMx_DIER）  \r\n\r\n![image-20210814220812726](cloudDisk/markdown/stm32笔记.assets/image-20210814220812726.png)\r\n\r\n这里我们同样仅关心它的第 0 位， 该位是更新中断允许位， 本章用到的是定时器的更新中断， 所以**该位要设置为 1**，来允许由于更新事件所产生的中断。  \r\n\r\n#### 3.3 预分频寄存器（TIMx_PSC）。该寄存器用设置对时钟进行分频，然后提供给计数器，作为计数器的时钟。  \r\n\r\n![image-20210814221555660](cloudDisk/markdown/stm32笔记.assets/image-20210814221555660.png)\r\n\r\n1） 内部时钟（CK_INT）\r\n2） 外部时钟模式 1：外部输入脚（TIx）\r\n3） 外部时钟模式 2：外部触发输入（ETR）\r\n4） 内部触发输入（ITRx）：使用 A 定时器作为 B 定时器的预分频器（A 为 B 提供时钟）。  \r\n\r\n#### 3.4 自动重装载寄存器  \r\n\r\n![image-20210814221710571](cloudDisk/markdown/stm32笔记.assets/image-20210814221710571.png)\r\n\r\n#### 3.5 状态寄存器（ TIMx_SR）  该寄存器用来标记当前与定时器相关的各种事件/中断是否发生。  \r\n\r\n![image-20210814221751771](cloudDisk/markdown/stm32笔记.assets/image-20210814221751771.png)\r\n\r\n## 4. 以通用定时器 TIM3 为实例，来说明要经过哪些步骤，才能达到这个要求，并产生中断。  \r\n\r\n### 1) TIM3 时钟使能。  \r\n\r\n* RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM3, ENABLE); //时钟使能  \r\n\r\n### 2) 初始化定时器参数,设置自动重装值， 分频系数，计数方式等。  \r\n\r\n定时器的初始化参数是通过初始化函数 TIM_TimeBaseInit 实现的：  void TIM_TimeBaseInit(TIM_TypeDef *TIMx,TIM_TimeBaseInitTypeDef *TIM_TimeBaseInitStruct);  \r\n\r\n* 第一个参数TIMx - 确定是哪个定时器  \r\n\r\n* 第二个参数是定时器初始化参数结构体指针, 结构体类型为 TIM_TimeBaseInitTypeDef\r\n\r\n  * ```c\r\n    typedef struct\r\n    {\r\n    uint16_t TIM_Prescaler; //  TIM_Prescaler 设置预分频系数\r\n    uint16_t TIM_CounterMode; //  TIM_CounterMode 是用来设置计数方式，上面讲解过，可以设置为向上计数，向下计数方式还有中央对齐计数方式， 比较常用的是向上计数模式 TIM_CounterMode_Up 和向下计数模式 TIM_CounterMode_Down。\r\n    uint16_t TIM_Period; // 设置自动装入的值\r\n    uint16_t TIM_ClockDivision; // 设置APB1时钟的分频因子\r\n    uint8_t TIM_RepetitionCounter; // 最后一个参数 TIM_RepetitionCounter 是高级定时器才有用的，这里不多解释\r\n    } TIM_TimeBaseInitTypeDef;\r\n    ```\r\n\r\n* 实例代码：\r\n\r\n  * ```c\r\n    TIM_TimeBaseInitTypeDef TIM_TimeBaseStructure;\r\n    TIM_TimeBaseStructure.TIM_Period = 5000;\r\n    TIM_TimeBaseStructure.TIM_Prescaler =7199;\r\n    TIM_TimeBaseStructure.TIM_ClockDivision = TIM_CKD_DIV1;\r\n    TIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Up; //向上计数\r\n    TIM_TimeBaseInit(TIM3, &TIM_TimeBaseStructure);\r\n    ```\r\n\r\n### 3) 设置 TIM3_DIER 允许更新中断  \r\n\r\n* 因为我们要使用 TIM3 的更新中断， 寄存器的相应位便可使能更新中断。 在库函数里面定\r\n  时器中断使能是通过 TIM_ITConfig 函数来实现的  \r\n\r\n* void TIM_ITConfig(TIM_TypeDef* TIMx, uint16_t TIM_IT, FunctionalState NewState)；  \r\n\r\n  * 第一个参数是选择定时器号，这个容易理解，取值为 TIM1~TIM17。  \r\n\r\n  * 第二个参数非常关键，是用来指明我们使能的定时器中断的类型，定时器中断的类型有很\r\n    多种，包括更新中断 TIM_IT_Update，触发中断 TIM_IT_Trigger，以及输入捕获中断等等。\r\n\r\n      ![image-20210814224543545](cloudDisk/markdown/stm32笔记.assets/image-20210814224543545.png)\r\n\r\n    TIM_IT_Update:更新中断，计数器向上溢出/向下溢出，计数器初始化(通过软件或者内部/外部触发) \r\n\r\n    TIM_IT_CC1~4：都是捕获/比较中断，貌似都是平等的，即输入捕获，输出比较\r\n\r\n    TIM_IT_Trigger：触发事件(计数器启动、停止、初始化或者由内部/外部触发计数)\r\n\r\n  * 第三个参数就很简单了， 就是失能还是使能  \r\n\r\n* 实例代码：\r\n\r\n  * ```c\r\n    TIM_ITConfig(TIM3,TIM_IT_Update,ENABLE );\r\n    ```\r\n\r\n### 4） TIM3 中断优先级设置。  \r\n\r\n* NVIC_Init 函数实现中断优先级的设置，这里就不重复讲解  \r\n\r\n### 5） 允许 TIM3 工作，也就是使能 TIM3。  \r\n\r\n* TIM_Cmd(TIM3, ENABLE); //使能 TIMx 外设  \r\n\r\n### 6） 编写中断服务函数。  void TIM3_IRQHandler(){}\r\n\r\n### 最后：\r\n\r\n我们这里使用的是更新（溢出）中断，所以在状态寄存器 SR 的最低位。在处理完中断之后应\r\n该向 TIM3_SR 的最低位写 0，来清除该中断标志。  \r\n\r\n* 用来读取中断状态寄存器的值判断中断类型的函数是：  ITStatus TIM_GetITStatus(TIM_TypeDef* TIMx, uint16_t)  \r\n  * 判断定时器 TIMx 的中断类型 TIM_IT 是否发生中断。 比如，我们要判断定时器 3 是否发生更新（溢出）中断，方法为：  if (TIM_GetITStatus(TIM3, TIM_IT_Update) != RESET){}  \r\n\r\n* 固件库中清除中断标志位的函数是：  void TIM_ClearITPendingBit(TIM_TypeDef* TIMx, uint16_t TIM_IT)  \r\n  * 比如我们在TIM3 的溢出中断发生后，我们要清除中断标志位，方法是：\r\n    TIM_ClearITPendingBit(TIM3, TIM_IT_Update );  \r\n\r\n## 5. 中断时间, 计算公式\r\n\r\n* 2 个参数用来设置 TIM3 的溢出时间  \r\n\r\n* 默认的系统初始化函数 SystemInit 函数里面已经初始化 APB1 的时钟为 2 分频，所以 APB1 的时钟为 36M  \r\n* ![image-20210814230631034](cloudDisk/markdown/stm32笔记.assets/image-20210814230631034.png)\r\n* 默认的系统初始化函数 SystemInit 函数里面已经初始化 APB1 的时钟为 2 分频，\r\n  所以 APB1 的时钟为 36M ；由于APB1的分频系数为2，所有TIMXCLK的输出频率应乘2，即72MHz\r\n* 中断时间, 计算公式 : Tout= ((arr+1)*(psc+1))/Tclk；  \r\n  * Tclk : TIM3 的输入时钟频率（单位为 Mhz)。\r\n  * Tout： TIM3 溢出时间（单位为 us）。  \r\n  * arr ： 自动装入的值\r\n  * psc : 预分频系数\r\n\r\n## 6. 案例 - 通过 TIM3 的中断来控制 DS1 的亮灭  \r\n\r\n```c\r\n#include \"stm32f10x.h\"\r\n#include \"delay.h\"\r\n#include \"sys.h\"\r\n#include \"usart.h\" \r\nvoid LedInit(void){\r\n	GPIO_InitTypeDef GPIO_InitStruct;\r\n	GPIO_InitStruct.GPIO_Mode = GPIO_Mode_Out_PP;\r\n	GPIO_InitStruct.GPIO_Pin = GPIO_Pin_5;\r\n	GPIO_InitStruct.GPIO_Speed = GPIO_Speed_50MHz;\r\n	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOE,ENABLE);\r\n	GPIO_Init(GPIOE,&GPIO_InitStruct);\r\n	GPIO_SetBits(GPIOE,GPIO_Pin_5);\r\n}\r\n\r\nvoid nvicInit(void){\r\n	NVIC_InitTypeDef NVIC_InitStructure;\r\n	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;\r\n	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0x02; // 设置抢占优先级2\r\n	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0x02; //子优先级 2\r\n	NVIC_InitStructure.NVIC_IRQChannel = TIM3_IRQn;\r\n	NVIC_Init(&NVIC_InitStructure);\r\n}\r\n\r\nvoid Timer3Init(u16 arr, u16 psc){\r\n	TIM_TimeBaseInitTypeDef TIM_TimeBaseInitStruct;\r\n	// 1) TIM3 时钟使能。  \r\n	RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM3, ENABLE); //时钟使能  \r\n	// 2) 初始化定时器参数,设置自动重装值， 分频系数，计数方式等。\r\n	TIM_TimeBaseInitStruct.TIM_Period = arr;// 设置自动装入的值\r\n	TIM_TimeBaseInitStruct.TIM_Prescaler =psc;//  TIM_Prescaler 设置预分频系数\r\n	TIM_TimeBaseInitStruct.TIM_ClockDivision = TIM_CKD_DIV1;// 设置APB1时钟的分频因子\r\n	TIM_TimeBaseInitStruct.TIM_CounterMode = TIM_CounterMode_Up; //  TIM_CounterMode是用来设置计数方式\r\n	TIM_TimeBaseInit(TIM3, &TIM_TimeBaseInitStruct);  \r\n	// 3) 设置 TIM3_DIER 允许更新中断  \r\n	TIM_ITConfig(TIM3,TIM_IT_Update,ENABLE );\r\n	// 4） TIM3 中断优先级设置。  \r\n	nvicInit();\r\n	// 5） 允许 TIM3 工作，也就是使能 TIM3。  \r\n	TIM_Cmd(TIM3, ENABLE); \r\n	// 6） 编写中断服务函数。  \r\n}\r\n//定时器 3 中断服务函数\r\nvoid TIM3_IRQHandler(void){\r\n	static int flag = 0;\r\n	//检查 TIM3 更新中断发生与否\r\n	if (TIM_GetITStatus(TIM3, TIM_IT_Update) == RESET)return;  \r\n	// 清除中断标志位\r\n	TIM_ClearITPendingBit(TIM3,TIM_IT_Update);\r\n	// LED取反\r\n	if(flag){\r\n		GPIO_SetBits(GPIOE,GPIO_Pin_5);\r\n		flag = 0;\r\n	}else {\r\n		GPIO_ResetBits(GPIOE,GPIO_Pin_5);\r\n		flag = 1;\r\n	}\r\n}\r\n\r\nint main(void){\r\n	delay_init();\r\n	LedInit();\r\n	NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2); 	 //设置NVIC中断分组2:2位抢占优先级，2位响应优先级\r\n	uart_init(115200);	 //串口初始化为115200\r\n	Timer3Init(4999,7199); // arr=4999,psc=7199\r\n  	// 区分输出的频率和计数器加一的频率\r\n    	// f（计数器加一的频率） = tclk / psc+1 = 72000000 / 7200 = 10khz\r\n    	// f(计数器每次计满的频率) = tclk / pss+1 / arr+1 = 2hz\r\n    //10Khz 的计数频率，计数到 5000 为 500ms\r\n    // Tout= ((arr+1)*(psc+1))/Tclk；\r\n    // Tout= ((4999+1)*( 7199+1))/72=500000us=500ms。\r\n	while(1){};\r\n	return 0;\r\n}\r\n```\r\n\r\n注意：TIM_TimeBaseInitStruct.TIM_ClockDivision = TIM_CKD_DIV1;// 设置APB1时钟的分频因子\r\n\r\n![image-20210814233855402](cloudDisk/markdown/stm32笔记.assets/image-20210814233855402.png)\r\n\r\n# 八、PWM\r\n\r\n脉冲宽度调制(PWM)，是英文“Pulse Width Modulation” 的缩写，简称脉宽调制，是利用微处理器的数字输出来对模拟电路进行控制的一种非常有效的技术。简单一点，就是对脉冲宽度的控制。  \r\n\r\n* 高级定时器 TIM1 和 TIM8 可以同时产生多达 7 路的 PWM 输出  \r\n* 通用定时器也能同时产生多达**4路**的 PWM 输出\r\n\r\n## 1. **确定PWM频率**\r\n\r\n* PWM的周期（频率）就是ARR寄存器值与PSC寄存器值相乘得来\r\n* 例如输出100HZ频率的PWM\r\n  1. 确定TIMx的时钟\r\n     * 除非APB1的时钟分频数设置为1，否则通用定时器TIMx的时钟是APB1时钟的2倍，这时的TIMx时钟为72MHz\r\n  2. 用这个TIMx时钟72MHz除以（PSC+1），得到定时器每隔多少秒加一\r\n     * 这里给PSC赋7199，计算得定时器每隔0.0001秒加一，即此时频率为10KHz\r\n  3. 再把这个值乘以（ARR+1）得出PWM频率\r\n     * 假如ARR值为0，即0.0001*（0+1），则输出PWM频率为10KHz\r\n\r\n## 2. **怎么**确定PWM的占空比\r\n\r\n![image-20210816004751679](cloudDisk/markdown/stm32笔记.assets/image-20210816004751679.png)\r\n\r\n* 占空比概念：**是一个脉冲周期内，高电平的时间与整个周期时间的比例**\r\n  * 单位： **%** (0%-100%)\r\n  * **比方说周期的时间是10ms，脉宽时间是8ms 那么低电平时间就是2ms 总的占空比 8/8+2= 80%**\r\n\r\n* TIMx_CCR1—TIMx_CCR4确定定时器的CH1—CH4四路PWM的占空比。直接给该寄存器赋0—65535值即可确定占空比。\r\n* 函数方式：void TIM_SetCompare2(TIM_TypeDef* TIMx, uint16_t Compare2)；  \r\n\r\n* 占空比计算方法：\r\n  * TIMx_CCRx的值(上面函数的第二个参数)除以ARR寄存器的值即为占空比，因为占空比在0—100%之间，所以一般TIMx_CCRx寄存器值不能超过ARR寄存器的值，否则可能会引起PWM的频率或占空比的准确性。\r\n\r\n## 3. 寄存器\r\n\r\n要使 STM32 的通用定时器 TIMx 产生 PWM 输出，除了上一章介绍的寄存器外，我们还会**用到 3 个寄存器**，来控制 PWM 的。  \r\n\r\n### 3.1 捕获/比较模式寄存（TIMx_CCMR1/2）  \r\n\r\n* 该寄存器总共有 2 个， TIMx _CCMR1和 TIMx _CCMR2\r\n* TIMx_CCMR1 控制 CH1 和 2，而 TIMx_CCMR2 控制 CH3 和4。  \r\n* ![image-20210815182116436](cloudDisk/markdown/stm32笔记.assets/image-20210815182116436.png)\r\n  * 这里我们需要说明的是模式设置位 OCxM，此部分由 3 位组成。总共可以配置成 7 种模式，我们使用的是 PWM 模式，所以这 3 位必须设置为 110/111。这两种PWM 模式的区别就是输出电平的极性相反。  \r\n\r\n### 3.2 捕获/比较使能寄存器（TIMx_CCER）  \r\n\r\n* ![image-20210815182155390](cloudDisk/markdown/stm32笔记.assets/image-20210815182155390.png)\r\n* 我们这里只用到了 CC2E 位，该位是输入/捕获 2 输出使能位，要想PWM 从 IO 口输出，**这个位必须设置为 1**。\r\n\r\n### 3.3 捕获/比较寄存器（TIMx_CCR1~4）  \r\n\r\n* 该寄存器总共有 4 个，对应 4 个输通道 CH1~4。因为这 4 个寄存器都差不多，我们仅以 TIMx_CCR1 为例介绍  \r\n\r\n* ![image-20210815182428728](cloudDisk/markdown/stm32笔记.assets/image-20210815182428728.png)\r\n* 在输出模式下，该寄存器的值与 CNT 的值比较，根据比较结果产生相应动作。利用这点，我们通过修改这个寄存器的值，就可以控制 PWM 的输出脉宽了。   \r\n\r\n* 本章，我们使用的是 TIM3的通道 2，所以我们需要修改 TIM3_CCR2 以实现脉宽控制 DS0 的亮度。  \r\n\r\n* 我们要利用 TIM3 的 CH2 输出 PWM 来控制 DS0 的亮度，但是 TIM3_CH2 默认是接在 PA7\r\n  上面的，而我们的 DS0 接在 PB5 上面，如果普通 MCU，可能就只能用飞线把 PA7 飞到 PB5上来实现了，不过，我们用的是 STM32，它比较高级，可以通过重映射功能，把TIM3_CH2映射到 PB5 上。  \r\n\r\n## 4. 重映射 - TIM3_CH2映射到 PB5 上  \r\n\r\n* STM32 的重映射控制是由复用重映射和调试 IO 配置寄存器（AFIO_MAPR）控制的  \r\n* ![image-20210815183233797](cloudDisk/markdown/stm32笔记.assets/image-20210815183233797.png)\r\n\r\n* 我们这里用到的是 TIM3 的重映射，从上图可以看出， TIM3_REMAP 是由[11:10]这 2 个位\r\n  控制的。   \r\n* TIM3_REMAP[1:0]重映射控制表如表 14.1.1 所示：  \r\n  * ![image-20210815183436300](cloudDisk/markdown/stm32笔记.assets/image-20210815183436300.png)\r\n  * 默认条件下， TIM3_REMAP[1:0]为 00，是没有重映射的，所以 TIM3_CH1~TIM3_CH4 分别是接在 PA6、 PA7、 PB0 和 PB1 上的  \r\n  * 我们想让 TIM3_CH2 映射到 PB5 上， 则需要设置TIM3_REMAP[1:0]=10，即部分重映射，这里需要注意，此时 TIM3_CH1 也被映射到 PB4 上了。  \r\n\r\n## 5. PWM 相关的函数，配置步骤  \r\n\r\n#### 1） 开启 TIM3 时钟以及复用功能时钟，配置 PB5 为复用输出。  \r\n\r\n* RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM3, ENABLE); //使能定时器 3 时钟  \r\n\r\n* 这里我们还要配置 PB5 为复用输出，这是因为 TIM3_CH2 通道将重映射到 PB5 上，此时， PB5属于复用功能输出。  \r\n  * RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO, ENABLE); //复用时钟使能  \r\n  * 初始化GPIOB.5为复用推挽输出：\r\n    * ... \r\n    * GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP; //复用推挽输出    \r\n    * ...  \r\n\r\n#### 2） 设置 TIM3_CH2 重映射到 PB5 上。  \r\n\r\n* 因为 TIM3_CH2 默认是接在 PA7 上的，所以我们需要设置 TIM3_REMAP 为部分重映射（通\r\n  过 AFIO_MAPR 配置），让 TIM3_CH2 重映射到 PB5 上面。  \r\n  * void GPIO_PinRemapConfig(uint32_t GPIO_Remap, FunctionalState NewState)；  \r\n    * 第一个入口参数可以理解为设置重映射的类型，比如 TIM3 部分重映射入口参数为\r\n      GPIO_PartialRemap_TIM3，这点可以顾名思义了。   \r\n    * 如：GPIO_PinRemapConfig(GPIO_PartialRemap_TIM3, ENABLE);  \r\n\r\n#### 3） 初始化 TIM3,设置 TIM3 的 ARR 和 PSC。  \r\n\r\n* 在开启了 TIM3 的时钟之后，我们要设置 ARR 和 PSC 两个寄存器的值来控制输出 PWM 的\r\n  周期。  \r\n\r\n* 当 PWM 周期太慢（低于 50Hz）的时候，我们就会明显感觉到闪烁了。  \r\n\r\n* 这在库函数是通过 TIM_TimeBaseInit 函数实现的，在上一节定时器\r\n  中断章节我们已经有讲解，这里就不详细讲解，调用的格式为：  \r\n\r\n  * ```c\r\n    TIM_TimeBaseStructure.TIM_Period = arr; //设置自动重装载值\r\n    TIM_TimeBaseStructure.TIM_Prescaler =psc; //设置预分频值\r\n    TIM_TimeBaseStructure.TIM_ClockDivision = 0; //设置时钟分割:TDTS = Tck_tim\r\n    TIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Up; //向上计数模式\r\n    TIM_TimeBaseInit(TIM3, &TIM_TimeBaseStructure); //根据指定的参数初始化 TIMx 的\r\n    ```\r\n\r\n#### 4） 设置 TIM3_CH2 的 PWM 模式，使能 TIM3 的 CH2 输出。  \r\n\r\n* 我们希望当 CCR2 的值小的时候， DS0 就暗， CCR2 值大的时候， DS0 就亮，所以我们要通过配置 TIM3_CCMR1 的相关位来控制 TIM3_CH2 的模式  \r\n\r\n* PWM 通道设置是通过函数 TIM_OC1Init()~TIM_OC4Init()来设置的， 不同的通道的设置函数不一样， 这里我们使用的是通道 2，所以使用的函数是 TIM_OC2Init()  \r\n\r\n  * void TIM_OC2Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct)；  \r\n\r\n    * 第二个结构体为：\r\n\r\n      * ```c\r\n        typedef struct\r\n        {\r\n            uint16_t TIM_OCMode;\r\n            uint16_t TIM_OutputState;\r\n            uint16_t TIM_OutputNState; */\r\n            uint16_t TIM_Pulse;\r\n            uint16_t TIM_OCPolarity;\r\n            uint16_t TIM_OCNPolarity;\r\n            uint16_t TIM_OCIdleState;\r\n            uint16_t TIM_OCNIdleState;\r\n        } TIM_OCInitTypeDef;\r\n        ```\r\n\r\n    * 参数 TIM_OCMode 设置模式是 PWM 还是输出比较，这里我们是 PWM 模式。  \r\n\r\n    * 参数 TIM_OutputState 用来设置比较输出使能，也就是使能 PWM 输出到端口。\r\n\r\n    * 参数 TIM_OCPolarity 用来设置极性是高还是低。 \r\n\r\n    * 其他的参数 TIM_OutputNState， TIM_OCNPolarity， TIM_OCIdleState 和 TIM_OCNIdleState 是高级定时器 TIM1 和 TIM8 才用到的。     \r\n\r\n    * 要实现我们上面提到的场景， 方法是：  \r\n\r\n      * ```c\r\n        TIM_OCInitTypeDef TIM_OCInitStructure;\r\n        TIM_OCInitStructure.TIM_OCMode = TIM_OCMode_PWM2; //选择 PWM 模式 2\r\n        TIM_OCInitStructure.TIM_OutputState = TIM_OutputState_Enable; //比较输出使能\r\n        TIM_OCInitStructure.TIM_OCPolarity = TIM_OCPolarity_High; //输出极性高\r\n        TIM_OC2Init(TIM3, &TIM_OCInitStructure); //初始化 TIM3 OC2\r\n        ```\r\n\r\n#### 5） 使能 TIM3。  \r\n\r\nTIM_Cmd(TIM3, ENABLE); //使能 TIM3  \r\n\r\n#### 6） 修改 TIM3_CCR2 来控制占空比  \r\n\r\n* 在经过以上设置之后， PWM 其实已经开始输出了，只是其占空比和频率都是固定的，而我们通过修改 TIM3_CCR2 则可以控制 CH2 的输出占空比。继而控制 DS0 的亮度。\r\n* 改 TIM3_CCR2 占空比的函数是：  \r\n  * void TIM_SetCompare2(TIM_TypeDef* TIMx, uint16_t Compare2)；  \r\n  * 理所当然，对于其他通道，分别有一个函数名字， 函数格式为TIM_SetComparex(x=1,2,3,4)。  \r\n\r\n## 6. 案例 - 控制LED0的亮度\r\n\r\n我们从死循环函数可以看出， 我们将 count这个值设置为 PWM 比较值，也就是通过 count来控制 PWM 的占空比，然后控制 count的值从 0 变到 80，然后又从 80变到 0， 如此循环，因此 DS0 的亮度也会跟着从暗变到亮，然后又从亮变到暗。至于这里的值，我们为什么取 80，是因为 PWM 的输出占空比达到这个值的时候，我们的 LED 亮度变化就不大了（虽然最大值可以设置到 899），因此设计过大的值在这里是没必要的。  \r\n\r\n总结：控制占空比可以控制LED的亮度。由于在一个周期之内，占空比>50%，那么它的高电平时间相比低电平时间就长。越高的占空比，它在这个周期内的平均电流就越高。LED自然就越亮。\r\n\r\n```c\r\n#include \"stm32f10x.h\"\r\n#include \"delay.h\"\r\n#include \"sys.h\"\r\n#include \"usart.h\" \r\nvoid LedInit(void){\r\n	GPIO_InitTypeDef GPIO_InitStruct;\r\n	GPIO_InitStruct.GPIO_Mode = GPIO_Mode_Out_PP;\r\n	GPIO_InitStruct.GPIO_Pin = GPIO_Pin_5;\r\n	GPIO_InitStruct.GPIO_Speed = GPIO_Speed_50MHz;\r\n	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOE,ENABLE);\r\n	GPIO_Init(GPIOE,&GPIO_InitStruct);\r\n	GPIO_SetBits(GPIOE,GPIO_Pin_5);\r\n}\r\n\r\nvoid nvicInit(void){\r\n	NVIC_InitTypeDef NVIC_InitStructure;\r\n	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;\r\n	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0x02; // 设置抢占优先级2\r\n	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0x02; //子优先级 2\r\n	NVIC_InitStructure.NVIC_IRQChannel = TIM3_IRQn;\r\n	NVIC_Init(&NVIC_InitStructure);\r\n}\r\n\r\nvoid Timer3Init(u16 arr, u16 psc){\r\n	TIM_TimeBaseInitTypeDef TIM_TimeBaseInitStruct;\r\n	TIM_TimeBaseInitStruct.TIM_Period = arr;\r\n	TIM_TimeBaseInitStruct.TIM_Prescaler =psc;\r\n	TIM_TimeBaseInitStruct.TIM_ClockDivision = TIM_CKD_DIV1;\r\n	TIM_TimeBaseInitStruct.TIM_CounterMode = TIM_CounterMode_Up;\r\n	RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM3, ENABLE); //使能定时器 3 时钟\r\n	TIM_TimeBaseInit(TIM3, &TIM_TimeBaseInitStruct);  \r\n\r\n}\r\nvoid pwmTim3Ch2Init(void){\r\n	GPIO_InitTypeDef GPIO_InitStruct;\r\n	TIM_OCInitTypeDef TIM_OCInitStruct;\r\n	// 1）以及复用功能时钟，配置 PB5 为复用输出。  \r\n	RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO, ENABLE); //复用时钟使能 \r\n	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB,ENABLE);\r\n	GPIO_InitStruct.GPIO_Mode = GPIO_Mode_AF_PP; //复用推挽输出\r\n	GPIO_InitStruct.GPIO_Pin = GPIO_Pin_5;\r\n	GPIO_InitStruct.GPIO_Speed = GPIO_Speed_50MHz;\r\n	GPIO_Init(GPIOB,&GPIO_InitStruct);	\r\n	// 2） 设置 TIM3_CH2 重映射到 PB5 上。  \r\n	GPIO_PinRemapConfig(GPIO_PartialRemap_TIM3, ENABLE);\r\n	// 3） 开启 TIM3 时钟, 初始化 TIM3,设置 TIM3 的 ARR 和 PSC。 \r\n    // 当 PWM 周期太慢（低于 50Hz）的时候，我们就会明显感觉到闪烁了。因此， PWM 周期在这里不宜设置的太小。f = 72MHz / 899+1\r\n	Timer3Init(899,0);\r\n	// 4） 设置 TIM3_CH2 的 PWM 模式，使能 TIM3 的 CH2 输出。\r\n	TIM_OCInitStruct.TIM_OCMode = TIM_OCMode_PWM2; //选择 PWM 模式 2\r\n	TIM_OCInitStruct.TIM_OutputState = TIM_OutputState_Enable; //比较输出使能\r\n	TIM_OCInitStruct.TIM_OCPolarity = TIM_OCPolarity_High; //输出极性高\r\n	TIM_OC2Init(TIM3, &TIM_OCInitStruct); // //初始化 TIM3 OC2\r\n	// 5） 使能 TIM3。  \r\n	TIM_Cmd(TIM3, ENABLE); //使能 TIM3 \r\n\r\n}\r\n\r\nint main(void){\r\n	u16 count = 0; \r\n	int flag = 1;\r\n	delay_init();\r\n	// LedInit();\r\n	NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2); 	 //设置NVIC中断分组2:2位抢占优先级，2位响应优先级\r\n	uart_init(115200);	 //串口初始化为115200\r\n	pwmTim3Ch2Init();\r\n	\r\n	while(1){\r\n		delay_ms(5);\r\n		if (flag)\r\n			count ++;\r\n		else \r\n			count --;\r\n		if(count==80)\r\n			flag = 0;\r\n		else if (count==0)\r\n			flag = 1;\r\n		// 6） 修改 TIM3_CCR2 来控制占空比  \r\n        // 这里的占空比为 0%    ~   80/(899+1) %\r\n		TIM_SetCompare2(TIM3,count);\r\n		\r\n	};\r\n}\r\n```\r\n\r\n# 九、输入捕获  \r\n\r\n## 概念\r\n\r\n输入捕获模式可以用来测量脉冲宽度或者测量频率。  \r\n\r\n* STM32 的定时器，除了 TIM6 和 TIM7，其他定时器都有输入捕获功能。  \r\n* STM32 的输入捕获，简单的说就是通过检测 TIMx_CHx 上的\r\n  边沿信号，在边沿信号发生跳变（比如上升沿/下降沿）的时候，将当前定时器的值（TIMx_CNT）存放到对应的通道的捕获/比较寄存器（TIMx_CCRx）里面，完成一次捕获。同时还可以配置捕获时是否触发中断/DMA 等。  \r\n\r\n## 相关寄存器\r\n\r\n### 1. 捕获/比较模式寄存器 1： TIMx_CCMR1  \r\n\r\n![image-20210818000520591](cloudDisk/markdown/stm32笔记.assets/image-20210818000520591.png)\r\n\r\n* 低八位[7： 0]用于捕获/比较通道 1 的控制，而高八位[15： 8]则用于捕获/比较通道 2 的控制，因为 TIMx 还有 CCMR2 这个寄存器，所以可以知道CCMR2 是用来控制通道 3 和通道 4  \r\n\r\n这里我们用到的是 TIM5 的捕获/比较通道 1，我们重点介绍 TIMx_CMMR1 的[7:0]位（其\r\n实高 8 位配置类似）， TIMx_CMMR1 的[7:0]位详细描述见图 15.1.2 所示：  \r\n\r\n![image-20211018105224266](cloudDisk/markdown/stm32笔记.assets/image-20211018105224266.png)\r\n\r\n![image-20210818001435823](cloudDisk/markdown/stm32笔记.assets/image-20210818001435823.png)\r\n\r\n* 其中 CC1S[1:0]，这两个位用于 CCR1 的通道配置， 这里我们设置 IC1S[1:0]=01，也就是配置 IC1 映射在 TI1 上  \r\n\r\n* 输入捕获 1 预分频器 IC1PSC[1:0]，这个比较好理解。我们是 1 次边沿就触发 1 次捕获，所以选择 00 就是了\r\n* 输入捕获 1 滤波器 IC1F[3:0]，这个用来设置输入采样频率和数字滤波器长度。  \r\n  * 其中， fCK_INT是定时器的输入频率（TIMxCLK），一般为 72Mhz    \r\n  * 而 fDTS 则是根据 TIMx_CR1 的 CKD[1:0]的设置来确定的，如果 CKD[1:0]设置为 00，那么 fDTS = fCK_INT。  \r\n  * N 值就是滤波长度，举个简单的例子：假设 IC1F[3:0]=0011，并设置 IC1 映射到通道 1 上，且为上升沿触发，那么在捕获到上升沿的时候，再以 的频率，连续采样到 8 次通道 1 的电平，如果都是高电平，则说明却是一个有效的触发，就会触发输入捕获中断（如果开启了的话）。  \r\n    * 这样可以滤除那些高电平\r\n      脉宽低于 8 个采样周期的脉冲信号，从而达到滤波的效果。  \r\n\r\n### 2. 捕获/比较使能寄存器： TIMx_CCER  \r\n\r\n![image-20210818010406420](cloudDisk/markdown/stm32笔记.assets/image-20210818010406420.png)\r\n\r\n* 要使能输入捕获，必须设置 CC1E=0，而 CC1P 则根据自己的需要来配置。  \r\n\r\n## 输入捕获的配置步骤： \r\n\r\n### 1）开启 TIM5 时钟和 GPIOA 时钟， 配置 PA0 为下拉输入。  \r\n\r\n* 这里我们还要配置 PA0 为下拉输入，因为我们要捕获 TIM5_CH1 上面的高电平脉宽，而 TIM5_CH1 是连接在 PA0 上面的  \r\n* RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM5, ENABLE); //使能 TIM5 时钟  \r\n* RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE); //使能 GPIOA 时钟  \r\n\r\n### 2） 初始化 TIM5,设置 TIM5 的 ARR 和 PSC。  \r\n\r\n* 在开启了 TIM5 的时钟之后，我们要设置 ARR 和 PSC 两个寄存器的值来设置输入捕获的\r\n  自动重装载值和计数频率。   \r\n\r\n  ```c\r\n  TIM_TimeBaseInitTypeDef TIM_TimeBaseStructure;  \r\n  TIM_TimeBaseStructure.TIM_Period = arr; //设定计数器自动重装值\r\n  TIM_TimeBaseStructure.TIM_Prescaler =psc; //设置预分频值\r\n  TIM_TimeBaseStructure.TIM_ClockDivision = TIM_CKD_DIV1; // TDTS = Tck_tim\r\n  TIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Up; //TIM 向上计数模式\r\n  TIM_TimeBaseInit(TIM5, &TIM_TimeBaseStructure); //根据指定的参数初始化 Tim5  \r\n  ```\r\n\r\n### 3）设置 TIM5 的输入比较参数，开启输入捕获  \r\n\r\n```c\r\nvoid TIM_ICInit(TIM_TypeDef* TIMx, TIM_ICInitTypeDef* TIM_ICInitStruct)；\r\n```\r\n\r\n```c\r\ntypedef struct\r\n{\r\nuint16_t TIM_Channel;\r\nuint16_t TIM_ICPolarity;\r\nuint16_t TIM_ICSelection;\r\nuint16_t TIM_ICPrescaler;\r\nuint16_t TIM_ICFilter;\r\n} TIM_ICInitTypeDef;\r\n```\r\n\r\n* 参数 TIM_Channel 很好理解， 用来设置通道。 我们设置为通道 1， 为 TIM_Channel_1  \r\n* 参 数 TIM_ICPolarity是 用 来 设 置 输 入 信 号 的 有 效 捕 获 极 性 ， 这 里 我 们 设 置 为\r\n  TIM_ICPolarity_Rising， 上升沿捕获  \r\n  * 同时库函数还提供了单独设置通道 1 捕获极性的函数为TIM_OC1PolarityConfig(TIM5,TIM_ICPolarity_Falling)，\r\n    * 这表示通道 1 为上升沿捕获，我们后面会用到    \r\n    * 其他三个通道也有一个类似的函数  格式为 TIM_OCxPolarityConfig()  \r\n* 参数 TIM_ICSelection 是用来设置映射关系，我们配置 IC1 直接映射在 TI1 上，选择\r\n  TIM_ICSelection_DirectTI  \r\n* 参 数 TIM_ICPrescaler 用 来 设 置 输 入 捕 获 分 频 系 数 ， 我 们 这 里 不 分 频 ， 所 以 选 中\r\n  TIM_ICPSC_DIV1,还有 2,4,8 分频可选  \r\n* 参数 TIM_ICFilter 设置滤波器长度，这里我们不使用滤波器， 所以设置为 0 \r\n\r\n例：\r\n\r\n![image-20210818221259549](cloudDisk/markdown/stm32笔记.assets/image-20210818221259549.png)\r\n\r\n```c\r\nTIM_ICInitTypeDef TIM5_ICInitStructure;\r\nTIM5_ICInitStructure.TIM_Channel = TIM_Channel_1; //选择输入端 IC1 映射到 TI1 上\r\nTIM5_ICInitStructure.TIM_ICPolarity = TIM_ICPolarity_Rising; //上升沿捕获\r\nTIM5_ICInitStructure.TIM_ICSelection = TIM_ICSelection_DirectTI; //映射到 TI1 上\r\nTIM5_ICInitStructure.TIM_ICPrescaler = TIM_ICPSC_DIV1; //配置输入分频,不分频\r\nTIM5_ICInitStructure.TIM_ICFilter = 0x00;//IC1F=0000 配置输入滤波器 不滤波\r\nTIM_ICInit(TIM5, &TIM5_ICInitStructure);\r\n```\r\n\r\n### 4）使能捕获和更新中断（设置 TIM5 的 DIER 寄存器）  \r\n\r\n* 因为我们要捕获的是高电平信号的脉宽，所以，第一次捕获是上升沿，第二次捕获时下降\r\n  沿，必须在捕获上升沿之后，设置捕获边沿为下降沿，同时，如果脉宽比较长，那么定时器就\r\n  会溢出，对溢出必须做处理，否则结果就不准了。  \r\n* 这两件事，我们都在中断里面做，所以必须开启捕获中断和更新中断。    \r\n* 这里我们使用定时器的开中断函数 TIM_ITConfig 即可使能捕获和更新中断： \r\n  * TIM_ITConfig( TIM5,TIM_IT_Update|TIM_IT_CC1,ENABLE);//允许更新中断和捕获中断   \r\n\r\n### 5）设置中断分组，编写中断服务函数  \r\n\r\n* 要是通过函数 NVIC_Init()来完成  \r\n\r\n* 分组完成后， 我们还需要在中断函数里面完成数据处理和捕获设置等关键操作，从而实现\r\n  高电平脉宽统计。   \r\n\r\n* 在中断服务函数里面，跟以前的外部中断和定时器中断实验中一样，我们在中断开始的时候要进行中断类型判断，在中断结束的时候要清除中断标志位。  \r\n\r\n  * 使用到的函数在上面的实验已经讲解过，分别为 TIM_GetITStatus()函数和 TIM_ClearITPendingBit()函数  \r\n\r\n  * ```c\r\n    if (TIM_GetITStatus(TIM5, TIM_IT_Update) != RESET){}//判断是否为更新中断\r\n    if (TIM_GetITStatus(TIM5, TIM_IT_CC1) != RESET){}//判断是否发生捕获事件\r\n    TIM_ClearITPendingBit(TIM5, TIM_IT_CC1|TIM_IT_Update);//清除中断和捕获标志位\r\n    ```\r\n\r\n### 6）使能定时器（设置 TIM5 的 CR1 寄存器）  \r\n\r\n* 最后，必须打开定时器的计数器开关， 启动 TIM5 的计数器，开始输入捕获  \r\n  * TIM_Cmd(TIM5,ENABLE ); //使能定时器 5  \r\n\r\n## 案例  - 计时按键按下的时间\r\n\r\n### 我的方法：\r\n\r\n```c\r\n#include \"stm32f10x.h\"\r\n#include \"delay.h\"\r\n#include \"sys.h\"\r\n#include \"usart.h\" \r\nvoid nvicInit(void){\r\n	NVIC_InitTypeDef NVIC_InitStructure;\r\n	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;\r\n	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0x02; // 设置抢占优先级2\r\n	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0x02; //子优先级 2\r\n	NVIC_InitStructure.NVIC_IRQChannel = TIM5_IRQn;\r\n	NVIC_Init(&NVIC_InitStructure);\r\n}\r\n\r\nvoid inputCatchInit(void){\r\n	GPIO_InitTypeDef GPIO_InitStruct;\r\n	TIM_ICInitTypeDef TIM_ICInitStruct;\r\n	TIM_TimeBaseInitTypeDef TIM_TimeBaseStructure;\r\n	// 1）开启 TIM5 时钟和 GPIOA 时钟， 配置 PA0 为下拉输入。  \r\n	RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM5, ENABLE); //使能 TIM5 时钟  \r\n	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE); //使能 GPIOA 时钟  \r\n	GPIO_InitStruct.GPIO_Mode = GPIO_Mode_IPD;\r\n	GPIO_InitStruct.GPIO_Pin = GPIO_Pin_0;\r\n	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOE,ENABLE);\r\n	GPIO_Init(GPIOA,&GPIO_InitStruct);\r\n	// 2） 初始化 TIM5,设置 TIM5 的 ARR 和 PSC。\r\n	TIM_TimeBaseStructure.TIM_Period = 899; //设定计数器自动重装值\r\n	TIM_TimeBaseStructure.TIM_Prescaler = 0; //设置预分频值\r\n	TIM_TimeBaseStructure.TIM_ClockDivision = TIM_CKD_DIV1; // TDTS = Tck_tim\r\n	TIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Up; //TIM 向上计数模式\r\n	TIM_TimeBaseInit(TIM5, &TIM_TimeBaseStructure); //根据指定的参数初始化 Tim5  \r\n	// 3）设置 TIM5 的输入比较参数，开启输入捕获  \r\n	TIM_ICInitStruct.TIM_Channel = TIM_Channel_1; // 设置为通道 1\r\n	TIM_ICInitStruct.TIM_ICSelection = TIM_ICPolarity_Rising; // 上升沿捕获  \r\n	TIM_ICInitStruct.TIM_ICSelection = TIM_ICSelection_DirectTI; // 配置 IC1 直接映射在 TI1 上\r\n	TIM_ICInitStruct.TIM_ICPrescaler = TIM_ICPSC_DIV1; // 设 置 输 入 捕 获 分 频 系 数 ， 我 们 这 里 不 分 频\r\n	TIM_ICInitStruct.TIM_ICFilter = 0x00; // 这里我们不使用滤波器， 所以设置为 0 \r\n	TIM_ICInit(TIM5, &TIM_ICInitStruct);\r\n	// 4）使能捕获和更新中断（设置 TIM5 的 DIER 寄存器）  \r\n	TIM_ITConfig(TIM5,TIM_IT_Update|TIM_IT_CC1,ENABLE);//允许更新中断和捕获中断\r\n	// 5）设置中断分组，编写中断服务函数  \r\n	nvicInit();\r\n	// 6）使能定时器（设置 TIM5 的 CR1 寄存器）  \r\n	TIM_Cmd(TIM5,ENABLE ); //使能定时器 5  \r\n}\r\n\r\n// 5）设置中断分组，编写中断服务函数  \r\nvoid TIM5_IRQHandler(void){\r\n	static u32 count = 0;\r\n	static int flag = 1;\r\n	//判断是否为更新中断（Tim5计数器满的时候让 count+1）\r\n	if (TIM_GetITStatus(TIM5, TIM_IT_Update) != RESET){\r\n		count ++ ;\r\n		// TIM_OC1PolarityConfig(TIM5,TIM_ICPolarity_Rising);\r\n	}\r\n	//判断是否发生捕获事件\r\n	if (TIM_GetITStatus(TIM5, TIM_IT_CC1) != RESET){\r\n		// 按下时，count=0; 开始计数\r\n		if(flag){\r\n			count = 0;\r\n			TIM_OC1PolarityConfig(TIM5,TIM_ICPolarity_Falling); // 接收到下降沿时，触发中断\r\n			flag = 0;\r\n		}else{\r\n			printf(\"%lfms  \",count * 0.0125); // 串口打印输出\r\n			TIM_OC1PolarityConfig(TIM5,TIM_ICPolarity_Rising); // 接收到上升沿时，触发中断\r\n			flag = 1;\r\n		}\r\n}\r\n	TIM_ClearITPendingBit(TIM5, TIM_IT_CC1|TIM_IT_Update);//清除中断和捕获标志位\r\n}\r\n\r\nint main(void){\r\n\r\n	delay_init();\r\n	// LedInit();\r\n	NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2); 	 //设置NVIC中断分组2:2位抢占优先级，2位响应优先级\r\n	uart_init(115200);	 //串口初始化为115200\r\n	inputCatchInit(); // 输入捕获初始化\r\n	while(1){\r\n	};\r\n}\r\n```\r\n\r\n### 参考方法：\r\n\r\n```c\r\n/*\r\n	timer.c\r\n*/\r\n/定时器 5 通道 1 输入捕获配置\r\nTIM_ICInitTypeDef TIM5_ICInitStructure;\r\nvoid TIM5_Cap_Init(u16 arr,u16 psc)\r\n{\r\n    GPIO_InitTypeDef GPIO_InitStructure;\r\n    TIM_TimeBaseInitTypeDef TIM_TimeBaseStructure;\r\n    NVIC_InitTypeDef NVIC_InitStructure;\r\n    RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM5, ENABLE); //①使能 TIM5 时钟\r\n    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE); //①使能 GPIOA 时钟\r\n        //初始化 GPIOA.0 ①\r\n    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0; //PA0 设置\r\n    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPD; //PA0 输入\r\n    GPIO_Init(GPIOA, &GPIO_InitStructure); //初始化 GPIOA.0\r\n    GPIO_ResetBits(GPIOA,GPIO_Pin_0); //PA0 下拉\r\n    //②初始化 TIM5 参数\r\n    TIM_TimeBaseStructure.TIM_Period = arr; //设定计数器自动重装值\r\n    TIM_TimeBaseStructure.TIM_Prescaler =psc; //预分频器\r\n    TIM_TimeBaseStructure.TIM_ClockDivision = TIM_CKD_DIV1; // TDTS = Tck_tim\r\n    TIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Up; //TIM 向上计数模式\r\n    TIM_TimeBaseInit(TIM5, &TIM_TimeBaseStructure); //初始化 TIMx\r\n    //③初始化 TIM5 输入捕获通道 1\r\n    TIM5_ICInitStructure.TIM_Channel = TIM_Channel_1; //选择输入端 IC1 映射到 TI1 上\r\n    TIM5_ICInitStructure.TIM_ICPolarity = TIM_ICPolarity_Rising; //上升沿捕获\r\n    TIM5_ICInitStructure.TIM_ICSelection = TIM_ICSelection_DirectTI; //映射到 TI1 上\r\n    TIM5_ICInitStructure.TIM_ICPrescaler = TIM_ICPSC_DIV1; //配置输入分频,不分频\r\n    TIM5_ICInitStructure.TIM_ICFilter = 0x00; //IC1F=0000 配置输入滤波器 不滤波\r\n    TIM_ICInit(TIM5, &TIM5_ICInitStructure); //初始化 TIM5 输入捕获通道 1\r\n    //⑤初始化 NVIC 中断优先级分组\r\n    NVIC_InitStructure.NVIC_IRQChannel = TIM5_IRQn; //TIM5 中断\r\n    NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 2; //先占优先级 2 级\r\n    NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0; //从优先级 0 级\r\n    NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE; //IRQ 通道被使能\r\n    NVIC_Init(&NVIC_InitStructure); //初始化 NVIC\r\n    TIM_ITConfig( TIM5,TIM_IT_Update|TIM_IT_CC1,ENABLE);//④允许更新中断捕获中断\r\n    TIM_Cmd(TIM5,ENABLE ); //⑥使能定时器 5\r\n}\r\n\r\nu8 TIM5CH1_CAPTURE_STA=0; //输入捕获状态\r\nu16 TIM5CH1_CAPTURE_VAL;//输入捕获值\r\n//⑤定时器 5 中断服务程序\r\nvoid TIM5_IRQHandler(void)\r\n{\r\n	if((TIM5CH1_CAPTURE_STA&0X80)==0)//还未成功捕获\r\n		{\r\n			if (TIM_GetITStatus(TIM5, TIM_IT_Update) != RESET)\r\n			{\r\n        	if(TIM5CH1_CAPTURE_STA&0X40) //已经捕获到高电平了\r\n			{\r\n				if((TIM5CH1_CAPTURE_STA&0X3F)==0X3F)//高电平太长了\r\n				{\r\n					TIM5CH1_CAPTURE_STA|=0X80; //标记成功捕获了一次\r\n					TIM5CH1_CAPTURE_VAL=0XFFFF;\r\n				}else TIM5CH1_CAPTURE_STA++;\r\n			}\r\n		}\r\n	if (TIM_GetITStatus(TIM5, TIM_IT_CC1) != RESET) //捕获 1 发生捕获事件\r\n		{\r\n		if(TIM5CH1_CAPTURE_STA&0X40) //捕获到一个下降沿\r\n			{\r\n                TIM5CH1_CAPTURE_STA|=0X80; //标记成功捕获到一次上升沿\r\n                TIM5CH1_CAPTURE_VAL=TIM_GetCapture1(TIM5);\r\n                TIM_OC1PolarityConfig(TIM5,TIM_ICPolarity_Rising); //设置为上升沿捕获\r\n        	}else //还未开始,第一次捕获上升沿\r\n			{\r\n                TIM5CH1_CAPTURE_STA=0; //清空\r\n                TIM5CH1_CAPTURE_VAL=0;\r\n                TIM_SetCounter(TIM5,0);\r\n                TIM5CH1_CAPTURE_STA|=0X40; //标记捕获到了上升沿\r\n                TIM_OC1PolarityConfig(TIM5,TIM_ICPolarity_Falling); //设置为下降沿捕获\r\n			}\r\n		}\r\n	}\r\n		TIM_ClearITPendingBit(TIM5, TIM_IT_CC1|TIM_IT_Update); //清除中断标志位\r\n}\r\n```\r\n\r\n* 重点来看看第二个函数。TIM5_IRQHandler 是 TIM5 的中断服务函数，该函数用到了两个全局变量，用于辅助实现高电平捕获。其中 TIM5CH1_CAPTURE_STA，是用来记录捕获状态，该变量类似我们在 usart.c里面自行定义的 USART_RX_STA 寄存器(其实就是个变量，只是我们把它当成一个寄存器那样来使用)。 TIM5CH1_CAPTURE_STA 各位描述如表 15.3.1 所示：\r\n\r\n  ![image-20210818233444838](cloudDisk/markdown/stm32笔记.assets/image-20210818233444838.png)\r\n\r\n* 另外一个变量 TIM5CH1_CAPTURE_VAL，则用来记录捕获到下降沿的时候， TIM5_CNT\r\n  的值。  \r\n\r\n* 现在我们来介绍一下，捕获高电平脉宽的思路：首先，设置 TIM5_CH1 捕获上升沿，这在\r\n  TIM5_Cap_Init 函数执行的时候就设置好了，然后等待上升沿中断到来， 当捕获到上升沿中断，  此时如果 TIM5CH1_CAPTURE_STA 的第 6 位为 0， 则表示还没有捕获到新的上升沿， 就先把TIM5CH1_CAPTURE_STA、 TIM5CH1_CAPTURE_VAL 和 TIM5->CNT 等清零，然后再设置\r\n  TIM5CH1_CAPTURE_STA 的第 6 位为 1， 标记捕获到高电平， 最后设置为下降沿捕获，等待\r\n  下降沿到来。如果等待下降沿到来期间，定时器发生了溢出，就在 TIM5CH1_CAPTURE_STA\r\n  里面对溢出次数进行计数，当最大溢出次数来到的时候，就强制标记捕获完成（虽然此时还没\r\n  有捕获到下降沿）。当下降沿到来的时候，先设置 TIM5CH1_CAPTURE_STA 的第 7 位为 1，标\r\n  记成功捕获一次高电平，然后读取此时的定时器值到 TIM5CH1_CAPTURE_VAL 里面，最后设\r\n  置为上升沿捕获，回到初始状态。  \r\n\r\n* 这样，我们就完成一次高电平捕获了，只要 TIM5CH1_CAPTURE_STA 的第 7 位一直为 1，\r\n  那么就不会进行第二次捕获，我们在main函数处理完捕获数据后，将TIM5CH1_CAPTURE_STA\r\n  置零，就可以开启第二次捕获。  \r\n\r\n* 这里我们还使用到一个函数 TIM_OC1PolarityConfig 来修改输入捕获通道 1 的极性的。 相信这\r\n  个不难理解：  void TIM_OC1PolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPolarity)  \r\n\r\n  * TIM_OC1PolarityConfig(TIM5,TIM_ICPolarity_Rising); //设置为上升沿捕获  \r\n\r\n* 还有一个函数用来设置计数器寄存器值，这个同样很好理解：  \r\n\r\n  * TIM_SetCounter(TIM5,0);  // 计数值清零  \r\n\r\n```c\r\n/*\r\n	main.c\r\n*/\r\nextern u8 TIM5CH1_CAPTURE_STA; //输入捕获状态\r\nextern u16 TIM5CH1_CAPTURE_VAL; //输入捕获值\r\nint main(void)\r\n{\r\n    u32 temp=0;\r\n    delay_init(); //延时函数初始化\r\n    NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2); //设置 NVIC 中断分组 2\r\n    uart_init(115200); //串口初始化波特率为 115200\r\n    LED_Init(); //LED 端口初始化\r\n    TIM5_Cap_Init(0XFFFF,72-1); //以 1Mhz 的频率计数\r\n    while(1)\r\n    {\r\n        delay_ms(10);\r\n        if(TIM5CH1_CAPTURE_STA&0X80)//成功捕获到了一次上升沿\r\n        {\r\n            temp=TIM5CH1_CAPTURE_STA&0X3F;\r\n            temp*=65536;//溢出时间总和\r\n            temp+=TIM5CH1_CAPTURE_VAL;//得到总的高电平时间\r\n            printf(\"HIGH:%d us\\r\\n\",temp); //打印总的高点平时间\r\n            TIM5CH1_CAPTURE_STA=0; //开启下一次捕获\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n# 十、电容触摸按键实验\r\n\r\n## 基本原理\r\n\r\n![image-20210819192127721](cloudDisk/markdown/stm32笔记.assets/image-20210819192127721.png)\r\n\r\n### 1. 元器件说明：\r\n\r\n* 图中 R 是外接的电容充电电阻  \r\n* Cs 是没有触摸按下时 TPAD 与 PCB 之间的杂散电容  \r\n  * 而 Cx 则是有手指按下的时候，手指与 TPAD 之间形成的电容。  \r\n* 图中的开关是电容放电开关（由实际使用时，由 STM32 的 IO代替）  \r\n\r\n### 2. 原理：\r\n\r\n* 先将开关S闭合，使得Cs（或 Cs+Cx）上的电放尽  \r\n* 然后断开开关，让 R 给 Cs（或 Cs+Cx）充电  \r\n* 当没有手指触摸的时候， Cs 的充电曲线如图中的 A 曲线  \r\n* 而当有手指触摸的时候， 手指和 TPAD之间引入了新的电容 Cx，此时 Cs+Cx 的充电曲线如图中的 B 曲线  \r\n* 从上图可以看出， A、 B 两种情况下， Vc 达到 Vth 的时间分别为 Tcs 和 Tcs+Tcx  \r\n\r\n### 3. 计算：\r\n\r\n* 除了 Cs 和 Cx 我们需要计算，其他都是已知的，根据电容充放电公式：  \r\n  * Vc=V0*(1-e^(-t/RC))  \r\n    * Vc   -  电容电压 \r\n    * V0  -   充电电压  \r\n    * R   -  充电电阻  \r\n    * C   -  电容容值  \r\n    * e   -  自然底数\r\n    * t   -  充电时间  \r\n  * 根据这个公式，我们就可以计算出 Cs 和 Cx  \r\n\r\n### 4. 程序设计思路：\r\n\r\n* 我们只要能够区分 Tcs 和 Tcs+Tcx，就已经可以实现触摸检测了，当充电时间在 Tcs 附近，就可以认为没有触摸，而当充电时间大于 Tcs+Tx 时，就认为有触摸按下（Tx为检测阀值）。  \r\n* 我们使用 PA1(TIM5_CH2)来检测 TPAD 是否有触摸  \r\n\r\n1. 在每次检测之前，我们先配置PA1 为推挽输出 ，将电容 Cs（或 Cs+Cx）放电  \r\n2. 然后配置 PA1 为浮空输入，利用外部上拉电阻给电容 Cs(Cs+Cx)充电 ，同时开启 TIM5_CH2 的输入捕获，检测上升沿，当检测到上升沿的时候，就认为电容充电完成了，完成一次捕获检测。 \r\n3. 在 MCU 每次复位重启的时候，我们执行一次捕获检测（可以认为没触摸），记录此时的充电时间的值（Tcs），记为 tpad_default_val，作为判断的依据。 在后续的捕获检测，我们就通过与  tpad_default_val 的对比，来判断是不是有触摸发生。  \r\n\r\n\r\n\r\n## 硬件连接\r\n\r\n![image-20210819194239389](cloudDisk/markdown/stm32笔记.assets/image-20210819194239389.png)\r\n\r\n## 程序设计\r\n\r\n#### 通过电容触摸按键 控制 DS1 的亮灭  \r\n\r\n* **首先得需要写个函数： 获取T(电容充电到上升沿是所需计数个数)阶段的计数器的值**\r\n\r\n1. 将电容初始化，即将电容放电，开始充电\r\n2. 清零计数器的值TIM_SetCounter(TIM5,0);、寄存器的边沿捕捉标志位TIM_ClearITPendingBit(TIM5, TIM_IT_CC2); 、寄存器的边沿捕捉时的计数值TIM2->CCR2 = 0X0000; \r\n3. 此时电容在充电，当电压充到足以使得PA1检测到上升沿信号，TIM5会捕捉此时的计数值，保存到寄存器TIM2->CCR2中\r\n\r\n```c\r\n#include \"stm32f10x.h\"\r\n#include \"delay.h\"\r\n#include \"sys.h\"\r\n#include \"usart.h\"\r\n#define resetLED GPIO_SetBits(GPIOE,GPIO_Pin_5)  \r\n#define setLED GPIO_ResetBits(GPIOE,GPIO_Pin_5)\r\nvoid LEDInit(void); // LED初始化\r\nvoid inputCatchInit(void); // 初始化 TIM5,通道2输入捕捉\r\nu16 getInitTcs(void); // 获取初始的Tcs阶段的计数器的值\r\nvoid resetC(void);  // 电容初始化为开始充电状态\r\n\r\nu16 getTs(void); // 获取T(电容充电到上升沿是所需计数个数)阶段的计数器的值，除以二是为预防计数器溢出归零\r\n\r\nint scanTck(void);  // 判断 电容充电阶段的计数次数（Tcs+Tck） 是否比 初始化得到的Tcs(tpad_default_val)大，如果大，说明有触摸\r\nu8 keyScan();  // 移植keyScan的扫描函数，实现边沿触发或电平触发\r\n\r\nu16 tpad_default_val;\r\n\r\nvoid LEDInit(void){\r\n	// LED0(PB5),LED1(PE5),推挽输出50MHZ\r\n	GPIO_InitTypeDef GPIO_InitStruct;\r\n	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOE,ENABLE);\r\n	GPIO_InitStruct.GPIO_Speed = GPIO_Speed_50MHz;\r\n	GPIO_InitStruct.GPIO_Mode = GPIO_Mode_Out_PP;\r\n	GPIO_InitStruct.GPIO_Pin = GPIO_Pin_5;\r\n	GPIO_Init(GPIOE,&GPIO_InitStruct);\r\n	// 灭灯\r\n	resetLED;\r\n}\r\n\r\nvoid resetC(void){\r\n	GPIO_InitTypeDef GPIO_InitStruct;\r\n	// 电容放电\r\n	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE); //使能 GPIOA 时钟  \r\n	GPIO_InitStruct.GPIO_Mode = GPIO_Mode_Out_PP;\r\n	GPIO_InitStruct.GPIO_Pin = GPIO_Pin_1;\r\n	GPIO_InitStruct.GPIO_Speed = GPIO_Speed_50MHz;\r\n	GPIO_Init(GPIOA,&GPIO_InitStruct);\r\n	GPIO_ResetBits(GPIOA,GPIO_Pin_1); //PA.1 输出 0,放电\r\n	delay_ms(5);  // 等待放完电\r\n	TIM2->CCR2 = 0X0000; // 清空捕获寄存器的值\r\n	// 电容充电\r\n	TIM_ClearITPendingBit(TIM5, TIM_IT_CC2); //清除中断标志\r\n	GPIO_InitStruct.GPIO_Mode = GPIO_Mode_IN_FLOATING;\r\n	GPIO_Init(GPIOA,&GPIO_InitStruct);\r\n}\r\n\r\nvoid inputCatchInit(void){\r\n	TIM_ICInitTypeDef TIM_ICInitStruct;\r\n	TIM_TimeBaseInitTypeDef TIM_TimeBaseStructure;\r\n	// 1）开启 TIM5 时钟和 GPIOA 时钟， 配置 PA0 为推挽输出。  \r\n	RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM5, ENABLE); //使能 TIM5 时钟  \r\n	resetC();\r\n	// 2） 初始化 TIM5,设置 TIM5 的 ARR 和 PSC。\r\n	TIM_TimeBaseStructure.TIM_Period = 0xffff; //设定计数器自动重装值\r\n	TIM_TimeBaseStructure.TIM_Prescaler = 0; //设置预分频值\r\n	TIM_TimeBaseStructure.TIM_ClockDivision = TIM_CKD_DIV1; // TDTS = Tck_tim\r\n	TIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Up; //TIM 向上计数模式\r\n	TIM_TimeBaseInit(TIM5, &TIM_TimeBaseStructure); //根据指定的参数初始化 Tim5  \r\n	// 3）设置 TIM5 的输入比较参数，开启输入捕获  \r\n	TIM_ICInitStruct.TIM_Channel = TIM_Channel_2; // 设置为通道 2\r\n	TIM_ICInitStruct.TIM_ICSelection = TIM_ICPolarity_Rising; // 上升沿捕获  \r\n	TIM_ICInitStruct.TIM_ICSelection = TIM_ICSelection_DirectTI; // 配置 IC1 直接映射在 TI1 上\r\n	TIM_ICInitStruct.TIM_ICPrescaler = TIM_ICPSC_DIV1; // 设 置 输 入 捕 获 分 频 系 数 ， 我 们 这 里 不 分 频\r\n	TIM_ICInitStruct.TIM_ICFilter = 0x03; // 这里我们不使用滤波器， 所以设置为 0 \r\n	TIM_ICInit(TIM5, &TIM_ICInitStruct);\r\n	// 4）使能捕获中断（设置 TIM5 的 DIER 寄存器）  \r\n	TIM_ITConfig(TIM5,TIM_IT_CC2,ENABLE);//允许捕获中断\r\n	// 6）使能定时器（设置 TIM5 的 CR1 寄存器）  \r\n	TIM_Cmd(TIM5,ENABLE); //使能定时器 5 \r\n	// 7) 获取初始的Tcs阶段的计数器的值\r\n	tpad_default_val = getInitTcs();\r\n}\r\n\r\n// 获取初始的Tcs阶段的计数器的值\r\nu16 getInitTcs(void){\r\n	// 调用 getTs() 10次，计算平均值，返回最大的值\r\n	int i,maxi;\r\n	u16 tcs[10];\r\n	for(i=0;i<10;i++){\r\n		tcs[i] = getTs();\r\n	}\r\n	// tcs排序\r\n	maxi = tcs[0];\r\n	for(i=0;i<10;i++){\r\n		if(maxi<tcs[i])\r\n			maxi = tcs[i];\r\n	}\r\n	return maxi;\r\n	\r\n}\r\n\r\n// 获取T(电容充电到上升沿时所需计数个数)阶段的计数器的值，除以二是为预防计数器溢出归零\r\nu16 getTs(void){\r\n	TIM_SetCounter(TIM5,0); // 计数器清零\r\n	resetC(); // 电容初始化为开始充电状态\r\n	while (TIM_GetITStatus(TIM5, TIM_IT_CC2) == RESET); // 程序暂停，如果发生了捕获中断（捕获到上升沿），则往下执行\r\n	return TIM_GetCapture2(TIM5)/2; // 电容充电到上升沿的触发电压时，返回寄存器的值\r\n}\r\n\r\n// 判断 电容充电阶段的计数次数（Tcs+Tck） 是否比 初始化得到的Tcs(tpad_default_val)大，如果大，说明有触摸\r\nint scanTck(void){\r\n	if(getTs() > tpad_default_val+50) // +50 为了预防误差\r\n		return 1;\r\n	else\r\n		return 0;\r\n}\r\n\r\n// 移植keyscan的扫描函数，实现边沿触发或电平触发\r\nu8 keyScan(u8 mode){ //mode=0上升沿触发  mode=1电平触发\r\n	static u8 preKey = 1;\r\n	if(mode)preKey=1; //支持连按\r\n	if(preKey&&(scanTck()==1)){\r\n		delay_ms(5);\r\n		preKey = 0;\r\n		if(scanTck()==1){\r\n			return 1;\r\n		}\r\n	}\r\n	else if(scanTck()==0){\r\n			preKey = 1;	\r\n	}\r\n	return 0;\r\n}\r\n\r\nint main(void){\r\n	int flag = 1;\r\n	LEDInit();\r\n	delay_init();\r\n	NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2); 	 //设置NVIC中断分组2:2位抢占优先级，2位响应优先级\r\n	uart_init(115200);	 //串口初始化为115200\r\n	inputCatchInit(); // 输入捕获初始化\r\n	while(1){\r\n		delay_ms(5);\r\n		if(keyScan(0)){ // 如果检测到有按下\r\n			// LED等取反\r\n			if(flag){\r\n				setLED;\r\n				flag = 0;\r\n			}else{\r\n				resetLED;\r\n				flag = 1;\r\n			}\r\n			\r\n		}\r\n		\r\n	};\r\n}\r\n```\r\n\r\n\r\n\r\n# 十一、OLED显示P236\r\n\r\n## 1. OLED简介\r\n\r\n* 多种接口方式，该模块提供了总共 5 种接口包括： 6800、 8080 两种并行接口方式、 3线或 4 线的穿行 SPI 接口方式，、 IIC 接口方式（只需要 2 根线就可以控制 OLED 了！）。 \r\n* 不需要高压，直接接 3.3V 就可以工作了   \r\n\r\n## 2. 8080的并口方式  \r\n\r\nALIENTEK OLED 模块的 8080 接口方式需要如下一些信号线：  \r\n\r\n* CS： OLED 片选信号。\r\n  WR：向 OLED 写入数据。\r\n  RD：从 OLED 读取数据。\r\n  D[7： 0]： 8 位双向数据线。\r\n  RST(RES)：硬复位 OLED。\r\n  DC：命令/数据标志（0，读写命令； 1，读写数据）。  \r\n\r\n* 模块的 8080 并口读/写的过程为：先根据要写入/读取的数据的类型，设置 DC 为高（数据）/低（命令），然后拉低片选，选中 SSD1306，接着我们根据是读数据，还是要写数据置 RD/WR为低，然后：  在 RD 的上升沿， 使数据锁存到数据线（D[7： 0]）上  ；在 WR 的上升沿，使数据写入到 SSD1306 里面；  \r\n* ![image-20210825002019308](cloudDisk/markdown/stm32笔记.assets/image-20210825002019308.png)\r\n* ![image-20210825002054878](cloudDisk/markdown/stm32笔记.assets/image-20210825002054878.png)\r\n* ![image-20210825002106140](cloudDisk/markdown/stm32笔记.assets/image-20210825002106140.png)\r\n\r\n## 2. 4 线串行（SPI）方式  \r\n\r\n* 4 先串口模式使用的信号线有如下几条：  \r\n\r\n  CS： OLED 片选信号。\r\n  RST(RES)：硬复位 OLED。\r\n  DC（RS）：命令/数据标志（0，读写命令； 1，读写数据）。\r\n  SCLK（SDA）：串行时钟线。在 4 线串行模式下， D0 信号线作为串行时钟线 SCLK。\r\n  SDIN：串行数据线。在 4 线串行模式下， D1 信号线作为串行数据线 SDIN。\r\n  模块的 D2 需要悬空，其他引脚可以接到 GND。在 4 线串行模式下，只能往模块写数据而不能读数据。  \r\n\r\n* 在 4 线 SPI 模式下，每个数据长度均为 8 位，在 SCLK 的上升沿，数据从 SDIN 移入到\r\n  SSD1306，并且是高位在前的。 DC 线还是用作命令/数据的标志线。在 4 线 SPI 模式下，写操\r\n  作的时序如图 17.1.6 所示：  \r\n\r\n![image-20210825002342264](cloudDisk/markdown/stm32笔记.assets/image-20210825002342264.png)\r\n\r\n## 3. 模块的显存  \r\n\r\n![image-20210825002413811](cloudDisk/markdown/stm32笔记.assets/image-20210825002413811.png)\r\n\r\n* SSD1306 的每页包含了 128 个字节，总共 8 页，这样刚好是 128*64 的点阵大小。  \r\n\r\n* STM32 的内部建立一个 OLED 的 GRAM（共 128*8 个字节），在每次修改的时候，只是修改 STM32 上的 GRAM（实际上就是 SRAM），在修改完了之后，一次性把 STM32 上的 GRAM 写入到 OLED 的 GRAM。  \r\n\r\n## 4. SSD1306命令\r\n\r\n![image-20210825002644378](cloudDisk/markdown/stm32笔记.assets/image-20210825002644378.png)\r\n\r\n* 第一个命令为 0X81，用于设置对比度的，这个命令包含了两个字节，第一个 0X81 为命令，随后发	送的一个字节为要设置的对比度的值。这个值设置得越大屏幕就越亮。\r\n* 第二个命令为 0XAE/0XAF。 0XAE 为关闭显示命令； 0XAF 为开启显示命令。\r\n* 第三个命令为 0X8D，该指令也包含 2 个字节，第一个为命令字，第二个为设置值，第二个字节的 	BIT2 表示电荷泵的开关状态，该位为 1，则开启电荷泵，为 0 则关闭。在模块初始化的时候，这	个必须要开启，否则是看不到屏幕显示的。\r\n* 第四个命令为 0XB0~B7，该命令用于设置页地址，其低三位的值对应着 GRAM 的页地址。  \r\n* 第五个指令为 0X00~0X0F，该指令用于设置显示时的起始列地址低四位。\r\n* 第六个指令为 0X10~0X1F，该指令用于设置显示时的起始列地址高四位。\r\n* 其他命令，我们就不在这里一一介绍了，大家可以参考 SSD1306 datasheet 的第 28 页。从\r\n  这页开始，对 SSD1306 的指令有详细的介绍。  \r\n\r\n## 5. OLED 模块的初始化过程  \r\n\r\n![image-20210825002814338](cloudDisk/markdown/stm32笔记.assets/image-20210825002814338.png)\r\n\r\n驱动 IC 的初始化代码，我们直接使用厂家推荐的设置就可以了，只要对细节部分进行一些\r\n修改，使其满足我们自己的要求即可，其他不需要变动。  \r\n\r\n* OLED 显示需要的相关设置步骤如下：  \r\n\r\n  ##### 1） 设置 STM32 与 OLED 模块相连接的 IO。\r\n\r\n  这一步，先将我们与 OLED 模块相连的 IO 口设置为输出，具体使用哪些 IO 口，这里需要\r\n  根据连接电路以及 OLED 模块所设置的通讯模式来确定。这些将在硬件设计部分向大家介绍。\r\n\r\n  ##### 2） 初始化 OLED 模块。\r\n\r\n  其实这里就是上面的初始化框图的内容，通过对 OLED 相关寄存器的初始化，来启动 OLED\r\n  的显示。为后续显示字符和数字做准备。\r\n\r\n  ##### 3） 通过函数将字符和数字显示到 OLED 模块上。\r\n\r\n  这里就是通过我们设计的程序，将要显示的字符送到 OLED 模块就可以了，这些函数将在\r\n  软件设计部分向大家介绍。\r\n  通过以上三步，我们就可以使用 ALIENTEK OLED 模块来显示字符和数字了，在后面我们\r\n  还将会给大家介绍显示汉字的方法。这一部分就先介绍到这里。  \r\n\r\n## 6. 硬件设计\r\n\r\n* GND：电源地\r\n* VCC：2.2V~5.5V\r\n\r\n* SCL（D0）：CLK 时钟 （高电平 2.2V~5.5V）\r\n  * \\#define OLED_SCLK PCout(0) // SCL（D0）：CLK 时钟\r\n* SDA(D1)：MOSI 数据（高电平 2.2V~5.5V）\r\n  * \\#define OLED_SDIN PCout(1) // SDA(D1)：MOSI 数据\r\n* RST：复位（高电平 2.2V~5.5V）\r\n  * \\#define OLED_RST PGout(15) // 复位\r\n* D/C：数据/命令（高电平 2.2V~5.5V）  \r\n  * \\#define OLED_RS PDout(3)  // 数据/命令\r\n\r\n![image-20210825003542773](cloudDisk/markdown/stm32笔记.assets/image-20210825003542773.png)\r\n\r\n## 7. 软件设计\r\n\r\n函数中心思想：\r\n\r\n1. 初始化\r\n2. 把oled的8页映射为绝对坐标（x,y）\r\n3. 写一个将点颜色填充的函数，衍生到字符显示，字符串显示，图片显示\r\n4. 写一个函数：将stm32内部的OLED_GRAM  刷新至 oled的GRAM \r\n\r\n### 1) OLED_Init 函数\r\n\r\n* oled.c 的代码，由于比较长，这里我们就不贴出来了，仅介绍几个比较重要的函数。首先\r\n  是 OLED_Init 函数，该函数的结构比较简单，开始是对 IO 口的初始化，这里我们用了宏定义\r\n  OLED_MODE 来决定要设置的 IO 口，其他就是一些初始化序列了，我们按照厂家提供的资料\r\n  来做就可以。最后要说明一点的是，因为 OLED 是无背光的，在初始化之后，我们把显存都清\r\n  空了，所以我们在屏幕上是看不到任何内容的，跟没通电一个样，不要以为这就是初始化失败，要写入数据模块才会显示的。 OLED_Init 函数代码如下：  \r\n\r\n```c\r\n//初始化SSD1306					    \r\nvoid OLED_Init(void)\r\n{ 	\r\n \r\n 	GPIO_InitTypeDef  GPIO_InitStructure;\r\n 	\r\n 	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOC|RCC_APB2Periph_GPIOD|RCC_APB2Periph_GPIOG, ENABLE);	 //使能PC,D,G端口时钟\r\n\r\n	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_3|GPIO_Pin_6;	 //PD3,PD6推挽输出  \r\n 	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP; 		 //推挽输出\r\n	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;//速度50MHz\r\n 	GPIO_Init(GPIOD, &GPIO_InitStructure);	  //初始化GPIOD3,6\r\n 	GPIO_SetBits(GPIOD,GPIO_Pin_3|GPIO_Pin_6);	//PD3,PD6 输出高\r\n\r\n #if OLED_MODE==1\r\n \r\n 	GPIO_InitStructure.GPIO_Pin =0xFF; //PC0~7 OUT推挽输出\r\n 	GPIO_Init(GPIOC, &GPIO_InitStructure);\r\n 	GPIO_SetBits(GPIOC,0xFF); //PC0~7输出高\r\n\r\n 	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_13|GPIO_Pin_14|GPIO_Pin_15;				 //PG13,14,15 OUT推挽输出\r\n 	GPIO_Init(GPIOG, &GPIO_InitStructure);\r\n 	GPIO_SetBits(GPIOG,GPIO_Pin_13|GPIO_Pin_14|GPIO_Pin_15);						 //PG13,14,15 OUT  输出高\r\n\r\n #else\r\n 	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0|GPIO_Pin_1;				 //PC0,1 OUT推挽输出\r\n 	GPIO_Init(GPIOC, &GPIO_InitStructure);\r\n 	GPIO_SetBits(GPIOC,GPIO_Pin_0|GPIO_Pin_1);						 //PC0,1 OUT  输出高\r\n\r\n	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_15;				 //PG15 OUT推挽输出	  RST\r\n 	GPIO_Init(GPIOG, &GPIO_InitStructure);\r\n 	GPIO_SetBits(GPIOG,GPIO_Pin_15);						 //PG15 OUT  输出高\r\n\r\n\r\n #endif\r\n  							  \r\n	OLED_CS=1;\r\n	OLED_RS=1;	 \r\n	\r\n	OLED_RST=0;\r\n	delay_ms(100);\r\n	OLED_RST=1; \r\n					  \r\n	OLED_WR_Byte(0xAE,OLED_CMD); //关闭显示\r\n	OLED_WR_Byte(0xD5,OLED_CMD); //设置时钟分频因子,震荡频率\r\n	OLED_WR_Byte(80,OLED_CMD);   //[3:0],分频因子;[7:4],震荡频率\r\n	OLED_WR_Byte(0xA8,OLED_CMD); //设置驱动路数\r\n	OLED_WR_Byte(0X3F,OLED_CMD); //默认0X3F(1/64) \r\n	OLED_WR_Byte(0xD3,OLED_CMD); //设置显示偏移\r\n	OLED_WR_Byte(0X00,OLED_CMD); //默认为0\r\n\r\n	OLED_WR_Byte(0x40,OLED_CMD); //设置显示开始行 [5:0],行数.\r\n													    \r\n	OLED_WR_Byte(0x8D,OLED_CMD); //电荷泵设置\r\n	OLED_WR_Byte(0x14,OLED_CMD); //bit2，开启/关闭\r\n	OLED_WR_Byte(0x20,OLED_CMD); //设置内存地址模式\r\n	OLED_WR_Byte(0x02,OLED_CMD); //[1:0],00，列地址模式;01，行地址模式;10,页地址模式;默认10;\r\n	OLED_WR_Byte(0xA1,OLED_CMD); //段重定义设置,bit0:0,0->0;1,0->127;\r\n	OLED_WR_Byte(0xC0,OLED_CMD); //设置COM扫描方向;bit3:0,普通模式;1,重定义模式 COM[N-1]->COM0;N:驱动路数\r\n	OLED_WR_Byte(0xDA,OLED_CMD); //设置COM硬件引脚配置\r\n	OLED_WR_Byte(0x12,OLED_CMD); //[5:4]配置\r\n		 \r\n	OLED_WR_Byte(0x81,OLED_CMD); //对比度设置\r\n	OLED_WR_Byte(0xEF,OLED_CMD); //1~255;默认0X7F (亮度设置,越大越亮)\r\n	OLED_WR_Byte(0xD9,OLED_CMD); //设置预充电周期\r\n	OLED_WR_Byte(0xf1,OLED_CMD); //[3:0],PHASE 1;[7:4],PHASE 2;\r\n	OLED_WR_Byte(0xDB,OLED_CMD); //设置VCOMH 电压倍率\r\n	OLED_WR_Byte(0x30,OLED_CMD); //[6:4] 000,0.65*vcc;001,0.77*vcc;011,0.83*vcc;\r\n\r\n	OLED_WR_Byte(0xA4,OLED_CMD); //全局显示开启;bit0:1,开启;0,关闭;(白屏/黑屏)\r\n	OLED_WR_Byte(0xA6,OLED_CMD); //设置显示方式;bit0:1,反相显示;0,正常显示	    						   \r\n	OLED_WR_Byte(0xAF,OLED_CMD); //开启显示	 \r\n	OLED_Clear();\r\n}  \r\n```\r\n\r\n### 2) OLED_Refresh_Gram 函数  \r\n\r\n我们在 STM32 内部定义了一个块 GRAM：u8 OLED_GRAM[128][8];此部分 GRAM 对应 OLED 模块上的 GRAM。在操作的时候，我们只要修改 STM32 内部的 GRAM 就可以了，然后通过OLED_Refresh_Gram 函数把 GRAM 一次刷新到 OLED 的 GRAM 上。该函数代码如下： \r\n\r\n```c\r\n//更新显存到LCD		 \r\nvoid OLED_Refresh_Gram(void)\r\n{\r\n	u8 i,n;		    \r\n	for(i=0;i<8;i++)  \r\n	{  \r\n		OLED_WR_Byte (0xb0+i,OLED_CMD);    //设置页地址（0~7）\r\n		OLED_WR_Byte (0x00,OLED_CMD);      //设置显示位置—列低地址\r\n		OLED_WR_Byte (0x10,OLED_CMD);      //设置显示位置—列高地址   \r\n		for(n=0;n<128;n++)OLED_WR_Byte(OLED_GRAM[n][i],OLED_DATA); // 写128字节\r\n	}   \r\n}\r\n```\r\n\r\n* OLED_Refresh_Gram 函数先设置页地址，然后写入列地址（也就是纵坐标），然后从 0 开始写入 128 个字节，写满该页，最后循环把 8 页的内容都写入，就实现了整个从 STM32 显存到 OLED 显存的拷贝。  \r\n\r\n* OLED_Refresh_Gram 函数还用到了一个外部函数，也就是我们接着要介绍的函数：\r\n  OLED_WR_Byte，该函数直接和硬件相关，函数代码如下：  \r\n\r\n```c\r\n#if OLED_MODE==1	//8080并口 \r\n//向SSD1306写入一个字节。\r\n//dat:要写入的数据/命令\r\n//cmd:数据/命令标志 0,表示命令;1,表示数据;\r\nvoid OLED_WR_Byte(u8 dat,u8 cmd)\r\n{\r\n	DATAOUT(dat);	    \r\n 	OLED_RS=cmd;\r\n	OLED_CS=0;	   \r\n	OLED_WR=0;	 \r\n	OLED_WR=1;\r\n	OLED_CS=1;	  \r\n	OLED_RS=1;	 \r\n} 	    	    \r\n#else\r\n//向SSD1306写入一个字节。\r\n//dat:要写入的数据/命令\r\n//cmd:数据/命令标志 0,表示命令;1,表示数据;\r\nvoid OLED_WR_Byte(u8 dat,u8 cmd)\r\n{	\r\n	u8 i;			  \r\n	OLED_RS=cmd; //写命令 \r\n	OLED_CS=0;		  \r\n	for(i=0;i<8;i++)\r\n	{			  \r\n		OLED_SCLK=0;\r\n		if(dat&0x80)OLED_SDIN=1;\r\n		else OLED_SDIN=0;\r\n		OLED_SCLK=1;\r\n		dat<<=1;   \r\n	}				 \r\n	OLED_CS=1;		  \r\n	OLED_RS=1;   	  \r\n} \r\n#endif\r\n```\r\n\r\n* 这里有 2 个一样的函数 ，通过宏定义 OLED_MODE 来决定使用哪一个。\r\n* 如果OLED_MODE=1，就定义为并口模式，选择第一个函数，\r\n* 而如果为 0，则为 4 线串口模式，选择第二个函数。\r\n* 这两个函数输入参数均为 2 个： dat 和 cmd， \r\n  * dat 为要写入的数据， \r\n  * cmd 则表明该数据是命令还是数据。\r\n\r\n\r\n\r\n```c\r\nfor(n=0;n<128;n++)\r\n    OLED_WR_Byte(OLED_GRAM[n][i],OLED_DATA); // 写128字节\r\n```\r\n\r\n* OLED_GRAM\\[128][8]中的 128 代表列数（x 坐标），而 8 代表的是页， 每页又包含 8 行，\r\n  总共 64 行（y 坐标）。  \r\n* 比如，我们要在 x=100， y=29 这个点写入1，则可以用这个句子实现：  \r\n  * OLED_GRAM\\[100][4]|=1<<2；  \r\n* 一个通用的在点（x， y）置 1 表达式为：  \r\n  * OLED_GRAM\\[x][7-y/8]|=1<<(7-y%8)；  \r\n  * 其中 x 的范围为： 0~127； y 的范围为： 0~63。  \r\n\r\n### 3) 画点函数， void OLED_DrawPoint(u8 x， u8 y，u8 t)；  \r\n\r\n```c\r\n//画点 \r\n//x:0~127\r\n//y:0~63\r\n//t:1 填充 0,清空				   \r\nvoid OLED_DrawPoint(u8 x,u8 y,u8 t)\r\n{\r\n	u8 pos,bx,temp=0;\r\n	if(x>127||y>63)return;//超出范围了.\r\n	pos=7-y/8;\r\n	bx=y%8;\r\n	temp=1<<(7-bx);\r\n	if(t)OLED_GRAM[x][pos]|=temp;\r\n	else OLED_GRAM[x][pos]&=~temp;	    \r\n}\r\n```\r\n\r\n该函数有 3 个参数，前两个是坐标，第三个 t 为要写入 1 还是 0。该函数实现了我们在 OLED\r\n模块上任意位置画点的功能。  \r\n\r\n### 4）显示字符函数 ，OLED_ShowChar  \r\n\r\n* 我们先要得到这个字符集的点阵数据，这里我们介绍一个款很好的字符提取软件：\r\n  PCtoLCD2002 完美版。  \r\n* ![image-20210825005904470](cloudDisk/markdown/stm32笔记.assets/image-20210825005904470.png)\r\n* ![image-20210825005913884](cloudDisk/markdown/stm32笔记.assets/image-20210825005913884.png)\r\n* 从第一列开始向下每取 8 个点作为一个字节，如果最后不足 8 个点就补满 8 位。取模顺序是从高到低，即第一个点作为最高位。如*-------取为 10000000。  \r\n\r\n* 从上到下，从左到右，高位在前。我们按这样的取模方式，然后把 ASCII 字符集按 12\\*6\r\n  大小和 16\\*0 大小取模出来（对应汉字大小为 12\\*12 和 16\\*16，字符的只有汉字的一半大！），保存在 oledfont.h 里面，每个 12\\*6 的字符占用 12 个字节，每个 16\\*8 的字符占用 16 个字节。具体见 oledfont.h 部分代码  \r\n\r\n```c\r\n//在指定位置显示一个字符,包括部分字符\r\n//x:0~127\r\n//y:0~63\r\n//mode:0,反白显示;1,正常显示				 \r\n//size:选择字体 12/16/24\r\nvoid OLED_ShowChar(u8 x,u8 y,u8 chr,u8 size,u8 mode)\r\n{      			    \r\n	u8 temp,t,t1;\r\n	u8 y0=y;\r\n	u8 csize=(size/8+((size%8)?1:0))*(size/2);		//得到字体一个字符对应点阵集所占的字节数\r\n	chr=chr-\' \';//得到偏移后的值		 \r\n    for(t=0;t<csize;t++)\r\n    {   \r\n		if(size==12)temp=asc2_1206[chr][t]; 	 	//调用1206字体\r\n		else if(size==16)temp=asc2_1608[chr][t];	//调用1608字体\r\n		else if(size==24)temp=asc2_2412[chr][t];	//调用2412字体\r\n		else return;								//没有的字库\r\n        for(t1=0;t1<8;t1++)\r\n		{\r\n			if(temp&0x80)OLED_DrawPoint(x,y,mode);\r\n			else OLED_DrawPoint(x,y,!mode);\r\n			temp<<=1;\r\n			y++;\r\n			if((y-y0)==size)\r\n			{\r\n				y=y0;\r\n				x++;\r\n				break;\r\n			}\r\n		}  	 \r\n    }          \r\n}\r\n```\r\n\r\n* 该函数为字符以及字符串显示的核心部分，函数中 chr=chr-\' \';这句是要得到在字符点阵数\r\n  据里面的实际地址，因为我们的取模是从空格键开始的，例如 oled_asc2_1206\\[0][0]，代表的是\r\n  空格符开始的点阵码。在接下来的代码，我们也是按照从上到小，从左到右的取模方式来编写\r\n  的，先得到最高位，然后判断是写 1 还是 0，画点；接着读第二位，如此循环，直到一个字符\r\n  的点阵全部取完为止。这其中涉及到列地址和行地址的自增，根据取模方式来理解，就不难了。  \r\n\r\n### 5) oled.h 的关键代码:  \r\n\r\n```c\r\n#ifndef __OLED_H\r\n#define __OLED_H			  	 \r\n#include \"sys.h\"\r\n#include \"stdlib.h\"	    \r\n//驱动方式:8080并口/4线串口\r\n\r\n//OLED模式设置\r\n//0: 4线串行模式  （模块的BS1，BS2均接GND）\r\n//1: 并行8080模式 （模块的BS1，BS2均接VCC）\r\n#define OLED_MODE 	0 \r\n		    						  \r\n//---------------------------OLED端口定义--------------------------  					   \r\n#define OLED_CS  PDout(6)\r\n#define OLED_RST PGout(15) 	// 复位\r\n#define OLED_RS  PDout(3)   // 数据/命令\r\n#define OLED_WR  PGout(14)		  \r\n#define OLED_RD  PGout(13)	   \r\n//PC0~7,作为数据线\r\n\r\n#define DATAOUT(x) GPIO_Write(GPIOC,x);//输出  \r\n  \r\n//使用4线串行接口时使用 \r\n#define OLED_SCLK PCout(0)  // SCL（D0）：CLK 时钟\r\n#define OLED_SDIN PCout(1)  // SDA(D1)：MOSI 数据\r\n		     \r\n#define OLED_CMD  0	//写命令\r\n#define OLED_DATA 1	//写数据\r\n//OLED控制用函数\r\nvoid OLED_WR_Byte(u8 dat,u8 cmd);	    \r\nvoid OLED_Display_On(void);\r\nvoid OLED_Display_Off(void);\r\nvoid OLED_Refresh_Gram(void);  		    \r\nvoid OLED_Init(void);\r\nvoid OLED_Clear(void);\r\nvoid OLED_DrawPoint(u8 x,u8 y,u8 t);\r\nvoid OLED_Fill(u8 x1,u8 y1,u8 x2,u8 y2,u8 dot);\r\nvoid OLED_ShowChar(u8 x,u8 y,u8 chr,u8 size,u8 mode);\r\nvoid OLED_ShowNum(u8 x,u8 y,u32 num,u8 len,u8 size);\r\nvoid OLED_ShowString(u8 x,u8 y,const u8 *p,u8 size);	 \r\n#endif  \r\n```\r\n\r\n## 8. 显示中文\r\n\r\n### 中文字取模\r\n\r\n![image-20211031172657494](cloudDisk/markdown/stm32笔记.assets/image-20211031172657494.png)\r\n\r\n\r\n\r\n![image-20211031172706305](cloudDisk/markdown/stm32笔记.assets/image-20211031172706305.png)\r\n\r\n![image-20211031172713072](cloudDisk/markdown/stm32笔记.assets/image-20211031172713072.png)\r\n\r\n### 新建一个.h文件，存汉字\r\n\r\n![image-20211031172759152](cloudDisk/markdown/stm32笔记.assets/image-20211031172759152.png)\r\n\r\n* 注意：\r\n  * 取模生成的数据，格式修改成上图那样\r\n\r\n### 显示汉字函数\r\n\r\n```c\r\nvoid show_byte(u8 x ,u8 y ,u8 byte){\r\n		OLED_DrawPoint(x,7+y,byte&0x80);\r\n		OLED_DrawPoint(x,6+y,byte&0x40);\r\n		OLED_DrawPoint(x,5+y,byte&0x20);\r\n		OLED_DrawPoint(x,4+y,byte&0x10);\r\n		OLED_DrawPoint(x,3+y,byte&0x08);\r\n		OLED_DrawPoint(x,2+y,byte&0x04);\r\n		OLED_DrawPoint(x,1+y,byte&0x02);\r\n		OLED_DrawPoint(x,0+y,byte&0x01);\r\n}\r\n/*\r\n	一个字符占 16*16 像素点\r\n*/\r\nvoid show_str(u8 x, u8 y, u8 str[]){\r\n	u8 i,j;\r\n	j = y;\r\n	for(i=0; i<16; i++){\r\n		show_byte(x+i,j,str[i]);\r\n	}\r\n	j += 8;\r\n	for(i=0; i<16; i++){\r\n		show_byte(x+i,j,str[i+16]);\r\n	}\r\n}\r\n```\r\n\r\n### 主函数\r\n\r\n```c\r\n	OLED_Init();\r\n\r\n	show_str(0,0,str1);\r\n	show_str(16,0,str2);\r\n	show_str(32,0,str3);\r\n	show_str(48,0,str4);\r\n	OLED_Refresh_Gram();\r\n```\r\n\r\n## 9. 显示图片\r\n\r\n![image-20211031194611557](cloudDisk/markdown/stm32笔记.assets/image-20211031194611557.png)\r\n\r\n![image-20211031194641246](cloudDisk/markdown/stm32笔记.assets/image-20211031194641246.png)\r\n\r\n\r\n\r\n```c\r\n/*\r\n	x,y 左上坐标\r\n	px,py 图片尺寸，单位：像素\r\n	index：nfc_bitmap数组的索引	\r\n	\r\n*/\r\nvoid OLED_ShowBMP(u8 x, u8 y, u8 px, u8 py, u8 index, u8 mode)\r\n{\r\n    u8 temp,t1;\r\n    u16 j,i;\r\n    u8 y0=y;\r\n    \r\n    i = (px/2)*(py/4);\r\n \r\n    for(j = 0; j < i;j++)\r\n    {\r\n        temp = nfc_bitmap[index][j];    //????                          \r\n        for(t1=0;t1<8;t1++)\r\n        {\r\n            if(temp&0x80)OLED_DrawPoint(x,y,mode);\r\n            else OLED_DrawPoint(x,y,!mode);\r\n            temp<<= 1;\r\n            y++;\r\n            if((y-y0) == py)\r\n            {\r\n                y=y0;\r\n                x++;\r\n                break;\r\n            }\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n\r\n\r\n# 十二、TFTLCD 显示实验  P253\r\n\r\n![image-20210826222207685](cloudDisk/markdown/stm32笔记.assets/image-20210826222207685.png)\r\n\r\n* 该模块的 80 并口有如下一些信号线：\r\n  CS： TFTLCD 片选信号。\r\n\r\n  WR：向 TFTLCD 写入数据。\r\n\r\n  RD：从 TFTLCD 读取数据。\r\n\r\n  D[15： 0]： 16 位双向数据线。\r\n\r\n  RST：硬复位 TFTLCD。  \r\n\r\n  RS：命令/数据标志（ 0，读写命令； 1，读写数据）  \r\n\r\n  * TFTLCD模块的 RST 信号线是直接接到 STM32 的复位脚上，并不由软件控制，这样可以省下来一个 IO\r\n    口  \r\n  * 另外我们还需要一个背光控制线来控制 TFTLCD 的背光  \r\n  * 总共需要的 IO 口数目为 21 个  \r\n\r\n## 1. ILI9341 控制器介绍\r\n\r\n![image-20210905183559894](cloudDisk/markdown/stm32笔记.assets/image-20210905183559894.png)\r\n\r\nILI9341 在 16 位模式下面，数据线有用的是： D17~D13 和 D11~D1， D0和 D12 没有用到，实际上在我们 LCD 模块里面， ILI9341 的 D0 和 D12 压根就没有引出来，这样， ILI9341 的 D17~D13 和 D11~D1 对应 MCU 的 D15~D0。\r\n\r\nMCU 的 16 位数据， 最低 5 位代表蓝色，中间 6 位为绿色，最高 5 位为红色。**数值越大，表示该颜色越深**。 另外，特别注意 ILI9341 所有的**指令都是 8 位的（高 8 位无效）**，且**参数除了读写 GRAM 的时候是 16 位，其他操作参数，都是 8 位的**。\r\n\r\n## 2. ILI9341 的重要命令\r\n\r\n### （1）**0XD3**\r\n\r\n这个是读 ID4 指令，用于读取 LCD 控制器的 ID\r\n\r\n![image-20210905183804902](cloudDisk/markdown/stm32笔记.assets/image-20210905183804902.png)\r\n\r\n可以看出， 0XD3 指令后面跟了 4 个参数，最后 2 个参数，读出来是 0X93 和 0X41，刚好是控制器 ILI9341 的数字部分，从而，通过该指令，即可判别所用的 LCD 驱动器是什么型号，这样，我们的代码，就可以根据控制器的型号去执行对应驱动 IC 的初始化代码，从而兼容不同驱动 IC 的屏，使得一个代码支持多款 LCD。\r\n\r\n### （2）**0X36**\r\n\r\n这是存储访问控制指令，可以控制 ILI9341 存储器的读写方向，简单的说，就是在连续写 GRAM 的时候，可以控制 GRAM 指针的增长方向，从而控制显示方式。（读 GRAM 也是一样）。该指令如表：\r\n\r\n![image-20210905183917334](cloudDisk/markdown/stm32笔记.assets/image-20210905183917334.png)\r\n\r\n0X36 指令后面，紧跟一个参数，主要关注： MY、 MX、 MV 这三个位，通过这三个位的设置，可以控制整个 ILI9341 的全部扫描方向。\r\n\r\n![image-20210905183950428](cloudDisk/markdown/stm32笔记.assets/image-20210905183950428.png)\r\n\r\n在利用 ILI9341 显示内容的时候，就有很大灵活性了，比如显示 BMP 图片，BMP 解码数据，就是从图片的左下角开始，慢慢显示到右上角，如果设置 LCD 扫描方向为从左到右，从下到上，那么我们只需要设置一次坐标，然后就不停的往 LCD 填充颜色数据即可，这样可以大大提高显示速度。\r\n\r\n### （3）**0X2A**\r\n\r\n这是列地址设置指令， 在从左到右，从上到下的扫描方式（默认）下面，该指令用于设置横坐标（ x 坐标），该指令如表 ：\r\n\r\n![image-20210905184107150](cloudDisk/markdown/stm32笔记.assets/image-20210905184107150.png)\r\n\r\n在默认扫描方式时，该指令用于设置 x 坐标，该指令带有 4 个参数，实际上是 2 个坐标值：SC 和 EC，即列地址的起始值和结束值， SC 必须小于等于 EC，且 0≤SC/EC≤239。一般在设置 x 坐标的时候，我们只需要带 2 个参数即可，也就是设置 SC 即可，因为如果 EC 没有变化，我们只需要设置一次即可（在初始化 ILI9341 的时候设置），从而提高速度。\r\n\r\n### （4）**0X2B**\r\n\r\n是页地址设置指令， 在从左到右，从上到下的扫描方（默认）下面，该指令用于设置纵坐标（ y 坐标）。该指令如表\r\n\r\n![image-20210905184510683](cloudDisk/markdown/stm32笔记.assets/image-20210905184510683.png)\r\n\r\n在默认扫描方式时，该指令用于设置 y 坐标，该指令带有 4 个参数，实际上是 2 个坐标值：SP 和 EP，即页地址的起始值和结束值， SP 必须小于等于 EP，且 0≤SP/EP≤319。一般在设置y 坐标的时候，我们只需要带 2 个参数即可，也就是设置 SP 即可，因为如果 EP 没有变化，我们只需要设置一次即可（在初始化 ILI9341 的时候设置），从而提高速度。\r\n\r\n### （5）**0X2C**\r\n\r\n该指令是写 GRAM 指令，在发送该指令之后，我们便可以往 LCD的 GRAM 里面写入颜色数据了，该指令支持连续写，指令描述如表：\r\n\r\n![image-20210905184632948](cloudDisk/markdown/stm32笔记.assets/image-20210905184632948.png)\r\n\r\n在收到指令 0X2C 之后，数据有效位宽变为 16 位，我们可以连续写入 LCD GRAM 值， 而 GRAM 的地址将根据 MY/MX/MV 设置的扫描方向进行自增。\r\n\r\n### （6）**0X2E**\r\n\r\n该指令是读 GRAM 指令，用于读取 ILI9341 的显存（ GRAM），输出情况如表：\r\n\r\n![image-20210905184759379](cloudDisk/markdown/stm32笔记.assets/image-20210905184759379.png)\r\n\r\n该指令用于读取 GRAM，如表 所示，ILI9341在收到该指令后，第一次输出的是 dummy数据，也就是无效的数据，第二次开始，读取到的才是有效的 GRAM 数据（从坐标： SC， SP开始），输出规律为：每个颜色分量占 8 个位，一次输出 2 个颜色分量。\r\n\r\n比如：\r\n\r\n第一次输出是R1G1，随后的规律为：B1R2G2B2R3G3B3R4G4B4R5G5… 以此类推。如果我们只需要读取一个点的颜色值，那么只需要接收到参数 3（参数1、参数2、参数3） 即可，如果要连续读取（利用 GRAM 地址自增），那么就按照上述规律去接收颜色数据。\r\n\r\n## 3.TFTLCD 模块的使用流程\r\n\r\n![image-20210905185022949](cloudDisk/markdown/stm32笔记.assets/image-20210905185022949.png)\r\n\r\n任何 LCD，使用流程都可以简单的用以上流程图表示。其中硬复位和初始化序列，只需要执行一次即可。而画点流程就是：设置坐标 -> 写 GRAM 指令 -> 写入颜色数据，然后在 LCD 上面，我们就可以看到对应的点显示我们写入的颜色了。读点流程为：设置坐标 -> 读 GRAM 指令 -> 读取颜色数据，这样就可以获取到对应点的颜色数据了。\r\n\r\n### 1） 设置 STM32 与 TFTLCD 模块相连接的 IO。\r\n\r\n先将我们与 TFTLCD 模块相连的 IO 口进行初始化，以便驱动 LCD。 这里需要根据连接电路以及 TFTLCD 模块的设置来确定。\r\n\r\n### 2） 初始化 TFTLCD 模块。\r\n\r\n即上图的初始化序列，这里我们没有硬复位 LCD，因为 MiniSTM32 开发板的 LCD 接口，将 TFTLCD 的 RST 同 STM32 的 RESET 连接在一起了，只要按下开发板的 RESET 键，就会对 LCD 进行硬复位。\r\n\r\n初始化序列，就是向 LCD 控制器写入一系列的设置值（比如伽马校准），这些初始化序列一般 LCD 供应商会提供给客户，我们直接使用这些序列即可，不需要深入研究。在初始化之后， LCD 才可以正常使用。\r\n\r\n### 3） 通过函数将字符和数字显示到 TFTLCD 模块上。\r\n\r\n这一步则通过上图 左侧的流程，即：设置坐标->写 GRAM 指令->写 GRAM 来实现，但是这个步骤，只是一个点的处理，我们要显示字符/数字，就必须要多次使用这个步骤，从而达到显示字符/数字的目标，所以需要设计一个函数来实现数字/字符的显示，之后调用该函数，就可以实现数字/字符的显示了。\r\n\r\n## 4. FSMC - 灵活的静态存储控制器\r\n\r\n* **stm32液晶显示为什么要和FSMC相连接？**\r\n\r\n  液晶显示就是将内存映射的数据一个一个的送到液晶屏里面FSMC只是ST的一种存储链接方式而已。\r\n  用FSMC 相当于DMA，换句话说即使没有FSMC 也可以用内存连LCD的。FSMC主要优势是减少CPU负担。特别是静态图片的时候，CPU完全不需要管。\r\n\r\n1）简介\r\n\r\nFSMC，即灵活的静态存储控制器，能够与同步或异步存储器和 16 位 PC 存储器卡连接，\r\nSTM32 的 FSMC 接口支持包括 SRAM、 NAND FLASH、 NOR FLASH 和 PSRAM 等存储器。  \r\n\r\n![image-20210907212140427](cloudDisk/markdown/stm32笔记.assets/image-20210907212140427.png)\r\n\r\n\r\n\r\n这里我们介绍下为什么可以把 TFTLCD 当成 SRAM 设备用：  首先我们了解下外部 SRAM的连接，外部 SRAM 的控制一般有：地址线（如 A0~A18）、数据线（如 D0~D15）、写信号（WE）、读信号（OE）、片选信号（CS），如果 SRAM 支持字节控制，那么还有 UB/LB 信号。而 TFTLCD的信号我们在 18.1.1 节有介绍，包括： RS、 D0~D15、 WR、 RD、 CS、 RST 和 BL 等，其中真正在操作 LCD 的时候需要用到的就只有： RS、 D0~D15、 WR、 RD 和 CS。其操作时序和 SRAM的控制完全类似，唯一不同就是 TFTLCD 有 RS 信号，但是没有地址信号。  \r\n\r\nTFTLCD 通过 RS 信号来决定传送的数据是数据还是命令，本质上可以理解为一个地址信号， 比如我们把 RS 接在 A0 上面，那么当 FSMC 控制器写地址 0 的时候，会使得 A0 变为 0， 对 TFTLCD 来说，就是写命令。而 FSMC 写地址 1 的时候， A0 将会变为 1，对 TFTLCD 来说，就是写数据了。这样，就把数据和命令区分开了，他们其实就是对应 SRAM 操作的两个连续地址。当然 RS 也可以接在其他地址线上， 精英 STM32 开发板是把 RS 连接在 A10 上面的。   \r\n\r\nSTM32 的 FSMC 支持 8/16/32 位数据宽度，我们这里用到的 LCD 是 16 位宽度的，所以在设置的时候，选择 16 位宽就 OK 了。我们再来看看 FSMC 的外部设备地址映像， STM32 的 FSMC将外部存储器划分为固定大小为 256M 字节的四个存储块，如图 18.1.2.2 所示：  \r\n\r\n![image-20210907212544181](cloudDisk/markdown/stm32笔记.assets/image-20210907212544181.png)\r\n\r\nSTM32 的 FSMC 存储块 1（Bank1）被分为 4 个区，每个区管理 64M 字节空间，每个区都\r\n有独立的寄存器对所连接的存储器进行配置。 Bank1 的 256M 字节空间由 28 根地址线\r\n（HADDR[27:0]）寻址。  \r\n\r\n这 里 HADDR 是内 部 AHB 地址总 线 ，其 中 HADDR[25:0]来自外部存储器地址FSMC_A[25:0]，而 HADDR[26:27]对 4 个区进行寻址。如表 18.1.2.1 所示：  \r\n\r\n![image-20210907213800323](cloudDisk/markdown/stm32笔记.assets/image-20210907213800323.png)\r\n\r\n* 我们要特别注意 HADDR[25:0]的对应关系：  \r\n\r\n  当 Bank1 接的是 16 位宽度存储器的时候： HADDR[25:1]→ FSMC_A[24:0]。\r\n  当 Bank1 接的是 8 位宽度存储器的时候： HADDR[25:0]→ FSMC_A[25:0]。  \r\n\r\n**不论外部接 8 位/16 位宽设备， FSMC_A[0]永远接在外部设备地址 A[0]。** 这里， TFTLCD\r\n使用的是 16 位数据宽度，所以 HADDR[0]并没有用到，只有 HADDR[25:1]是有效的，对应关\r\n系变为： HADDR[25:1]→ FSMC_A[24:0]，相当于右移了一位，这里请大家特别留意。另外，\r\nHADDR[27:26]的设置，是不需要我们干预的，比如：当你选择使用 Bank1 的第三个区，即使\r\n用 FSMC_NE3 来连接外部设备的时候，即对应了 HADDR[27:26]=10，我们要做的就是配置对\r\n应第 3 区的寄存器组，来适应外部设备即可。   \r\n\r\n![image-20210907214337578](cloudDisk/markdown/stm32笔记.assets/image-20210907214337578.png)\r\n\r\n对于 NOR FLASH 控制器，主要是通过 FSMC_BCRx、 FSMC_BTRx 和 FSMC_BWTRx 寄存器设置（其中 x=1~4，对应 4 个区）。 通过这 3 个寄存器， 可以设置 FSMC 访问外部存储器的时序参数，拓宽了可选用的外部存储器的速度范围。 FSMC 的 NOR FLASH 控制器支持同步和异步突发两种访问方式。选用同步突发访问方式时， FSMC 将 HCLK(系统时钟)分频后，发送给外部存储器作为同步时钟信号 FSMC_CLK。此时需要的设置的时间参数有 2 个：  \r\n	1， HCLK 与 FSMC_CLK 的分频系数(CLKDIV)，可以为 2～16 分频；\r\n	2， 同步突发访问中获得第 1 个数据所需要的等待延迟(DATLAT)。  \r\n\r\n对于异步突发访问方式， FSMC 主要设置 3 个时间参数：地址建立时间(ADDSET)、数据建立时间(DATAST)和地址保持时间(ADDHLD)。 FSMC 综合了 SRAM／ ROM、 PSRAM 和 NORFlash 产品的信号特点，定义了 4 种不同的异步时序模型。 选用不同的时序模型时，需要设置不同的时序参数，如表 18.1.2.3 所列：  \r\n\r\n![image-20210907214827241](cloudDisk/markdown/stm32笔记.assets/image-20210907214827241.png)\r\n\r\n在实际扩展时，根据选用存储器的特征确定时序模型，从而确定各时间参数与存储器读／写周期参数指标之间的计算关系；利用该计算关系和存储芯片数据手册中给定的参数指标，可计算出 FSMC 所需要的各时间参数，从而对时间参数寄存器进行合理的配置。  \r\n\r\n本章，我们使用异步模式 A（ModeA）方式来控制 TFTLCD，模式 A 的读操作时序如图\r\n18.1.2.3 所示：  \r\n![image-20210907215051117](cloudDisk/markdown/stm32笔记.assets/image-20210907215051117.png)\r\n\r\n模式 A 支持独立的读写时序控制，这个对我们驱动 TFTLCD 来说非常有用，因为 TFTLCD在读的时候，一般比较慢，而在写的时候可以比较快，如果读写用一样的时序，那么只能以读的时序为基准，从而导致写的速度变慢，或者在读数据的时候，重新配置 FSMC 的延时，在读操作完成的时候，再配置回写的时序，这样虽然也不会降低写的速度，但是频繁配置，比较麻烦。而如果有独立的读写时序控制，那么我们只要初始化的时候配置好，之后就不用再配置，既可以满足速度要求，又不需要频繁改配置。  \r\n\r\n模式 A 的写操作时序如图 18.1.2.4 所示：  \r\n![image-20210907215352575](cloudDisk/markdown/stm32笔记.assets/image-20210907215352575.png)\r\n\r\n从模式 A 的读写时序图，我们可以看出，读操作还存在额外的 2 个 HCLK 周期，用于数据存储，所以同样的配置读操作一般比写操作会慢一点。图 18.1.2.3 和图 18.1.2.4 中的 ADDSET与 DATAST，是通过不同的寄存器设置的，接下来我们讲解一下 Bank1 的几个控制寄存器\r\n首先，我们介绍 SRAM/NOR 闪存片选控制寄存器： FSMC_BCRx（x=1~4），该寄存器各位描述如图 18.1.2.5 所示：  ![image-20210907215451316](cloudDisk/markdown/stm32笔记.assets/image-20210907215451316.png)\r\n\r\n该寄存器我们在本章用到的设置有： EXTMOD、 WREN、 MWID、 MTYP 和 MBKEN 这几\r\n\r\n个设置，我们将逐个介绍。\r\n	EXTMOD：扩展模式使能位，也就是是否允许读写不同的时序，很明显，我们本章需要读\r\n写不同的时序，故该位需要设置为 1。\r\n	WREN：写使能位。我们需要向 TFTLCD 写数据，故该位必须设置为 1。\r\n	MWID[1:0]：存储器数据总线宽度。 00，表示 8 位数据模式； 01 表示 16 位数据模式； 10\r\n和 11 保留。我们的 TFTLCD 是 16 位数据线，所以设置 WMID[1:0]=01。\r\n	MTYP[1:0]：存储器类型。 00 表示 SRAM、 ROM； 01 表示 PSRAM； 10 表示 NOR FLASH;11\r\n保留。前面提到，我们把 TFTLCD 当成 SRAM 用，所以需要设置 MTYP[1:0]=00。\r\n	MBKEN：存储块使能位。这个容易理解，我们需要用到该存储块控制 TFTLCD，当然要\r\n使能这个存储块了 \r\n	 接下来，我们看看 SRAM/NOR 闪存片选时序寄存器： FSMC_BTRx（x=1~4），该寄存器各\r\n位描述如图 18.1.2.6 所示：  \r\n\r\n![image-20210907215908851](cloudDisk/markdown/stm32笔记.assets/image-20210907215908851.png)\r\n\r\n​	这个寄存器包含了每个存储器块的控制信息，可以用于 SRAM、 ROM 和 NOR 闪存存储器。\r\n如果 FSMC_BCRx 寄存器中设置了 EXTMOD 位，则有两个时序寄存器分别对应读(本寄存器)\r\n和写操作(FSMC_BWTRx 寄存器)。因为我们要求读写分开时序控制，所以 EXTMOD 是使能了\r\n的，也就是本寄存器是读操作时序寄存器，控制读操作的相关时序。 本章我们要用到的设置有：\r\nACCMOD、 DATAST 和 ADDSET 这三个设置。\r\n​	ACCMOD[1:0]：访问模式。 00 表示访问模式 A； 01 表示访问模式 B； 10 表示访问模式 C；\r\n11 表示访问模式 D，本章我们用到模式 A，故设置为 00。\r\n​	DATAST[7:0]：数据保持时间。 0 为保留设置，其他设置则代表保持时间为: DATAST 个\r\nHCLK 时钟周期，最大为 255 个 HCLK 周期。对 ILI9341 来说，其实就是 RD 低电平持续时间，\r\n一般为 355ns。而一个 HCLK 时钟周期为 13.8ns 左右（1/72Mhz），为了兼容其他屏，我们这里\r\n设置 DATAST 为 15，也就是 16 个 HCLK 周期，时间大约是 234ns （未计算数据存储的 2 个 HCLK\r\n时间，对 9341 来说超频了，但是实际上是可以正常使用的）。\r\n​	ADDSET[3:0]：地址建立时间。其建立时间为： ADDSET 个 HCLK 周期，最大为 15 个 HCLK\r\n周期。对 ILI9341 来说，这里相当于 RD 高电平持续时间，为 90ns，本来这里我们应该设置和\r\nDATAST 一样，但是由于 STM32F103 FSMC 的性能问题，就算设置 ADDSET 为 0， RD 的高电\r\n平持续时间也达到了 190ns 以上，所有，我们这里可以设置 ADDSET 为较小的值，本章我们设\r\n置 ADDSET 为 1，即 2 个 HCLK 周期，实际 RD 高电平大于 200ns。\r\n​	最后，我们再来看看 SRAM/NOR 闪写时序寄存器： FSMC_BWTRx（x=1~4），该寄存器各\r\n位描述如图 18.1.2.7 所示：  \r\n\r\n![image-20210907225855664](cloudDisk/markdown/stm32笔记.assets/image-20210907225855664.png)\r\n\r\n​	该寄存器在本章用作写操作时序控制寄存器，需要用到的设置同样是： ACCMOD、 DATAST\r\n和 ADDSET 这三个设置。这三个设置的方法同 FSMC_BTRx 一模一样，只是这里对应的是写\r\n操作的时序， ACCMOD 设置同 FSMC_BTRx 一模一样，同样是选择模式 A，另外 DATAST 和\r\nADDSET 则对应低电平和高电平持续时间，对 ILI9341 来说，这两个时间只需要 15ns 就够了，\r\n比读操作快得多。所以我们这里设置 DATAST 为 3，即 4 个 HCLK 周期，时间约为 55ns（因为\r\n9320 等控制器，这个时间要求比较长，要 50ns）。然后 ADDSET（也存在性能问题）设置为 0，\r\n即 1 个 HCLK 周期，实际 WR 高电平时间大于 100ns。\r\n​	至此，我们对 STM32 的 FSMC 介绍就差不多了，通过以上两个小节的了解，我们可以开\r\n始写 LCD 的驱动代码了。不过，这里还要给大家做下科普，在 MDK 的寄存器定义里面，并没\r\n有定义 FSMC_BCRx、 FSMC_BTRx、 FSMC_BWTRx 等这个单独的寄存器，而是将他们进行了\r\n一些组合。\r\n​	FSMC_BCRx 和 FSMC_BTRx，组合成 BTCR[8]寄存器组，他们的对应关系如下：  \r\n\r\n​	BTCR[0]对应 FSMC_BCR1， BTCR[1]对应 FSMC_BTR1\r\n​	BTCR[2]对应 FSMC_BCR2， BTCR[3]对应 FSMC_BTR2\r\n​	BTCR[4]对应 FSMC_BCR3， BTCR[5]对应 FSMC_BTR3\r\n​	BTCR[6]对应 FSMC_BCR4， BTCR[7]对应 FSMC_BTR4\r\n​	FSMC_BWTRx 则组合成 BWTR[7]，他们的对应关系如下：\r\n​	BWTR[0]对应 FSMC_BWTR1， BWTR[2]对应 FSMC_BWTR2，\r\n​	BWTR[4]对应 FSMC_BWTR3， BWTR[6]对应 FSMC_BWTR4，\r\n​	BWTR[1]、 BWTR[3]和 BWTR[5]保留，没有用到。  \r\n\r\n## 5. FSMC相关函数\r\n\r\n### 1）初始化函数\r\n\r\n初始化 FSMC 主要是初始化三个寄存器 FSMC_BCRx， FSMC_BTRx，FSMC_BWTRx，那么在固件库中是怎么初始化这三个参数的呢？  \r\n\r\n* 固件库提供了 3 个 FSMC 初始化函数分别为  \r\n\r\n  ```c\r\n  FSMC_NORSRAMInit()；\r\n  FSMC_NANDInit()；\r\n  FSMC_PCCARDInit()；\r\n  ```\r\n\r\n  这三个函数分别用来初始化 4 种类型存储器。这里根据名字就很好判断对应关系。 用来初始化NOR 和 SRAM 使用同一个函数 FSMC_NORSRAMInit()。所以我们之后使用的 FSMC 初始化函数为 FSMC_NORSRAMInit()。 下面我们看看函数定义：  \r\n\r\n  ```c\r\n  void FSMC_NORSRAMInit(FSMC_NORSRAMInitTypeDef* FSMC_NORSRAMInitStruct)；\r\n  ```\r\n\r\n  ```c\r\n  typedef struct\r\n  {\r\n      uint32_t FSMC_Bank;\r\n      uint32_t FSMC_DataAddressMux;\r\n      uint32_t FSMC_MemoryType;\r\n      uint32_t FSMC_MemoryDataWidth;\r\n      uint32_t FSMC_BurstAccessMode;\r\n      uint32_t FSMC_AsynchronousWait;\r\n      uint32_t FSMC_WaitSignalPolarity;\r\n      uint32_t FSMC_WrapMode;\r\n      uint32_t FSMC_WaitSignalActive;\r\n      uint32_t FSMC_WriteOperation;\r\n      uint32_t FSMC_WaitSignal;\r\n      uint32_t FSMC_ExtendedMode;\r\n      uint32_t FSMC_WriteBurst;\r\n      FSMC_NORSRAMTimingInitTypeDef* FSMC_ReadWriteTimingStruct;\r\n      FSMC_NORSRAMTimingInitTypeDef* FSMC_WriteTimingStruct;\r\n  }FSMC_NORSRAMInitTypeDef;\r\n  ```\r\n\r\n  * 从这个结构体我们可以看出，前面有 13 个基本类型（unit32_t）的成员变量， 这 13 个参数是用来配置片选控制寄存器 FSMC_BCRx。 最后面还有两个SMC_NORSRAMTimingInitTypeDef 指针类型的成员变量。  前面我们讲到， FSMC 有读时序和写时序之分，所以这里就是用来设置读时序和写时序的参数了， 也就是说，这两个参数是用来配置寄存器 FSMC_BTRx 和 FSMC_BWTRx，后面我们会讲解到。  \r\n  * **参数 FSMC_Bank** 用来设置使用到的存储块标号和区号，前面讲过， 我们是使用的存储块 1 区号 4， 所以选择值为 FSMC_Bank1_NORSRAM4。  \r\n  * **参数 FSMC_MemoryType** 用来设置存储器类型，我们这里是 SRAM，所以选择值为FSMC_MemoryType_SRAM。  \r\n  * **参数 FSMC_MemoryDataWidth** 用来设置数据宽度，可选 8 位还是 16 位，这里我们是 16 位数据宽度，所以选择值为 FSMC_MemoryDataWidth_16b。  \r\n  * **参数 FSMC_WriteOperation** 用来设置写使能，毫无疑问，我们前面讲解过我们要向 TFT 写数据，所以要写使能，这里我们选择 FSMC_WriteOperation_Enable。 \r\n  * **参数 FSMC_ExtendedMode** 是设置扩展模式使能位，也就是是否允许读写不同的时序，这里我们采取的读写不同时序，所以设置值为 FSMC_ExtendedMode_Enable。 \r\n  * **参数 FSMC_ExtendedMode** 是设置扩展模式使能位，也就是是否允许读写不同的时序，这里我们采取的读写不同时序，所以设置值为 FSMC_ExtendedMode_Enable。   \r\n\r\n  上面的这些参数是与模式 A 相关的，下面我们也来稍微了解一下其他几个参数的意义吧：  \r\n\r\n  * **参数 FSMC_DataAddressMux** 用来设置地址/数据复用使能，若设置为使能，那么地址的低 16位和数据将共用数据总线，仅对 NOR 和 PSRAM 有效，所以我们设置为默认值不复用，值FSMC_DataAddressMux_Disable。  \r\n  * 参 数 FSMC_BurstAccessMode ， FSMC_AsynchronousWait ， FSMC_WaitSignalPolarity ，FSMC_WaitSignalActive ， FSMC_WrapMode ， FSMC_WaitSignal FSMC_WriteBurst 和FSMC_WaitSignal 这些参数在成组模式同步模式才需要设置，大家可以参考中文参考手册了解相关参数的意思。  \r\n\r\n  设 置 **读 写 时 序 参 数 的 两 个 变 量 FSMC_ReadWriteTimingStruct 和FSMC_WriteTimingStruct**，他们都是 FSMC_NORSRAMTimingInitTypeDef 结构体指针类型， 这两个参数在初始化的时候分别用来初始化片选控制寄存器 FSMC_BTRx 和写操作时序控制寄存器 FSMC_BWTRx。 下面我们看看FSMC_NORSRAMTimingInitTypeDef 类型的定义：\r\n\r\n  * ```c\r\n    typedef struct\r\n    {\r\n    uint32_t FSMC_AddressSetupTime;\r\n    uint32_t FSMC_AddressHoldTime;\r\n    uint32_t FSMC_DataSetupTime;\r\n    uint32_t FSMC_BusTurnAroundDuration;\r\n    uint32_t FSMC_CLKDivision;\r\n    uint32_t FSMC_DataLatency;\r\n    uint32_t FSMC_AccessMode;\r\n    }FSMC_NORSRAMTimingInitTypeDef;\r\n    ```\r\n\r\n    这个结构体有 7 个参数用来设置 FSMC 读写时序。 \r\n\r\n    主要是设计地址建立保持时间，数据建立时间等等配置， 对于我们的实验中，读写时序不一样，读写速度要求不一样，所以对于参数 FSMC_DataSetupTime 设置了不同的值    \r\n\r\n### 2）使能函数\r\n\r\n```c\r\nvoid FSMC_NORSRAMCmd(uint32_t FSMC_Bank, FunctionalState NewState);\r\nvoid FSMC_NANDCmd(uint32_t FSMC_Bank, FunctionalState NewState);\r\nvoid FSMC_PCCARDCmd(FunctionalState NewState);\r\n```\r\n\r\n这个就比较好理解，我们这里不讲解，我们是 SRAM,所以使用的第一个函数。  \r\n\r\n\r\n\r\n## 6. 实例学习\r\n\r\n### 1）硬件设计\r\n\r\n**TFTLCD 模块与 STM32 开发板的 IO口对应关系如下：**\r\n\r\n| 功能             | IO               | 备注           |\r\n| ---------------- | ---------------- | -------------- |\r\n| LCD_BL(背光控制) | PB0              |                |\r\n| LCD_CS           | PG12 即 FSMC_NE4 | TFTLCD片选信号 |\r\n| LCD _RS          | PG0 即 FSMC_A10  | 命令/数据标志  |\r\n| LCD _WR          | PD5 即 FSMC_NWE  | 写数据         |\r\n| LCD _RD          | PD4 即 FSMC_NOE  | 读数据         |\r\n| LCD _D[15:0]     | FSMC_D15~FSMC_D0 | 16位双向数据线 |\r\n| RST              |                  | 硬复位TFTLCD   |\r\n\r\n### 2）软件设计\r\n\r\n#### 1. 读写数据命令\r\n\r\n```c\r\nLCD->LCD_REG=CMD; //写命令\r\nLCD->LCD_RAM=DATA; //写数据\r\n\r\nCMD= LCD->LCD_REG; //读 LCD 寄存器\r\nDATA = LCD->LCD_RAM; //读 LCD 数据\r\n```\r\n\r\n#### 2. 重要结构体 - LCD 重要参数集\r\n\r\nCS、 WR、 RD 和 IO 口方向都是由 FSMC 控制，不需要我们手动设置了。 接下来，我们先介绍一下 lcd.h 里面的另一个重要结构体:  \r\n\r\n```c\r\n//LCD 重要参数集\r\ntypedef struct\r\n{\r\n    u16 width; //LCD 宽度\r\n    u16 height; //LCD 高度\r\n    u16 id; //LCD ID\r\n    u8 dir; //横屏还是竖屏控制： 0，竖屏； 1，横屏。\r\n    u16 wramcmd; //开始写 gram 指令\r\n    u16 setxcmd; //设置 x 坐标指令\r\n    u16 setycmd; //设置 y 坐标指令\r\n}_lcd_dev;\r\n//LCD 参数\r\nextern _lcd_dev lcddev; //管理 LCD 重要参数\r\n```\r\n\r\n\r\n\r\n#### 3. lcd.c 里面的一些重要函数 :\r\n\r\n```c\r\n//写寄存器函数\r\n//regval:寄存器值\r\nvoid LCD_WR_REG(u16 regval)\r\n{\r\n	LCD->LCD_REG=regval; //写入要写的寄存器序号\r\n}\r\n\r\n//写 LCD 数据\r\n//data:要写入的值\r\nvoid LCD_WR_DATA(u16 data)\r\n{\r\n	LCD->LCD_RAM=data;\r\n}\r\n\r\n//读 LCD 数据\r\n//返回值:读到的值\r\nu16 LCD_RD_DATA(void)\r\n{\r\n    vu16 ram; //防止被优化\r\n    ram=LCD->LCD_RAM;\r\n    return ram;\r\n}\r\n\r\n//写寄存器\r\n//LCD_Reg:寄存器地址\r\n//LCD_RegValue:要写入的数据\r\nvoid LCD_WriteReg(u16 LCD_Reg, u16 LCD_RegValue)\r\n{\r\n    LCD->LCD_REG = LCD_Reg; //写入要写的寄存器序号\r\n    LCD->LCD_RAM = LCD_RegValue; //写入数据\r\n}\r\n\r\n//读寄存器\r\n//LCD_Reg:寄存器地址\r\n//返回值:读到的数据\r\nu16 LCD_ReadReg(u16 LCD_Reg)\r\n{\r\n    LCD_WR_REG(LCD_Reg); //写入要读的寄存器序号\r\n    delay_us(5);\r\n    return LCD_RD_DATA(); //返回读到的值\r\n}\r\n\r\n//开始写 GRAM\r\nvoid LCD_WriteRAM_Prepare(void)\r\n{\r\n    LCD->LCD_REG=lcddev.wramcmd;\r\n}\r\n\r\n//LCD 写 GRAM\r\n//RGB_Code:颜色值\r\nvoid LCD_WriteRAM(u16 RGB_Code)\r\n{\r\n    LCD->LCD_RAM = RGB_Code;//写十六位 GRAM\r\n}\r\n```\r\n\r\n#### 4. 坐标设置函数，该函数代码如下：  \r\n\r\n```c\r\n//设置光标位置\r\n//Xpos:横坐标\r\n//Ypos:纵坐标\r\nvoid LCD_SetCursor(u16 Xpos, u16 Ypos)\r\n{\r\n    if(lcddev.id==0X9341||lcddev.id==0X5310)\r\n    {\r\n        LCD_WR_REG(lcddev.setxcmd);\r\n        LCD_WR_DATA(Xpos>>8);LCD_WR_DATA(Xpos&0XFF);\r\n        LCD_WR_REG(lcddev.setycmd);\r\n        LCD_WR_DATA(Ypos>>8);LCD_WR_DATA(Ypos&0XFF);\r\n    }else if(lcddev.id==0X6804)\r\n    {\r\n        if(lcddev.dir==1)Xpos=lcddev.width-1-Xpos;//横屏时处理\r\n        LCD_WR_REG(lcddev.setxcmd);\r\n        LCD_WR_DATA(Xpos>>8);LCD_WR_DATA(Xpos&0XFF);\r\n        LCD_WR_REG(lcddev.setycmd);\r\n        LCD_WR_DATA(Ypos>>8);LCD_WR_DATA(Ypos&0XFF);\r\n    }else if(lcddev.id==0X1963)\r\n        {\r\n        if(lcddev.dir==0)//x 坐标需要变换\r\n        {\r\n            Xpos=lcddev.width-1-Xpos;\r\n            LCD_WR_REG(lcddev.setxcmd);\r\n            LCD_WR_DATA(0);LCD_WR_DATA(0);\r\n            LCD_WR_DATA(Xpos>>8);LCD_WR_DATA(Xpos&0XFF);\r\n        }else\r\n        {\r\n            LCD_WR_REG(lcddev.setxcmd);\r\n            LCD_WR_DATA(Xpos>>8);LCD_WR_DATA(Xpos&0XFF);\r\n            LCD_WR_DATA((lcddev.width-1)>>8);\r\n            LCD_WR_DATA((lcddev.width-1)&0XFF);\r\n        }\r\n        LCD_WR_REG(lcddev.setycmd);\r\n        LCD_WR_DATA(Ypos>>8);LCD_WR_DATA(Ypos&0XFF);\r\n        LCD_WR_DATA((lcddev.height-1)>>8);LCD_WR_DATA((lcddev.height-1)&0XFF);\r\n    }else if(lcddev.id==0X5510)\r\n    {\r\n        LCD_WR_REG(lcddev.setxcmd);LCD_WR_DATA(Xpos>>8);\r\n        LCD_WR_REG(lcddev.setxcmd+1);LCD_WR_DATA(Xpos&0XFF);\r\n        LCD_WR_REG(lcddev.setycmd);LCD_WR_DATA(Ypos>>8);\r\n        LCD_WR_REG(lcddev.setycmd+1);LCD_WR_DATA(Ypos&0XFF);\r\n    }else\r\n    {\r\n    	if(lcddev.dir==1)Xpos=lcddev.width-1-Xpos;//横屏其实就是调转 x,y 坐标\r\n    	LCD_WriteReg(lcddev.setxcmd, Xpos);\r\n        LCD_WriteReg(lcddev.setycmd, Ypos);\r\n    }\r\n}\r\n```\r\n\r\n该函数非常重要，该函数实现了将 LCD 的当前操作点设置到指定坐标(x,y)，有了该函数，我们就可以在液晶上任意作图了。这里面的 lcddev.setxcmd、 lcddev.setycmd、 lcddev.width、lcddev.height 等指令/参数都是在 LCD_Display_Dir 函数里面初始化的，该函数根据 lcddev.id 的不同，执行不同的设置。\r\n\r\n\r\n\r\n#### 5. 画点函数。该函数实现代码如下： \r\n\r\n```c\r\n//画点\r\n//x,y:坐标\r\n//POINT_COLOR:此点的颜色\r\nvoid LCD_DrawPoint(u16 x,u16 y)\r\n{\r\n    LCD_SetCursor(x,y); //设置光标位置\r\n    LCD_WriteRAM_Prepare(); //开始写入 GRAM\r\n    LCD->LCD_RAM=POINT_COLOR;\r\n}\r\n```\r\n\r\n就是先设置坐标，然后往坐标写颜色。其中 POINT_COLOR 是我们定义的一个全局变量，用于存放画笔颜色，顺带介绍一下另外一个全局变量： BACK_COLOR，该变量代表 LCD 的背景色。 LCD_DrawPoint 函数虽然简单，但是至关重要，其他几乎所有上层函数，都是通过调用这个函数实现的。  \r\n\r\n\r\n\r\n#### 6. 读点函数\r\n\r\n有了画点，当然还需要有读点的函数，第九个介绍的函数就是读点函数，用于读取 LCD的 GRAM， 这里说明一下，为什么 OLED 模块没做读 GRAM 的函数，而这里做了。因为 OLED模块是单色的，所需要全部 GRAM 也就 1K 个字节，而 TFTLCD 模块为彩色的，点数也比 OLED模块多很多，以 16 位色计算，一款 320× 240 的液晶，需要 320× 240× 2 个字节来存储颜色值，也就是也需要 150K 字节，这对任何一款单片机来说，都不是一个小数目了。而且我们在图形叠加的时候，可以先读回原来的值，然后写入新的值， 在完成叠加后，我们又恢复原来的值。这样在做一些简单菜单的时候，是很有用的。这里我们读取 TFTLCD 模块数据的函数为LCD_ReadPoint，该函数直接返回读到的 GRAM 值。该函数使用之前要先设置读取的 GRAM地址，通过 LCD_SetCursor 函数来实现。 LCD_ReadPoint 的代码如下：  \r\n\r\n```c\r\n//读取个某点的颜色值\r\n//x,y:坐标\r\n//返回值:此点的颜色\r\nu16 LCD_ReadPoint(u16 x,u16 y)\r\n{\r\n    vu16 r=0,g=0,b=0;\r\n    if(x>=lcddev.width||y>=lcddev.height)\r\n        return 0; //超过了范围,直接返回\r\n    LCD_SetCursor(x,y);\r\n    if(lcddev.id==0X9341||lcddev.id==0X6804||lcddev.id==0X5310||lcddev.id==0X1963)\r\n    	LCD_WR_REG(0X2E);//9341/6804/3510/1963 发送读 GRAM 指令\r\n    else if(lcddev.id==0X5510)\r\n        LCD_WR_REG(0X2E00);//5510 发送读 GRAM 指令\r\n    else \r\n        CD_WR_REG(0X22); //其他 IC 发送读 GRAM 指令\r\n    if(lcddev.id==0X9320)\r\n        opt_delay(2); //FOR 9320,延时 2us //或许是时序问题，对于这种类型LCD，需要延时\r\n    r=LCD_RD_DATA(); //dummy Read\r\n    if(lcddev.id==0X1963)\r\n        return r; //1963 直接读就可以\r\n    opt_delay(2);\r\n    r=LCD_RD_DATA(); //实际坐标颜色\r\n    if(lcddev.id==0X9341||lcddev.id==0X5310||lcddev.id==0X5510)//这些 LCD 要分 2 次读出\r\n    {\r\n        opt_delay(2);\r\n        b=LCD_RD_DATA();\r\n        g=r&0XFF;//对于 9341/5310/5510,第一次读取的是 RG 值,R 在前,G 在后,各占 8 位\r\n        g<<=8;\r\n    }\r\n    if(lcddev.id==0X9325||lcddev.id==0X4535||lcddev.id==0X4531||lcddev.id==0XB505||\r\n    lcddev.id==0XC505)\r\n        return r; //这几种 IC 直接返回颜色值\r\n    else if(lcddev.id==0X9341||lcddev.id==0X5310||lcddev.id==0X5510)\r\n        return (((r>>11)<<11)|((g>>10)<<5)|(b>>11)); //ILI9341/NT35310/NT35510 需要公式转换一下\r\n    else \r\n        return LCD_BGR2RGB(r); //其他 IC\r\n}\r\n```\r\n\r\n在LCD_ReadPoint 函数中， 因为我们的代码不止支持一种 LCD 驱动器，所以，我们根据不同的 LCD 驱动器（(lcddev.id）型号，执行不同的操作，以实现对各个驱动器兼容，提高函数的通用性。  \r\n\r\n\r\n\r\n#### 7. 字符显示函数\r\n\r\n第十一个要介绍的是字符显示函数 LCD_ShowChar，该函数同前面 OLED 模块的字符显示函数差不多，但是这里的字符显示函数多了 1 个功能，就是可以以叠加方式显示，或者以非叠加方式显示。叠加方式显示多用于在显示的图片上再显示字符。非叠加方式一般用于普通的显示。 该函数实现代码如下：  \r\n\r\n```c\r\n//在指定位置显示一个字符\r\n//x,y:起始坐标\r\n//num:要显示的字符:\" \"--->\"~\"\r\n//size:字体大小 12/16/24\r\n//mode:叠加方式(1)还是非叠加方式(0)\r\nvoid LCD_ShowChar(u16 x,u16 y,u8 num,u8 size,u8 mode)\r\n{\r\n    u8 temp,t1,t;\r\n    u16 y0=y;\r\n    u8 csize=(size/8+((size%8)?1:0))*(size/2);//得到字体一个字符对应点阵集所占的字节数\r\n    num=num-\' \'; //ASCII 字库从空格开始取模，所以-\' \'即可得到对应字符的字库（点阵）\r\n    for(t=0;t<csize;t++)\r\n    {\r\n        if(size==12)temp=asc2_1206[num][t]; //调用 1206 字体\r\n        else if(size==16)temp=asc2_1608[num][t]; //调用 1608 字体\r\n        else if(size==24)temp=asc2_2412[num][t]; //调用 2412 字体\r\n        else return; //没有的字库\r\n        for(t1=0;t1<8;t1++)\r\n            {\r\n            if(temp&0x80)LCD_Fast_DrawPoint(x,y,POINT_COLOR);\r\n            else if(mode==0)LCD_Fast_DrawPoint(x,y,BACK_COLOR);\r\n            temp<<=1;\r\n            y++;\r\n            if(y>=lcddev.height)return; //超区域了\r\n            if((y-y0)==size)\r\n            {\r\n                y=y0; x++;\r\n                if(x>=lcddev.width)return; //超区域了\r\n                break;\r\n            }\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n在 LCD_ShowChar 函数里面，我们采用快速画点函数 LCD_Fast_DrawPoint 来画点显示字符，该函数同 LCD_DrawPoint 一样，只是带了颜色参数，且减少了函数调用的时间，详见本例程源码。该代码中我们用到了三个字符集点阵数据数组 asc2_2412、 asc2_1206 和 asc2_1608，这几个字符集的点阵数据的提取方式，同十七章介绍的提取方法是一模一样的。详细请参考第十七章。  \r\n\r\n\r\n\r\n#### 8. TFTLCD模块初始化函数\r\n\r\n最后，我们再介绍一下 TFTLCD 模块的初始化函数 LCD_Init，该函数先初始化 STM32 与TFTLCD 连接的 IO 口，并配置 FSMC 控制器，然后读取 LCD 控制器的型号，根据控制 IC 的型号执行不同的初始化代码，其简化代码如下：  \r\n\r\n```c\r\n//初始化 lcd\r\n//该初始化函数可以初始化各种 ILI93XX 液晶,但是其他函数是基于 ILI9320 的!!!\r\n//在其他型号的驱动芯片上没有测试!\r\nvoid LCD_Init(void)\r\n{\r\n    GPIO_InitTypeDef GPIO_InitStructure;\r\n    FSMC_NORSRAMInitTypeDef FSMC_NSInitStructure;\r\n    FSMC_NORSRAMTimingInitTypeDef readWriteTiming;\r\n    FSMC_NORSRAMTimingInitTypeDef writeTiming;\r\n    RCC_AHBPeriphClockCmd(RCC_AHBPeriph_FSMC,ENABLE);//使能 FSMC 时钟\r\n    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB|RCC_APB2Periph_GPIOD|\r\n    RCC_APB2Periph_GPIOE|RCC_APB2Periph_GPIOG|\r\n    RCC_APB2Periph_AFIO,ENABLE); // ①使能 GPIO 以及 AFIO 复用功能时钟\r\n    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0; //PB0 推挽输出 背光\r\n    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP; //推挽输出\r\n    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;\r\n    GPIO_Init(GPIOB, &GPIO_InitStructure); //②初始化 PB0\r\n    //PORTD 复用推挽输出\r\n    GPIO_InitStructure.GPIO_Pin= GPIO_Pin_0|GPIO_Pin_1|GPIO_Pin_4|GPIO_Pin_5|\r\n    GPIO_Pin_8|GPIO_Pin_9|GPIO_Pin_10|GPIO_Pin_14|GPIO_Pin_15;\r\n    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP; //复用推挽输出\r\n    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;\r\n    GPIO_Init(GPIOD, &GPIO_InitStructure); //②初始化 PORTD\r\n    //PORTE 复用推挽输出\r\n    GPIO_InitStructure.GPIO_Pin =GPIO_Pin_7|GPIO_Pin_8|GPIO_Pin_9|GPIO_Pin_10|\r\n    GPIO_Pin_11|GPIO_Pin_12|GPIO_Pin_13|GPIO_Pin_14|GPIO_Pin_15;\r\n    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP; //复用推挽输出\r\n    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;\r\n    GPIO_Init(GPIOE, &GPIO_InitStructure); //②初始化 PORTE\r\n    //PORTG12 复用推挽输出 A0\r\n    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0|GPIO_Pin_12; //PORTD 复用推挽输出\r\n    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP; //复用推挽输出\r\n    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;\r\n    GPIO_Init(GPIOG, &GPIO_InitStructure); //②初始化 PORTG\r\n    readWriteTiming.FSMC_AddressSetupTime = 0x01; //地址建立时间 2 个 HCLK 1\r\n    readWriteTiming.FSMC_AddressHoldTime = 0x00; //地址保持时间模式 A 未用到\r\n    readWriteTiming.FSMC_DataSetupTime = 0x0f; // 数据保存时间为 16 个 HCLK\r\n    readWriteTiming.FSMC_BusTurnAroundDuration = 0x00;\r\n    readWriteTiming.FSMC_CLKDivision = 0x00;\r\n    readWriteTiming.FSMC_DataLatency = 0x00;\r\n    readWriteTiming.FSMC_AccessMode = FSMC_AccessMode_A; //模式 A\r\n    writeTiming.FSMC_AddressSetupTime = 0x00; //地址建立时间为 1 个 HCLK\r\n    writeTiming.FSMC_AddressHoldTime = 0x00; //地址保持时间（A\r\n    writeTiming.FSMC_DataSetupTime = 0x03; //数据保存时间为 4 个 HCLK\r\n    writeTiming.FSMC_BusTurnAroundDuration = 0x00;\r\n    writeTiming.FSMC_CLKDivision = 0x00;\r\n    writeTiming.FSMC_DataLatency = 0x00;\r\n    writeTiming.FSMC_AccessMode = FSMC_AccessMode_A; //模式 A\r\n    FSMC_NSInitStructure.FSMC_Bank = FSMC_Bank1_NORSRAM4;//这里我们使\r\n    //用 NE4， 也就对应 BTCR[6],[7]。\r\n    FSMC_NSInitStructure.FSMC_DataAddressMux =\r\n    FSMC_DataAddressMux_Disable; //不复用数据地址\r\n    FSMC_NSInitStructure.FSMC_MemoryType=FSMC_MemoryType_SRAM;// SRAM\r\n    FSMC_NSInitStructure.FSMC_MemoryDataWidth= FSMC_MemoryDataWidth_16b;\r\n    //存储器数据宽度为 16bit\r\n    FSMC_NSInitStructure.FSMC_BurstAccessMode=FSMC_BurstAccessMode_Disable;\r\n        FSMC_NSInitStructure.FSMC_WaitSignalPolarity = FSMC_WaitSignalPolarity_Low;\r\n    FSMC_NSInitStructure.FSMC_AsynchronousWait=\r\n    FSMC_AsynchronousWait_Disable;\r\n    FSMC_NSInitStructure.FSMC_WrapMode = FSMC_WrapMode_Disable;\r\n    FSMC_NSInitStructure.FSMC_WaitSignalActive=\r\n    FSMC_WaitSignalActive_BeforeWaitState;\r\n    FSMC_NSInitStructure.FSMC_WriteOperation = FSMC_WriteOperation_Enable;\r\n    //存储器写使能\r\n    FSMC_NSInitStructure.FSMC_WaitSignal = FSMC_WaitSignal_Disable;\r\n    FSMC_NSInitStructure.FSMC_ExtendedMode = FSMC_ExtendedMode_Enable;\r\n    // 读写使用不同的时序\r\n    FSMC_NSInitStructure.FSMC_WriteBurst = FSMC_WriteBurst_Disable;\r\n    FSMC_NSInitStructure.FSMC_ReadWriteTimingStruct = &readWriteTiming;\r\n    FSMC_NSInitStructure.FSMC_WriteTimingStruct = &writeTiming; //写时序\r\n    FSMC_NORSRAMInit(&FSMC_NSInitStructure); //③初始化 FSMC 配置\r\n    FSMC_NORSRAMCmd(FSMC_Bank1_NORSRAM4, ENABLE); // ④使能 BANK1\r\n    delay_ms(50); // delay 50 ms\r\n    lcddev.id=LCD_ReadReg(0x0000); //读 ID（9320/9325/9328/4531/4535 等 IC）\r\n    if(lcddev.id<0XFF||lcddev.id==0XFFFF||lcddev.id==0X9300)\r\n        //ID 不正确,新增 0X9300 判断，因为 9341 在未被复位的情况下会被读成 9300\r\n        {\r\n        //尝试 9341 ID 的读取\r\n        LCD_WR_REG(0XD3);\r\n        lcddev.id=LCD_RD_DATA(); //dummy read\r\n        lcddev.id=LCD_RD_DATA(); //读到 0X00\r\n        lcddev.id=LCD_RD_DATA(); //读取 93\r\n        lcddev.id<<=8;\r\n        lcddev.id|=LCD_RD_DATA(); //读取 41\r\n    if(lcddev.id!=0X9341) //非 9341,尝试是不是 6804\r\n    {\r\n        LCD_WR_REG(0XBF);\r\n        lcddev.id=LCD_RD_DATA();//dummy read\r\n        lcddev.id=LCD_RD_DATA();//读回 0X01\r\n        lcddev.id=LCD_RD_DATA();//读回 0XD0\r\n        lcddev.id=LCD_RD_DATA();//这里读回 0X68\r\n        lcddev.id<<=8;\r\n        lcddev.id|=LCD_RD_DATA();//这里读回 0X04\r\n    if(lcddev.id!=0X6804) //也不是 6804,尝试看看是不是 NT35310\r\n    {\r\n        LCD_WR_REG(0XD4);\r\n        lcddev.id=LCD_RD_DATA(); //dummy read\r\n        lcddev.id=LCD_RD_DATA(); //读回 0X01\r\n            lcddev.id=LCD_RD_DATA(); //读回 0X53\r\n        lcddev.id<<=8;\r\n        lcddev.id|=LCD_RD_DATA(); //这里读回 0X10\r\n        if(lcddev.id!=0X5310) //也不是 NT35310,尝试看看是不是 NT35510\r\n        {\r\n            LCD_WR_REG(0XDA00);\r\n            lcddev.id=LCD_RD_DATA(); //读回 0X00\r\n            LCD_WR_REG(0XDB00);\r\n            lcddev.id=LCD_RD_DATA(); //读回 0X80\r\n            lcddev.id<<=8;\r\n            LCD_WR_REG(0XDC00);\r\n            lcddev.id|=LCD_RD_DATA(); //读回 0X00\r\n            if(lcddev.id==0x8000)lcddev.id=0x5510;\r\n                //NT35510 读回的 ID 是 8000H,为方便区分,我们强制设置为 5510\r\n                if(lcddev.id!=0X5510)//也不是 NT5510,尝试看看是不是 SSD1963\r\n                {\r\n                    LCD_WR_REG(0XA1);\r\n                    lcddev.id=LCD_RD_DATA();\r\n                    lcddev.id=LCD_RD_DATA(); //读回 0X57\r\n                    lcddev.id<<=8;\r\n                    lcddev.id|=LCD_RD_DATA(); //读回 0X61\r\n                    if(lcddev.id==0X5761)lcddev.id=0X1963;//SSD1963 读回的 ID 是\r\n                    //5761H,为方便区分,我们强制设置为 1963\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    printf(\" LCD ID:%x\\r\\n\",lcddev.id); //打印 LCD ID\r\n    if(lcddev.id==0X9341) //9341 初始化\r\n    {\r\n    	……//9341 初始化代码\r\n    }else if(lcddev.id==0xXXXX) //其他 LCD 初始化代码\r\n    {\r\n    	……//其他 LCD 驱动 IC，初始化代码\r\n    }\r\n    LCD_Display_Dir(0); //默认为竖屏显示\r\n    LCD_LED=1; //点亮背光\r\n    LCD_Clear(WHITE);\r\n}\r\n```\r\n\r\n```c\r\n// 带注释的\r\n/* 从初始化代码可以看出， LCD 初始化步骤为①~⑤在代码中标注：  \r\n\r\n①GPIO,FSMC,AFIO 时钟使能。  \r\n②GPIO 初始化： GPIO_Init()函数。\r\n③FSMC 初始化： FSMC_NORSRAMInit()函数。\r\n④ FSMC 使能： FSMC_NORSRAMCmd()函数。\r\n⑤ 同的 LCD 驱动器的初始化代码。  \r\n\r\n该函数先对 FSMC 相关 IO 进行初始化，然后是 FSMC 的初始化，\r\n这个我们在前面都有介绍，最后根据读到的 LCD ID，对不同的驱动器执行不同的初始化代码， \r\n从上面的代码可以看出，这个初始化函数可以针对十多款不同的驱动 IC 执行初始化操作，\r\n这样大大提高了整个程序的通用性。大家在以后的学习中应该多使用这样的方式，以提高程序的通用性、兼容性。 */\r\nvoid LCD_Init(void){\r\n    GPIO_InitTypeDef GPIO_InitStruct;\r\n    FSMC_NORSRAMInitTypeDef FSMC_NORSRAMInitStruct;\r\n    FSMC_NORSRAMTimingInitTypeDef readWriteTiming;\r\n    FSMC_NORSRAMTimingInitTypeDef writeTiming;\r\n    // ①GPIO,FSMC,AFIO 时钟使能。 \r\n    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB,ENABLE);\r\n    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOG,ENABLE);\r\n    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOD,ENABLE);\r\n    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOE,ENABLE);\r\n    RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO,ENABLE);\r\n    RCC_AHBPeriphClockCmd(RCC_AHBPeriph_FSMC,ENABLE); \r\n\r\n    // ②GPIO 初始化： GPIO_Init()函数。\r\n    // 背光控制 PBO,\r\n    // TFTLCD片选信号 PG12,\r\n    // 命令/数据标志 PG0,\r\n    // 写数据 PD5,\r\n    // 读数据 PD4,\r\n    // 16位双向数据线 PD14,PD15,PD0,PD1,PE7-PE15,PD8-PD10\r\n    GPIO_InitStruct.GPIO_Mode = GPIO_Mode_Out_PP;\r\n    GPIO_InitStruct.GPIO_Pin = GPIO_Pin_0;\r\n    GPIO_InitStruct.GPIO_Speed = GPIO_Speed_50MHz;\r\n    GPIO_Init(GPIOB,&GPIO_InitStruct); // 背光控制 PBO, ///\r\n\r\n    GPIO_InitStruct.GPIO_Mode = GPIO_Mode_AF_PP;\r\n    GPIO_InitStruct.GPIO_Pin = GPIO_Pin_12;\r\n    GPIO_Init(GPIOG,&GPIO_InitStruct); // TFTLCD片选信号 PG12,\r\n\r\n    GPIO_InitStruct.GPIO_Pin = GPIO_Pin_0;\r\n    GPIO_Init(GPIOG,&GPIO_InitStruct); // 命令/数据标志 PG0,\r\n\r\n    GPIO_InitStruct.GPIO_Mode = GPIO_Mode_AF_PP;\r\n    GPIO_InitStruct.GPIO_Pin = GPIO_Pin_4;\r\n    GPIO_Init(GPIOD,&GPIO_InitStruct); // 写数据 PD5,\r\n\r\n    GPIO_InitStruct.GPIO_Mode = GPIO_Mode_AF_PP;\r\n    GPIO_InitStruct.GPIO_Pin = GPIO_Pin_5;\r\n    GPIO_Init(GPIOD,&GPIO_InitStruct); // 读数据 PD4,\r\n\r\n    // 16位双向数据线 PD14,PD15,PD0,PD1,PE7-PE15,PD8-PD10\r\n    GPIO_InitStruct.GPIO_Mode = GPIO_Mode_AF_PP;\r\n    GPIO_InitStruct.GPIO_Pin = GPIO_Pin_14|GPIO_Pin_15|GPIO_Pin_8|GPIO_Pin_9|GPIO_Pin_10|GPIO_Pin_0|GPIO_Pin_1;\r\n    GPIO_Init(GPIOD,&GPIO_InitStruct);\r\n    GPIO_InitStruct.GPIO_Pin = GPIO_Pin_7|GPIO_Pin_8|GPIO_Pin_9|GPIO_Pin_10|GPIO_Pin_11|GPIO_Pin_12|GPIO_Pin_13|GPIO_Pin_14|GPIO_Pin_15;\r\n    GPIO_Init(GPIOE,&GPIO_InitStruct);\r\n\r\n    // ③FSMC 初始化： FSMC_NORSRAMInit()函数。\r\n/*     * **参数 FSMC_Bank** 用来设置使用到的存储块标号和区号，前面讲过， 我们是使用的存储块 1 区号 4， 所以选择值为 FSMC_Bank1_NORSRAM4。  \r\n        * **参数 FSMC_MemoryType** 用来设置存储器类型，我们这里是 SRAM，所以选择值为FSMC_MemoryType_SRAM。  \r\n        * **参数 FSMC_MemoryDataWidth** 用来设置数据宽度，可选 8 位还是 16 位，这里我们是 16 位数据宽度，所以选择值为 FSMC_MemoryDataWidth_16b。  \r\n        * **参数 FSMC_WriteOperation** 用来设置写使能，毫无疑问，我们前面讲解过我们要向 TFT 写数据，所以要写使能，这里我们选择 FSMC_WriteOperation_Enable。 \r\n        * **参数 FSMC_ExtendedMode** 是设置扩展模式使能位，也就是是否允许读写不同的时序，这里我们采取的读写不同时序，所以设置值为 FSMC_ExtendedMode_Enable。 \r\n        上面的这些参数是与模式 A 相关的，下面我们也来稍微了解一下其他几个参数的意义吧：  \r\n\r\n    * **参数 FSMC_DataAddressMux** 用来设置地址/数据复用使能，若设置为使能，那么地址的低 16位和数据将共用数据总线，仅对 NOR 和 PSRAM 有效，所以我们设置为默认值不复用，值FSMC_DataAddressMux_Disable。   \r\n\r\n    设 置 **读 写 时 序 参 数 的 两 个 变 量 FSMC_ReadWriteTimingStruct 和FSMC_WriteTimingStruct**，\r\n    他们都是 FSMC_NORSRAMTimingInitTypeDef 结构体指针类型， \r\n    这两个参数在初始化的时候分别用来初始化片选控制寄存器 FSMC_BTRx 和写操作时序控制寄存器 FSMC_BWTRx。\r\n    */\r\n    readWriteTiming.FSMC_AddressSetupTime = 0x01; //地址建立时间 2 个 HCLK 1\r\n    readWriteTiming.FSMC_AddressHoldTime = 0x00; //地址保持时间模式 A 未用到\r\n    readWriteTiming.FSMC_DataSetupTime = 0x0f; // 数据保存时间为 16 个 HCLK\r\n    readWriteTiming.FSMC_BusTurnAroundDuration = 0x00;\r\n    readWriteTiming.FSMC_CLKDivision = 0x00;\r\n    readWriteTiming.FSMC_DataLatency = 0x00;\r\n    readWriteTiming.FSMC_AccessMode = FSMC_AccessMode_A; //模式 A\r\n\r\n    writeTiming.FSMC_AddressSetupTime = 0x00; //地址建立时间为 1 个 HCLK\r\n    writeTiming.FSMC_AddressHoldTime = 0x00; //地址保持时间（A\r\n    writeTiming.FSMC_DataSetupTime = 0x03; //数据保存时间为 4 个 HCLK\r\n    writeTiming.FSMC_BusTurnAroundDuration = 0x00;\r\n    writeTiming.FSMC_CLKDivision = 0x00;\r\n    writeTiming.FSMC_DataLatency = 0x00;\r\n    writeTiming.FSMC_AccessMode = FSMC_AccessMode_A; //模式 A\r\n\r\n    FSMC_NORSRAMInitStruct.FSMC_Bank = FSMC_Bank1_NORSRAM4; //我们是使用的存储块 1 区, 号 4\r\n    FSMC_NORSRAMInitStruct.FSMC_MemoryType = FSMC_MemoryType_SRAM;  // SRAM\r\n    FSMC_NORSRAMInitStruct.FSMC_MemoryDataWidth = FSMC_MemoryDataWidth_16b; // 这里我们是 16 位数据宽度\r\n\r\n    FSMC_NORSRAMInitStruct.FSMC_ExtendedMode = FSMC_ExtendedMode_Enable; // 读写使用不同的时序\r\n    FSMC_NORSRAMInitStruct.FSMC_ReadWriteTimingStruct = &readWriteTiming; // 读时序\r\n    FSMC_NORSRAMInitStruct.FSMC_WriteTimingStruct = &writeTiming; //写时序\r\n    FSMC_NORSRAMInitStruct.FSMC_WriteOperation = FSMC_WriteOperation_Enable; // 存储器写使能\r\n    FSMC_NORSRAMInitStruct.FSMC_DataAddressMux = FSMC_DataAddressMux_Disable; //不复用数据地址\r\n\r\n    /*     参 数 FSMC_BurstAccessMode ， FSMC_AsynchronousWait ， FSMC_WaitSignalPolarity ，\r\n    FSMC_WaitSignalActive ， FSMC_WrapMode ， FSMC_WaitSignal FSMC_WriteBurst 和FSMC_WaitSignal \r\n    这些参数在成组模式同步模式才需要设置，大家可以参考中文参考手册了解相关参数的意思。   */\r\n    FSMC_NORSRAMInitStruct.FSMC_BurstAccessMode=FSMC_BurstAccessMode_Disable; \r\n    FSMC_NORSRAMInitStruct.FSMC_WaitSignalPolarity = FSMC_WaitSignalPolarity_Low;\r\n    FSMC_NORSRAMInitStruct.FSMC_AsynchronousWait=FSMC_AsynchronousWait_Disable;\r\n    FSMC_NORSRAMInitStruct.FSMC_WrapMode = FSMC_WrapMode_Disable;\r\n    FSMC_NORSRAMInitStruct.FSMC_WaitSignalActive=FSMC_WaitSignalActive_BeforeWaitState;\r\n    FSMC_NORSRAMInitStruct.FSMC_WaitSignal = FSMC_WaitSignal_Disable;\r\n    FSMC_NORSRAMInitStruct.FSMC_WriteBurst = FSMC_WriteBurst_Disable;\r\n\r\n    FSMC_NORSRAMInit(&FSMC_NORSRAMInitStruct); // 初始化 FSMC 配置\r\n\r\n    // ④ FSMC 使能： FSMC_NORSRAMCmd()函数。\r\n    FSMC_NORSRAMCmd(FSMC_Bank1_NORSRAM4, ENABLE);\r\n    // ⑤ 同的 LCD 驱动器的初始化代码。\r\n   delay_ms(50); // delay 50 ms\r\n   // ... \r\n```\r\n\r\n从初始化代码可以看出， LCD 初始化步骤为①~⑤在代码中标注：  \r\n\r\n①GPIO,FSMC,AFIO 时钟使能。  \r\n②GPIO 初始化： GPIO_Init()函数。\r\n③FSMC 初始化： FSMC_NORSRAMInit()函数。\r\n④ FSMC 使能： FSMC_NORSRAMCmd()函数。\r\n⑤ 同的 LCD 驱动器的初始化代码。  \r\n\r\n该函数先对 FSMC 相关 IO 进行初始化，然后是 FSMC 的初始化，这个我们在前面都有介绍，最后根据读到的 LCD ID，对不同的驱动器执行不同的初始化代码， 从上面的代码可以看出，这个初始化函数可以针对十多款不同的驱动 IC 执行初始化操作，这样大大提高了整个程序的通用性。大家在以后的学习中应该多使用这样的方式，以提高程序的通用性、兼容性。\r\n**特别注意：** 本函数使用了 printf 来打印 LCD ID，所以，如果你在主函数里面没有初始化串口，那么将导致程序死在 printf 里面！！如果不想用 printf，那么请注释掉它。  \r\n\r\n#### 9. 主函数\r\n\r\n```c\r\nint main(void)\r\n{\r\n    u8 x=0;\r\n    u8 lcd_id[12]; //存放 LCD ID 字符串\r\n    delay_init(); //延时函数初始化\r\n    NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2); //设置 NVIC 中断分组 2\r\n    uart_init(115200); //串口初始化波特率为 115200\r\n    LED_Init(); //LED 端口初始化\r\n    LCD_Init();\r\n    POINT_COLOR=RED;\r\n    sprintf((char*)lcd_id,\"LCD ID:%04X\",lcddev.id);//将 LCD ID 打印到 lcd_id 数组。\r\n    while(1)\r\n    {\r\n        switch(x)\r\n        {\r\n            case 0:LCD_Clear(WHITE);break;\r\n            case 1:LCD_Clear(BLACK);break;\r\n            case 2:LCD_Clear(BLUE);break;\r\n            case 3:LCD_Clear(RED);break;\r\n            case 4:LCD_Clear(MAGENTA);break;\r\n            case 5:LCD_Clear(GREEN);break;\r\n            case 6:LCD_Clear(CYAN);break;\r\n            case 7:LCD_Clear(YELLOW);break;\r\n            case 8:LCD_Clear(BRRED);break;\r\n            case 9:LCD_Clear(GRAY);break;\r\n            case 10:LCD_Clear(LGRAY);break;\r\n            case 11:LCD_Clear(BROWN);break;\r\n        }\r\n        POINT_COLOR=RED;\r\n        LCD_ShowString(30,40,210,24,24,\" ELITE STM32 ^_^\");\r\n        LCD_ShowString(30,70,200,16,16,\"TFTLCD TEST\");\r\n        LCD_ShowString(30,90,200,16,16,\"ATOM@ALIENTEK\");\r\n        LCD_ShowString(30,110,200,16,16,lcd_id); //显示 LCD ID\r\n        LCD_ShowString(30,130,200,12,12,\"2014/5/4\");\r\n        x++;\r\n        if(x==12)x=0;\r\n        LED0=!LED0;\r\n        delay_ms(1000);\r\n    }\r\n}\r\n```\r\n\r\n该部分代码将显示一些固定的字符，字体大小包括 24*12、 16*8 和 12*6 等三种，同时显示LCD 驱动 IC 的型号，然后不停的切换背景颜色，每 1s 切换一次。而 LED0 也会不停的闪烁，指示程序已经在运行了。 其中我们用到一个 sprintf 的函数，该函数用法同 printf，只是 sprintf把打印内容输出到指定的内存区间上， sprintf 的详细用法，请百度。  \r\n\r\n![image-20210908232532891](cloudDisk/markdown/stm32笔记.assets/image-20210908232532891.png)\r\n\r\n# 十三、RTC\r\n\r\n## RTC 正常工作的一般配置步骤如下：\r\n\r\n### 1） 使能电源时钟和备份区域时钟。\r\n\r\n前面已经介绍了，我们要访问 RTC 和备份区域就必须先使能电源时钟和备份区域时钟。\r\nRCC_APB1PeriphClockCmd(RCC_APB1Periph_PWR | RCC_APB1Periph_BKP, ENABLE);\r\n\r\n### 2） 取消备份区写保护。\r\n\r\n要向备份区域写入数据，就要先取消备份区域写保护（写保护在每次硬复位之后被使能），\r\n否则是无法向备份区域写入数据的。我们需要用到向备份区域写入一个字节，来标记时钟已经\r\n配置过了，这样避免每次复位之后重新配置时钟。 取消备份区域写保护的库函数实现方法是：\r\nPWR_BackupAccessCmd(ENABLE); //使能 RTC 和后备寄存器访问\r\n\r\n### 3） 复位备份区域，开启外部低速振荡器。\r\n\r\n在取消备份区域写保护之后，我们可以先对这个区域复位，以清除前面的设置，当然这个\r\n操作不要每次都执行，因为备份区域的复位将导致之前存在的数据丢失，所以要不要复位，要\r\n看情况而定。然后我们使能外部低速振荡器，注意这里一般要先判断 RCC_BDCR 的 LSERDY\r\n位来确定低速振荡器已经就绪了才开始下面的操作。\r\n备份区域复位的函数是：\r\nBKP_DeInit();//复位备份区域\r\n开启外部低速振荡器的函数是：\r\nRCC_LSEConfig(RCC_LSE_ON);// 开启外部低速振荡器\r\n\r\n### 4） 选择 RTC 时钟，并使能。\r\n\r\n这里我们将通过 RCC_BDCR 的 RTCSEL 来选择选择外部 LSI 作为 RTC 的时钟。然后通过\r\nRTCEN 位使能 RTC 时钟。\r\n库函数中，选择 RTC 时钟的函数是：\r\nRCC_RTCCLKConfig(RCC_RTCCLKSource_LSE); //选择 LSE 作为 RTC 时钟\r\n对于 RTC 时钟的选择，还有 RCC_RTCCLKSource_LSI 和 RCC_RTCCLKSource_HSE_Div128\r\n两个，顾名思义，前者为 LSI，后者为 HSE 的 128 分频，这在时钟系统章节有讲解过。\r\n使能 RTC 时钟的函数是：\r\nRCC_RTCCLKCmd(ENABLE); //使能 RTC 时钟\r\n\r\n### 5） 设置 RTC 的分频，以及配置 RTC 时钟。\r\n\r\n在开启了 RTC 时钟之后，我们要做的就是设置 RTC 时钟的分频数，通过 RTC_PRLH 和\r\nRTC_PRLL 来设置，然后等待 RTC 寄存器操作完成，并同步之后，设置秒钟中断。然后设置\r\nRTC 的允许配置位（RTC_CRH 的 CNF 位），设置时间（其实就是设置 RTC_CNTH 和 RTC_CNTL\r\n两个寄存器）。 下面我们一一这些步骤用到的库函数：\r\n在进行 RTC 配置之前首先要打开允许配置位(CNF)，库函数是：\r\nRTC_EnterConfigMode();/// 允许配置\r\n在配置完成之后，千万别忘记更新配置同时退出配置模式，函数是：\r\nRTC_ExitConfigMode();//退出配置模式， 更新配置\r\n设置 RTC 时钟分频数， 库函数是：\r\nvoid RTC_SetPrescaler(uint32_t PrescalerValue);\r\n这个函数只有一个入口参数，就是 RTC 时钟的分频数，很好理解。\r\n然后是设置秒中断允许， RTC 使能中断的函数是：\r\nvoid RTC_ITConfig(uint16_t RTC_IT, FunctionalState NewState)；\r\n这个函数的第一个参数是设置秒中断类型，这些通过宏定义定义的。 对于使能秒中断方法是：\r\nRTC_ITConfig(RTC_IT_SEC, ENABLE); //使能 RTC 秒中断\r\n\r\nALIENTEK 精英 STM32F103 V1 开发板教程\r\n\r\n300\r\nSTM32F1 开发指南（精英板-库函数版)\r\n下一步便是设置时间了，设置时间实际上就是设置 RTC 的计数值，时间与计数值之间是需要换\r\n算的。库函数中设置 RTC 计数值的方法是：\r\nvoid RTC_SetCounter(uint32_t CounterValue)最后在配置完成之后\r\n通过这个函数直接设置 RTC 计数值。\r\n\r\n### 6） 更新配置，设置 RTC 中断分组。\r\n\r\n在设置完时钟之后，我们将配置更新同时退出配置模式，这里还是通过 RTC_CRH 的 CNF\r\n来实现。 库函数的方法是：\r\nRTC_ExitConfigMode();//退出配置模式，更新配置\r\n在退出配置模式更新配置之后我们在备份区域 BKP_DR1 中写入 0X5050 代表我们已经初始化\r\n过时钟了，下次开机（或复位）的时候，先读取 BKP_DR1 的值，然后判断是否是 0X5050 来\r\n决定是不是要配置。接着我们配置 RTC 的秒钟中断，并进行分组。\r\n往备份区域写用户数据的函数是：\r\nvoid BKP_WriteBackupRegister(uint16_t BKP_DR, uint16_t Data)；\r\n这个函数的第一个参数就是寄存器的标号了，这个是通过宏定义定义的。 比如我们要往\r\nBKP_DR1 写入 0x5050，方法是：\r\nBKP_WriteBackupRegister(BKP_DR1, 0X5050);\r\n同时，有写便有读，读取备份区域指定寄存器的用户数据的函数是：\r\nuint16_t BKP_ReadBackupRegister(uint16_t BKP_DR)；\r\n这个函数就很好理解了，这里不做过多讲解。\r\n设置中断分组的方法之前已经详细讲解过， 调用 NVIC_Init 函数即可， 这里不做重复讲解。\r\n\r\n### 7） 编写中断服务函数。\r\n\r\n最后，我们要编写中断服务函数，在秒钟中断产生的时候，读取当前的时间值，并显示到\r\nTFTLCD 模块上。\r\n通过以上几个步骤，我们就完成了对 RTC 的配置，并通过秒钟中断来更新时间。接下来我\r\n们将进行下一步的工作。\r\n\r\n\r\n\r\n## 初始化函数\r\n\r\n```c\r\n//BKP->DR1 用于保存是否第一次配置的设置\r\n//返回 0:正常\r\n//其他:错误代码\r\nu8 RTC_Init(void)\r\n{\r\n    u8 temp=0;\r\n    //检查是不是第一次配置时钟\r\n    RCC_APB1PeriphClockCmd(RCC_APB1Periph_PWR |\r\n    RCC_APB1Periph_BKP, ENABLE); //①使能 PWR 和 BKP 外设时钟\r\n    PWR_BackupAccessCmd(ENABLE); //②使能后备寄存器访问\r\n    if (BKP_ReadBackupRegister(BKP_DR1) != 0x5050) //从指定的后备寄存器中\r\n    //读出数据:读出了与写入的指定数据不相乎\r\n        {\r\n        BKP_DeInit(); //③复位备份区域\r\n        RCC_LSEConfig(RCC_LSE_ON); //设置外部低速晶振(LSE)\r\n        while (RCC_GetFlagStatus(RCC_FLAG_LSERDY) == RESET&&temp<250)\r\n        //检查指定的 RCC 标志位设置与否,等待低速晶振就绪\r\n        {\r\n            temp++;\r\n            delay_ms(10);\r\n        }\r\n        if(temp>=250)return 1;//初始化时钟失败,晶振有问题\r\n        RCC_RTCCLKConfig(RCC_RTCCLKSource_LSE); //设置 RTC 时钟\r\n        //(RTCCLK),选择 LSE 作为 RTC 时钟\r\n        RCC_RTCCLKCmd(ENABLE); //使能 RTC 时钟\r\n        RTC_WaitForLastTask(); //等待最近一次对 RTC 寄存器的写操作完成\r\n        RTC_WaitForSynchro(); //等待 RTC 寄存器同步\r\n        RTC_ITConfig(RTC_IT_SEC, ENABLE); //使能 RTC 秒中断\r\n        RTC_WaitForLastTask(); //等待最近一次对 RTC 寄存器的写操作完成\r\n        RTC_EnterConfigMode(); // 允许配置\r\n        RTC_SetPrescaler(32767); //设置 RTC 预分频的值\r\n        RTC_WaitForLastTask(); //等待最近一次对 RTC 寄存器的写操作完成\r\n        RTC_Set(2015,1,14,17,42,55); //设置时间\r\n        RTC_ExitConfigMode(); //退出配置模式\r\n        BKP_WriteBackupRegister(BKP_DR1, 0X5050); //向指定的后备寄存器中\r\n        //写入用户程序数据 0x5050\r\n    }\r\n    else//系统继续计时\r\n    {\r\n        RTC_WaitForSynchro(); //等待最近一次对 RTC 寄存器的写操作完成\r\n        RTC_ITConfig(RTC_IT_SEC, ENABLE); //使能 RTC 秒中断\r\n        RTC_WaitForLastTask(); //等待最近一次对 RTC 寄存器的写操作完成\r\n    }\r\n    RTC_NVIC_Config(); //RCT 中断分组设置\r\n    RTC_Get(); //更新时间\r\n    return 0; //ok\r\n}\r\n```\r\n\r\n该函数用来初始化 RTC 时钟，但是只在第一次的时候设置时间，以后如果重新上电/复位\r\n都不会再进行时间设置了（前提是备份电池有电），在第一次配置的时候，我们是按照上面介绍\r\n的RTC初始化步骤来做的，这里就不在多说了，这里我们设置时间是通过时间设置函数RTC_Set\r\n函数来实现的， 该函数将在后续进行介绍。 这里我们默认将时间设置为 2015 年 1 月 14 日， 17\r\n点 42 分 55 秒。在设置好时间之后，我们通过 BKP_WriteBackupRegister()函数向 BKP->DR1 写\r\n入标志字 0X5050，用于标记时间已经被设置了。这样，再次发生复位的时候，该函数通过\r\nBKP_ReadBackupRegister()读取 BKP->DR1 的值，来判断决定是不是需要重新设置时间，如果\r\n不需要设置，则跳过时间设置，仅仅使能秒钟中断一下，就进行中断分组，然后返回了。这样\r\n不会重复设置时间，使得我们设置的时间不会因复位或者断电而丢失。\r\n该函数还有返回值，返回值代表此次操作的成功与否，如果返回 0，则代表初始化 RTC 成\r\n功，如果返回值非零则代表错误代码了。  \r\n\r\n## RTC_Set 函数 ,用来设置时钟\r\n\r\n```c\r\n//设置时钟\r\n//把输入的时钟转换为秒钟\r\n//以 1970 年 1 月 1 日为基准\r\n//1970~2099 年为合法年份\r\n//返回值:0,成功;其他:错误代码.\r\n//月份数据表\r\nu8 const table_week[12]={0,3,3,6,1,4,6,2,5,0,3,5}; //月修正数据表\r\n//平年的月份日期表\r\nconst u8 mon_table[12]={31,28,31,30,31,30,31,31,30,31,30,31};\r\nu8 RTC_Set(u16 syear,u8 smon,u8 sday,u8 hour,u8 min,u8 sec)\r\n{\r\n    u16 t;\r\n    u32 seccount=0;\r\n    if(syear<1970||syear>2099)return 1;\r\n    for(t=1970;t<syear;t++) //把所有年份的秒钟相加\r\n    { \r\n        if(Is_Leap_Year(t))seccount+=31622400;//闰年的秒钟数\r\n        else seccount+=31536000; //平年的秒钟数\r\n    }\r\n        smon-=1;\r\n        for(t=0;t<smon;t++) //把前面月份的秒钟数相加\r\n        { seccount+=(u32)mon_table[t]*86400; //月份秒钟数相加\r\n        if(Is_Leap_Year(syear)&&t==1)seccount+=86400;//闰年 2 月份增加一天的秒钟数\r\n    }\r\n    seccount+=(u32)(sday-1)*86400; //把前面日期的秒钟数相加\r\n    seccount+=(u32)hour*3600; //小时秒钟数\r\n    seccount+=(u32)min*60; //分钟秒钟数\r\n    seccount+=sec; //最后的秒钟加上去\r\n    RCC_APB1PeriphClockCmd(RCC_APB1Periph_PWR |\r\n    RCC_APB1Periph_BKP, ENABLE); //使能 PWR 和 BKP 外设时钟\r\n    PWR_BackupAccessCmd(ENABLE); //使能 RTC 和后备寄存器访问\r\n    RTC_SetCounter(seccount); //设置 RTC 计数器的值\r\n    RTC_WaitForLastTask(); //等待最近一次对 RTC 寄存器的写操作完成\r\n    return 0;\r\n}\r\n```\r\n\r\n## RTC_Get 函数，该函数用于获取时间和日期等数据  \r\n\r\n```c\r\n//得到当前的时间，结果保存在 calendar 结构体里面\r\n//返回值:0,成功;其他:错误代码.\r\nu8 RTC_Get(void)\r\n{ \r\n	static u16 daycnt=0;\r\n    u32 timecount=0;\r\n    u32 temp=0;\r\n    u16 temp1=0;\r\n    timecount=RTC->CNTH; //得到计数器中的值(秒钟数)\r\n    timecount<<=16;\r\n    timecount+=RTC->CNTL;\r\n    temp=timecount/86400; //得到天数(秒钟数对应的)\r\n    if(daycnt!=temp) //超过一天了\r\n    {\r\n        daycnt=temp;\r\n        temp1=1970; //从 1970 年开始\r\n        while(temp>=365)\r\n        {\r\n            if(Is_Leap_Year(temp1)) //是闰年\r\n            {\r\n                if(temp>=366)temp-=366; //闰年的秒钟数\r\n                else break;\r\n            }\r\n            else temp-=365; //平年\r\n            temp1++;\r\n        }\r\n        calendar.w_year=temp1; //得到年份\r\n        temp1=0;\r\n        while(temp>=28) //超过了一个月\r\n        {\r\n            if(Is_Leap_Year(calendar.w_year)&&temp1==1)//当年是不是闰年/2 月份\r\n                {\r\n                    if(temp>=29)temp-=29;//闰年的秒钟数\r\n                    else break;\r\n                }\r\n            else\r\n                { \r\n                    if(temp>=mon_table[temp1])temp-=mon_table[temp1];//平年\r\n                    else break;\r\n                }\r\n                temp1++;\r\n            }\r\n            calendar.w_month=temp1+1; //得到月份\r\n            calendar.w_date=temp+1; //得到日期\r\n    }\r\n    temp=timecount%86400; //得到秒钟数\r\n    calendar.hour=temp/3600; //小时\r\n    calendar.min=(temp%3600)/60; //分钟\r\n    calendar.sec=(temp%3600)%60; //秒钟\r\n    calendar.week=RTC_Get_Week(calendar.w_year,calendar.w_month,calendar.w_date);\r\n    //获取星期\r\n    return 0;\r\n}\r\n```\r\n\r\n函数其实就是将存储在秒钟寄存器 RTC->CNTH 和 RTC->CNTL 中的秒钟数据(通过函数\r\nRTC_SetCounter 设置)转换为真正的时间和日期。该代码还用到了一个 calendar 的结构体，\r\ncalendar 是我们在 rtc.h 里面将要定义的一个时间结构体，用来存放时钟的年月日时分秒等信息。\r\n因为 STM32 的 RTC 只有秒钟计数器，而年月日，时分秒这些需要我们自己软件计算。我们把\r\n计算好的值保存在 calendar 里面，方便其他程序调用。  \r\n\r\n## 秒钟中断服务函数  \r\n\r\n```c\r\n//RTC 时钟中断\r\n//每秒触发一次\r\nvoid RTC_IRQHandler(void)\r\n{\r\n    if (RTC_GetITStatus(RTC_IT_SEC) != RESET) //秒钟中断\r\n    {\r\n    	RTC_Get(); //更新时间\r\n    }\r\n    if(RTC_GetITStatus(RTC_IT_ALR)!= RESET) //闹钟中断\r\n    {\r\n        RTC_ClearITPendingBit(RTC_IT_ALR); //清闹钟中断\r\n        RTC_Get(); //更新时间\r\n        printf(\"Alarm Time:%d-%d-%d %d:%d:%d\\n\",calendar.w_year,calendar.w_month,\r\n        calendar.w_date,calendar.hour,calendar.min,calendar.sec);//输出闹铃时间\r\n   	}\r\n    RTC_ClearITPendingBit(RTC_IT_SEC|RTC_IT_OW); //清闹钟中断\r\n    RTC_WaitForLastTask();\r\n}\r\n```\r\n\r\n通过 RTC_GetITStatus 来判断发生的是何种中断，如果是秒钟\r\n中断，则执行一次时间的计算，获得最新时间，结果保存在 calendar 结构体里面，因此，我们\r\n可以在 calendar 里面读到最新的时间、日期等信息。如果是闹钟中断，则更新时间后，将当前\r\n的闹铃时间通过 printf 打印出来，可以在串口调试助手看到当前的闹铃情况。\r\nrtc.c 的其他程序，这里就不再介绍了，请大家直接看光盘的源码。 接下来看看 rtc.h 代码，\r\n在 rtc.h 中，我们定义了一个结构体：  \r\n\r\n```c\r\ntypedef struct\r\n{\r\n    vu8 hour;\r\n    vu8 min;\r\n    vu8 sec;\r\n    //公历日月年周\r\n    vu16 w_year;\r\n    vu8 w_month;\r\n    vu8 w_date;\r\n    vu8 week;\r\n}_calendar_obj;\r\n```\r\n\r\n从上面结构体定义可以看到_calendar_obj 结构体所包含的成员变量是一个完整的公历信\r\n息，包括年、月、日、周、时、分、秒等 7 个元素。  \r\n\r\n## main函数\r\n\r\n```c\r\n#include \"stm32f10x.h\"\r\n#include \"delay.h\"\r\n#include \"sys.h\"\r\n#include \"usart.h\"\r\n#include \"led.h\"\r\n#include \"lcd.h\"\r\n#include \"key.h\"\r\n#include \"rtc.h\"\r\n\r\nint main(void){\r\n    u8 t=0;\r\n    delay_init(); //延时函数初始化\r\n    NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);//设置 NVIC 中断分组 2\r\n    uart_init(115200); //串口初始化波特率为 115200\r\n    LED_Init(); //LED 端口初始化\r\n    LCD_Init(); //LCD 初始化\r\n    while(RTC_Init()) //RTC 初始化 ，一定要初始化成功\r\n    { \r\n        LCD_ShowString(60,130,200,16,16,\"RTC ERROR! \");\r\n        delay_ms(800);\r\n        LCD_ShowString(60,130,200,16,16,\"RTC Trying...\");\r\n    }\r\n    //显示时间\r\n    POINT_COLOR=BLUE; //设置字体为蓝色\r\n    while(1)\r\n    {\r\n        if(t!=calendar.sec)\r\n        {\r\n            t=calendar.sec;\r\n            LCD_ShowNum(60,130,calendar.w_year,4,16);\r\n            LCD_ShowNum(100,130,calendar.w_month,2,16);\r\n            LCD_ShowNum(124,130,calendar.w_date,2,16);\r\n            switch(calendar.week)\r\n            {\r\n                case 0:LCD_ShowString(60,148,200,16,16,\"Sunday \");\r\n                break;\r\n                case 1:LCD_ShowString(60,148,200,16,16,\"Monday \");\r\n                break;\r\n                case 2:LCD_ShowString(60,148,200,16,16,\"Tuesday \");\r\n                break;\r\n                case 3:LCD_ShowString(60,148,200,16,16,\"Wednesday\");\r\n                break;\r\n                case 4:LCD_ShowString(60,148,200,16,16,\"Thursday \");\r\n                break;\r\n                case 5:LCD_ShowString(60,148,200,16,16,\"Friday \");\r\n                break;\r\n                case 6:LCD_ShowString(60,148,200,16,16,\"Saturday \");\r\n                break;\r\n            }\r\n            LCD_ShowNum(60,162,calendar.hour,2,16);\r\n            LCD_ShowNum(84,162,calendar.min,2,16);\r\n            LCD_ShowNum(108,162,calendar.sec,2,16);\r\n        }\r\n        delay_ms(10);\r\n    };\r\n}\r\n```\r\n\r\n# 十四、待机唤醒实验\r\n\r\n## 相关寄存器\r\n\r\n### 电源控制寄存器（PWR_CR）  \r\n\r\n![image-20211009213442935](cloudDisk/markdown/stm32笔记.assets/image-20211009213442935.png)\r\n\r\n![image-20211009213459336](cloudDisk/markdown/stm32笔记.assets/image-20211009213459336.png)\r\n\r\n### 电源控制/状态寄存器（PWR_CSR）  \r\n\r\n![image-20211009213518505](cloudDisk/markdown/stm32笔记.assets/image-20211009213518505.png)\r\n\r\n![image-20211009213524859](cloudDisk/markdown/stm32笔记.assets/image-20211009213524859.png)\r\n\r\n我们通过设置 PWR_CSR 的 EWUP 位，来使能 WKUP 引脚用于待机模式唤醒。我\r\n们还可以从 WUF 来检查是否发生了唤醒事件。  \r\n\r\n## 配置步骤\r\n\r\n### 1） 使能电源时钟。\r\n\r\n因为要配置电源控制寄存器，所以必须先使能电源时钟。\r\n在库函数中，使能电源时钟的方法是：\r\n\r\n```c\r\nRCC_APB1PeriphClockCmd(RCC_APB1Periph_PWR, ENABLE); //使能 PWR 外设时\r\n```\r\n\r\n### 2) 设置 WK_UP 引脚作为唤醒源。\r\n\r\n使能时钟之后后再设置 PWR_CSR 的 EWUP 位，使能 WK_UP 用于将 CPU 从待机模式唤\r\n醒。 在库函数中，设置使能 WK_UP 用于唤醒 CPU 待机模式的函数是：  \r\n\r\n```c\r\nPWR_WakeUpPinCmd(ENABLE); //使能唤醒管脚功能\r\n```\r\n\r\n### 3） 设置 SLEEPDEEP 位， 设置 PDDS 位，执行 WFI 指令，进入待机模式。\r\n\r\n进入待机模式， 首先要设置 SLEEPDEEP 位（该位在系统控制寄存器（SCB_SCR）的第\r\n二位，详见《CM3 权威指南》，第 182 页表 13.1）， 接着我们通过 PWR_CR 设置 PDDS 位，使\r\n得 CPU 进入深度睡眠时进入待机模式，最后执行 WFI 指令开始进入待机模式，并等待 WK_UP\r\n中断的到来。在库函数中，进行上面三个功能进入待机模式是在函数 PWR_EnterSTANDBYMode\r\n中实现的：\r\n\r\n```c\r\nvoid PWR_EnterSTANDBYMode(void)；\r\n```\r\n\r\n\r\n\r\n### 4） 最后编写 WK_UP  中断函数。\r\n\r\n因为我们通过 WK_UP 中断（PA0 中断）来唤醒 CPU，所以我们有必要设置一下该中断函\r\n数，同时我们也通过该函数里面进入待机模式。\r\n通过以上几个步骤的设置，我们就可以使用 STM32 的待机模式了，并且可以通过 WK_UP\r\n来唤醒 CPU，我们最终要实现这样一个功能：通过长按（3 秒） WK_UP 按键开机，并且通过\r\nDS0 的闪烁指示程序已经开始运行，再次长按该键，则进入待机模式， DS0 关闭，程序停止运\r\n行。类似于手机的开关机  \r\n\r\n## 思路\r\n\r\n进入待机模式：\r\n\r\n1. 将A0映射到外部中断0\r\n2. 编写外部中断0函数，该函数功能：清楚外部中断标志位，按键检测判断是否按满3秒，进入待机模式\r\n\r\n唤醒CPU：\r\n\r\n1. A0接收到信号会自动唤醒，在初始化程序中，把GPIOA. 0设置为上拉输入\r\n2. 判断A0是否按下三秒？\r\n3. 是：执行下面代码\r\n4. 否：进入待机模式\r\n\r\n## 程序设计\r\n\r\n引入的库函数\r\n\r\n```c\r\n#include \"stm32f10x.h\"\r\n#include \"delay.h\"\r\n#include \"usart.h\"\r\n#include \"lcd.h\"\r\n#include \"led.h\"\r\n#include \"sys.h\" \r\n#include \"key.h\"\r\n#define keyUp GPIO_ReadInputDataBit(GPIOA,GPIO_Pin_0)\r\n```\r\n\r\nGPIOA.0 映射到外部中断0\r\n\r\n```c\r\nvoid keyInterruptInit(void)\r\n{\r\n	// GPIOE.3 - KEY1 - EXTI3\r\n	// GPIOE.4 - KEY0 - EXTI4\r\n	// GPIOA.0 - KEYUP - EXTI0\r\n	\r\n	EXTI_InitTypeDef EXTI_InitStruct;\r\n 	NVIC_InitTypeDef NVIC_InitStructure;\r\n	\r\n	// 1）初始化 IO 口为输入。\r\n	KEY_Init();\r\n	\r\n	// 2）开启 AFIO 时钟\r\n	RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO,ENABLE);\r\n	\r\n	// 3） 设置 IO 口与中断线的映射关系。\r\n	GPIO_EXTILineConfig(GPIO_PortSourceGPIOA,GPIO_PinSource0); // GPIOA.0 映射到 外部中断线0\r\n	\r\n	// 4）初始化线上中断，设置触发条件等。\r\n	EXTI_InitStruct.EXTI_Line = EXTI_Line0; // 初始化外部中断线0、3、4\r\n	EXTI_InitStruct.EXTI_Mode = EXTI_Mode_Interrupt;\r\n	EXTI_InitStruct.EXTI_Trigger = EXTI_Trigger_Rising; // 上升沿触发\r\n	EXTI_Init(&EXTI_InitStruct);\r\n	\r\n	\r\n	// 5）配置中断分组（NVIC），并使能中断。\r\n	// 定义初始化的是哪个中断，这个我们可以在 stm32f10x.h 中找到每个中断对应的名字。例如 EXTI0_IRQn。\r\n	NVIC_InitStructure.NVIC_IRQChannel = EXTI0_IRQn;\r\n	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;\r\n	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0x02; // 设置抢占优先级2\r\n	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0x02; //子优先级 2\r\n	NVIC_Init(&NVIC_InitStructure);\r\n}\r\n```\r\n\r\n进入待机模式\r\n\r\n```c\r\nvoid standby(void){\r\n    printf(\"standby method\");\r\n    // 复位所有GPIO\r\n    RCC_APB2PeriphResetCmd(0X01FC,DISABLE); //复位所有 IO 口\r\n    RCC_APB1PeriphClockCmd(RCC_APB1Periph_PWR, ENABLE); //使能PWR外设时钟\r\n    PWR_WakeUpPinCmd(ENABLE); //使能唤醒管脚功能\r\n    // 进入待机模式\r\n    PWR_EnterSTANDBYMode(); //进入待命（STANDBY）模式\r\n}\r\n```\r\n\r\n外部中断0服务函数\r\n\r\n```c\r\nvoid EXTI0_IRQHandler(void){\r\n    printf(\"press A0\");\r\n    // 判断是否按满3秒\r\n    if (is_keyup_pushed_for_three_sec()){\r\n        // 待机模式\r\n        standby();\r\n    }\r\n    EXTI_ClearITPendingBit(EXTI_Line0); //清除 LINE 上的中断标志位\r\n}\r\n\r\n```\r\n\r\n判断KEYUP是否按下2秒，并且led闪烁\r\n\r\n```c\r\nint is_keyup_pushed_for_three_sec(void){\r\n/*     static u8 key_up=1;//按键按松开标志		  \r\n    printf(\"is_keyup_pushed_for_three_sec method\");\r\n	if(key_up&&(WK_UP==1))\r\n	{\r\n		delay_ms(3000);\r\n		key_up=0;\r\n		if(WK_UP==1)return 1;\r\n	}else if(WK_UP==0)key_up=1; 	    \r\n 	return 0;// 无按键按下 */\r\n    u8 t = 0;\r\n    while (1)\r\n    {\r\n        if(WK_UP){\r\n            delay_ms(30);\r\n            t++;\r\n            if (t%10 == 0){\r\n                LED0 = !LED0;\r\n            }\r\n            if (t>100){\r\n                return 1;\r\n            }\r\n            \r\n        }\r\n        else{\r\n            t = 0;\r\n            return 0;\r\n        }\r\n        \r\n    }\r\n    \r\n}\r\n```\r\n\r\n唤醒初始化函数\r\n\r\n```java\r\nvoid wakeUp_init(void){\r\n    // A0映射到外部中断0\r\n	// GPIOA.0 - KEYUP - EXTI0\r\n    keyInterruptInit();\r\n    // 初始化判断keyup按键是否持续按了3秒，没有则继续待机\r\n    if(!is_keyup_pushed_for_three_sec()){\r\n        standby();\r\n        // 去抖动\r\n        delay_ms(50);\r\n    }\r\n}\r\n```\r\n\r\n主函数\r\n\r\n```c\r\nint main(void)\r\n {		\r\n	delay_init();	    	 //延时函数初始化	  \r\n	NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2); //设置NVIC中断分组2:2位抢占优先级，2位响应优先级 	\r\n	uart_init(115200);\r\n    KEY_Init();\r\n	wakeUp_init();         	//初始化外部中断输入 \r\n    LED_Init();\r\n    LCD_Init();\r\n    \r\n    POINT_COLOR=BLUE;\r\n    LCD_ShowString(0,0,200,16,16,\"CPU is running!!!\");\r\n	while(1)\r\n	{	    \r\n		delay_ms(1000);	  \r\n	}	 \r\n}\r\n\r\n```\r\n\r\n# 十五、ADC（采样模拟信号）\r\n\r\n## csdn文档\r\n\r\nhttps://blog.csdn.net/qq_43743762/article/details/100067558?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522163395559616780264097739%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=163395559616780264097739&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-100067558.first_rank_v2_pc_rank_v29&utm_term=stm32+adc%E8%AF%A6%E8%A7%A3&spm=1018.2226.3001.4187\r\n\r\n## 简介\r\n\r\nSTM32 将 ADC 的转换分为 2 个通道组：规则通道组和注入通道组。规则通道相当于你正\r\n常运行的程序，而注入通道呢，就相当于中断。  \r\n\r\n以规则通道为例，一旦所选择的通道转换完成，转换结果将被存在 ADC_DR 寄存器中，\r\nEOC（转换结束）标志将被置位，如果设置了 EOCIE，则会产生中断。然后 ADC 将停止，直\r\n到下次启动。  \r\n\r\n## 相关寄存器\r\n\r\n### ADC_CR1\r\n\r\n![image-20211011154724422](cloudDisk/markdown/stm32笔记.assets/image-20211011154724422.png)\r\n\r\nADC_CR1 的 SCAN 位，该位用于设置扫描模式，由软件设置和清除，如果设置为 1，则\r\n使用扫描模式，如果为 0，则关闭扫描模式。在扫描模式下，由 ADC_SQRx 或 ADC_JSQRx 寄\r\n存器选中的通道被转换。如果设置了 EOCIE 或 JEOCIE，只在最后一个通道转换完毕后才会产\r\n生 EOC 或 JEOC 中断。  \r\n\r\n![image-20211011154816287](cloudDisk/markdown/stm32笔记.assets/image-20211011154816287.png)\r\n\r\n### ADC_CR2\r\n\r\n![image-20211011154908543](cloudDisk/markdown/stm32笔记.assets/image-20211011154908543.png)\r\n\r\nADON 位用于开关 AD 转换器。而 CONT 位用于\r\n设置是否进行连续转换，我们使用单次转换，所以 CONT 位必须为 0。 CAL 和 RSTCAL 用于\r\nAD 校准。 ALIGN 用于设置数据对齐，我们使用右对齐，该位设置为 0。  \r\n\r\n![image-20211011154950127](cloudDisk/markdown/stm32笔记.assets/image-20211011154950127.png)\r\n\r\n我们这里使用的是软件触发（ SWSTART），所以设置这 3 个位为 111。 ADC_CR2 的\r\nSWSTART 位用于开始规则通道的转换，我们每次转换（单次转换模式下）都需要向该位写 1。\r\nAWDEN 为用于使能温度传感器和 Vrefint。   \r\n\r\n### 采样事件寄存器   ADC_SMPR1 和 ADC_SMPR2\r\n\r\n这两个寄存器\r\n用于设置通道 0~17 的采样时间，每个通道占用 3 个位。   \r\n\r\n![image-20211011155249189](cloudDisk/markdown/stm32笔记.assets/image-20211011155249189.png)\r\n\r\n![image-20211011155321915](cloudDisk/markdown/stm32笔记.assets/image-20211011155321915.png)\r\n\r\n![image-20211011155339635](cloudDisk/markdown/stm32笔记.assets/image-20211011155339635.png)\r\n\r\n对于每个要转换的通道，采样时间建议尽量长一点，以获得较高的准确度，但是这样会降\r\n低 ADC 的转换速率。 ADC 的转换时间可以由以下公式计算：  \r\n\r\n```\r\nTcovn=采样时间+12.5 个周期  \r\n```\r\n\r\n其中： Tcovn 为总转换时间，采样时间是根据每个通道的 SMP 位的设置来决定的。例如，\r\n当 ADCCLK=14Mhz 的时候，并设置 1.5 个周期的采样时间，则得到： Tcovn=1.5+12.5=14 个周\r\n期=1us。  \r\n\r\n### ADC 规则序列寄存器（ADC_SQR1~3）  \r\n\r\n![image-20211011155626291](cloudDisk/markdown/stm32笔记.assets/image-20211011155626291.png)\r\n\r\nL[3： 0]用于存储规则序列的长度，我们这里只用了 1 个，所以设置这几个位的值为 0。其\r\n他的 SQ13~16 则存储了规则序列中第 13~16 个通道的编号（0~17）。另外两个规则序列寄存器  同 ADC_SQR1 大同小异，我们这里就不再介绍了，要说明一点的是：我们选择的是单次转换，\r\n所以只有一个通道在规则序列里面，这个序列就是 SQ1，通过 ADC_SQR3 的最低 5 位（也就\r\n是 SQ1） 设置。  \r\n\r\n### ADC 规则数据寄存器(ADC_DR)\r\n\r\n规则序列中的 AD 转化结果都将被存\r\n在这个寄存器里面，而注入通道的转换结果被保存在 ADC_JDRx 里面。   \r\n\r\n![image-20211011155846458](cloudDisk/markdown/stm32笔记.assets/image-20211011155846458.png)\r\n\r\n该寄存器的数据可以通过 ADC_CR2 的 ALIGN 位设置左对齐还是\r\n右对齐。在读取数据的时候要注意。  \r\n\r\n### ADC 寄存器为 ADC 状态寄存器（ADC_SR）  \r\n\r\n![image-20211011155929592](cloudDisk/markdown/stm32笔记.assets/image-20211011155929592.png)\r\n\r\n这里我们要用到的是 EOC 位，我们通过判断该位来决定是否此次规则通道的 AD 转换已经\r\n完成，如果完成我们就从 ADC_DR 中读取转换结果，否则等待转换完成。  \r\n\r\n## 配置步骤\r\n\r\n### 1） 开启 PA 口时钟和 ADC1 时钟，设置 PA1 为模拟输入。\r\n\r\nSTM32F103ZET6 的 ADC 通道 1 在 PA1 上，所以，我们先要使能 PORTA 的时钟和 ADC1\r\n时钟， 然后设置 PA1 为模拟输入。 使能 GPIOA 和 ADC 时钟用 RCC_APB2PeriphClockCmd 函\r\n数，设置 PA1 的输入方式，使用 GPIO_Init 函数即可。 这里我们列出 STM32 的 ADC 通道与\r\nGPIO 对应表：  \r\n\r\n![image-20211011160031154](cloudDisk/markdown/stm32笔记.assets/image-20211011160031154.png)\r\n\r\n### 2） 复位 ADC1，同时设置 ADC1 分频因子。\r\n\r\n开启 ADC1 时钟之后，我们要复位 ADC1， 将 ADC1 的全部寄存器重设为缺省值之后我们\r\n就可以通过 RCC_CFGR 设置 ADC1 的分频因子。分频因子要确保 ADC1 的时钟（ADCCLK）\r\n不要超过 14Mhz。 这个我们设置分频因子位 6， 时钟为 72/6=12MHz,库函数的实现方法是:\r\n\r\n```c\r\nRCC_ADCCLKConfig(RCC_PCLK2_Div6);\r\n```\r\n\r\nADC 时钟复位的方法是：\r\n\r\n```c\r\nADC_DeInit(ADC1);\r\n```\r\n\r\n这个函数非常容易理解，就是复位指定的 ADC。\r\n\r\n### 3） 初始化 ADC1 参数， 设置 ADC1 的工作模式以及规则序列的相关信息。\r\n\r\n在设置完分频因子之后，我们就可以开始 ADC1 的模式配置了，设置**单次转换模式、触发**\r\n**方式选择、数据对齐方式等**都在这一步实现。 同时，我们还要设置 ADC1 规则序列的相关信息，\r\n我们这里只有一个通道，并且是单次转换的，所以设置规则序列中通道数为 1。 这些在库函数\r\n中是通过函数 ADC_Init 实现的，下面我们看看其定义：\r\n\r\n```c\r\nvoid ADC_Init(ADC_TypeDef* ADCx, ADC_InitTypeDef* ADC_InitStruct)；\r\n```\r\n\r\n从函数定义可以看出，第一个参数是指定 ADC 号。这里我们来看看第二个参数，跟其他外设\r\n初始化一样，同样是通过设置结构体成员变量的值来设定参数。\r\n\r\n```c\r\ntypedef struct\r\n{\r\n    uint32_t ADC_Mode;\r\n    FunctionalState ADC_ScanConvMode;\r\n    FunctionalState ADC_ContinuousConvMode;\r\n    uint32_t ADC_ExternalTrigConv;\r\n    uint32_t ADC_DataAlign;\r\n    uint8_t ADC_NbrOfChannel;\r\n}ADC_InitTypeDef;  \r\n```\r\n\r\n**参数 ADC_Mode** 故名是以是用来设置 ADC 的模式。前面讲解过， ADC 的模式非常多， 包括独\r\n立模式，注入同步模式等等，这里我们选择独立模式，所以参数为 ADC_Mode_Independent。\r\n\r\n* ADC_Mode_Independent 这个模式下，双ADC不能同步，每个ADC接口独立工作。所以如果不需要ADC同步或者只是用了一个ADC的时候，就应该设成独立模式了。\r\n* 同步注入模式，类似浏览器发送get请求\r\n* 异步注入模式，类似发送ajax请求\r\n\r\n**参数 ADC_ScanConvMode** 用来设置是否开启扫描模式， 因为是单次转换，这里我们选择不开\r\n启值 DISABLE 即可。\r\n\r\n* 转换模式：\r\n  * ADC单通道：\r\n\r\n    * 要求进行一次ADC转换：配置为单次模式使能，扫描模式失能。这样ADC的这个通道，转换一次后，就停止转换。\r\n\r\n    * 要求进行连续ADC转换：配置为连续模式使能，扫描模式失能。这样ADC的这个通道，转换一次后，接着进行下一次转换，不断连续。\r\n\r\n  * ADC多通道：\r\n\r\n    * 要求进行一次ADC转换：配置为单次模式使能，扫描模式使能。这样ADC的多个通道，按照配置的顺序依次转换一次后，就停止转换。\r\n\r\n    * 要求进行连续ADC转换：配置为连续模式使能，扫描模式使能。这样ADC的多个通道，按照配置的顺序依次转换一次后，接着进行下一次转换，不断连续。\r\n\r\n  * 因此，得出结论：扫描模式只在多通道的条件下有效，来使得各个通道按照配置循序依次转换。而单次模式无论在单通道还是多通道下只对这些或者这个通道进行一次转换，连续模式无论是在单通道还是多通道下都对这些或者这个通道不断进行连续的转换。\r\n\r\n**参数 ADC_ContinuousConvMode** 用来设置是否开启连续转换模式，因为是单次转换模式，所以\r\n我们选择不开启连续转换模式， DISABLE 即可。\r\n**参数 ADC_ExternalTrigConv** 是用来设置启动规则转换组转换的外部事件，这里我们选择软件触\r\n发，选择值为 ADC_ExternalTrigConv_None 即可。\r\n\r\n![image-20211011165002615](cloudDisk/markdown/stm32笔记.assets/image-20211011165002615.png)\r\n\r\n**参数 DataAlign** 用来设置 ADC 数据对齐方式是左对齐还是右对齐，这里我们选择右对齐方式\r\nADC_DataAlign_Right。\r\n\r\n![image-20211011165417247](cloudDisk/markdown/stm32笔记.assets/image-20211011165417247.png)\r\n\r\n* 上左对齐，下又对齐\r\n\r\n**参数 ADC_NbrOfChannel** 用来设置规则序列的长度，这里我们是单次转换，所以值为 1 即可。\r\n通过上面对每个参数的讲解， 下面来看看我们的初始化范例：\r\n\r\n```c\r\nADC_InitTypeDef ADC_InitStructure;\r\nADC_InitStructure.ADC_Mode = ADC_Mode_Independent; //ADC 工作模式:独立模式\r\nADC_InitStructure.ADC_ScanConvMode = DISABLE; //AD 单通道模式\r\nADC_InitStructure.ADC_ContinuousConvMode = DISABLE; //AD 单次转换模式\r\nADC_InitStructure.ADC_ExternalTrigConv = ADC_ExternalTrigConv_None;\r\n//转换由软件而不是外部触发启动\r\nADC_InitStructure.ADC_DataAlign = ADC_DataAlign_Right; //ADC 数据右对齐\r\nADC_InitStructure.ADC_NbrOfChannel = 1; //顺序进行规则转换的 ADC 通道的数目 1\r\nADC_Init(ADC1, &ADC_InitStructure); //根据指定的参数初始化外设 ADCx\r\n```\r\n\r\n### 5） 使能 ADC 并校准。\r\n\r\n在设置完了以上信息后， 我们就使能 AD 转换器，执行复位校准和 AD 校准，注意这两步\r\n是必须的！不校准将导致结果很不准确。\r\n使能指定的 ADC 的方法是：\r\n\r\n```c\r\nADC_Cmd(ADC1, ENABLE); //使能指定的 ADC1\r\n```\r\n\r\n执行复位校准的方法是：\r\n\r\n```c\r\nADC_ResetCalibration(ADC1);\r\n```\r\n\r\n执行 ADC 校准的方法是：\r\n\r\n```c\r\nADC_StartCalibration(ADC1); //开始指定 ADC1 的校准状态\r\n```\r\n\r\n记住，每次进行校准之后要等待校准结束。 这里是通过获取校准状态来判断是否校准是否结束。\r\n下面我们一一列出复位校准和 AD 校准的等待结束方法：\r\n\r\n```c\r\nwhile(ADC_GetResetCalibrationStatus(ADC1)); //等待复位校准结束\r\nwhile(ADC_GetCalibrationStatus(ADC1)); //等待校 AD 准结束\r\n```\r\n\r\n### 6） 读取 ADC 值。\r\n\r\n在上面的校准完成之后， ADC 就算准备好了。接下来我们要做的就是设置规则序列 1 里面\r\n的通道，采样顺序， 以及通道的采样周期， 然后启动 ADC 转换。在转换结束后，读取 ADC 转\r\n换结果值就是了。 这里设置规则序列通道以及采样周期的函数是：\r\n\r\n```c\r\nvoid ADC_RegularChannelConfig(ADC_TypeDef* ADCx, uint8_t ADC_Channel,\r\nuint8_t Rank, uint8_t ADC_SampleTime)；\r\n```\r\n\r\n我们这里是规则序列中的第 1 个转换，同时采样周期为 239.5，所以设置为：\r\n\r\n```c\r\nADC_RegularChannelConfig(ADC1, ch, 1, ADC_SampleTime_239Cycles5 );\r\n```\r\n\r\n软件开启 ADC 转换的方法是：\r\n\r\n```c\r\nADC_SoftwareStartConvCmd(ADC1, ENABLE);//使能指定的 ADC1 的软件转换启动功能\r\n```\r\n\r\n开启转换之后，就可以获取转换 ADC 转换结果数据， 方法是：\r\n\r\n```c\r\nADC_GetConversionValue(ADC1);\r\n```\r\n\r\n同时在 AD 转换中，我们还要根据状态寄存器的标志位来获取 AD 转换的各个状态信息。库函\r\n数获取 AD 转换的状态信息的函数是：\r\n\r\n```c\r\nFlagStatus ADC_GetFlagStatus(ADC_TypeDef* ADCx, uint8_t ADC_FLAG)\r\n```\r\n\r\n比如我们要判断 ADC1d 的转换是否结束，方法是：\r\n\r\n```c\r\nwhile(!ADC_GetFlagStatus(ADC1, ADC_FLAG_EOC ));//等待转换结束\r\n```\r\n\r\n这里还需要说明一下 ADC 的参考电压， 精英 STM32 开发板使用的是 STM32F103ZET6，\r\n该芯片有外部参考电压： Vref-和 Vref+，其中 Vref-必须和 VSSA 连接在一起，而 Vref+的输入\r\n范围为： 2.4~VDDA。 精英 STM23 开发板通过 P7 端口，设置 Vref-和 Vref+设置参考电压，默\r\n认的我们是通过跳线帽将 Vref-接到 GND， Vref+接到 VDDA，参考电压就是 3.3V。如果大家想\r\n自己设置其他参考电压，将你的参考电压接在 Vref-和 Vref+上就 OK 了。本章我们的参考电压\r\n设置的是 3.3V。\r\n通过以上几个步骤的设置，我们就能正常的使用 STM32 的 ADC1 来执行 AD 转换操作了  \r\n\r\n## 程序设计\r\n\r\n### ADC初始化\r\n\r\n```c\r\nvoid ADC_init(void){\r\n	GPIO_InitTypeDef GPIO_InitStruct;\r\n	ADC_InitTypeDef ADC_InitStruct;\r\n	// 1） 开启 PA 口时钟和 ADC1 时钟，设置 PA1 为模拟输入。\r\n	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA|RCC_APB2Periph_ADC1,ENABLE);\r\n	GPIO_InitStruct.GPIO_Mode = GPIO_Mode_AIN;\r\n	GPIO_InitStruct.GPIO_Pin = GPIO_Pin_1;\r\n	GPIO_Init(GPIOA,&GPIO_InitStruct);\r\n	// 2） 复位 ADC1，同时设置 ADC1 分频因子。\r\n	ADC_DeInit(ADC1);\r\n	RCC_ADCCLKConfig(RCC_PCLK2_Div6); // 72MHz的六分频，12MHz\r\n	// 3） 初始化 ADC1 参数， 设置 ADC1 的工作模式以及规则序列的相关信息。\r\n	ADC_InitStruct.ADC_ContinuousConvMode = DISABLE; //AD 单次转换模式\r\n	ADC_InitStruct.ADC_DataAlign = ADC_DataAlign_Right; //ADC 数据右对齐\r\n	ADC_InitStruct.ADC_ExternalTrigConv = ADC_ExternalTrigConv_None;\r\n//转换由软件而不是外部触发启动\r\n	ADC_InitStruct.ADC_Mode = ADC_Mode_Independent; //ADC 工作模式:独立模式\r\n	ADC_InitStruct.ADC_NbrOfChannel = 1; //顺序进行规则转换的 ADC 通道的数目 1\r\n	ADC_InitStruct.ADC_ScanConvMode = DISABLE; //AD 单通道模式\r\n	ADC_Init(ADC1, &ADC_InitStruct);\r\n\r\n	// 5） 使能 ADC 并校准。\r\n	ADC_Cmd(ADC1, ENABLE); //使能指定的 ADC1\r\n	ADC_ResetCalibration(ADC1); // 执行复位校准\r\n	while(ADC_GetResetCalibrationStatus(ADC1)); //等待复位校准结束\r\n	ADC_StartCalibration(ADC1); //开始指定 ADC1 的校准状态\r\n	while(ADC_GetCalibrationStatus(ADC1)); //等待校 AD 准结束\r\n}\r\n```\r\n\r\n### 获取采样值\r\n\r\n```c\r\nu16 getSample(void){\r\n	u16 result;\r\n	// 6） 读取 ADC 值。\r\n	// 我们这里是规则序列中的第 1 个转换，同时采样周期为 239.5，所以设置为\r\n	ADC_RegularChannelConfig(ADC1, ADC_Channel_1, 1, ADC_SampleTime_239Cycles5 );\r\n	// 软件开启 ADC 转换\r\n	ADC_SoftwareStartConvCmd(ADC1, ENABLE);//使能指定的 ADC1 的软件转换启动功能\r\n	while(!ADC_GetFlagStatus(ADC1, ADC_FLAG_EOC));//等待转换结束\r\n	// 获取转换 ADC 转换结果数据\r\n	result = ADC_GetConversionValue(ADC1);\r\n	// printf(\"采样结果：%d\\n\",result);\r\n	return result;\r\n}\r\n```\r\n\r\n### 平均采样值\r\n\r\n```c\r\nu16 get_avr_sample(u8 times){\r\n	u8 i;\r\n	u16 res=0;\r\n	for (i=0; i<times; i++){\r\n		res += getSample();\r\n	}\r\n	res = res/times;\r\n	return res;\r\n}\r\n```\r\n\r\n### 主函数\r\n\r\n```c\r\nint main(void)\r\n {		\r\n	u16 sampleValue;\r\n	float voltage;\r\n	delay_init();	    	 //延时函数初始化	  \r\n	NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2); //设置NVIC中断分组2:2位抢占优先级，2位响应优先级 	\r\n	uart_init(115200);\r\n    KEY_Init();\r\n    LED_Init();\r\n    LCD_Init();\r\n    POINT_COLOR=BLUE;\r\n    \r\n	ADC_init();\r\n	LCD_ShowString(0,0,200,16,16,\"voltage: \");\r\n	while(1)\r\n	{	    \r\n		delay_ms(1000);\r\n		sampleValue = get_avr_sample(10); // 平均采样值\r\n		// printf(\"sampleValue=%d\",sampleValue);\r\n		voltage = (sampleValue * 3.3 / 4096.00); // 12位的ADC，基准电压3.3v\r\n		// printf(\"%d.%d%d\\n\",voltage_zhengshu,voltage_xiaoshu_1,voltage_xiaoshu_2);\r\n		LCD_ShowNum(0,16,voltage,1,16);\r\n		LCD_ShowChar(16,16,\'.\',16,0);\r\n		LCD_ShowNum(32,16,voltage*1000,3,16);\r\n	}	 \r\n}\r\n```\r\n\r\n# 十六、内部温度传感器\r\n\r\n该温度传感器\r\n在内部和 ADCx_IN16 输入通道相连接，此通道把传感器输出的电压转换成数字值。温度传感\r\n器模拟输入推荐采样时间是 17.1μ s。 STM32 的内部温度传感器支持的温度范围为： -40~125\r\n度。精度比较差，为±1.5℃左右。  \r\n\r\n![image-20211012101810572](cloudDisk/markdown/stm32笔记.assets/image-20211012101810572.png)\r\n\r\n我们介绍一下和温度传感器设置相关的 2 个地方。\r\n第一个地方，我们要使用 STM32 的内部温度传感器，必须先激活 ADC 的内部通道，这里\r\n通过 ADC_CR2 的 AWDEN 位（bit23）设置。设置该位为 1 则启用内部温度传感器  \r\n\r\n第二个地方， STM32 的内部温度传感器固定的连接在 ADC 的通道 16 上，所以，我们在设\r\n置好 ADC 之后只要读取通道 16 的值，就是温度传感器返回来的电压值了。根据这个值，我们\r\n就可以计算出当前温度。计算公式如下：\r\n\r\n```\r\nT（℃） ={（V25-Vsense） /Avg_Slope}+25  \r\n上式中：\r\nV25=Vsense 在 25 度时的数值（典型值为： 1.43）。\r\nAvg_Slope=温度与 Vsense 曲线的平均斜率（单位为 mv/℃或 uv/℃）（典型值为\r\n4.3Mv/℃）。\r\n```\r\n\r\n## 配置步骤\r\n\r\n### 1） 设置 ADC， 开启内部温度传感器。\r\n\r\n关于如何设置 ADC，上一节已经介绍了，我们采用与上一节相似的设置。 不同的是上一节\r\n温度传感器是读取外部通道的值，而内部温度传感器相当与把通道端口连接在内部温度传感器\r\n上。所以这里，我们要开启内部温度传感器功能:\r\n\r\n```C\r\nADC_TempSensorVrefintCmd(ENABLE);\r\n```\r\n\r\n\r\n\r\n### 2） 读取通道 16 的 AD 值，计算结果。\r\n\r\n在设置完之后，我们就可以读取温度传感器的电压值了， 得到该值就可以用上面的公式计\r\n算温度值。从上个实验的 ADC 通道与 GPIO 对应表（图 22.1.20 ADC 通道与 GPIO 对应表）可\r\n以知道，内部温度传感器是通过对应的是 ADC 的通道 16。其它的跟上一节的讲解是一样的。  \r\n\r\n## 程序设计\r\n\r\n### 初始化函数\r\n\r\n```c\r\nvoid ADC_init(void){\r\n	ADC_InitTypeDef ADC_InitStruct;\r\n	// 1） 开启 ADC1 时钟\r\n	RCC_APB2PeriphClockCmd(RCC_APB2Periph_ADC1,ENABLE);\r\n\r\n	// 2） 复位 ADC1，同时设置 ADC1 分频因子。\r\n	ADC_DeInit(ADC1);\r\n	RCC_ADCCLKConfig(RCC_PCLK2_Div6); // 72MHz的六分频，14MHz\r\n	// 3） 初始化 ADC1 参数， 设置 ADC1 的工作模式以及规则序列的相关信息。\r\n	ADC_InitStruct.ADC_ContinuousConvMode = DISABLE; //AD 单次转换模式\r\n	ADC_InitStruct.ADC_DataAlign = ADC_DataAlign_Right; //ADC 数据右对齐\r\n	ADC_InitStruct.ADC_ExternalTrigConv = ADC_ExternalTrigConv_None;\r\n//转换由软件而不是外部触发启动\r\n	ADC_InitStruct.ADC_Mode = ADC_Mode_Independent; //ADC 工作模式:独立模式\r\n	ADC_InitStruct.ADC_NbrOfChannel = 1; //顺序进行规则转换的 ADC 通道的数目 1\r\n	ADC_InitStruct.ADC_ScanConvMode = DISABLE; //AD 单通道模式\r\n	ADC_Init(ADC1, &ADC_InitStruct);\r\n	// 开启温度传感器\r\n	ADC_TempSensorVrefintCmd(ENABLE);\r\n	// 5） 使能 ADC 并校准。\r\n	ADC_Cmd(ADC1, ENABLE); //使能指定的 ADC1\r\n	ADC_ResetCalibration(ADC1); // 执行复位校准\r\n	while(ADC_GetResetCalibrationStatus(ADC1)); //等待复位校准结束\r\n	ADC_StartCalibration(ADC1); //开始指定 ADC1 的校准状态\r\n	while(ADC_GetCalibrationStatus(ADC1)); //等待校 AD 准结束\r\n}\r\n\r\n```\r\n\r\n### 获取采样值\r\n\r\n```c\r\nu16 getSample(void){\r\n	u16 result;\r\n	// 6） 读取 ADC 值。\r\n	// 我们这里是规则序列中的第 1 个转换，同时采样周期为 239.5，所以设置为\r\n	ADC_RegularChannelConfig(ADC1, ADC_Channel_16, 1, ADC_SampleTime_239Cycles5 );\r\n	// 软件开启 ADC 转换\r\n	ADC_SoftwareStartConvCmd(ADC1, ENABLE);//使能指定的 ADC1 的软件转换启动功能\r\n	while(!ADC_GetFlagStatus(ADC1, ADC_FLAG_EOC));//等待转换结束\r\n	// 获取转换 ADC 转换结果数据\r\n	result = ADC_GetConversionValue(ADC1);\r\n	// printf(\"采样结果：%d\\n\",result);\r\n	return result;\r\n}\r\n\r\n```\r\n\r\n### 主函数\r\n\r\n```c\r\nint main(void)\r\n {		\r\n	u16 sampleValue;\r\n	float temp;\r\n	delay_init();	    	 //延时函数初始化	  \r\n	NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2); //设置NVIC中断分组2:2位抢占优先级，2位响应优先级 	\r\n	uart_init(115200);\r\n    KEY_Init();\r\n    LED_Init();\r\n    LCD_Init();\r\n    POINT_COLOR=BLUE;\r\n    \r\n	ADC_init();\r\n	LCD_ShowString(0,0,200,16,16,\"voltage: \");\r\n	while(1)\r\n	{	    \r\n		delay_ms(1000);\r\n		sampleValue = getSample(); // 平均采样值\r\n		temp = (1.43-(3.3*sampleValue/4096.00))/0.0043 + 25;\r\n		printf(\"sampleValue=%d\\n\",sampleValue);\r\n		printf(\"temp=%d\\n\",(u8)temp);\r\n		LCD_ShowNum(0,16,temp,4,16); // 整数部分\r\n		LCD_ShowNum(5*16,16,(u8)(temp*100)%100,2,16); // 小数部分\r\n	}	 \r\n}\r\n\r\n```\r\n\r\n# 十七、光敏传感器\r\n\r\n## 简介\r\n\r\n光敏二极管与半导体二极管在结构上是类似的,其管芯是\r\n一个具有光敏特征的 PN 结，具有单向导电性，因此工作时需加上反向电压。无光照时，有很\r\n小的饱和反向漏电流，即暗电流，此时光敏二极管截止。当受到光照时,饱和反向漏电流大大增\r\n加，形成光电流,它随入射光强度的变化而变化。当光线照射 PN 结时，可以使 PN 结中产生电\r\n子一空穴对，使少数载流子的密度增加。这些载流子在反向电压下漂移，使反向电流增加。因\r\n此可以利用光照强弱来改变电路中的电流。\r\n利用这个电流变化，我们串接一个电阻，就可以转换成电压的变化，从而通过 ADC 读取\r\n电压值，判断外部光线的强弱。\r\n本章，我们利用 ADC3 的通道 6（PF8）来读取光敏二极管电压的变化，从而得到环境光线\r\n的变化，并将得到的光线强度，显示在 TFTLCD 上面。  \r\n\r\n![image-20211013090842275](cloudDisk/markdown/stm32笔记.assets/image-20211013090842275.png)\r\n\r\nR29 为其提供反向电压，当环\r\n境光线变化时， LS1 两端的电压也会随之改变，从而通过 ADC3_IN6 通道，读取 LIGHT_SENSOR\r\n（PF8）上面的电压，即可得到环境光线的强弱。光线越强，电压越低，光线越暗，电压越高。  \r\n\r\n## 程序设计\r\n\r\n### 初始化函数\r\n\r\n```c\r\nvoid ADC_init(void){\r\n	ADC_InitTypeDef ADC_InitStruct;\r\n	GPIO_InitTypeDef GPIO_InitStruct;\r\n	// 初始化GPIOF.8为模拟输入\r\n	GPIO_InitStruct.GPIO_Mode = GPIO_Mode_AIN;\r\n	GPIO_InitStruct.GPIO_Pin = GPIO_Pin_8;\r\n	GPIO_Init(GPIOF,&GPIO_InitStruct);\r\n	// 1） 开启 ADC3 时钟\r\n	RCC_APB2PeriphClockCmd(RCC_APB2Periph_ADC3|RCC_APB2Periph_GPIOF,ENABLE);\r\n\r\n	// 2） 复位 ADC3，同时设置 ADC3 分频因子。\r\n	ADC_DeInit(ADC3);\r\n	RCC_ADCCLKConfig(RCC_PCLK2_Div6); // 72MHz的六分频，14MHz\r\n	// 3） 初始化 ADC1 参数， 设置 ADC1 的工作模式以及规则序列的相关信息。\r\n	ADC_InitStruct.ADC_ContinuousConvMode = DISABLE; //AD 单次转换模式\r\n	ADC_InitStruct.ADC_DataAlign = ADC_DataAlign_Right; //ADC 数据右对齐\r\n	ADC_InitStruct.ADC_ExternalTrigConv = ADC_ExternalTrigConv_None;\r\n//转换由软件而不是外部触发启动\r\n	ADC_InitStruct.ADC_Mode = ADC_Mode_Independent; //ADC 工作模式:独立模式\r\n	ADC_InitStruct.ADC_NbrOfChannel = 1; //顺序进行规则转换的 ADC 通道的数目 1\r\n	ADC_InitStruct.ADC_ScanConvMode = DISABLE; //AD 单通道模式\r\n	ADC_Init(ADC3, &ADC_InitStruct);\r\n	\r\n	// 5） 使能 ADC 并校准。\r\n	ADC_Cmd(ADC3, ENABLE); //使能指定的 ADC1\r\n	ADC_ResetCalibration(ADC3); // 执行复位校准\r\n	while(ADC_GetResetCalibrationStatus(ADC3)); //等待复位校准结束\r\n	ADC_StartCalibration(ADC3); //开始指定 ADC3 的校准状态\r\n	while(ADC_GetCalibrationStatus(ADC3)); //等待校 AD 准结束\r\n}\r\n```\r\n\r\n### 采样值函数\r\n\r\n```c\r\nu16 getSample(void){\r\n	u16 result;\r\n	// 6） 读取 ADC 值。\r\n	// 我们这里是规则序列中的第 1 个转换，同时采样周期为 239.5，所以设置为\r\n	ADC_RegularChannelConfig(ADC3, ADC_Channel_6, 1, ADC_SampleTime_239Cycles5 );\r\n	// 软件开启 ADC 转换\r\n	ADC_SoftwareStartConvCmd(ADC3, ENABLE);//使能指定的 ADC1 的软件转换启动功能\r\n	while(!ADC_GetFlagStatus(ADC3, ADC_FLAG_EOC));//等待转换结束\r\n	// 获取转换 ADC 转换结果数据\r\n	result = ADC_GetConversionValue(ADC3);\r\n	// printf(\"采样结果：%d\\n\",result);\r\n	return result;\r\n}\r\n```\r\n\r\n### 主函数\r\n\r\n```c\r\nint main(void)\r\n {		\r\n	u16 sampleValue;\r\n	float light_degree;\r\n	delay_init();	    	 //延时函数初始化	  \r\n	NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2); //设置NVIC中断分组2:2位抢占优先级，2位响应优先级 	\r\n	uart_init(115200);\r\n    KEY_Init();\r\n    LED_Init();\r\n    LCD_Init();\r\n    POINT_COLOR=BLUE;\r\n    \r\n	ADC_init();\r\n	LCD_ShowString(0,0,200,16,16,\"light dgree: \");\r\n	while(1)\r\n	{	    \r\n		delay_ms(1000);\r\n		sampleValue = getSample();\r\n		light_degree = 1 - (sampleValue / 4096.00); // 所占百分比0.xxxxx\r\n		//printf(\"sampleValue=%d.%d\\n\",light_degree*100,(u16)(light_degree*10000)%100);\r\n		// printf(\"temp=%d\\n\",(u8)temp);\r\n		LCD_ShowNum(0,16,light_degree*100,4,16);\r\n		LCD_ShowChar(4*16,16,\'.\',16,1);\r\n		LCD_ShowNum(5*16,16,(u16)(light_degree*10000)%100,2,16);\r\n		LCD_ShowChar(7*16,16,\'%\',16,1);\r\n	}	 \r\n}\r\n```\r\n\r\n# 十八、DAC（输出模拟信号）\r\n\r\n在本章中，我们将利用按键（或 USMART）控制 STM32 内部 DAC 模块的通道 1 来输出电压，\r\n通过 ADC1 的通道 1 采集 DAC 的输出电压，在 LCD 模块上面显示 ADC 获取到的电压值以及\r\nDAC 的设定输出电压值等信息。  \r\n\r\n## 简介\r\n\r\n大容量的 STM32F103 具有内部 DAC， 精英 STM32 选择的是 STM32F103ZET6 属于大容量\r\n产品，所以是带有 DAC 模块的。\r\nSTM32 的 DAC 模块(数字/模拟转换模块)是 12 位数字输入，电压输出型的 DAC。 DAC 可以配\r\n置为 8 位或 12 位模式，也可以与 DMA 控制器配合使用。 DAC 工作在 12 位模式时，数据可以\r\n设置成左对齐或右对齐。 DAC 模块有 2 个输出通道，每个通道都有单独的转换器。在双 DAC\r\n模式下， 2 个通道可以独立地进行转换，也可以同时进行转换并同步地更新 2 个通道的输出。\r\nDAC 可以通过引脚输入参考电压 VREF+以获得更精确的转换结果。  \r\n\r\nSTM32 的 DAC 模块主要特点有：\r\n① 2 个 DAC 转换器：每个转换器对应 1 个输出通道\r\n② 8 位或者 12 位单调输出\r\n③ 12 位模式下数据左对齐或者右对齐\r\n④ 同步更新功能\r\n⑤ 噪声波形生成\r\n⑥ 三角波形生成\r\n⑦ 双 DAC 通道同时或者分别转换\r\n⑧ 每个通道都有 DMA 功能  \r\n\r\n![image-20211013103055688](cloudDisk/markdown/stm32笔记.assets/image-20211013103055688.png)\r\n\r\n图中 VDDA 和 VSSA 为 DAC 模块模拟部分的供电，而 Vref+则是 DAC 模块的参考电压。  \r\n\r\nDAC_OUTx 就是 DAC 的输出通道了（对应 PA4 或者 PA5 引脚）。  \r\n\r\n![image-20211013103647795](cloudDisk/markdown/stm32笔记.assets/image-20211013103647795.png)\r\n\r\n![image-20211013104715815](cloudDisk/markdown/stm32笔记.assets/image-20211013104715815.png)\r\n\r\n当 DAC 的参考电压为 Vref+的时候， DAC 的输出电压是线性的从 0~Vref+， 12 位模式下 DAC\r\n输出电压与 Vref+以及 DORx 的计算公式如下：  \r\n\r\n```\r\nDACx 输出电压=Vref*（DORx/4095）  \r\n```\r\n\r\n## 相关寄存器\r\n\r\n我们介绍一下要实现 DAC 的通道 1 输出，需要用到的一些寄存器。  \r\n\r\nDAC\r\n\r\n### 控制寄存器 DAC_CR  \r\n\r\n![image-20211013105213497](cloudDisk/markdown/stm32笔记.assets/image-20211013105213497.png)\r\n\r\nDAC_CR 的低 16 位用于控制通道 1，而高 16 位用于控制通道 2，我们这里仅列出比较重\r\n要的最低 8 位的详细描述  \r\n\r\n![image-20211013105247522](cloudDisk/markdown/stm32笔记.assets/image-20211013105247522.png)\r\n\r\n![image-20211013105306124](cloudDisk/markdown/stm32笔记.assets/image-20211013105306124.png)\r\n\r\nDAC 通道 1 使能位(EN1)，该位用来控制 DAC 通道 1 使能的，本章我们\r\n就是用的 DAC 通道 1，所以该位设置为 1。  \r\n\r\n关闭 DAC 通道 1 输出缓存控制位（BOFF1），这里 STM32 的 DAC 输出缓存做的有些不好，如果使能的话，虽然输出能力强一点，但是输出没法到 0，这是个很严重的问题。所以本章我们不使用输出缓存。即设置该位为 1。  \r\n\r\nDAC 通道 1 触发使能位（TEN1），该位用来控制是否使用触发，里我们不使用触发，所以设置该位为 0。  \r\n\r\nDAC 通道 1 触发选择位（TSEL1[2:0]），这里我们没用到外部触发，所以设置这几个位为 0就行了。  \r\n\r\nDAC 通道 1 噪声/三角波生成使能位（WAVE1[1:0]），这里我们同样没用到波形发生器，故也设置为 0 即可。\r\n\r\nDAC 通道 1 屏蔽/幅值选择器（MAMP[3:0]），这些位仅在使用了波形发生器的时候有用，本章没有用到波形发生器，故设置为 0 就可以了。\r\n\r\n最后是 DAC 通道 1 DMA 使能位（DMAEN1），本章我们没有用到 DMA 功能，故还是设置为 0。\r\n\r\n通道 2 的情况和通道 1 一模一样，这里就不不细说了。在 DAC_CR 设置好之后， DAC 就可以正常工作了，我们仅需要再设置 DAC 的数据保持寄存器的值，就可以在 DAC 输出通道得到你想要的电压了（对应 IO 口设置为模拟输入）。  \r\n\r\n### DAC 通道 1 的 12 位右对齐数据保持寄存器： DAC_DHR12R1\r\n\r\n![image-20211013105815779](cloudDisk/markdown/stm32笔记.assets/image-20211013105815779.png)\r\n\r\n\r\n\r\n该寄存器用来设置 DAC 输出，通过写入 12 位数据到该寄存器，就可以在 DAC 输出通道 1（PA4）得到我们所要的结果。  \r\n\r\n## 配置步骤\r\n\r\n本章我们将使用库函数的方法来设置 DAC 模块的通道 1 来输出模拟电压，其详细设置步骤如下：  \r\n\r\n### 1）开启 PA 口时钟，设置 PA4 为模拟输入。\r\n\r\nSTM32F103ZET6 的 DAC 通道 1 在 PA4 上，所以，我们先要使能 PORTA 的时钟，然后设置 PA4 为模拟输入。 DAC 本身是输出，但是为什么端口要设置为模拟输入模式呢？因为一但使能 DACx 通道之后，相应的 GPIO 引脚（PA4 或者 PA5）会自动与 DAC 的模拟输出相连，设置为输入，是为了避免额外的干扰。\r\n使能 GPIOA 时钟：\r\n\r\n```c\r\nRCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE ); //使能 PORTA 时钟\r\n设置 PA1 为模拟输入只需要设置初始化参数即可\r\n```\r\n\r\n设置 PA1 为模拟输入只需要设置初始化参数即可：\r\n\r\n```c\r\nGPIO_InitStructure.GPIO_Mode = GPIO_Mode_AIN; //模拟输入\r\n```\r\n\r\n同其他外设一样，要想使用，必须先开启相应的时钟。 STM32 的 DAC 模块时钟是由 APB1\r\n提供的，所以我们调用函数 RCC_APB1PeriphClockCmd()设置 DAC 模块的时钟使能。\r\n\r\n### 2）使能 DAC1 时钟。\r\n\r\n同其他外设一样，要想使用，必须先开启相应的时钟。 STM32 的 DAC 模块时钟是由 APB1\r\n提供的，所以我们调用函数 RCC_APB1PeriphClockCmd()设置 DAC 模块的时钟使能。\r\n\r\n```c\r\nRCC_APB1PeriphClockCmd(RCC_APB1Periph_DAC, ENABLE ); //使能 DAC 通道时钟\r\n```\r\n\r\n### 3）初始化 DAC,设置 DAC 的工作模式。\r\n\r\n该部分设置全部通过 DAC_CR 设置实现，包括： DAC 通道 1 使能、 DAC 通道 1 输出缓存关闭、不使用触发、不使用波形发生器等设置。这里 DMA 初始化是通过函数 DAC_Init 完成的：\r\n\r\n```c\r\nvoid DAC_Init(uint32_t DAC_Channel, DAC_InitTypeDef* DAC_InitStruct)\r\n```\r\n\r\n跟前面一样，首先我们来看看参数设置结构体类型 DAC_InitTypeDef 的定义：\r\n\r\n```c\r\ntypedef struct\r\n{\r\n    uint32_t DAC_Trigger;\r\n    uint32_t DAC_WaveGeneration;\r\n    uint32_t DAC_LFSRUnmask_TriangleAmplitude;\r\n    uint32_t DAC_OutputBuffer;\r\n}DAC_InitTypeDef;\r\n```\r\n\r\n这个结构体的定义还是比较简单的，只有四个成员变量，下面我们一一讲解。\r\n**第一个参数 DAC_Trigger** 用来设置是否使用触发功能，前面已经讲解过这个的含义，这里我们不是用触发功能，所以值为 DAC_Trigger_None。\r\n**第二个参数 DAC_WaveGeneratio** 用来设置是否使用波形发生，这里我们前面同样讲解过不使用。所以值为 DAC_WaveGeneration_None。\r\n**第三个参数 DAC_LFSRUnmask_TriangleAmplitude** 用来设置屏蔽/幅值选择器，这个变量只在使用波形发生器的时候才有用，这里我们设置为 0 即可，值为DAC_LFSRUnmask_Bit0。\r\n**第四个参数 DAC_OutputBuffer** 是用来设置输出缓存控制位，前面讲解过，我们不使用输出缓存，所以值为 DAC_OutputBuffer_Disable。到此四个参数设置完毕。看看我们的实例代码：\r\n\r\n```c\r\nDAC_InitTypeDef DAC_InitType;\r\nDAC_InitType.DAC_Trigger=DAC_Trigger_None; //不使用触发功能 TEN1=0\r\nDAC_InitType.DAC_WaveGeneration=DAC_WaveGeneration_None;//不使用波形发生\r\nDAC_InitType.DAC_LFSRUnmask_TriangleAmplitude=DAC_LFSRUnmask_Bit0;\r\nDAC_InitType.DAC_OutputBuffer=DAC_OutputBuffer_Disable ; //DAC1 输出缓存关闭\r\nDAC_Init(DAC_Channel_1,&DAC_InitType); //初始化 DAC 通道 1\r\n```\r\n\r\n### 4）使能 DAC 转换通道\r\n\r\n初始化 DAC 之后，理所当然要使能 DAC 转换通道，库函数方法是：\r\n\r\n```c\r\nDAC_Cmd(DAC_Channel_1, ENABLE); //使能 DAC1\r\n```\r\n\r\n\r\n\r\n### 5）设置 DAC 的输出值。\r\n\r\n通过前面 4 个步骤的设置， DAC 就可以开始工作了，我们使用 12 位右对齐数据格式，所以我们通过设置 DHR12R1，就可以在 DAC 输出引脚（PA4）得到不同的电压值了。库函数的函数是：\r\n\r\n```c\r\nDAC_SetChannel1Data(DAC_Align_12b_R, 0);\r\n```\r\n\r\n**第一个参数设置对齐方式**，可以为 12 位右对齐 DAC_Align_12b_R， 12 位左对齐\r\nDAC_Align_12b_L 以及 8 位右对齐 DAC_Align_8b_R 方式。\r\n**第二个参数就是 DAC 的输入值了**，这个很好理解，初始化设置为 0。\r\n这里，还可以读出 DAC 的数值，函数是：\r\n\r\n```c\r\nDAC_GetDataOutputValue(DAC_Channel_1);\r\n```\r\n\r\n设置和读出一一对应很好理解，这里就不多讲解了。\r\n最后，再提醒一下大家，本例程，我们使用的是 3.3V 的参考电压，即 Vref+连接 VDDA。通过以上几个步骤的设置，我们就能正常的使用 STM32 的 DAC 通道 1 来输出不同的模拟电压了。\r\n\r\n## 硬件连接\r\n\r\n本章，我们使用 DAC 通道 1 输出模拟电压，然后通过 ADC1 的通道 1 对该输出电压进行读取，并显示在 LCD 模块上面， DAC 的输出电压，我们通过按键（或 USMART）进行设置。  \r\n\r\n![image-20211013111645902](cloudDisk/markdown/stm32笔记.assets/image-20211013111645902.png)\r\n\r\n注意： STM_DAC 和 GBC_KEY 共用 PA4，所以，如果您的开发板 ATK MODULE 位置插\r\n了其他模块，那么可能影响 DAC 的输出结果，建议在做 DAC 实验的时候， ATK MODULE 位置，不要插任何其他模块。\r\nP7 是 AD/DA 组合接口，我们只需要通过跳线帽短接 P7 的 ADC 和 DAC，就可以开始做本\r\n章实验了。如图 25.2.2 所示：  \r\n\r\n![image-20211013111737044](cloudDisk/markdown/stm32笔记.assets/image-20211013111737044.png)\r\n\r\n## 程序设计\r\n\r\n按key_up GPIOA.4输出0.5v电压\r\n\r\n按key1 GPIOA.4输出1v电压\r\n\r\n按key2 GPIOA.4输出2v电压\r\n\r\n### 按键外部中断初始化函数\r\n\r\n```c\r\n#define key0 GPIO_ReadInputDataBit(GPIOE,GPIO_Pin_4)\r\n#define key1 GPIO_ReadInputDataBit(GPIOE,GPIO_Pin_3)\r\n#define keyUp GPIO_ReadInputDataBit(GPIOA,GPIO_Pin_0)\r\nvoid keyInit(void){\r\n	// key0 key1 keyUp初始化\r\n 	GPIO_InitTypeDef GPIO_InitStructure;\r\n 	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA,ENABLE);//使能PORTA,PORTE时钟\r\n	GPIO_InitStructure.GPIO_Pin  = GPIO_Pin_4|GPIO_Pin_3;//KEY0-KEY1\r\n	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU; //设置成上拉输入\r\n 	GPIO_Init(GPIOE, &GPIO_InitStructure);//初始化GPIOE4,3\r\n\r\n	//初始化 WK_UP-->GPIOA.0	  下拉输入\r\n	GPIO_InitStructure.GPIO_Pin  = GPIO_Pin_0;\r\n	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPD; //PA0设置成输入，默认下拉	  \r\n	GPIO_Init(GPIOA, &GPIO_InitStructure);//初始化GPIOA.0\r\n}\r\n\r\nvoid keyInterruptInit(void)\r\n{\r\n	// GPIOE.3 - KEY1 - EXTI3\r\n	// GPIOE.4 - KEY0 - EXTI4\r\n	// GPIOA.0 - KEYUP - EXTI0\r\n	\r\n	EXTI_InitTypeDef EXTI_InitStruct;\r\n 	NVIC_InitTypeDef NVIC_InitStructure;\r\n	\r\n	// 1）初始化 IO 口为输入。\r\n	keyInit();\r\n	\r\n	// 2）开启 AFIO 时钟\r\n	RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO,ENABLE);\r\n	\r\n	// 3） 设置 IO 口与中断线的映射关系。\r\n	GPIO_EXTILineConfig(GPIO_PortSourceGPIOA,GPIO_PinSource0); // GPIOA.0 映射到 外部中断线0\r\n	GPIO_EXTILineConfig(GPIO_PortSourceGPIOE,GPIO_PinSource3); // GPIOE.3 映射到 外部中断线3\r\n	GPIO_EXTILineConfig(GPIO_PortSourceGPIOE,GPIO_PinSource4); // GPIOE.4 映射到 外部中断线4\r\n	\r\n	// 4）初始化线上中断，设置触发条件等。\r\n	EXTI_InitStruct.EXTI_Line = EXTI_Line0; // 初始化外部中断线0、3、4\r\n	EXTI_InitStruct.EXTI_Mode = EXTI_Mode_Interrupt;\r\n	EXTI_InitStruct.EXTI_Trigger = EXTI_Trigger_Rising; // 上升沿触发\r\n	EXTI_Init(&EXTI_InitStruct);\r\n	\r\n	EXTI_InitStruct.EXTI_Mode = EXTI_Mode_Interrupt;\r\n	EXTI_InitStruct.EXTI_Trigger = EXTI_Trigger_Falling; // 下降沿触发\r\n	EXTI_InitStruct.EXTI_Line =EXTI_Line3;\r\n	EXTI_Init(&EXTI_InitStruct);\r\n	\r\n	EXTI_InitStruct.EXTI_Mode = EXTI_Mode_Interrupt;\r\n	EXTI_InitStruct.EXTI_Trigger = EXTI_Trigger_Falling; // 下降沿触发\r\n	EXTI_InitStruct.EXTI_Line =EXTI_Line4;\r\n	EXTI_Init(&EXTI_InitStruct);\r\n	\r\n	// 5）配置中断分组（NVIC），并使能中断。\r\n	// 定义初始化的是哪个中断，这个我们可以在 stm32f10x.h 中找到每个中断对应的名字。例如 EXTI0_IRQn。\r\n	NVIC_InitStructure.NVIC_IRQChannel = EXTI0_IRQn;\r\n	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;\r\n	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0x02; // 设置抢占优先级2\r\n	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0x02; //子优先级 2\r\n	NVIC_Init(&NVIC_InitStructure);\r\n	\r\n	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;\r\n	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0x02; // 设置抢占优先级2\r\n	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0x02; //子优先级 2\r\n	NVIC_InitStructure.NVIC_IRQChannel = EXTI3_IRQn;\r\n	NVIC_Init(&NVIC_InitStructure);\r\n	\r\n	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;\r\n	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0x02; // 设置抢占优先级2\r\n	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0x02; //子优先级 2\r\n	NVIC_InitStructure.NVIC_IRQChannel = EXTI4_IRQn;\r\n	NVIC_Init(&NVIC_InitStructure);\r\n}\r\n```\r\n\r\n### ADC初始化（读取模拟信号）\r\n\r\n```c\r\nvoid ADC_init(void){\r\n	ADC_InitTypeDef ADC_InitStruct;\r\n	GPIO_InitTypeDef GPIO_InitStruct;\r\n	// 初始化GPIOA.1为模拟输入\r\n	GPIO_InitStruct.GPIO_Mode = GPIO_Mode_AIN;\r\n	GPIO_InitStruct.GPIO_Pin = GPIO_Pin_1;\r\n	GPIO_Init(GPIOA,&GPIO_InitStruct);\r\n	// 1） 开启 ADC1 时钟\r\n	RCC_APB2PeriphClockCmd(RCC_APB2Periph_ADC1|RCC_APB2Periph_GPIOF,ENABLE);\r\n\r\n	// 2） 复位 ADC3，同时设置 ADC3 分频因子。\r\n	ADC_DeInit(ADC1);\r\n	RCC_ADCCLKConfig(RCC_PCLK2_Div6); // 72MHz的六分频，14MHz\r\n	// 3） 初始化 ADC1 参数， 设置 ADC1 的工作模式以及规则序列的相关信息。\r\n	ADC_InitStruct.ADC_ContinuousConvMode = DISABLE; //AD 单次转换模式\r\n	ADC_InitStruct.ADC_DataAlign = ADC_DataAlign_Right; //ADC 数据右对齐\r\n	ADC_InitStruct.ADC_ExternalTrigConv = ADC_ExternalTrigConv_None;\r\n//转换由软件而不是外部触发启动\r\n	ADC_InitStruct.ADC_Mode = ADC_Mode_Independent; //ADC 工作模式:独立模式\r\n	ADC_InitStruct.ADC_NbrOfChannel = 1; //顺序进行规则转换的 ADC 通道的数目 1\r\n	ADC_InitStruct.ADC_ScanConvMode = DISABLE; //AD 单通道模式\r\n	ADC_Init(ADC1, &ADC_InitStruct);\r\n	\r\n	// 5） 使能 ADC 并校准。\r\n	ADC_Cmd(ADC1, ENABLE); //使能指定的 ADC1\r\n	ADC_ResetCalibration(ADC1); // 执行复位校准\r\n	while(ADC_GetResetCalibrationStatus(ADC1)); //等待复位校准结束\r\n	ADC_StartCalibration(ADC1); //开始指定 ADC3 的校准状态\r\n	while(ADC_GetCalibrationStatus(ADC1)); //等待校 AD 准结束\r\n}\r\n```\r\n\r\n### DAC初始化（输出模拟信号）\r\n\r\n```c\r\nvoid DAC_init(void){\r\n	GPIO_InitTypeDef GPIO_InitStruct;\r\n	DAC_InitTypeDef DAC_InitType;\r\n	// 1）开启 PA 口时钟，设置 PA4 为模拟输入。\r\n	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE); //使能 PORTA 时钟\r\n	GPIO_InitStruct.GPIO_Mode = GPIO_Mode_AIN; //模拟输入\r\n	GPIO_InitStruct.GPIO_Pin = GPIO_Pin_4;\r\n	GPIO_Init(GPIOA,&GPIO_InitStruct);\r\n	// 2）使能 DAC1 时钟。\r\n	RCC_APB1PeriphClockCmd(RCC_APB1Periph_DAC, ENABLE); //使能 DAC 通道时钟\r\n	// 3）初始化 DAC,设置 DAC 的工作模式。\r\n	DAC_InitType.DAC_Trigger=DAC_Trigger_None; //不使用触发功能 TEN1=0\r\n	DAC_InitType.DAC_WaveGeneration=DAC_WaveGeneration_None;//不使用波形发生\r\n	DAC_InitType.DAC_LFSRUnmask_TriangleAmplitude=DAC_LFSRUnmask_Bit0;\r\n	DAC_InitType.DAC_OutputBuffer=DAC_OutputBuffer_Disable ; //DAC1 输出缓存关闭\r\n	DAC_Init(DAC_Channel_1,&DAC_InitType); //初始化 DAC 通道 1\r\n	// 4）使能 DAC 转换通道\r\n	DAC_Cmd(DAC_Channel_1, ENABLE); //使能 DAC1\r\n	DAC_SetChannel1Data(DAC_Align_12b_R, 0); // 0v\r\n}\r\n```\r\n\r\n### ADC获取采样值\r\n\r\n```c\r\nu16 getSample(void){\r\n	u16 result;\r\n	// 6） 读取 ADC 值。\r\n	// 我们这里是规则序列中的第 1 个转换，同时采样周期为 239.5，所以设置为\r\n	ADC_RegularChannelConfig(ADC1, ADC_Channel_1, 1, ADC_SampleTime_239Cycles5 );\r\n	// 软件开启 ADC 转换\r\n	ADC_SoftwareStartConvCmd(ADC1, ENABLE);//使能指定的 ADC1 的软件转换启动功能\r\n	while(!ADC_GetFlagStatus(ADC1, ADC_FLAG_EOC));//等待转换结束\r\n	// 获取转换 ADC 转换结果数据\r\n	result = ADC_GetConversionValue(ADC1);\r\n	// printf(\"采样结果：%d\\n\",result);\r\n	return result;\r\n}\r\n\r\nu16 get_avr_sample(u8 times){\r\n	u8 i;\r\n	u16 res=0;\r\n	for (i=0; i<times; i++){\r\n		res += getSample();\r\n	}\r\n	res = res/times;\r\n	return res;\r\n}\r\n```\r\n\r\n### 按键外部中断输出不同的电压值\r\n\r\n```c\r\nvoid EXTI0_IRQHandler(void){\r\n	// 令模拟输出三种电压值 0.5v、1v、2v\r\n	// 5）设置 DAC 的输出值。\r\n	// data = (v/3.3)*2^12 = 620\r\n	DAC_SetChannel1Data(DAC_Align_12b_R, 620); // 0.5V,   (data/2^12)*3.3=0.5 // 3.3-参考电压，12-12位，0.5-输出电压值\r\n	// DAC_GetDataOutputValue(DAC_Channel_1);\r\n	EXTI_ClearITPendingBit(EXTI_Line0); //清除 LINE 上的中断标志位\r\n}\r\nvoid EXTI3_IRQHandler(void){\r\n	// 令模拟输出三种电压值 0.5v、1v、2v\r\n	// 5）设置 DAC 的输出值。\r\n	DAC_SetChannel1Data(DAC_Align_12b_R, 1241); // 1v\r\n	// DAC_GetDataOutputValue(DAC_Channel_1);\r\n	EXTI_ClearITPendingBit(EXTI_Line3); //清除 LINE 上的中断标志位\r\n}\r\n\r\nvoid EXTI4_IRQHandler(void){\r\n	// 令模拟输出三种电压值 0.5v、1v、2v\r\n	// 5）设置 DAC 的输出值。\r\n	DAC_SetChannel1Data(DAC_Align_12b_R, 2482); // 2v\r\n	// DAC_GetDataOutputValue(DAC_Channel_1);\r\n	EXTI_ClearITPendingBit(EXTI_Line4); //清除 LINE 上的中断标志位\r\n}\r\n```\r\n\r\n### 主函数\r\n\r\n```c\r\nint main(void)\r\n {		\r\n	u16 sampleValue;\r\n	float voltage;\r\n	delay_init();	    	 //延时函数初始化	  \r\n	NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2); //设置NVIC中断分组2:2位抢占优先级，2位响应优先级 	\r\n	uart_init(115200);\r\n    KEY_Init();\r\n	keyInterruptInit();\r\n    LED_Init();\r\n	ADC_init();\r\n	DAC_init();\r\n	LCD_Init();\r\n    POINT_COLOR=BLUE;\r\n	LCD_ShowString(0,0,200,16,16,\"voltage:\");\r\n	while(1)\r\n	{	    \r\n		delay_ms(1000);\r\n		sampleValue = get_avr_sample(10); // 平均采样值\r\n		// printf(\"sampleValue=%d\",sampleValue);\r\n		voltage = (sampleValue * 3.3 / 4096.00); // 12位的ADC，基准电压3.3v\r\n		// printf(\"%d.%d%d\\n\",voltage_zhengshu,voltage_xiaoshu_1,voltage_xiaoshu_2);\r\n		LCD_ShowNum(0,16,voltage,1,16);\r\n		LCD_ShowChar(16,16,\'.\',16,0);\r\n		LCD_ShowNum(32,16,(u16)(voltage*10)%10,1,16);\r\n		LCD_ShowNum(48,16,(u16)(voltage*100)%10,1,16);\r\n		LCD_ShowNum(64,16,(u16)(voltage*1000)%10,1,16);\r\n		// LCD_ShowNum(32,16,(u16)(voltage*1000)%1000,3,16);\r\n		LCD_ShowChar(80,16,\'V\',16,0);\r\n	}	  \r\n}\r\n\r\n```\r\n\r\n![image-20211013135926261](cloudDisk/markdown/stm32笔记.assets/image-20211013135926261.png)\r\n\r\n# 十九、DMA\r\n\r\n## 简介\r\n\r\n![image-20211015110247338](cloudDisk/markdown/stm32笔记.assets/image-20211015110247338.png)\r\n\r\nDMA，全称为： Direct Memory Access，即直接存储器访问， **DMA 传输将数据从一个地址空间复制到另外一个地址空间**。 当 CPU 初始化这个传输动作，传输动作本身是由\r\nDMA 控制器 来实行和完成。典型的例子就是移动一个外部内存的区块到芯片内部更快的内存区。像是这样的操作并没有让处理器工作拖延，反而可以被重新排程去处理其他的工\r\n作。 DMA 传输对于高效能嵌入式系统算法和网络是很重要的。 DMA 传输方式无需 CPU 直接控制传输，也没有中断处理方式那样保留现场和恢复现场的过程，通过硬件为 RAM 与 I/O 设备开辟一条直接传送数据的通路， 能使 CPU 的效率大为提高。  \r\n\r\nSTM32 最多有 2 个 DMA 控制器（DMA2 仅存在大容量产品中）， DMA1 有 7 个通道。 **DMA2 有 5个通道。**每个通道专门用来管理来自于一个或多个外设对存储器访问的请求。还有一个仲裁起来协调各个 DMA 请求的优先权。  \r\n\r\nSTM32 的 DMA 有以下一些特性：\r\n●每个通道都直接连接专用的硬件 DMA 请求，每个通道都同样**支持软件触发**。这些功能通过软件来配置。\r\n●在七个请求间的**优先权可以通过软件编程设置(共有四级：很高、高、中等和低)**，假如在相等优先权时由硬件决定(请求 0 优先于请求 1，依此类推) 。\r\n●独立的源和目标数据区的**传输宽度(字节、半字、全字)**，模拟打包和拆包的过程。源和目标地址必须按数据传输宽度对齐。\r\n●**支持循环的缓冲器管理**\r\n●每个通道都有 **3 个事件标志(DMA 半传输， DMA 传输完成和 DMA 传输出错)**，这 3 个事件标志逻辑或成为一个单独的中断请求。\r\n●**存储器和存储器间的传输**\r\n●外设和存储器，存储器和外设的传输\r\n●闪存、 SRAM、外设的 SRAM、 APB1 APB2 和 AHB 外设均可作为访问的源和目标。\r\n●可编程的数据传输数目：最大为 65536  \r\n\r\n![image-20211014154746737](cloudDisk/markdown/stm32笔记.assets/image-20211014154746737.png)\r\n\r\n通道 1 的几个 DMA1 请求（ADC1、 TIM2_CH3、 TIM4_CH1），\r\n这几个是通过逻辑或到通道 1 的，这样我们在同一时间，就只能使用其中的一个。其他通道也\r\n是类似的  \r\n\r\n## 相关寄存器\r\n\r\n### DMA 中断状态寄存器（DMA_ISR）  \r\n\r\n这里我们要使用的是串口 1 的 DMA 传送，也就是要用到通道 4。  \r\n\r\n![image-20211014154926483](cloudDisk/markdown/stm32笔记.assets/image-20211014154926483.png)\r\n\r\n我们如果开启了 DMA_ISR 中这些中断，在达到条件后就会跳到中断服务函数里面去，即使\r\n没开启，我们也可以通过查询这些位来获得当前 DMA 传输的状态。这里我们常用的是 TCIFx，\r\n即通道 DMA 传输完成与否的标志。注意此寄存器为只读寄存器，所以在这些位被置位之后，只\r\n能通过其他的操作来清除  \r\n\r\n### DMA 中断标志清除寄存器（DMA_IFCR）  \r\n\r\n![image-20211014160750924](cloudDisk/markdown/stm32笔记.assets/image-20211014160750924.png)\r\n\r\nDMA_IFCR 的各位就是用来清除 DMA_ISR 的对应位的，通过写 0 清除。在 DMA_ISR 被置位后，\r\n我们必须通过向该位寄存器对应的位写入 0 来清除。  \r\n\r\n### 配置步骤\r\n\r\n#### 1）使能 DMA 时钟\r\n\r\n```c\r\nRCC_AHBPeriphClockCmd(RCC_AHBPeriph_DMA1, ENABLE); //使能 DMA 时钟\r\n```\r\n\r\n#### 2）初始化 DMA 通道 4 参数\r\n\r\n前面讲解过， DMA 通道配置参数种类比较繁多，包括内存地址，外设地址，传输数据长度，\r\n数据宽度，通道优先级等等。这些参数的配置在库函数中都是在函数 DMA_Init 中完成，下面我\r\n们看看函数定义：\r\n\r\n```c\r\nvoid DMA_Init(DMA_Channel_TypeDef* DMAy_Channelx,DMA_InitTypeDef* DMA_InitStruct)\r\n```\r\n\r\n函数的第一个参数是指定初始化的 DMA 通道号，这个很容易理解，下面我们主要看看第二\r\n个参数。跟其他外设一样，同样是通过初始化结构体成员变量值来达到初始化的目的，下面我\r\n们来看看 DMA_InitTypeDef 结构体的定义：\r\n\r\n```c\r\ntypedef struct\r\n{\r\n    uint32_t DMA_PeripheralBaseAddr;\r\n    uint32_t DMA_MemoryBaseAddr;\r\n    uint32_t DMA_DIR;\r\n    uint32_t DMA_BufferSize;\r\n    uint32_t DMA_PeripheralInc;\r\n    uint32_t DMA_MemoryInc;\r\n    uint32_t DMA_PeripheralDataSize;\r\n    uint32_t DMA_MemoryDataSize;\r\n    uint32_t DMA_Mode;\r\n    uint32_t DMA_Priority;\r\n    uint32_t DMA_M2M;\r\n}DMA_InitTypeDef;\r\n```\r\n\r\n这个结构体的成员比较多，但是每个成员变量的意义我们在前面基本都已经讲解过，这里\r\n我们一一做个简要的介绍。\r\n**第一个参数 DMA_PeripheralBaseAddr** 用来设置 DMA 传输的外设基地址，比如要进行串口\r\nDMA 传输，那么外设基地址为串口接受发送数据存储器 USART1->DR 的地址，表示方法为\r\n&USART1->DR。\r\n**第二个参数DMA_MemoryBaseAddr为内存基地址**，也就是我们存放DMA传输数据的内存地址。\r\n**第三个参数 DMA_DIR 设置数据传输方向**， 决定是从外设读取数据到内存还送从内存读取数\r\n据发送到外设， 也就是外设是源地还是目的地， 这里**我们设置为从内存读取数据发送到串口**，\r\n所以外设自然就是目的地了，所以选择值为 DMA_DIR_PeripheralDST。\r\n**第四个参数 DMA_BufferSize** 设置一次传输数据量的大小，这个很容易理解。\r\n**第五个参数 DMA_PeripheralInc** 设置传输数据的时候外设地址是不变还是递增。如果设置\r\n为递增，那么下一次传输的时候地址加 1，这里因为我们是一直往固定外设地址&USART1->DR\r\n发送数据，所以地址不递增，值为 DMA_PeripheralInc_Disable；\r\n**第六个参 数 DMA_MemoryInc** 设置传输数据时候内存地址 是否递增。 这个参数 和\r\nDMA_PeripheralInc 意思接近，只不过针对的是内存。 这里我们的场景是将内存中连续存储单\r\n元的数据发送到串口，毫无疑问内存地址是需要递增的，所以值为 DMA_MemoryInc_Enable。\r\n**第七个参数 DMA_PeripheralDataSize** 用来设置外设的数据长度是为字节传输（8bits），半\r\n字 传 输 (16bits) 还 是 字 传 输 (32bits) ， 这 里 我 们 是 8 位 字 节 传 输 ， 所 以 值 设 置 为\r\nDMA_PeripheralDataSize_Byte。\r\n**第八个参数 DMA_MemoryDataSize** 是用来设置内存的数据长度，和第七个参数意思接近，这\r\n里我们同样设置为字节传输 DMA_MemoryDataSize_Byte。\r\n**第九个参数 DMA_Mode** 用来设置 DMA 模式是否循环采集，也就是说，比如我们要从内存中采\r\n集 64 个字节发送到串口，如果设置为重复采集，那么它会在 64 个字节采集完成之后继续从内\r\n存的第一个地址采集，如此循环。这里我们设置为一次连续采集完成之后不循环。所以设置值\r\n为 DMA_Mode_Normal。在我们下面的实验中，如果设置此参数为循环采集，那么你会看到串口\r\n不停的打印数据，不会中断，大家在实验中可以修改这个参数测试一下。\r\n**第十个参数是设置 DMA 通道的优先级**，有低，中，高，超高三种模式，这个在前面讲解过，\r\n这里我们设置优先级别为中级，所以值为 DMA_Priority_Medium。如果要开启多个通道，那么\r\n这个值就非常有意义。\r\n**第 十 一 个 参 数 DMA_M2M 设 置 是 否 是 存 储 器 到 存 储 器 模 式 传 输** ， 这 里 我 们 选 择\r\nDMA_M2M_Disable。\r\n这里我们给出上面场景的实例代码：\r\n\r\n```c\r\nDMA_InitTypeDef DMA_InitStructure;\r\nDMA_InitStructure.DMA_PeripheralBaseAddr = &USART1->DR; //DMA 外设 ADC 基地址\r\nDMA_InitStructure.DMA_MemoryBaseAddr = cmar; //DMA 内存基地址\r\nDMA_InitStructure.DMA_DIR = DMA_DIR_PeripheralDST; //从内存读取发送到外设\r\nDMA_InitStructure.DMA_BufferSize = 64; //DMA 通道的 DMA 缓存的大小\r\nDMA_InitStructure.DMA_PeripheralInc = DMA_PeripheralInc_Disable;//外设地址不变\r\nDMA_InitStructure.DMA_MemoryInc = DMA_MemoryInc_Enable; //内存地址递增\r\nDMA_InitStructure.DMA_PeripheralDataSize = DMA_PeripheralDataSize_Byte; //8 位\r\nDMA_InitStructure.DMA_MemoryDataSize = DMA_MemoryDataSize_Byte; // 8 位\r\nDMA_InitStructure.DMA_Mode = DMA_Mode_Normal; //工作在正常缓存模式\r\nDMA_InitStructure.DMA_Priority = DMA_Priority_Medium; //DMA 通道 x 拥有中优先级\r\nDMA_InitStructure.DMA_M2M = DMA_M2M_Disable; //非内存到内存传输\r\nDMA_Init(DMA_CHx, &DMA_InitStructure); //根据指定的参数初始化\r\n```\r\n\r\n### 3） 使能串口 DMA 发送\r\n\r\n进行 DMA 配置之后，我们就要开启串口的 DMA 发送功能，使用的函数是：\r\n\r\n```c\r\nUSART_DMACmd(USART1,USART_DMAReq_Tx,ENABLE);\r\n```\r\n\r\n如果是要使能串口 DMA 接受，那么第二个参数修改为 USART_DMAReq_Rx 即可。\r\n\r\n### 4） 使能 DMA1 通道 4，启动传输。\r\n\r\n使能串口 DMA 发送之后，我们接着就要使能 DMA 传输通道：\r\n\r\n```c\r\nDMA_Cmd(DMA_CHx, ENABLE);\r\n```\r\n\r\n通过以上 3 步设置，我们就可以启动一次 USART1 的 DMA 传输了。\r\n\r\n### 5） 查询 DMA 传输状态\r\n\r\n在 DMA 传输过程中，我们要查询 DMA 传输通道的状态，使用的函数是：\r\n\r\n```c\r\nFlagStatus DMA_GetFlagStatus(uint32_t DMAy_FLAG)\r\n```\r\n\r\n比如我们要查询 DMA 通道 4 传输是否完成，方法是：\r\n\r\n```c\r\nDMA_GetFlagStatus(DMA2_FLAG_TC4);\r\n```\r\n\r\n这里还有一个比较重要的函数就是获取当前剩余数据量大小的函数：\r\n\r\n```c\r\nuint16_t DMA_GetCurrDataCounter(DMA_Channel_TypeDef* DMAy_Channelx)\r\n```\r\n\r\n比如我们要获取 DMA 通道 4 还有多少个数据没有传输，方法是：\r\n\r\n```c\r\nDMA_GetCurrDataCounter(DMA1_Channel4);\r\n```\r\n\r\nDMA 相关的库函数我们就讲解到这里，大家可以查看固件库中文手册详细了解。\r\n\r\n## 程序设计\r\n\r\n### DMA的4通道初始化\r\n\r\n```c\r\nvoid DMA_CH4_init(u16 bufferSize){\r\n	DMA_InitTypeDef DMA_InitStructure;\r\n	// 1）使能 DMA 时钟\r\n	RCC_AHBPeriphClockCmd(RCC_AHBPeriph_DMA1, ENABLE); //使能 DMA 时钟\r\n	// 2）初始化 DMA 通道 4 参数\r\n	DMA_InitStructure.DMA_PeripheralBaseAddr = (u32)&USART1->DR; //DMA 外设 ADC 基地址\r\n	DMA_InitStructure.DMA_MemoryBaseAddr = (u32)SendBuff; //DMA 内存基地址 // 就是要传的数据的首地址\r\n	DMA_InitStructure.DMA_DIR = DMA_DIR_PeripheralDST; //从内存读取发送到外设\r\n	DMA_InitStructure.DMA_BufferSize = bufferSize; //DMA 通道的 DMA 缓存的大小\r\n	DMA_InitStructure.DMA_PeripheralInc = DMA_PeripheralInc_Disable;//外设地址不变\r\n	DMA_InitStructure.DMA_MemoryInc = DMA_MemoryInc_Enable; //内存地址递增\r\n	DMA_InitStructure.DMA_PeripheralDataSize = DMA_PeripheralDataSize_Byte; //8 位\r\n	DMA_InitStructure.DMA_MemoryDataSize = DMA_MemoryDataSize_Byte; // 8 位\r\n	DMA_InitStructure.DMA_Mode = DMA_Mode_Normal; //工作在正常缓存模式\r\n	DMA_InitStructure.DMA_Priority = DMA_Priority_Medium; //DMA 通道 x 拥有中优先级\r\n	DMA_InitStructure.DMA_M2M = DMA_M2M_Disable; //非内存到内存传输\r\n	DMA_Init(DMA1_Channel4, &DMA_InitStructure); //根据指定的参数初始化\r\n	// 3） 使能串口 DMA 发送\r\n	USART_DMACmd(USART1,USART_DMAReq_Tx,ENABLE);\r\n	// 4） 使能 DMA1 通道 4，启动传输。\r\n	DMA_Cmd(DMA1_Channel4, ENABLE);\r\n}\r\n```\r\n\r\n### 开启一次DMA传输\r\n\r\n```c\r\n//开启一次 DMA 传输\r\nvoid MYDMA_Enable(DMA_Channel_TypeDef*DMA_CHx)\r\n{\r\n	DMA_Cmd(DMA_CHx, DISABLE ); //关闭 USART1 TX DMA1 所指示的通道\r\n	DMA_SetCurrDataCounter(DMA1_Channel4,SEND_BUF_SIZE);//设置 DMA 缓存的大小\r\n	DMA_Cmd(DMA_CHx, ENABLE); //使能 USART1 TX DMA1 所指示的通道\r\n}\r\n\r\n```\r\n\r\n### 主函数\r\n\r\n```c\r\n#include \"stm32f10x.h\"\r\n#include \"delay.h\"\r\n#include \"usart.h\"\r\n#include \"lcd.h\"\r\n#include \"led.h\"\r\n#include \"sys.h\" \r\n#include \"key.h\"\r\n#define SEND_BUF_SIZE 8200\r\nu8 SendBuff[SEND_BUF_SIZE]; //发送数据缓冲区\r\nconst u8 TEXT_TO_SEND[]={\"hello world \"};\r\nint main(void)\r\n {		\r\n	u16 i;\r\n	u8 t=0;\r\n	u8 j,mask=0;\r\n	float pro=0;//进度\r\n	delay_init();	    	 //延时函数初始化	  \r\n	NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2); //设置NVIC中断分组2:2位抢占优先级，2位响应优先级 	\r\n	uart_init(115200);\r\n    KEY_Init();\r\n    LED_Init();\r\n	LCD_Init();\r\n	DMA_CH4_init(SEND_BUF_SIZE);\r\n\r\n	j=sizeof(TEXT_TO_SEND);\r\n	for(i=0;i<SEND_BUF_SIZE;i++)//填充数据到 SendBuff\r\n	{\r\n		if(t>=j)//加入换行符\r\n		{\r\n			if(mask)\r\n			{\r\n				SendBuff[i]=0x0a;\r\n				t=0;\r\n			}else\r\n			{\r\n				SendBuff[i]=0x0d;\r\n				mask++;\r\n			}\r\n		}else//复制 TEXT_TO_SEND 语句\r\n		{\r\n			mask=0;\r\n			SendBuff[i]=TEXT_TO_SEND[t];\r\n			t++;\r\n		}\r\n	}\r\n	while(1)\r\n	{	    \r\n		t=KEY_Scan(0);\r\n	 	if(t==KEY0_PRES)\r\n		{//KEY0 按下\r\n			USART_DMACmd(USART1,USART_DMAReq_Tx,ENABLE);\r\n			//使能串口 1 的 DMA 发送\r\n			MYDMA_Enable(DMA1_Channel4);//开始一次 DMA 传输！\r\n			//等待 DMA 传输完成，此时我们来做另外一些事，点灯\r\n			//实际应用中，传输数据期间，可以执行另外的任务\r\n			while(1)\r\n			{\r\n				if(DMA_GetFlagStatus(DMA1_FLAG_TC4)!=RESET)//判断通道 4 传输完成\r\n				{\r\n					DMA_ClearFlag(DMA1_FLAG_TC4);//清除通道 4 传输完成标志\r\n					break;\r\n				}\r\n					pro=DMA_GetCurrDataCounter(DMA1_Channel4);//得到当前剩余数据量\r\n					pro=1-pro/SEND_BUF_SIZE;//得到百分比\r\n					pro*=100; //扩大 100 倍\r\n					LCD_ShowNum(30,170,pro,3,16);\r\n			}\r\n				LCD_ShowNum(30,170,100,3,16);//显示 100%\r\n				LCD_ShowString(30,150,200,16,16,\"Transimit Finished!\");//提示传送完成\r\n		}\r\n	}\r\n}\r\n```\r\n\r\n# 二十、IIC\r\n\r\n利用 STM32F1 的普通 IO 口模拟 IIC 时序，并实现和 24C02 之\r\n间的双向通信。   \r\n\r\n## 简介\r\n\r\nIIC(Inter－Integrated Circuit)总线是一种由 PHILIPS 公司开发的两线式串行总线，用于连接\r\n微控制器及其外围设备。它是由数据线 SDA 和时钟 SCL 构成的串行总线，可发送和接收数据。\r\n在 CPU 与被控 IC 之间、 IC 与 IC 之间进行双向传送， 高速 IIC 总线一般可达 400kbps 以上。\r\nI2C 总线在传送数据过程中共有三种类型信号， 它们分别是：开始信号、结束信号和应答\r\n信号。\r\n开始信号： SCL 为高电平时， SDA 由高电平向低电平跳变，开始传送数据。\r\n结束信号： SCL 为高电平时， SDA 由低电平向高电平跳变，结束传送数据。\r\n应答信号：接收数据的 IC 在接收到 8bit 数据后，向发送数据的 IC 发出特定的低电平脉冲，\r\n表示已收到数据。 CPU 向受控单元发出一个信号后，等待受控单元发出一个应答信号， CPU 接\r\n收到应答信号后，根据实际情况作出是否继续传递信号的判断。若未收到应答信号，由判断为\r\n受控单元出现故障。  \r\n\r\n![image-20211015110347285](cloudDisk/markdown/stm32笔记.assets/image-20211015110347285.png)\r\n\r\n本章实验功能简介：开机的时候先检测 24C02 是否存在，然后在主循环里面用 1 个按键\r\n（KEY0）用来执行写入 24C02 的操作，另外一个按键（WK_UP）用来执行读出操作，在 TFTLCD\r\n模块上显示相关信息。同时用 DS0 提示程序正在运行。  \r\n\r\n## 硬件设计\r\n\r\n![image-20211015110455928](cloudDisk/markdown/stm32笔记.assets/image-20211015110455928.png)\r\n\r\n## 程序设计\r\n\r\n### 引入两个库\r\n\r\n![image-20211015130813306](cloudDisk/markdown/stm32笔记.assets/image-20211015130813306.png)\r\n\r\n### 库中主要方法定义\r\n\r\n```c\r\nu8 AT24CXX_ReadOneByte(u16 ReadAddr);							//指定地址读取一个字节\r\nvoid AT24CXX_WriteOneByte(u16 WriteAddr,u8 DataToWrite);		//指定地址写入一个字节\r\nvoid AT24CXX_WriteLenByte(u16 WriteAddr,u32 DataToWrite,u8 Len);//指定地址开始写入指定长度的数据\r\nu32 AT24CXX_ReadLenByte(u16 ReadAddr,u8 Len);					//指定地址开始读取指定长度数据\r\nvoid AT24CXX_Write(u16 WriteAddr,u8 *pBuffer,u16 NumToWrite);	//从指定地址开始写入指定长度的数据\r\nvoid AT24CXX_Read(u16 ReadAddr,u8 *pBuffer,u16 NumToRead);   	//从指定地址开始读出指定长度的数据\r\n\r\nu8 AT24CXX_Check(void);  //检查器件\r\nvoid AT24CXX_Init(void); //初始化IIC\r\n```\r\n\r\n### 主函数\r\n\r\n```C\r\n#include \"stm32f10x.h\"\r\n#include \"delay.h\"\r\n#include \"usart.h\"\r\n#include \"lcd.h\"\r\n#include \"led.h\"\r\n#include \"sys.h\" \r\n#include \"key.h\"\r\n#include \"myiic.h\"\r\n#include \"24cxx.h\"\r\nint main(void){		\r\n	u8 k;\r\n	u8 write_data[] = {\"w x h n z x\"}; // 要发送的数据\r\n	const u16 size = sizeof(write_data); // 发送的数据大小\r\n	u8 read_data[size]; // 读取到的数据存入的地方\r\n	delay_init();	    	 //延时函数初始化	  \r\n	NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2); //设置NVIC中断分组2:2位抢占优先级，2位响应优先级 	\r\n	uart_init(115200);\r\n    KEY_Init();\r\n    LED_Init();\r\n	LCD_Init();\r\n	AT24CXX_Init();\r\n    POINT_COLOR=BLUE;\r\n	LCD_ShowString(0,0,200,16,16,\"voltage:\");\r\n	// 看看有没有接入AT24CXX\r\n	while (AT24CXX_Check()){\r\n		// 检测器件\r\n		LCD_ShowString(30,150,200,16,16,\"24C02 Check Failed!\");\r\n		delay_ms(500);\r\n		LCD_ShowString(30,150,200,16,16,\"Please Check! \");\r\n		delay_ms(500);\r\n		LED0=!LED0;//DS0 闪烁\r\n	}\r\n	LCD_ShowString(30,150,200,16,16,\"24C02 Ready!\");\r\n	while(1){	    \r\n		k = KEY_Scan(0);\r\n		if(k == KEY0){\r\n			// 写入数据\r\n			LCD_Fill(0,170,239,319,WHITE);//清除半屏\r\n			LCD_ShowString(30,170,200,16,16,\"Start Write 24C02....\");\r\n			AT24CXX_Write(0,write_data,size);\r\n			LCD_ShowString(30,170,200,16,16,\"24C02 Write Finished!\");//提示传送完成\r\n		}else if (k == KEY1){\r\n			// 读取数据\r\n			LCD_ShowString(30,170,200,16,16,\"Start Read 24C02.... \");\r\n			AT24CXX_Read(0,read_data,size);\r\n			LCD_ShowString(30,170,200,16,16,\"The Data Readed Is: \");//提示传送完成\r\n			LCD_ShowString(30,190,200,16,16,read_data);//显示读到的字符串\r\n			// printf(\"%s\",read_data);\r\n		}\r\n		\r\n	}	  \r\n}\r\n```\r\n\r\n# 二十一、SPI\r\n\r\n利用 STM32F1 自带的 SPI来实现对外部 FLASH（W25Q128）的读写  \r\n\r\n## 简介\r\n\r\nSPI 是英语 Serial Peripheral interface 的缩写，顾名思义就是串行外围设备接口。是 Motorola首先在其 MC68HCXX 系列处理器上定义的。 SPI 接口主要应用在 EEPROM， FLASH，实时时钟， AD 转换器，还有数字信号处理器和数字信号解码器之间。 SPI，是一种高速的，全双工，同步的通信总线，并且在芯片的管脚上只占用四根线，节约了芯片的管脚，同时为 PCB 的布局上节省空间，提供方便，正是出于这种简单易用的特性，现在越来越多的芯片集成了这种通信协议， STM32 也有 SPI 接口。 下面我们看看 SPI 的内部简明图（图 28.1.1）：  \r\n\r\n![image-20211015135246052](cloudDisk/markdown/stm32笔记.assets/image-20211015135246052.png)\r\n\r\n主机和从机都有一个串行移位寄存器，主机通过向它的 SPI 串行寄存器\r\n写入一个字节来发起一次传输。寄存器通过 MOSI 信号线将字节传送给从机，从机也将自己的移位寄存器中的内容通过 MISO 信号线返回给主机。这样，两个移位寄存器中的内容就被交换。外设的写操作和读操作是同步完成的。如果只进行写操作，主机只需忽略接收到的字节；反之，若主机要读取从机的一个字节，就必须发送一个空字节来引发从机的传输。  \r\n\r\nSPI 主要特点有： 可以同时发出和接收串行数据； 可以当作主机或从机工作； 提供频率可编程时钟； 发送结束中断标志； 写冲突保护； 总线竞争保护等。  \r\n\r\nSPI 总线**四种工作方式** SPI 模块为了和外设进行数据交换，根据外设工作要求，其输出串行同步时钟极性和相位可以进行配置，时钟极性（CPOL）对传输协议没有重大的影响。如果CPOL=0，串行同步时钟的空闲状态为低电平；如果 CPOL=1，串行同步时钟的空闲状态为高电\r\n平。时钟相位（ CPHA）能够配置用于选择两种不同的传输协议之一进行数据传输。如果CPHA=0，在串行同步时钟的第一个跳变沿（上升或下降）数据被采样；如果 CPHA=1，在串行同步时钟的第二个跳变沿（上升或下降）数据被采样。 SPI 主模块和与之通信的外设备时钟相位和极性应该一致。  \r\n\r\n![image-20211015154343900](cloudDisk/markdown/stm32笔记.assets/image-20211015154343900.png)\r\n\r\nSTM32 的 SPI 功能很强大， SPI 时钟最多可以到 18Mhz，支持 DMA，可以配置为 SPI 协\r\n议或者 I2S 协议（仅大容量型号支持， 精英 STM32 开发板是支持的）。\r\n本章，我们将利用 STM32 的 SPI 来读取外部 SPI FLASH 芯片（W25Q128），实现类似上\r\n节的功能。这里对 SPI 我们只简单介绍一下 SPI 的使用  \r\n\r\n## 配置步骤\r\n\r\n![image-20211015155110690](cloudDisk/markdown/stm32笔记.assets/image-20211015155110690.png)\r\n\r\n### 1） 配置相关引脚的复用功能，使能 SPI2 时钟\r\n\r\n我们要用 SPI2，第一步就要使能 SPI2 的时钟。其次要设置 SPI2 的相关引脚为复用输出，\r\n这样才会连接到 SPI2 上否则这些 IO 口还是默认的状态，也就是标准输入输出口。这里我们使\r\n用的是 PB13、 14、 15 这 3 个（SCK.、 MISO、 MOSI， CS 使用软件管理方式），所以设置这三\r\n个为复用 IO。\r\n\r\n```c\r\nGPIO_InitTypeDef GPIO_InitStructure;\r\nRCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB, ENABLE );//PORTB 时钟使能\r\nRCC_APB1PeriphClockCmd(RCC_APB1Periph_SPI2, ENABLE );//SPI2 时钟使能\r\nGPIO_InitStructure.GPIO_Pin = GPIO_Pin_13 | GPIO_Pin_14 | GPIO_Pin_15;\r\nGPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP; //PB13/14/15 复用推挽输出\r\nGPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;\r\nGPIO_Init(GPIOB, &GPIO_InitStructure);//初始化 GPIOB\r\n```\r\n\r\n类似的时钟使能和 IO 初始化我们前面多次讲解到，这里不做详细介绍。\r\n\r\n### 2） 初始化 SPI2,设置 SPI2 工作模式\r\n\r\n接下来我们要初始化 SPI2,设置 SPI2 为主机模式，设置数据格式为 8 位，然设置 SCK 时钟极性及采样方式。并设置 SPI2 的时钟频率（最大 18Mhz），以及数据的格式（MSB 在前还是LSB 在前）。 这在库函数中是通过 SPI_Init 函数来实现的。\r\n\r\n```c\r\nvoid SPI_Init(SPI_TypeDef* SPIx, SPI_InitTypeDef* SPI_InitStruct)；\r\n```\r\n\r\n跟其他外设初始化一样，第一个参数是 SPI 标号，这里我们是使用的 SPI2。 下面我们来看看第\r\n二个参数结构体类型 SPI_InitTypeDef 的定义：\r\n\r\n```c\r\ntypedef struct\r\n{\r\n    uint16_t SPI_Direction;\r\n    uint16_t SPI_Mode;\r\n    uint16_t SPI_DataSize;\r\n    uint16_t SPI_CPOL;\r\n    uint16_t SPI_CPHA;\r\n    uint16_t SPI_NSS;\r\n    uint16_t SPI_BaudRatePrescaler;\r\n    uint16_t SPI_FirstBit;\r\n    uint16_t SPI_CRCPolynomial;\r\n}SPI_InitTypeDef;\r\n```\r\n\r\n结构体成员变量比较多，这里我们挑取几个重要的成员变量讲解一下：\r\n**第一个参数 SPI_Direction** 是用来设置 SPI 的通信方式， 可以选择为半双工，全双工，以及串行发和串行收方式， 这里我们选择全双工模式 SPI_Direction_2Lines_FullDuplex。\r\n**第二个参数 SPI_Mode** 用来设置 SPI 的主从模式，这里我们设置为主机模式 SPI_Mode_Master，当然有需要你也可以选择为从机模式 SPI_Mode_Slave。\r\n**第三个参数 SPI_DataSiz** 为 8 位还是 16 位帧格式选择项，这里我们是 8 位传输，选择SPI_DataSize_8b。\r\n**第四个参数 SPI_CPOL** 用来设置时钟极性， 我们设置串行同步时钟的空闲状态为高电平所以我们选择 SPI_CPOL_High。\r\n**第五个参数 SPI_CPHA** 用来设置时钟相位， 也就是选择在串行同步时钟的第几个跳变沿（上升或下降）数据被采样， 可以为第一个或者第二个条边沿采集， 这里我们选择第二个跳变沿，所以选择 SPI_CPHA_2Edge\r\n**第六个参数 SPI_NSS** 设置 NSS 信号由硬件（NSS 管脚）还是软件控制，这里我们通过软件控制 NSS 关键，而不是硬件自动控制，所以选择 SPI_NSS_Soft。\r\n**第七个参数 SPI_BaudRatePrescaler** 很关键，就是设置 SPI 波特率预分频值也就是决定 SPI 的时钟的参数， 从不分频道 256 分频 8 个可选值，初始化的时候我们选择 256 分频值SPI_BaudRatePrescaler_256, 传输速度为 36M/256=140.625KHz。\r\n**第八个参数 SPI_FirstBit** 设置数据传输顺序是 MSB 位在前还是 LSB 位在前， ，这里我们选择SPI_FirstBit_MSB 高位在前。\r\n**第九个参数 SPI_CRCPolynomial** 是用来设置 CRC 校验多项式， 提高通信可靠性， 大于 1 即可。设置好上面 9 个参数，我们就可以初始化 SPI 外设了。 初始化的范例格式为：\r\n\r\n```c\r\nSPI_InitTypeDef SPI_InitStructure;\r\nSPI_InitStructure.SPI_Direction = SPI_Direction_2Lines_FullDuplex; //双线双向全双工\r\nSPI_InitStructure.SPI_Mode = SPI_Mode_Master; //主 SPI\r\nSPI_InitStructure.SPI_DataSize = SPI_DataSize_8b; // SPI 发送接收 8 位帧结构\r\nSPI_InitStructure.SPI_CPOL = SPI_CPOL_High;//串行同步时钟的空闲状态为高电平\r\nSPI_InitStructure.SPI_CPHA = SPI_CPHA_2Edge;//第二个跳变沿数据被采样\r\nSPI_InitStructure.SPI_NSS = SPI_NSS_Soft; //NSS 信号由软件控制\r\nSPI_InitStructure.SPI_BaudRatePrescaler = SPI_BaudRatePrescaler_256; //预分频 256\r\nSPI_InitStructure.SPI_FirstBit = SPI_FirstBit_MSB; //数据传输从 MSB 位开始\r\nSPI_InitStructure.SPI_CRCPolynomial = 7; //CRC 值计算的多项式\r\nSPI_Init(SPI2, &SPI_InitStructure); //根据指定的参数初始化外设 SPIx 寄存器\r\n```\r\n\r\n### 3） 使能 SPI2\r\n\r\n初始化完成之后接下来是要使能 SPI2 通信了， 在使能 SPI2 之后，我们就可以开始 SPI 通\r\n讯了。 使能 SPI2 的方法是：\r\n\r\n```c\r\nSPI_Cmd(SPI2, ENABLE); //使能 SPI 外设\r\n```\r\n\r\n\r\n\r\n### 4） SPI 传输数据\r\n\r\n通信接口当然需要有发送数据和接受数据的函数，固件库提供的发送数据函数原型为：\r\n\r\n```c\r\nvoid SPI_I2S_SendData(SPI_TypeDef* SPIx, uint16_t Data)；\r\n```\r\n\r\n这个函数很好理解，往 SPIx 数据寄存器写入数据 Data，从而实现发送。\r\n固件库提供的接受数据函数原型为：\r\n\r\n```c\r\nuint16_t SPI_I2S_ReceiveData(SPI_TypeDef* SPIx) ；\r\n```\r\n\r\n这个函数也不难理解，从 SPIx 数据寄存器读出接受到的数据。\r\n\r\n### 5） 查看 SPI 传输状态\r\n\r\n在 SPI 传输过程中，我们经常要判断数据是否传输完成，发送区是否为空等等状态，这是\r\n通过函数 SPI_I2S_GetFlagStatus 实现的，这个函数很简单就不详细讲解，判断发送是否完成的\r\n方法是：\r\n\r\n```c\r\nSPI_I2S_GetFlagStatus(SPI2, SPI_I2S_FLAG_RXNE)；\r\n```\r\n\r\n### 6）片选cs\r\n\r\ncs为1时不选中\r\n\r\n```c\r\nW25QXX_CS=1;	\r\n```\r\n\r\ncs为0时选中\r\n\r\n```c\r\nW25QXX_CS=0;	\r\n```\r\n\r\nSPI2 的使用就介绍到这里，接下来介绍一下 W25Q128。 W25Q128 是华邦公司推出的大容量 SPI FLASH 产品， W25Q128 的容量为 128Mb， 该系列还有 W25Q80/16/32/64 等。 ALIENTEK所选择的 W25Q128 容量为 128Mb，也就是 16M 字节。W25Q128 将 **16M 的容量分为 256 个块（Block），每个块大小为 64K 字节，每个块又分为16 个扇区（Sector），每个扇区 4K 个字节。** W25Q128 的最小擦除单位为一个扇区，也就是每次必须擦除 4K 个字节。这样**我们需要给 W25Q128 开辟一个至少 4K 的缓存区，这样对 SRAM 要求比较高，要求芯片必须有 4K 以上 SRAM 才能很好的操作**。W25Q128 的擦写周期多达 10W 次，具有 20 年的数据保存期限，支持电压为 2.7~3.6V，W25Q128 支持标准的 SPI，还支持双输出/四输出的 SPI，最大 SPI 时钟可以到 80Mhz（双输出时相当于 160Mhz，四输出时相当于 320M），更多的 W25Q128 的介绍，请参考 W25Q128 的DATASHEET。\r\n\r\n## 程序设计\r\n\r\n### spi2初始化函数\r\n\r\n```c\r\nvoid SPI2_Init(void)\r\n{\r\n 	GPIO_InitTypeDef GPIO_InitStructure;\r\n  SPI_InitTypeDef  SPI_InitStructure;\r\n\r\n	RCC_APB2PeriphClockCmd(	RCC_APB2Periph_GPIOB, ENABLE );//PORTB时钟使能 \r\n	RCC_APB1PeriphClockCmd(	RCC_APB1Periph_SPI2,  ENABLE );//SPI2时钟使能 	\r\n \r\n	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_13 | GPIO_Pin_14 | GPIO_Pin_15;\r\n	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;  //PB13/14/15复用推挽输出 \r\n	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;\r\n	GPIO_Init(GPIOB, &GPIO_InitStructure);//初始化GPIOB\r\n\r\n 	GPIO_SetBits(GPIOB,GPIO_Pin_13|GPIO_Pin_14|GPIO_Pin_15);  //PB13/14/15上拉\r\n\r\n	SPI_InitStructure.SPI_Direction = SPI_Direction_2Lines_FullDuplex;  //设置SPI单向或者双向的数据模式:SPI设置为双线双向全双工\r\n	SPI_InitStructure.SPI_Mode = SPI_Mode_Master;		//设置SPI工作模式:设置为主SPI\r\n	SPI_InitStructure.SPI_DataSize = SPI_DataSize_8b;		//设置SPI的数据大小:SPI发送接收8位帧结构\r\n	SPI_InitStructure.SPI_CPOL = SPI_CPOL_High;		//串行同步时钟的空闲状态为高电平\r\n	SPI_InitStructure.SPI_CPHA = SPI_CPHA_2Edge;	//串行同步时钟的第二个跳变沿（上升或下降）数据被采样\r\n	SPI_InitStructure.SPI_NSS = SPI_NSS_Soft;		//NSS信号由硬件（NSS管脚）还是软件（使用SSI位）管理:内部NSS信号有SSI位控制\r\n	SPI_InitStructure.SPI_BaudRatePrescaler = SPI_BaudRatePrescaler_256;		//定义波特率预分频的值:波特率预分频值为256\r\n	SPI_InitStructure.SPI_FirstBit = SPI_FirstBit_MSB;	//指定数据传输从MSB位还是LSB位开始:数据传输从MSB位开始\r\n	SPI_InitStructure.SPI_CRCPolynomial = 7;	//CRC值计算的多项式\r\n	SPI_Init(SPI2, &SPI_InitStructure);  //根据SPI_InitStruct中指定的参数初始化外设SPIx寄存器\r\n \r\n	SPI_Cmd(SPI2, ENABLE); //使能SPI外设\r\n	\r\n	SPI2_ReadWriteByte(0xff);//启动传输		 \r\n \r\n\r\n}   \r\n```\r\n\r\n### spi速度设置\r\n\r\n```c\r\n//SPI 速度设置函数\r\n//SpeedSet:\r\n//SPI_BaudRatePrescaler_2   2分频   \r\n//SPI_BaudRatePrescaler_8   8分频   \r\n//SPI_BaudRatePrescaler_16  16分频  \r\n//SPI_BaudRatePrescaler_256 256分频 \r\n  \r\nvoid SPI2_SetSpeed(u8 SPI_BaudRatePrescaler)\r\n{\r\n  assert_param(IS_SPI_BAUDRATE_PRESCALER(SPI_BaudRatePrescaler));\r\n	SPI2->CR1&=0XFFC7;\r\n	SPI2->CR1|=SPI_BaudRatePrescaler;	//设置SPI2速度 \r\n	SPI_Cmd(SPI2,ENABLE); \r\n\r\n} \r\n```\r\n\r\n### 读写指令函数\r\n\r\n```c\r\n//SPIx 读写一个字节\r\n//TxData:要写入的字节\r\n//返回值:读取到的字节\r\nu8 SPI2_ReadWriteByte(u8 TxData)\r\n{		\r\n	u8 retry=0;				 	\r\n	while (SPI_I2S_GetFlagStatus(SPI2, SPI_I2S_FLAG_TXE) == RESET) //检查指定的SPI标志位设置与否:发送缓存空标志位\r\n		{\r\n		retry++;\r\n		if(retry>200)return 0;\r\n		}			  \r\n	SPI_I2S_SendData(SPI2, TxData); //通过外设SPIx发送一个数据\r\n	retry=0;\r\n\r\n	while (SPI_I2S_GetFlagStatus(SPI2, SPI_I2S_FLAG_RXNE) == RESET) //检查指定的SPI标志位设置与否:接受缓存非空标志位\r\n		{\r\n		retry++;\r\n		if(retry>200)return 0;\r\n		}	  						    \r\n	return SPI_I2S_ReceiveData(SPI2); //返回通过SPIx最近接收的数据					    \r\n}\r\n```\r\n\r\n### w25qxx.c - W25Q128 操作相关的代码 \r\n\r\n#### 头文件\r\n\r\n```c\r\n#include \"w25qxx.h\" \r\n#include \"spi.h\"\r\n#include \"delay.h\"\r\n#include \"usart.h\"\r\n25QXX_TYPE=W25Q128;	//默认是W25Q128\r\n```\r\n\r\n#### 初始化\r\n\r\n```c\r\n//4Kbytes为一个Sector\r\n//16个扇区为1个Block\r\n//W25Q128\r\n//容量为16M字节,共有128个Block,4096个Sector \r\n													 \r\n//初始化SPI FLASH的IO口\r\nvoid W25QXX_Init(void)\r\n{	\r\n	// 使能控制片选的GPIO引脚\r\n  GPIO_InitTypeDef GPIO_InitStructure;\r\n	RCC_APB2PeriphClockCmd(	RCC_APB2Periph_GPIOB, ENABLE );//PORTB时钟使能 \r\n\r\n	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_12;  // PB12 推挽 \r\n 	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;  //推挽输出\r\n	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;\r\n 	GPIO_Init(GPIOB, &GPIO_InitStructure);\r\n 	GPIO_SetBits(GPIOB,GPIO_Pin_12);\r\n \r\n        W25QXX_CS=1;				//SPI FLASH不选中\r\n	SPI2_Init();		   	//初始化SPI\r\n	SPI2_SetSpeed(SPI_BaudRatePrescaler_2);//设置为18M时钟,高速模式\r\n	W25QXX_TYPE=W25QXX_ReadID();//读取FLASH ID.  \r\n\r\n}  \r\n```\r\n\r\n#### 读取状态寄存器\r\n\r\n```c\r\n//读取W25QXX的状态寄存器\r\n//BIT7  6   5   4   3   2   1   0\r\n//SPR   RV  TB BP2 BP1 BP0 WEL BUSY\r\n//SPR:默认0,状态寄存器保护位,配合WP使用\r\n//TB,BP2,BP1,BP0:FLASH区域写保护设置\r\n//WEL:写使能锁定\r\n//BUSY:忙标记位(1,忙;0,空闲)\r\n//默认:0x00\r\nu8 W25QXX_ReadSR(void)   \r\n{  \r\n	u8 byte=0;   \r\n	W25QXX_CS=0;                            //使能器件   \r\n	SPI2_ReadWriteByte(W25X_ReadStatusReg); //发送读取状态寄存器命令    \r\n	byte=SPI2_ReadWriteByte(0Xff);          //读取一个字节  \r\n	W25QXX_CS=1;                            //取消片选     \r\n	return byte;   \r\n} \r\n```\r\n\r\n#### 写状态寄存器\r\n\r\n```c\r\n//写W25QXX状态寄存器\r\n//只有SPR,TB,BP2,BP1,BP0(bit 7,5,4,3,2)可以写!!!\r\nvoid W25QXX_Write_SR(u8 sr)   \r\n{   \r\n	W25QXX_CS=0;                            //使能器件   \r\n	SPI2_ReadWriteByte(W25X_WriteStatusReg);//发送写取状态寄存器命令    \r\n	SPI2_ReadWriteByte(sr);               	//写入一个字节  \r\n	W25QXX_CS=1;                            //取消片选     	      \r\n}   \r\n```\r\n\r\n#### 写使能\r\n\r\n```c\r\n//W25QXX写使能	\r\n//将WEL置位   \r\nvoid W25QXX_Write_Enable(void)   \r\n{\r\n	W25QXX_CS=0;                          	//使能器件   \r\n    SPI2_ReadWriteByte(W25X_WriteEnable); 	//发送写使能  \r\n	W25QXX_CS=1;                           	//取消片选     	      \r\n} \r\n```\r\n\r\n#### 写禁止\r\n\r\n```c\r\n//W25QXX写禁止	\r\n//将WEL清零  \r\nvoid W25QXX_Write_Disable(void)   \r\n{  \r\n	W25QXX_CS=0;                            //使能器件   \r\n    SPI2_ReadWriteByte(W25X_WriteDisable);  //发送写禁止指令    \r\n	W25QXX_CS=1;                            //取消片选     	      \r\n} \r\n```\r\n\r\n#### 读芯片id\r\n\r\n```c\r\n//读取芯片ID\r\n//返回值如下:				   \r\n//0XEF13,表示芯片型号为W25Q80  \r\n//0XEF14,表示芯片型号为W25Q16    \r\n//0XEF15,表示芯片型号为W25Q32  \r\n//0XEF16,表示芯片型号为W25Q64 \r\n//0XEF17,表示芯片型号为W25Q128 	  \r\nu16 W25QXX_ReadID(void)\r\n{\r\n	u16 Temp = 0;	  \r\n	W25QXX_CS=0;				    \r\n	SPI2_ReadWriteByte(0x90);//发送读取ID命令	    \r\n	SPI2_ReadWriteByte(0x00); 	    \r\n	SPI2_ReadWriteByte(0x00); 	    \r\n	SPI2_ReadWriteByte(0x00); 	 			   \r\n	Temp|=SPI2_ReadWriteByte(0xFF)<<8;  \r\n	Temp|=SPI2_ReadWriteByte(0xFF);	 \r\n	W25QXX_CS=1;				    \r\n	return Temp;\r\n}   	\r\n```\r\n\r\n#### 读flash\r\n\r\n```c\r\n//读取SPI FLASH  \r\n//在指定地址开始读取指定长度的数据\r\n//pBuffer:数据存储区\r\n//ReadAddr:开始读取的地址(24bit)\r\n//NumByteToRead:要读取的字节数(最大65535)\r\nvoid W25QXX_Read(u8* pBuffer,u32 ReadAddr,u16 NumByteToRead)   \r\n{ \r\n 	u16 i;   										    \r\n	W25QXX_CS=0;                            	//使能器件   \r\n    SPI2_ReadWriteByte(W25X_ReadData);         	//发送读取命令   \r\n    SPI2_ReadWriteByte((u8)((ReadAddr)>>16));  	//发送24bit地址    \r\n    SPI2_ReadWriteByte((u8)((ReadAddr)>>8));   \r\n    SPI2_ReadWriteByte((u8)ReadAddr);   \r\n    for(i=0;i<NumByteToRead;i++)\r\n	{ \r\n        pBuffer[i]=SPI2_ReadWriteByte(0XFF);   	//循环读数  \r\n    }\r\n	W25QXX_CS=1;  				    	      \r\n}  \r\n```\r\n\r\nW25Q128 支持以任意地址（但是不能超过 W25Q128 的地址范围）开始读取数据，所以，这个代码相对来说就比较简单了，在发送 24 位地址之后，程序就可以开始循环读数据了，其地址会自动增加的，不过要注意，不能读的数据超过了 W25Q128 的地址范围哦！否则读出来的数据，就不是你想要的数据了  \r\n\r\n#### 写flash_page\r\n\r\n```c\r\n//SPI在一页(0~65535)内写入少于256个字节的数据\r\n//在指定地址开始写入最大256字节的数据\r\n//pBuffer:数据存储区\r\n//WriteAddr:开始写入的地址(24bit)\r\n//NumByteToWrite:要写入的字节数(最大256),该数不应该超过该页的剩余字节数!!!	 \r\nvoid W25QXX_Write_Page(u8* pBuffer,u32 WriteAddr,u16 NumByteToWrite)\r\n{\r\n 	u16 i;  \r\n    W25QXX_Write_Enable();                  	//SET WEL \r\n	W25QXX_CS=0;                            	//使能器件   \r\n    SPI2_ReadWriteByte(W25X_PageProgram);      	//发送写页命令   \r\n    SPI2_ReadWriteByte((u8)((WriteAddr)>>16)); 	//发送24bit地址    \r\n    SPI2_ReadWriteByte((u8)((WriteAddr)>>8));   \r\n    SPI2_ReadWriteByte((u8)WriteAddr);   \r\n    for(i=0;i<NumByteToWrite;i++)SPI2_ReadWriteByte(pBuffer[i]);//循环写数  \r\n	W25QXX_CS=1;                            	//取消片选 \r\n	W25QXX_Wait_Busy();					   		//等待写入结束\r\n} \r\n```\r\n\r\n#### 写flash，无校验位\r\n\r\n```c\r\n//无检验写SPI FLASH \r\n//必须确保所写的地址范围内的数据全部为0XFF,否则在非0XFF处写入的数据将失败!\r\n//具有自动换页功能 \r\n//在指定地址开始写入指定长度的数据,但是要确保地址不越界!\r\n//pBuffer:数据存储区\r\n//WriteAddr:开始写入的地址(24bit)\r\n//NumByteToWrite:要写入的字节数(最大65535)\r\n//CHECK OK\r\nvoid W25QXX_Write_NoCheck(u8* pBuffer,u32 WriteAddr,u16 NumByteToWrite)   \r\n{ 			 		 \r\n	u16 pageremain;	   \r\n	pageremain=256-WriteAddr%256; //单页剩余的字节数		 	    \r\n	if(NumByteToWrite<=pageremain)pageremain=NumByteToWrite;//不大于256个字节\r\n	while(1)\r\n	{	   \r\n		W25QXX_Write_Page(pBuffer,WriteAddr,pageremain);\r\n		if(NumByteToWrite==pageremain)break;//写入结束了\r\n	 	else //NumByteToWrite>pageremain\r\n		{\r\n			pBuffer+=pageremain;\r\n			WriteAddr+=pageremain;	\r\n\r\n			NumByteToWrite-=pageremain;			  //减去已经写入了的字节数\r\n			if(NumByteToWrite>256)pageremain=256; //一次可以写入256个字节\r\n			else pageremain=NumByteToWrite; 	  //不够256个字节了\r\n		}\r\n	};	    \r\n} \r\n```\r\n\r\n#### 写flash\r\n\r\n```c\r\n//写SPI FLASH  \r\n//在指定地址开始写入指定长度的数据\r\n//该函数带擦除操作!\r\n//pBuffer:数据存储区\r\n//WriteAddr:开始写入的地址(24bit)						\r\n//NumByteToWrite:要写入的字节数(最大65535)   \r\nu8 W25QXX_BUFFER[4096];		 \r\nvoid W25QXX_Write(u8* pBuffer,u32 WriteAddr,u16 NumByteToWrite)   \r\n{ \r\n	u32 secpos;\r\n	u16 secoff;\r\n	u16 secremain;	   \r\n 	u16 i;    \r\n	u8 * W25QXX_BUF;	  \r\n   	W25QXX_BUF=W25QXX_BUFFER;	     \r\n 	secpos=WriteAddr/4096;//扇区地址  \r\n	secoff=WriteAddr%4096;//在扇区内的偏移\r\n	secremain=4096-secoff;//扇区剩余空间大小   \r\n 	//printf(\"ad:%X,nb:%X\\r\\n\",WriteAddr,NumByteToWrite);//测试用\r\n 	if(NumByteToWrite<=secremain)secremain=NumByteToWrite;//不大于4096个字节\r\n	while(1) \r\n	{	\r\n		W25QXX_Read(W25QXX_BUF,secpos*4096,4096);//读出整个扇区的内容\r\n		for(i=0;i<secremain;i++)//校验数据\r\n		{\r\n			if(W25QXX_BUF[secoff+i]!=0XFF)break;//需要擦除  	  \r\n		}\r\n		if(i<secremain)//需要擦除\r\n		{\r\n			W25QXX_Erase_Sector(secpos);		//擦除这个扇区\r\n			for(i=0;i<secremain;i++)	   		//复制\r\n			{\r\n				W25QXX_BUF[i+secoff]=pBuffer[i];	  \r\n			}\r\n			W25QXX_Write_NoCheck(W25QXX_BUF,secpos*4096,4096);//写入整个扇区  \r\n\r\n		}else W25QXX_Write_NoCheck(pBuffer,WriteAddr,secremain);//写已经擦除了的,直接写入扇区剩余区间. 				   \r\n		if(NumByteToWrite==secremain)break;//写入结束了\r\n		else//写入未结束\r\n		{\r\n			secpos++;//扇区地址增1\r\n			secoff=0;//偏移位置为0 	 \r\n\r\n		   	pBuffer+=secremain;  				//指针偏移\r\n			WriteAddr+=secremain;				//写地址偏移	   \r\n		   	NumByteToWrite-=secremain;			//字节数递减\r\n			if(NumByteToWrite>4096)secremain=4096;//下一个扇区还是写不完\r\n			else secremain=NumByteToWrite;		//下一个扇区可以写完了\r\n		}	 \r\n	};	 \r\n}\r\n```\r\n\r\n该函数的作用与 W25QXX_Flash_Read 的作用类似，不过是用来写数据到 W25Q128 里面的  \r\n\r\n(W25Q128 将 **16M 的容量分为 256 个块（Block），每个块大小为 64K 字节，每个块又分为16 个扇区（Sector），每个扇区 4K 个字节。** W25Q128 的最小擦除单位为一个扇区，也就是每次必须擦除 4K 个字节。这样**我们需要给 W25Q128 开辟一个至少 4K 的缓存区，这样对 SRAM 要求比较高，要求芯片必须有 4K 以上 SRAM 才能很好的操作**。)\r\n\r\n该函数可以在 W25Q128 的任意地址开始写入任意长度（必须不超过 W25Q128 的容量）的数据。我们这里简单介绍一下思路：先获得首地址（WriteAddr）所在的扇区，并计算在扇区内的偏移，然后判断要写入的数据长度是否超过本扇区所剩下的长度，如果不超过，再先看看是否要擦除，如果不要，则直接写入数据即可，如果要则读出整个扇区，在偏移处开始写入指定长度的数据，然后擦除这个扇区，再一次性写入。当所需要写入的数据长度超过一个扇区的长度的时候，我们先按照前面的步骤把扇区剩余部分写完，再在新扇区内执行同样的操作，如此 循环，直到写入结束。 \r\n\r\n#### 清楚整个flash\r\n\r\n```c\r\n//擦除整个芯片		  \r\n//等待时间超长...\r\nvoid W25QXX_Erase_Chip(void)   \r\n{                                   \r\n    W25QXX_Write_Enable();                 	 	//SET WEL \r\n    W25QXX_Wait_Busy();   \r\n  	W25QXX_CS=0;                            	//使能器件   \r\n    SPI2_ReadWriteByte(W25X_ChipErase);        	//发送片擦除命令  \r\n	W25QXX_CS=1;                            	//取消片选     	      \r\n	W25QXX_Wait_Busy();   				   		//等待芯片擦除结束\r\n}   \r\n```\r\n\r\n####  擦除一个扇区\r\n\r\n```c\r\n//擦除一个扇区\r\n//Dst_Addr:扇区地址 根据实际容量设置\r\n//擦除一个山区的最少时间:150ms\r\nvoid W25QXX_Erase_Sector(u32 Dst_Addr)   \r\n{  \r\n	//监视falsh擦除情况,测试用   \r\n 	printf(\"fe:%x\\r\\n\",Dst_Addr);	  \r\n 	Dst_Addr*=4096;\r\n    W25QXX_Write_Enable();                  	//SET WEL 	 \r\n    W25QXX_Wait_Busy();   \r\n  	W25QXX_CS=0;                            	//使能器件   \r\n    SPI2_ReadWriteByte(W25X_SectorErase);      	//发送扇区擦除指令 \r\n    SPI2_ReadWriteByte((u8)((Dst_Addr)>>16));  	//发送24bit地址    \r\n    SPI2_ReadWriteByte((u8)((Dst_Addr)>>8));   \r\n    SPI2_ReadWriteByte((u8)Dst_Addr);  \r\n	W25QXX_CS=1;                            	//取消片选     	      \r\n    W25QXX_Wait_Busy();   				   		//等待擦除完成\r\n}  \r\n```\r\n\r\n#### 等待空闲的到来\r\n\r\n```c\r\n/等待空闲\r\nvoid W25QXX_Wait_Busy(void)   \r\n{   \r\n	while((W25QXX_ReadSR()&0x01)==0x01);  		// 等待BUSY位清空\r\n}  \r\n```\r\n\r\n#### 进入掉电模式\r\n\r\n```c\r\n//进入掉电模式\r\nvoid W25QXX_PowerDown(void)   \r\n{ \r\n  	W25QXX_CS=0;                           	 	//使能器件   \r\n    SPI2_ReadWriteByte(W25X_PowerDown);        //发送掉电命令  \r\n	W25QXX_CS=1;                            	//取消片选     	      \r\n    delay_us(3);                               //等待TPD  \r\n}   \r\n```\r\n\r\n#### 唤醒\r\n\r\n```c\r\n//唤醒\r\nvoid W25QXX_WAKEUP(void)   \r\n{  \r\n  	W25QXX_CS=0;                            	//使能器件   \r\n    SPI2_ReadWriteByte(W25X_ReleasePowerDown);	//  send W25X_PowerDown command 0xAB    \r\n	W25QXX_CS=1;                            	//取消片选     	      \r\n    delay_us(3);                            	//等待TRES1\r\n}   \r\n```\r\n\r\n\r\n\r\n### 主函数\r\n\r\n```c\r\n#include \"stm32f10x.h\"\r\n#include \"delay.h\"\r\n#include \"usart.h\"\r\n#include \"lcd.h\"\r\n#include \"led.h\"\r\n#include \"sys.h\" \r\n#include \"key.h\"\r\n#include \"w25qxx.h\"\r\nint main(void){		\r\n	u8 k;\r\n	u8 write_data[] = {\"i l v y z x\"}; // 要发送的数据\r\n	const u16 size = sizeof(write_data); // 发送的数据大小\r\n	u8 read_data[size]; // 读取到的数据存入的地方\r\n	u16 write_addr = 4000;\r\n	// u32 FLASH_SIZE;\r\n	delay_init();	    	 //延时函数初始化	  \r\n	NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2); //设置NVIC中断分组2:2位抢占优先级，2位响应优先级 	\r\n	uart_init(115200);\r\n    KEY_Init();\r\n    LED_Init();\r\n	LCD_Init();\r\n	W25QXX_Init();\r\n    POINT_COLOR=BLUE;\r\n	while(W25QXX_ReadID()!=W25Q128)//检测不到 W25Q128\r\n	{\r\n		LCD_ShowString(30,150,200,16,16,\"W25Q128 Check Failed!\");\r\n		delay_ms(500);\r\n		LCD_ShowString(30,150,200,16,16,\"Please Check! \");\r\n		delay_ms(500);\r\n		LED0=!LED0;//DS0 闪烁\r\n	}\r\n	LCD_ShowString(30,150,200,16,16,\"W25Q128 Ready!\");\r\n	// FLASH_SIZE=128*1024*1024; //FLASH 大小为 16M 字节\r\n	while(1){	    \r\n		k = KEY_Scan(0);\r\n		if(k == KEY0){\r\n			// 写入数据\r\n			LCD_Fill(0,170,239,319,WHITE);//清除半屏\r\n			LCD_ShowString(30,170,200,16,16,\"Start Write W25Q128....\");\r\n			// W25QXX_Write((u8*)TEXT_Buffer,FLASH_SIZE-100,SIZE);\r\n			W25QXX_Write(write_data,write_addr,size);\r\n			printf(\"写入数据\\n\");\r\n			//从倒数第 100 个地址处开始,写入 SIZE 长度的数据\r\n			LCD_ShowString(30,170,200,16,16,\"W25Q128 Write Finished!\"); //传送完成\r\n		}else if(k == KEY1){\r\n			// 读入数据\r\n			LCD_ShowString(30,170,200,16,16,\"Start Read W25Q128.... \");\r\n			// W25QXX_Read(datatemp,FLASH_SIZE-100,SIZE);\r\n			W25QXX_Read(read_data,write_addr,size);\r\n			printf(\"%s\",read_data);\r\n			//从倒数第 100 个地址处开始,读出 SIZE 个字节\r\n			LCD_ShowString(30,170,200,16,16,\"The Data Readed Is: \"); //提示传送完成\r\n			LCD_ShowString(30,190,200,16,16,read_data);//显示读到的字符串\r\n		}\r\n	}	  \r\n}\r\n```\r\n\r\n# 二十二、触摸屏\r\n\r\n## OTT2001A简介\r\n\r\nOTT2001A 是台湾旭曜科技生产的一颗电容触摸屏驱动 IC，最多支持 208 个通道。支持SPI/IIC 接口，在 ALIENTEK 4.3’ TFTLCD 电容触摸屏上， OTT2001A 只用了 104 个通道，采用 IIC 接口。 IIC 接口模式下，该驱动 IC 与 STM32F1 的连接仅需要 4 根线： SDA、 SCL、 RST和 INT， SDA 和 SCL 是 IIC 通信用的， RST 是复位脚（低电平有效）， INT 是中断输出信号，关于 IIC 我们就不详细介绍了，请参考第二十七章。\r\nOTT2001A 的器件地址为 0X59（不含最低位，换算成读写命令则是读： 0XB3，写： 0XB2），接下来，介绍一下 OTT2001A 的几个重要的寄存器  \r\n\r\n### OTT2001A 的几个重要的寄存器  \r\n\r\n#### 1， 手势 ID 寄存器  \r\n\r\n手势 ID 寄存器（00H）用于告诉 MCU，哪些点有效，哪些点无效，从而读取对应的数据，该寄存器各位描述如表 31.1.2.1 所示：  \r\n\r\n![image-20211016152305398](cloudDisk/markdown/stm32笔记.assets/image-20211016152305398.png)\r\n\r\nOTT2001A 支持最多 5 点触摸，所以表中只有 5 个位用来表示对应点坐标是否有效，其余位为保留位（读为 0），通过读取该寄存器，我们可以知道哪些点有数据，哪些点无数据，如果读到的全是 0，则说明没有任何触摸。  \r\n\r\n#### 2， 传感器控制寄存器（ODH）  \r\n\r\n传感器控制寄存器（ODH），该寄存器也是 8 位，仅最高位有效，其他位都是保留，当最高位为 1 的时候，打开传感器（开始检测），当最高位设置为 0 的时候，关闭传感器（停止检测）。  \r\n\r\n#### 3， 坐标数据寄存器（共 20 个）  \r\n\r\n坐标数据寄存器总共有 20 个，每个坐标占用 4 个寄存器，坐标寄存器与坐标的对应关系如\r\n表 31.1.2.2 所示：  \r\n\r\n![image-20211016152654238](cloudDisk/markdown/stm32笔记.assets/image-20211016152654238.png)\r\n\r\n![image-20211016152704020](cloudDisk/markdown/stm32笔记.assets/image-20211016152704020.png)\r\n\r\n从表中可以看出，每个坐标的值，可以通过 4 个寄存器读出，比如读取坐标 1（X1， Y1），我们则可以读取 01H~04H，就可以知道当前坐标 1 的具体数值了，这里我们也可以只发送寄存器 01，然后连续读取 4 个字节，也可以正常读取坐标 1，寄存器地址会自动增加，从而提高读\r\n取速度  \r\n\r\n更详细的资料，请参考： OTT2001A IIC 协议指导.pdf 这个文档  \r\n\r\n另外， OTT2001A 有两个地方需要特别注意一下：\r\n1， OTT2001A 的寄存器是 8 位的，但是发送的时候要发送 16 位（高八位有效），才可以正常使用。\r\n2， OTT2001A 的输出坐标，默认是以： X 坐标最大值是 2700， Y 坐标最大值是 1500 的分辨率输出的，也就是输出范围为： X： 0~2700， Y： 0~1500； MCU 在读取到坐标后，必须根据 LCD 分辨率做一个换算，才能得到真实的 LCD 坐标。  \r\n\r\n## GT9147  简介\r\n\r\n该芯片是深圳汇顶科技研发的一颗电容触摸屏驱动 IC，支\r\n持 100Hz 触点扫描频率，支持 5 点触摸，支持 18*10 个检测通道，适合小于 4.5 寸的电容触摸屏使用。和 OTT2001A 一样， GT9147 与 MCU 连接也是通过 4 根线： SDA、 SCL、 RST 和 INT。不过， GT9147 的 IIC 地址，可以是 0X14 或者 0X5D，当复位结束后的 5ms 内，如果 INT 是高电平，则使用 0X14 作为地址，否则使用 0X5D 作为地址，具体的设置过程，请看： GT9147 数据手册.pdf 这个文档。本章我们使用 0X14 作为器件地址（不含最低位，换算成读写命令则是读：\r\n0X29，写： 0X28）  \r\n\r\n### GT9147 相关寄存器\r\n\r\n#### 1，控制4命令寄存器（0X8040）\r\n\r\n该寄存器可以写入不同值，实现不同的控制，我们一般使用 0 和 2 这两个值，写入 2，即\r\n可软复位 GT9147，在硬复位之后，一般要往该寄存器写 2，实行软复位。然后，写入 0，即可\r\n正常读取坐标数据（并且会结束软复位）。\r\n\r\n#### 2，配置寄存器组（0X8047~0X8100）\r\n\r\n这里共 186 个寄存器，用于配置 GT9147 的各个参数，这些配置一般由厂家提供给我们（一\r\n个数组），所以我们只需要将厂家给我们的配置，写入到这些寄存器里面，即可完成 GT9147 的\r\n配置。由于 GT9147 可以保存配置信息（可写入内部 FLASH，从而不需要每次上电都更新配置），\r\n我们有几点注意的地方提醒大家： 1， 0X8047 寄存器用于指示配置文件版本号，程序写入的版\r\n本号，必须大于等于 GT9147 本地保存的版本号，才可以更新配置。 2， 0X80FF 寄存器用于存\r\n储校验和，使得 0X8047~0X80FF 之间所有数据之和为 0。 3， 0X8100 用于控制是否将配置保存\r\n在本地，写 0，则不保存配置，写 1 则保存配置。\r\n\r\n#### 3，产品 ID 寄存器（0X8140~0X8143）\r\n\r\n这里总共由 4 个寄存器组成，用于保存产品 ID，对于 GT9147，这 4 个寄存器读出来就是：\r\n9， 1， 4， 7 四个字符（ASCII 码格式）。因此，我们可以通过这 4 个寄存器的值，来判断驱动\r\nIC 的型号，从而判断是 OTT2001A 还是 GT9147，以便执行不同的初始化。\r\n\r\n#### 4，状态寄存器（0X814E）\r\n\r\n该寄存器各位描述如表 31.1.2.3 所示：  \r\n\r\n![image-20211016153112739](cloudDisk/markdown/stm32笔记.assets/image-20211016153112739.png)\r\n\r\n这里，我们仅关心最高位和最低 4 位，最高位用于表示 buffer 状态，如果有数据（坐标/按键）， buffer 就会是 1，最低 4 位用于表示有效触点的个数，范围是： 0~5， 0，表示没有触摸，5 表示有 5 点触摸。这和前面 OTT2001A 的表示方法稍微有点区别， OTT2001A 是每个位表示一个触点，这里是有多少有效触点值就是多少。最后，该寄存器在每次读取后，如果 bit7 有效，则必须写 0，清除这个位，否则不会输出下一次数据！！这个要特别注意！！！\r\n\r\n#### 5，坐标数据寄存器（共 30 个）\r\n\r\n这里共分成 5 组（5 个点），每组 6 个寄存器存储数据，以触点 1 的坐标数据寄存器组为例，\r\n如表 31.1.2.4 所示：  \r\n\r\n![image-20211016153129266](cloudDisk/markdown/stm32笔记.assets/image-20211016153129266.png)\r\n\r\n我们一般只用到触点的 x， y 坐标，所以只需要读取 0X8150~0X8153 的数据，组合即可得到触点坐标。其他 4 组分别是： 0X8158、 0X8160、 0X8168 和 0X8170 等开头的 16 个寄存器组成，分别针对触点 2~4 的坐标。同样 GT9147 也支持寄存器地址自增，我们只需要发送寄存器组的首地址，然后连续读取即可， GT9147 会自动地址自增，从而提高读取速度。GT9147 相关寄存器的介绍就介绍到这里，更详细的资料，请参考： GT9147 编程指南.pdf这个文档。\r\nGT9147 只需要经过简单的初始化就可以正常使用了，初始化流程：硬复位→延时 10ms→结束硬复位→设置 IIC 地址→延时 100ms→软复位→更新配置（需要时） →结束软复位。此时GT9147 即可正常使用了。然后，我们不停的查询 0X814E 寄存器，判断是否有有效触点，如果有，则读取坐标数据寄存器，得到触点坐标，特别注意，如果 0X814E 读到的值最高位为 1，就必须对该位写 0，否则无法读到下一次坐标数据。  \r\n\r\n## 硬件设计\r\n\r\n本章实验功能简介：开机的时候先初始化 LCD，读取 LCD ID，随后，根据 LCD ID 判断是电阻触摸屏还是电容触摸屏，如果是电阻触摸屏，则先读取 24C02 的数据判断触摸屏是否已经校准过，如果没有校准，则执行校准程序，校准过后再进入电阻触摸屏测试程序， 如果已经校准了，就直接进入电阻触摸屏测试程序。  \r\n\r\n如果是 4.3 寸电容触摸屏，则先读取芯片 ID，判断是不是 GT9147，如果是则执行 GT9147的初始化代码，如果不是，则执行 OTT2001A 的初始化代码；如果是 7 寸电容触摸屏（仅支持新款 7 寸屏，使用 SSD1963+FT5206 方案），则执行 FT5206 的初始化代码，在初始化电容触摸屏完成后，进入电容触摸屏测试程序（电容触摸屏无需校准！！）。\r\n\r\n电阻触摸屏测试程序和电容触摸屏测试程序基本一样，只是电容触摸屏支持最多 5 点同时触摸，电阻触摸屏只支持一点触摸，其他一模一样。测试界面的右上角会有一个清空的操作区域（RST），点击这个地方就会将输入全部清除，恢复白板状态。 使用电阻触摸屏的时候， 可以通过按 KEY0 来实现强制触摸屏校准，只要按下 KEY0 就会进入强制校准程序。  \r\n\r\n![image-20211016153442864](cloudDisk/markdown/stm32笔记.assets/image-20211016153442864.png)\r\n\r\n如果是电容式触摸屏，我们的接口和电阻式触摸屏一样（上图右侧接口），只是没有用到五 根 线 了 ， 而 是 四 根 线 ， 分 别 是 ： T_PEN(CT_INT) 、 T_CS(CT_RST) 、 T_CLK(CT_SCL) 和T_MOSI(CT_SDA)。其中： CT_INT、 CT_RST、 CT_SCL 和 CT_SDA 分别是 OTT2001A/GT9147/FT5206的：中断输出信号、复位信号， IIC 的 SCL 和 SDA 信号。这里，我们用查询的方式读取OTT2001A/GT9147/FT5206 的数据，对于 OTT2001A/FT5206 没有用到中断信号（CT_INT），所以同 STM32F1 的连接，最少只需要 3 根线即可，不过 GT9147 还需要用到 CT_INT 做 IIC 地址设定，所以需要 4 根线连接。  \r\n\r\n## 程序设计\r\n\r\n### TP_Read_XY2 这个函数  \r\n\r\n该函数专门用于从触摸屏控制 IC 读取坐标的\r\n值（0~4095）  \r\n\r\n```c\r\n//连续 2 次读取触摸屏 IC,且这两次的偏差不能超过\r\n//ERR_RANGE,满足条件,则认为读数正确,否则读数错误.\r\n//该函数能大大提高准确度\r\n//x,y:读取到的坐标值\r\n//返回值:0,失败;1,成功。\r\n#define ERR_RANGE 50 //误差范围\r\nu8 TP_Read_XY2(u16 *x,u16 *y)\r\n{\r\n    u16 x1,y1;\r\n    u16 x2,y2;\r\n    u8 flag;\r\n    flag=TP_Read_XY(&x1,&y1);\r\n    if(flag==0)return(0);\r\n    flag=TP_Read_XY(&x2,&y2);\r\n    if(flag==0)return(0);\r\n    //前后两次采样在+- ERR_RANGE 内\r\n    if(((x2<=x1&&x1<x2+ERR_RANGE)||(x1<=x2&&x2<x1+ERR_RANGE))\r\n    &&((y2<=y1&&y1<y2+ERR_RANGE)||(y1<=y2&&y2<y1+ERR_RANGE)))\r\n    {\r\n        *x=(x1+x2)/2;\r\n        *y=(y1+y2)/2;\r\n        return 1;\r\n    }else return 0;\r\n}\r\n```\r\n\r\n该函数采用了一个非常好的办法来读取屏幕坐标值，就是连续读两次，两次读取的值之差不能超过一个特定的值（ERR_RANGE），通过这种方式，我们可以大大提高触摸屏的准确度。另外该函数调用的TP_Read_XY 函数，用于单次读取坐标值。 TP_Read_XY 也采用了一些软件滤波算法，具体见光盘的源码。\r\n\r\n### 触摸屏和屏幕对应，TP_Adjust函数\r\n\r\n```c\r\n//触摸屏校准代码\r\n//得到四个校准参数\r\nvoid TP_Adjust(void) {\r\n	u16 pos_temp[4][2];\r\n	//坐标缓存值\r\n	u8 cnt=0;\r\n	u16 d1,d2;\r\n	u32 tem1,tem2;\r\n	float fac;\r\n	u16 outtime=0;\r\n	cnt=0;\r\n	POINT_COLOR=BLUE;\r\n	BACK_COLOR =WHITE;\r\n	LCD_Clear(WHITE);\r\n	//清屏\r\n	POINT_COLOR=RED;\r\n	//红色\r\n	LCD_Clear(WHITE);\r\n	//清屏\r\n	POINT_COLOR=BLACK;\r\n	LCD_ShowString(40,40,160,100,16,(u8*)TP_REMIND_MSG_TBL);\r\n	//显示提示信息\r\n	TP_Drow_Touch_Point(20,20,RED);\r\n	//画点 1\r\n	tp_dev.sta=0;\r\n	//消除触发信号\r\n	tp_dev.xfac=0;\r\n	//xfac 用来标记是否校准过,所以校准之前必须清掉!以免错误\r\n	while(1) //如果连续 10 秒钟没有按下,则自动退出 {\r\n		tp_dev.scan(1);\r\n		//扫描物理坐标\r\n		if((tp_dev.sta&0xc0)==TP_CATH_PRES) //按键按下了一次(此时按键松开了.) {\r\n			outtime=0;\r\n			tp_dev.sta&=~(1<<6);\r\n			//标记按键已经被处理过了.\r\n			pos_temp[cnt][0]=tp_dev.x;\r\n			pos_temp[cnt][1]=tp_dev.y;\r\n			cnt++;\r\n			switch(cnt) {\r\n				case 1:\r\n				        TP_Drow_Touch_Point(20,20,WHITE);\r\n				//清除点 1\r\n				TP_Drow_Touch_Point(lcddev.width-20,20,RED);\r\n				//画点 2\r\n				break;\r\n				case 2:\r\n				        TP_Drow_Touch_Point(lcddev.width-20,20,WHITE);\r\n				//清除点 2\r\n				TP_Drow_Touch_Point(20,lcddev.height-20,RED);\r\n				//画点 3\r\n				break;\r\n				case 3:\r\n				        TP_Drow_Touch_Point(20,lcddev.height-20,WHITE);\r\n				//清除点 3\r\n				TP_Drow_Touch_Point(lcddev.width-20,lcddev.height-20,RED);\r\n				//画点 4\r\n				break;\r\n				case 4://全部四个点已经得到\r\n				//对边相等\r\n				tem1=abs(pos_temp[0][0]-pos_temp[1][0]);\r\n				//x1-x2\r\n				tem2=abs(pos_temp[0][1]-pos_temp[1][1]);\r\n				//y1-y2\r\n				tem1*=tem1;\r\n				tem2*=tem2;\r\n				d1=sqrt(tem1+tem2);\r\n				//得到 1,2 的距离\r\n				tem1=abs(pos_temp[2][0]-pos_temp[3][0]);\r\n				//x3-x4\r\n				tem2=abs(pos_temp[2][1]-pos_temp[3][1]);\r\n				//y3-y4\r\n				tem1*=tem1;\r\n				tem2*=tem2;\r\n				d2=sqrt(tem1+tem2);\r\n				//得到 3,4 的距离\r\n				fac=(float)d1/d2;\r\n				if(fac<0.95||fac>1.05||d1==0||d2==0)//不合格 {\r\n					cnt=0;\r\n					TP_Drow_Touch_Point(lcddev.width-20,lcddev.height-20,WHITE);\r\n					//清除点 4\r\n					TP_Drow_Touch_Point(20,20,RED);\r\n					//画点 1\r\n					TP_Adj_Info_Show(pos_temp[0][0],pos_temp[0][1],pos_temp[1]\r\n					        [0],pos_temp[1][1],pos_temp[2][0],pos_temp[2][1],pos_temp[3]\r\n					        [0],pos_temp[3][1],fac*100);\r\n					//显示数据\r\n					continue;\r\n				}\r\n				tem1=abs(pos_temp[0][0]-pos_temp[2][0]);\r\n				//x1-x3\r\n				tem2=abs(pos_temp[0][1]-pos_temp[2][1]);\r\n				//y1-y3\r\n				tem1*=tem1;\r\n				tem2*=tem2;\r\n				d1=sqrt(tem1+tem2);\r\n				//得到 1,3 的距离\r\n				tem1=abs(pos_temp[1][0]-pos_temp[3][0]);\r\n				//x2-x4\r\n				tem2=abs(pos_temp[1][1]-pos_temp[3][1]);\r\n				//y2-y4\r\n				tem1*=tem1;\r\n				tem2*=tem2;\r\n				d2=sqrt(tem1+tem2);\r\n				//得到 2,4 的距离\r\n				fac=(float)d1/d2;\r\n				if(fac<0.95||fac>1.05)//不合格 {\r\n					cnt=0;\r\n					TP_Drow_Touch_Point(lcddev.width-20,lcddev.height-20,\r\n					        WHITE);\r\n					//清除点 4\r\n					TP_Drow_Touch_Point(20,20,RED);\r\n					//画点 1\r\n					TP_Adj_Info_Show(pos_temp[0][0],pos_temp[0][1],pos_temp[1]\r\n					        [0],pos_temp[1][1],pos_temp[2][0],pos_temp[2][1],pos_temp[3]\r\n					        [0],pos_temp[3][1],fac*100);\r\n					//显示数据\r\n					continue;\r\n				}\r\n				//正确了\r\n				//对角线相等\r\n				tem1=abs(pos_temp[1][0]-pos_temp[2][0]);\r\n				//x1-x3\r\n				tem2=abs(pos_temp[1][1]-pos_temp[2][1]);\r\n				//y1-y3\r\n				tem1*=tem1;\r\n				tem2*=tem2;\r\n				d1=sqrt(tem1+tem2);\r\n				//得到 1,4 的距离\r\n				tem1=abs(pos_temp[0][0]-pos_temp[3][0]);\r\n				//x2-x4\r\n				tem2=abs(pos_temp[0][1]-pos_temp[3][1]);\r\n				//y2-y4\r\n				tem1*=tem1;\r\n				tem2*=tem2;\r\n				d2=sqrt(tem1+tem2);\r\n				//得到 2,3 的距离\r\n				fac=(float)d1/d2;\r\n				if(fac<0.95||fac>1.05)//不合格 {\r\n					cnt=0;\r\n					TP_Drow_Touch_Point(lcddev.width-20,lcddev.height-20,\r\n					        WHITE);\r\n					//清除点 4\r\n					TP_Drow_Touch_Point(20,20,RED);\r\n					//画点 1\r\n					TP_Adj_Info_Show(pos_temp[0][0],pos_temp[0][1],pos_temp[1]\r\n					        [0],pos_temp[1][1],pos_temp[2][0],pos_temp[2][1],pos_temp[3]\r\n					        [0],pos_temp[3][1],fac*100);\r\n					//显示数据\r\n					continue;\r\n				}\r\n				//正确了\r\n				//计算结果\r\n				tp_dev.xfac=(float)(lcddev.width-40)/(pos_temp[1][0]-pos_temp[0][0]);\r\n				//得到 xfac\r\n				tp_dev.xoff=(lcddev.width-tp_dev.xfac*(pos_temp[1][0]+pos_temp[0]\r\n				        [0]))/2;\r\n				//得到 xoff\r\n				tp_dev.yfac=(float)(lcddev.height-40)/(pos_temp[2][1]-pos_temp[0][1]\r\n				        );\r\n				//得到 yfac\r\n				tp_dev.yoff=(lcddev.height-tp_dev.yfac*(pos_temp[2][1]+pos_temp[0]\r\n				        [1]))/2;\r\n				//得到 yoff\r\n				if(abs(tp_dev.xfac)>2||abs(tp_dev.yfac)>2)//触屏和预设的相反了. {\r\n					cnt=0;\r\n					TP_Drow_Touch_Point(lcddev.width-20,lcddev.height-20,WHITE\r\n					        );\r\n					//清除点 4\r\n					TP_Drow_Touch_Point(20,20,RED);\r\n					//画点 1\r\n					LCD_ShowString(40,26,lcddev.width,lcddev.height,16,\"TP Need\r\n        readjust!\");\r\n					tp_dev.touchtype=!tp_dev.touchtype;\r\n					//修改触屏类型.\r\n					if(tp_dev.touchtype)//X,Y 方向与屏幕相反 {\r\n						CMD_RDX=0X90;\r\n						CMD_RDY=0XD0;\r\n					} else //X,Y 方向与屏幕相同 {\r\n						CMD_RDX=0XD0;\r\n						CMD_RDY=0X90;\r\n					}\r\n					continue;\r\n				}\r\n				POINT_COLOR=BLUE;\r\n				LCD_Clear(WHITE);\r\n				//清屏\r\n				LCD_ShowString(35,110,lcddev.width,lcddev.height,16,\"Touch Screen\r\n        Adjust OK!\");\r\n				//校正完成\r\n				delay_ms(1000);\r\n				TP_Save_Adjdata();\r\n				LCD_Clear(WHITE);\r\n				//清屏\r\n				return;\r\n				//校正完成\r\n			}\r\n		}\r\n		delay_ms(10);\r\n		outtime++;\r\n		if(outtime>1000) {\r\n			TP_Get_Adjdata();\r\n			break;\r\n		}\r\n	}\r\n}\r\n```\r\n\r\nTP_Adjust 是此部分最核心的代码， 在这里，给大家介绍一下我们这里所使用的触摸屏校正原理：  我们传统的鼠标是一种相对定位系统，只和前一次鼠标的位置坐标有关。而触摸屏则是一种绝对坐标系统，要选哪就直接点哪，与相对定位系统有着本质的区别。绝对坐标系统的\r\n特点是每一次定位坐标与上一次定位坐标没有关系，每次触摸的数据通过校准转为屏幕上的坐标，不管在什么情况下，触摸屏这套坐标在同一点的输出数据是稳定的。不过由于技术原理的原因，并不能保证同一点触摸每一次采样数据相同，不能保证绝对坐标定位，点不准，这就是触摸屏最怕出现的问题：漂移。对于性能质量好的触摸屏来说，漂移的情况出现并不是很严重。所以很多应用触摸屏的系统启动后，进入应用程序前， 先要执行校准程序。 通常应用程序中使用的 LCD 坐标是以像素为单位的。比如说：左上角的坐标是一组非 0 的数值，比如（20， 20），而右下角的坐标为（220， 300）。这些点的坐标都是以像素为单位的，而从触摸屏中读出的是点的物理坐标，其坐标轴的方向、 XY 值的比例因子、偏移量都与 LCD 坐标不同，所以， 需要在程序中把物理坐标首先转换为像素坐标，然后再赋给 POS 结构，达到坐标转换的目的。\r\n校正思路：在了解了校正原理之后，我们可以得出下面的一个从物理坐标到像素坐标的转换关系式：  \r\n\r\n```\r\nLCDx=xfac*Px+xoff；\r\nLCDy=yfac*Py+yoff；\r\n```\r\n\r\n其中(LCDx,LCDy)是在 LCD 上的像素坐标，（Px,Py）是从触摸屏读到的物理坐标。 xfac，yfac 分别是 X 轴方向和 Y 轴方向的比例因子，而 xoff 和 yoff 则是这两个方向的偏移量。\r\n这样我们只要事先在屏幕上面显示 4 个点（这四个点的坐标是已知的），分别按这四个点就可以从触摸屏读到 4 个物理坐标，这样就可以通过待定系数法求出 xfac、 yfac、 xoff、 yoff 这四个参数。我们保存好这四个参数，在以后的使用中，我们把所有得到的物理坐标都按照这个关系式来计算，得到的就是准确的屏幕坐标。达到了触摸屏校准的目的 。\r\n\r\nTP_Adjust 就 是根 据 上面 的 原理 设 计的 校准函 数 ，注 意 该函 数里面 多 次使 用 了lcddev.width和lcddev.height，用于坐标设置，主要是为了兼容不同尺寸的LCD （比如320\\*240、480\\*320 和 800\\*480 的屏都可以兼容）。    \r\n\r\n### 触摸屏初始化函数： TP_Init\r\n\r\n该函数根据 LCD 的 ID（即 lcddev.id）判别是电阻屏还是电容屏，执行不同的初始化，该函数代码如下：  \r\n\r\n```c\r\n//触摸屏初始化\r\n//返回值:0,没有进行校准\r\n// 1,进行过校准\r\nu8 TP_Init(void) {\r\n	if(lcddev.id==0X5510) //4.3 寸电容触摸屏 {\r\n		if(GT9147_Init()==0) //是 GT9147 {\r\n			tp_dev.scan=GT9147_Scan;\r\n			//扫描函数指向 GT9147 触摸屏扫描\r\n		} else {\r\n			OTT2001A_Init();\r\n			tp_dev.scan=OTT2001A_Scan;\r\n			//扫描函数指向 OTT2001A 触摸屏扫描\r\n		}\r\n		tp_dev.touchtype|=0X80;\r\n		//电容屏\r\n		tp_dev.touchtype|=lcddev.dir&0X01;\r\n		//横屏还是竖屏\r\n		return 0;\r\n	} else if(lcddev.id==0X1963) //7 寸电容触摸屏 {\r\n		FT5206_Init();\r\n		tp_dev.scan=FT5206_Scan;\r\n		//扫描函数指向 GT9147 触摸屏扫描\r\n		tp_dev.touchtype|=0X80;\r\n		//电容屏\r\n		tp_dev.touchtype|=lcddev.dir&0X01;\r\n		//横屏还是竖屏\r\n		return 0;\r\n	} else {\r\n		GPIO_InitTypeDef GPIO_InitStructure;\r\n		//注意,时钟使能之后,对 GPIO 的操作才有效\r\n		//所以上拉之前,必须使能时钟.才能实现真正的上拉输出\r\n		RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB|RCC_APB2Periph_GPIOF,\r\n		ENABLE);\r\n		//使能 PB,PF 端口时钟\r\n		GPIO_InitStructure.GPIO_Pin = GPIO_Pin_1;\r\n		// PB1 端口配置\r\n		GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;\r\n		//推挽输出\r\n		GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;\r\n		GPIO_Init(GPIOB, &GPIO_InitStructure);\r\n		//B1 推挽输出\r\n		GPIO_SetBits(GPIOB,GPIO_Pin_1);\r\n		//上拉\r\n		GPIO_InitStructure.GPIO_Pin = GPIO_Pin_2;\r\n		// PB2 端口配置\r\n		GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;\r\n		//上拉输入\r\n		GPIO_Init(GPIOB, &GPIO_InitStructure);\r\n		//B2 上拉输入\r\n		GPIO_SetBits(GPIOB,GPIO_Pin_2);\r\n		//上拉\r\n		GPIO_InitStructure.GPIO_Pin = GPIO_Pin_11|GPIO_Pin_9;\r\n		// F9， PF11 端口配置\r\n		GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;\r\n		//推挽输出\r\n		GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;\r\n		GPIO_Init(GPIOF, &GPIO_InitStructure);\r\n		//PF9,PF11 推挽输出\r\n		GPIO_SetBits(GPIOF, GPIO_Pin_11|GPIO_Pin_9);\r\n		//上拉\r\n		GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10;\r\n		// PF10 端口配置\r\n		GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;\r\n		//上拉输入\r\n		GPIO_Init(GPIOF, &GPIO_InitStructure);\r\n		//PF10 上拉输入\r\n		GPIO_SetBits(GPIOF,GPIO_Pin_10);\r\n		//上拉\r\n		TP_Read_XY(&tp_dev.x[0],&tp_dev.y[0]);\r\n		//第一次读取初始化\r\n		AT24CXX_Init();\r\n		//初始化 24CXX\r\n		if(TP_Get_Adjdata())return 0;\r\n		//已经校准 else //未校准? {\r\n			LCD_Clear(WHITE);\r\n			//清屏\r\n			TP_Adjust();\r\n			//屏幕校准\r\n		}\r\n		TP_Get_Adjdata();\r\n	}\r\n	return 1;\r\n}\r\n```\r\n\r\n重点说一下： tp_dev.scan，这个结构体函数指针，默认是指向 TP_Scan的，如果是电阻屏则用默认的即可，如果是电容屏，则指向新的扫描函数 GT9147_Scan、OTT2001A_Scan 或 FT5206_Scan（根据芯片 ID 判断到底指向那个），执行电容触摸屏的扫描函数，这两个函数在后续会介绍  \r\n\r\n### touch.h 文件  \r\n\r\n#### 非常重要的结构体_m_tp_dev  \r\n\r\n```c\r\ntypedef struct\r\n{\r\nu8 (*init)(void); //初始化触摸屏控制器\r\nu8 (*scan)(u8); //扫描触摸屏.0,屏幕扫描;1,物理坐标;\r\nvoid (*adjust)(void); //触摸屏校准\r\nu16 x0; //原始坐标(第一次按下时的坐标)\r\nu16 y0;\r\nu16 x; //当前坐标(此次扫描时,触屏的坐标)\r\nu16 y;\r\nu8 sta; //笔的状态 ： b7:按下 1/松开 0;\r\n//b6:0,没有按键按下;1,有按键按下.\r\n////////////////////////触摸屏校准参数/////////////////////////\r\nfloat xfac;\r\nfloat yfac;\r\nshort xoff;\r\nshort yoff;\r\n//新增的参数,当触摸屏的左右上下完全颠倒时需要用到.\r\n//touchtype=0 的时候,适合左右为 X 坐标,上下为 Y 坐标的 TP.\r\n//touchtype=1 的时候,适合左右为 Y 坐标,上下为 X 坐标的 TP.\r\nu8 touchtype;\r\n}_m_tp_dev;\r\nextern _m_tp_dev tp_dev; //触屏控制器在 touch.c 里面定义\r\n#endif\r\n```\r\n\r\n该结构体用于管理和记录触摸屏相关信息，在外部调用的时候，我们一般直接调用 tp_dev的相关成员函数/变量屏即可达到需要的效果。这样种设计简化了接口，另外管理和维护也比较方便，大家可以效仿一下。  \r\n\r\n### ctiic.c 和 ctiic.h 是电容触摸屏的 IIC 接口部分代码\r\n\r\n与第二十八章的 myiic.c 和 myiic.h 基本一样  \r\n\r\n### ott2001a.c 文件  \r\n\r\n```c\r\n//向 OTT2001A 写入一次数据\r\n//reg:起始寄存器地址\r\n//buf:数据缓缓存区\r\n//len:写数据长度\r\n//返回值:0,成功;1,失败.\r\nu8 OTT2001A_WR_Reg(u16 reg,u8 *buf,u8 len) {\r\n	u8 i;\r\n	u8 ret=0;\r\n	CT_IIC_Start();\r\n	CT_IIC_Send_Byte(OTT_CMD_WR);\r\n	//发送写命令\r\n	CT_IIC_Wait_Ack();\r\n	CT_IIC_Send_Byte(reg>>8);\r\n	//发送高 8 位地址\r\n	CT_IIC_Wait_Ack();\r\n	CT_IIC_Send_Byte(reg&0XFF);\r\n	//发送低 8 位地址\r\n	CT_IIC_Wait_Ack();\r\n	for (i=0;i<len;i++) {\r\n		CT_IIC_Send_Byte(buf[i]);\r\n		//发数据\r\n		ret=CT_IIC_Wait_Ack();\r\n		if(ret)break;\r\n	}\r\n	CT_IIC_Stop();\r\n	//产生一个停止条件\r\n	return ret;\r\n}\r\n//从 OTT2001A 读出一次数据\r\n//reg:起始寄存器地址\r\n//buf:数据缓缓存区\r\n//len:读数据长度\r\nvoid OTT2001A_RD_Reg(u16 reg,u8 *buf,u8 len) {\r\n	u8 i;\r\n	CT_IIC_Start();\r\n	CT_IIC_Send_Byte(OTT_CMD_WR);\r\n	//发送写命令\r\n	CT_IIC_Wait_Ack();\r\n	CT_IIC_Send_Byte(reg>>8);\r\n	//发送高 8 位地址\r\n	CT_IIC_Wait_Ack();\r\n	CT_IIC_Send_Byte(reg&0XFF);\r\n	//发送低 8 位地址\r\n	CT_IIC_Wait_Ack();\r\n	CT_IIC_Start();\r\n	CT_IIC_Send_Byte(OTT_CMD_RD);\r\n	//发送读命令\r\n	CT_IIC_Wait_Ack();\r\n	for (i=0;i<len;i++) {\r\n		buf[i]=CT_IIC_Read_Byte(i==(len-1)?0:1);\r\n		//发数据\r\n	}\r\n	CT_IIC_Stop();\r\n	//产生一个停止条件\r\n}\r\n//传感器打开/关闭操作\r\n//cmd:1,打开传感器;0,关闭传感器\r\nvoid OTT2001A_SensorControl(u8 cmd) {\r\n	u8 regval=0X00;\r\n	if(cmd)regval=0X80;\r\n	OTT2001A_WR_Reg(OTT_CTRL_REG,&regval,1);\r\n}\r\n//初始化触摸屏\r\n//返回值:0,初始化成功;1,初始化失败\r\nu8 OTT2001A_Init(void) {\r\n	u8 regval=0;\r\n	GPIO_InitTypeDef GPIO_InitStructure;\r\n	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOF, ENABLE);\r\n	//使能 PF 端口时钟\r\n	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_11;\r\n	// PF11 端口配置\r\n	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;\r\n	//推挽输出\r\n	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;\r\n	GPIO_Init(GPIOF, &GPIO_InitStructure);\r\n	//PF11 推挽输出\r\n	GPIO_SetBits(GPIOF,GPIO_Pin_1);\r\n	//上拉\r\n	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10;\r\n	// PB2 端口配置\r\n	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;\r\n	//上拉输入\r\n	GPIO_Init(GPIOF, &GPIO_InitStructure);\r\n	//PF10 上拉输入\r\n	GPIO_SetBits(GPIOF,GPIO_Pin_10);\r\n	//上拉\r\n	CT_IIC_Init();\r\n	//初始化电容屏的 I2C 总线\r\n	OTT_RST=0;\r\n	//复位\r\n	delay_ms(100);\r\n	OTT_RST=1;\r\n	//释放复位\r\n	delay_ms(100);\r\n	OTT2001A_SensorControl(1);\r\n	//打开传感器\r\n	OTT2001A_RD_Reg(OTT_CTRL_REG,&regval,1);\r\n	printf(\"CTP ID:%x\\r\\n\",regval);\r\n	if(regval==0x80)return 0;\r\n	return 1;\r\n}\r\nconstu16 OTT_TPX_TBL[5]= {\r\n	OTT_TP1_REG,OTT_TP2_REG,OTT_TP3_REG,OTT_TP4_REG,OTT_TP5_REG\r\n}\r\n;\r\n//扫描触摸屏(采用查询方式)\r\n//mode:0,正常扫描.\r\n//返回值:当前触屏状态.\r\n//0,触屏无触摸;1,触屏有触摸\r\nu8 OTT2001A_Scan(u8 mode) {\r\n	u8 buf[4];\r\n	u8 i=0;\r\n	u8 res=0;\r\n	static u8 t=0;\r\n	//控制查询间隔,从而降低 CPU 占用率\r\n	t++;\r\n	if((t%10)==0||t<10)//空闲时,每进入 10 次 CTP_Scan 函数才检测 1 次,节省 CPU 使用率 {\r\n		OTT2001A_RD_Reg(OTT_GSTID_REG,&mode,1);\r\n		//读取触摸点的状态\r\n		if(mode&0X1F) {\r\n			tp_dev.sta=(mode&0X1F)|TP_PRES_DOWN|TP_CATH_PRES;\r\n			for (i=0;i<5;i++) {\r\n				if(tp_dev.sta&(1<<i)) //触摸有效? {\r\n					OTT2001A_RD_Reg(OTT_TPX_TBL[i],buf,4);\r\n					//读取 XY 坐标值\r\n					if(tp_dev.touchtype&0X01)//横屏 {\r\n						tp_dev.y[i]=(((u16)buf[2]<<8)+buf[3])*OTT_SCAL_Y;\r\n						tp_dev.x[i]=800-((((u16)buf[0]<<8)+buf[1])*OTT_SCAL_X);\r\n					} else {\r\n						tp_dev.x[i]=(((u16)buf[2]<<8)+buf[3])*OTT_SCAL_Y;\r\n						tp_dev.y[i]=(((u16)buf[0]<<8)+buf[1])*OTT_SCAL_X;\r\n					}\r\n					//printf(\"x[%d]:%d,y[%d]:%d\\r\\n\",i,tp_dev.x[i],i,tp_dev.y[i]);\r\n				}\r\n			}\r\n			res=1;\r\n			if(tp_dev.x[0]==0 && tp_dev.y[0]==0)mode=0;\r\n			//读到的数据都是 0 则忽略\r\n			t=0;\r\n			//触发一次,则会最少连续监测 10 次,从而提高命中率\r\n		}\r\n	}\r\n	if((mode&0X1F)==0)//无触摸点按下 {\r\n		if(tp_dev.sta&TP_PRES_DOWN) //之前是被按下的 {\r\n			tp_dev.sta&=~(1<<7);\r\n			//标记按键松开\r\n		} else //之前就没有被按下 {\r\n			tp_dev.x[0]=0xffff;\r\n			tp_dev.y[0]=0xffff;\r\n			tp_dev.sta&=0XE0;\r\n			//清除点有效标记\r\n		}\r\n	}\r\n	if(t>240)t=10;\r\n	//重新从 10 开始计数\r\n	return res;\r\n}\r\n```\r\n\r\nGT9147_Init 用于初始化 GT9147，该函数通过读取 0X8140~0X8143 这 4 个寄存器，并判断是否是：“9147”,来确定是不是 GT9147 芯片，在读取到正确的 ID 后，软复位 GT9147，然后根据当前芯片版本号，确定是否需要更新配置，通过 GT9147_Send_Cfg 函数，发送配置信息（一个数组），配置完后，结束软复位，即完成 GT9147 初始化。 GT9147_Scan 函数，用于读取触摸屏坐标数据，这个和前面的 OTT2001A_Scan 大同小异，大家看源码即可。   \r\n\r\n### main.c 文件  \r\n\r\n```c\r\n//5 个触控点的颜色(电容触摸屏用)\r\nconst u16 POINT_COLOR_TBL[5]= {\r\n	RED,GREEN,BLUE,BROWN,GRED\r\n}\r\n;\r\n//电阻触摸屏测试函数\r\nvoid rtp_test(void) {\r\n	u8 key;\r\n	u8 i=0;\r\n	while(1) {\r\n		key=KEY_Scan(0);\r\n		tp_dev.scan(0);\r\n		if(tp_dev.sta&TP_PRES_DOWN) //触摸屏被按下 {\r\n			if(tp_dev.x[0]<lcddev.width&&tp_dev.y[0]<lcddev.height) {\r\n				if(tp_dev.x[0]>(lcddev.width-24)&&tp_dev.y[0]<16)Load_Drow_Dialog(); else TP_Draw_Big_Point(tp_dev.x[0],tp_dev.y[0],RED);\r\n				//画图\r\n			}\r\n		} else delay_ms(10);\r\n		//没有按键按下的时候\r\n		if(key==KEY0_PRES) //KEY0 按下,则执行校准程序 {\r\n			LCD_Clear(WHITE);\r\n			//清屏\r\n			TP_Adjust();\r\n			//屏幕校准\r\n			Load_Drow_Dialog();\r\n		}\r\n		i++;\r\n		if(i%20==0)LED0=!LED0;\r\n	}\r\n}\r\n//电容触摸屏测试函数\r\nvoid ctp_test(void) {\r\n	u8 t=0;\r\n	u8 i=0;\r\n	u16 lastpos[5][2];\r\n	//最后一次的数据\r\n	while(1) {\r\n		tp_dev.scan(0);\r\n		for (t=0;t<CT_MAX_TOUCH;t++) {\r\n			if((tp_dev.sta)&(1<<t)) {\r\n				if(tp_dev.x[t]<lcddev.width&&tp_dev.y[t]<lcddev.height) {\r\n					if(lastpos[t][0]==0XFFFF) {\r\n						lastpos[t][0] = tp_dev.x[t];\r\n						lastpos[t][1] = tp_dev.y[t];\r\n					}\r\n					lcd_draw_bline(lastpos[t][0],lastpos[t][1],tp_dev.x[t],tp_dev.y[t],2,\r\n					POINT_COLOR_TBL[t]);\r\n					//画线\r\n					lastpos[t][0]=tp_dev.x[t];\r\n					lastpos[t][1]=tp_dev.y[t];\r\n					if(tp_dev.x[t]>(lcddev.width-24)&&tp_dev.y[t]<16) {\r\n						Load_Drow_Dialog();\r\n						//清除\r\n					}\r\n				}\r\n			} else lastpos[t][0]=0XFFFF;\r\n		}\r\n		delay_ms(5);\r\n		i++;\r\n		if(i%20==0)LED0=!LED0;\r\n	}\r\n}\r\nint main(void) {\r\n	delay_init();\r\n	//延时函数初始化\r\n	NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);\r\n	//设置中断优先级分组为组 2\r\n	uart_init(115200);\r\n	//串口初始化为 115200\r\n	LED_Init();\r\n	//初始化与 LED 连接的硬件接口\r\n	LCD_Init();\r\n	//初始化 LCD\r\n	KEY_Init();\r\n	//按键初始化\r\n	tp_dev.init();\r\n	//触摸屏初始化\r\n	POINT_COLOR=RED;\r\n	//设置字体为红色\r\n	LCD_ShowString(30,50,200,16,16,\"ELITE STM32\");\r\n	LCD_ShowString(30,70,200,16,16,\"TOUCH TEST\");\r\n	LCD_ShowString(30,90,200,16,16,\"ATOM@ALIENTEK\");\r\n	LCD_ShowString(30,110,200,16,16,\"2015/1/15\");\r\n	if(tp_dev.touchtype&0X80==0)//仅电阻屏显示校准提示信息，电容屏不提示\r\n	LCD_ShowString(30,130,200,16,16,\"Press KEY0 to Adjust\");\r\n	delay_ms(1500);\r\n	Load_Drow_Dialog();\r\n	if(tp_dev.touchtype&0X80)ctp_test();\r\n	//电容屏测试 else rtp_test();\r\n	//电阻屏测试\r\n}\r\n```\r\n\r\nrtp_test，该函数用于电阻触摸屏的测试，该函数代码比较简单，就是扫描按键和触摸屏，如果触摸屏有按下，则在触摸屏上面划线，如果按中“RST” 区域，则执行清屏。如果按键 KEY0按下，则执行触摸屏校准。\r\nctp_test，该函数用于电容触摸屏的测试，由于我们采用 tp_dev.sta 来标记当前按下的触摸屏点数，所以判断是否有电容触摸屏按下，也就是判断 tp_dev.sta 的最低 5 位，如果有数据，则划线，如果没数据则忽略，且 5 个点划线的颜色各不一样，方便区分。另外，电容触摸屏不\r\n需要校准，所以没有校准程序。\r\nmain 函数，则比较简单，初始化相关外设，然后根据触摸屏类型，去选择执行 ctp_test 还是 rtp_test。  \r\n\r\n\r\n\r\n# 二十三、红外遥控\r\n\r\n## 简介\r\n\r\n在实际的通信领域，发出来的信号一般有较宽的频谱，而且都是在比较低的频率段分布大量的能量，所以称之为基带信号，这种信号是不适合直接在信道中传输的。为便于传输、提高抗干扰能力和有效的利用带宽，通常需要将信号调制到适合信道和噪声特性的频率范围内进行传输，这就叫做信号调制。在通信系统的接收端要对接收到的信号进行解调，恢复出原来的基带信号。这部分通信原理的内容，大家了解一下即可。\r\n\r\n　　我们平时用到的红外遥控器里的红外通信，通常是使用38K左右的载波进行调制的，下面我把原理大概给大家介绍一下，了解一下，先看发送部分原理。\r\n\r\n　　调制：就是用待传送信号去控制某个高频信号的幅度、相位、频率等参量变化的过程，即用一个信号去装载另一个信号。比如我们的红外遥控信号要发送的时候，先经过38K调制，如图1所示。\r\n\r\n![image-20211018164013289](cloudDisk/markdown/stm32笔记.assets/image-20211018164013289.png)\r\n\r\n　　图1 红外信号调制\r\n\r\n　　原始信号就是我们要发送的一个数据“0”位或者一位数据“1”位，而所谓38K载波就是频率为38K的方波信号，调制后信号就是最终我们发射出去的波形。我们使用原始信号来控制38K载波，当信号是数据“0”的时候，38K载波毫无保留的全部发送出去，当信号是数据“1”的时候，不发送任何载波信号。\r\n\r\n　　那在原理上，我们如何从电路的角度去实现这个功能呢？如图2所示。![image-20211018164026782](cloudDisk/markdown/stm32笔记.assets/image-20211018164026782.png)\r\n\r\n　38K载波，我们可以用455K晶振，经过12分频得到37.91K，也可以由时基电路NE555来产生，或者使用单片机的PWM来产生。当信号输出引脚输出高电平时，Q2截止，不管38K载波信号如何控制Q1，右侧的竖向支路都不会导通，红外管L1不会发送任何信息。当信号输出是低电平的时候，那么38K载波就会通过Q1释放出来，在L1上产生38K的载波信号。这里要说明的是，大多数家电遥控器的38K的占空比是1/3，也有1/2的，但是相对少一些。\r\n\r\n　　正常的通信来讲，接收端要首先对信号通过监测、放大、滤波、解调等等一系列电路处理，然后输出基带信号。但是红外通信的一体化接收头HS0038B，已经把这些电路全部集成到一起了，我们只需要把这个电路接上去，就可以直接输出我们所要的基带信号了，如图3所示。\r\n\r\n![image-20211018164045781](cloudDisk/markdown/stm32笔记.assets/image-20211018164045781.png)\r\n\r\n由于红外接收头内部放大器的增益很大，很容易引起干扰，因此在接收头供电引脚上必须加上滤波电容，官方手册给的值是4.7uF，我们这里直接用的10uF，手册里还要求在供电引脚和电源之间串联100欧的电阻，进一步降低干扰。\r\n\r\n　　图3所示的电路，用来接收图16-5电路发送出来的波形，当HS0038监测到有38K的红外信号时，就会在OUT引脚输出低电平，当没有38K的时候，OUT引脚就会输出高电平。那我们把OUT引脚接到单片机的IO口上，通过编程，就可以获取红外通信发过来的数据了。\r\n\r\n　　大家想想，OUT引脚输出的数据是不是又恢复成为基带信号数据了呢？那我们单片机在接收这个基带信号数据的时候，如何判断接收到的是什么数据，应该遵循什么协议呢？像我们前边学到的UART、I2C、SPI等通信协议都是基带通信的通信协议，而红外的38K仅仅是对基带信号进行调制解调，让信号更适合在信号中传输。\r\n\r\n　　由于我们的红外调制信号是半双工的，而且同时空间只能允许一个信号源，所以我们红外的基带信号不适合在I2C或者SPI通信协议中进行的，我们前边提到过UART虽然是2条线，但是通信的时候，实际上一条线即可，所以红外可以在UART中进行通信。当然，这个通信也不是没有限制的，比如在HS0038B的数据手册中标明，要想让HS0038B识别到38K的红外信号，那么这个38K的载波必须要大于10个周期，这就限定了我们红外通信的基带信号的比特率必须不能高于3800，那如果把串口输出的信号直接用38K调制的话，波特率也就不能高于3800。\r\n\r\n## 红外协议\r\n\r\n**一、 NEC 协议**\r\n\r\n　　特征：\r\n\r\n　　8 位地址和 8 位命令长度为提高可靠性每次传输两遍地址（用户码）和命令（按键值）通过脉冲串之间的时间间隔来实现信号的调制 38Khz 载波每位的周期为 1.12ms 或者 2.25ms\r\n\r\n　　调制方式：![image-20211018164119284](cloudDisk/markdown/stm32笔记.assets/image-20211018164119284.png)\r\n\r\nNote：对于测试红外接收头的信号来说，有脉冲信号的地方就是高电平。即逻辑“1” 为 0.56ms 高电平+1.69ms 低电平，逻辑“0”为 0.56ms 高电平+0.56ms 低电平。\r\n\r\n　　协议：![image-20211018164135259](cloudDisk/markdown/stm32笔记.assets/image-20211018164135259.png)\r\n\r\n上图为典型的 NEC 协议传输格式，起始位（引导码）为 9ms 高+4.5ms 低组成，有效数据为地址+地址反码+命令+命令反码。反码的作用是用来校准前面的地址和命令，如果对可靠性不感兴趣，也可以去掉取反的数据，或者将地址和命令扩展到 16 位\r\n\r\n　　上图传输的地址数据为 10011010，需要注意的是先发低位地址再发高位地址，因此该波形的地址为 01011001=0X59，同理，命令为 00010110=0X16。\r\n\r\n　　长按键时，如下图所示，每隔 110ms 重复发送一次，但是命令只发送一次，重复发送的是 9ms 高电平+2.25ms 低电平+0.56ms 高电平+低电平![image-20211018164152349](cloudDisk/markdown/stm32笔记.assets/image-20211018164152349.png)\r\n\r\n　　扩展协议只是将地址改为 16 位，其他不变。\r\n\r\n　　实测波形：\r\n\r\n　　下面的波形是从红外接收头上得到的波形：（调制脉冲信号转变成高低电平了）\r\n\r\n![image-20211018164205695](cloudDisk/markdown/stm32笔记.assets/image-20211018164205695.png)\r\n\r\n由于红外接收头在接收信号时（或者是发送的时候）将波形反向了，因此在读数据时可以将示波器的反向功能打开，就能读到有效数据了。\r\n\r\n　　下面实例是已知 NEC 类型遥控器所截获的波形：\r\n\r\n　　遥控器的识别码是 Address=0xDD20;其中一个键值是 Command=0x0E\r\n\r\n![image-20211018164217808](cloudDisk/markdown/stm32笔记.assets/image-20211018164217808.png)\r\n\r\n## 代码部分\r\n\r\n### 初始化函数\r\n\r\n```c\r\n//红外遥控初始化\r\n//设置IO以及定时器4的输入捕获\r\nvoid Remote_Init(void)    			  \r\n{  \r\n	GPIO_InitTypeDef GPIO_InitStructure;\r\n	NVIC_InitTypeDef NVIC_InitStructure;\r\n	TIM_TimeBaseInitTypeDef  TIM_TimeBaseStructure;\r\n	TIM_ICInitTypeDef  TIM_ICInitStructure;  \r\n \r\n 	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB,ENABLE); //使能PORTB时钟 \r\n	RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM4,ENABLE);	//TIM4 时钟使能 \r\n\r\n	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9;				 //PB9 输入 \r\n 	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPD; 		//上拉输入 \r\n 	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;\r\n 	GPIO_Init(GPIOB, &GPIO_InitStructure);\r\n 	GPIO_SetBits(GPIOB,GPIO_Pin_9);	//初始化GPIOB.9\r\n	\r\n						  \r\n 	TIM_TimeBaseStructure.TIM_Period = 10000; //设定计数器自动重装值 最大10ms溢出  \r\n	TIM_TimeBaseStructure.TIM_Prescaler =(72-1); 	//预分频器,1M的计数频率,1us加1.	   \r\n	TIM_TimeBaseStructure.TIM_ClockDivision = TIM_CKD_DIV1; //设置时钟分割:TDTS = Tck_tim\r\n	TIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Up;  //TIM向上计数模式\r\n\r\n	TIM_TimeBaseInit(TIM4, &TIM_TimeBaseStructure); //根据指定的参数初始化TIMx\r\n\r\n  TIM_ICInitStructure.TIM_Channel = TIM_Channel_4;  // 选择输入端 IC4映射到TI4上\r\n  TIM_ICInitStructure.TIM_ICPolarity = TIM_ICPolarity_Rising;	//上升沿捕获\r\n  TIM_ICInitStructure.TIM_ICSelection = TIM_ICSelection_DirectTI;\r\n  TIM_ICInitStructure.TIM_ICPrescaler = TIM_ICPSC_DIV1;	 //配置输入分频,不分频 \r\n  TIM_ICInitStructure.TIM_ICFilter = 0x03;//IC4F=0011 配置输入滤波器 8个定时器时钟周期滤波\r\n  TIM_ICInit(TIM4, &TIM_ICInitStructure);//初始化定时器输入捕获通道\r\n\r\n  TIM_Cmd(TIM4,ENABLE ); 	//使能定时器4\r\n \r\n	NVIC_InitStructure.NVIC_IRQChannel = TIM4_IRQn;  //TIM3中断\r\n	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 1;  //先占优先级0级\r\n	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 3;  //从优先级3级\r\n	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE; //IRQ通道被使能\r\n	NVIC_Init(&NVIC_InitStructure);  //根据NVIC_InitStruct中指定的参数初始化外设NVIC寄存器	\r\n\r\n	TIM_ITConfig( TIM4,TIM_IT_Update|TIM_IT_CC4,ENABLE);//允许更新中断 ,允许CC4IE捕获中断								 \r\n}\r\n```\r\n\r\n### 中断服务函数\r\n\r\n```c\r\n//遥控器接收状态\r\n//[7]:收到了引导码标志\r\n//[6]:得到了一个按键的所有信息\r\n//[5]:保留	\r\n//[4]:标记上升沿是否已经被捕获								   \r\n//[3:0]:溢出计时器 // 初始化了计数器溢出值10000，技术频率72/72mhz = 1um,所以每10ms溢出一次，溢出计数器加一\r\nu8 	RmtSta=0;	  	  \r\nu16 Dval;		//下降沿时计数器的值\r\nu16 test_dval;\r\nu32 RmtRec=0;	//红外接收到的数据	   		    \r\nu8  RmtCnt=0;	//按键按下的次数\r\nu16 arr_dval[40]; // 测试\r\nu8 count = 0;\r\n//定时器4中断服务程序	 \r\n// 1. 因初始化设置了上升沿，触发边沿中断\r\nvoid TIM4_IRQHandler(void)\r\n{ 		    	 \r\n	if(TIM_GetITStatus(TIM4,TIM_IT_Update)!=RESET) // 更新中断，定时器超过预设定的最大计数值，就会走这，设置了10ms\r\n	{\r\n		if(RmtSta&0x80)								//上次有数据被接收到了\r\n		{	\r\n			RmtSta&=~0X10;							//取消上升沿已经被捕获标记\r\n			// 传输过程在150ms的时候，标记完成一次采集\r\n			if((RmtSta&0X0F)==0X00)RmtSta|=1<<6;	//标记已经完成一次按键的键值信息采集\r\n			// 如果传输过程的总时间大于 140ms，让计数器清空，引导位清空，就不能再进行数据采集\r\n			if((RmtSta&0X0F)<14)RmtSta++;\r\n			else\r\n			{\r\n				RmtSta&=~(1<<7);					//清空引导标识\r\n				RmtSta&=0XF0;						//清空计数器	\r\n			}								 	   	\r\n		}							    \r\n	}\r\n	if(TIM_GetITStatus(TIM4,TIM_IT_CC4)!=RESET)\r\n	{	  \r\n		if(RDATA)//上升沿捕获 // 2. 遥控器发送指令后，一开始必定先走这\r\n		{\r\n  			TIM_OC4PolarityConfig(TIM4,TIM_ICPolarity_Falling);						//CC4P=1	设置为下降沿捕获\r\n			TIM_SetCounter(TIM4,0);							//清空定时器值\r\n			RmtSta|=0X10;							//标记上升沿已经被捕获\r\n		}else //下降沿捕获  // 3. 接收到遥控器第一个指令后的第一个下降沿到来，走这\r\n		{\r\n			Dval=TIM_GetCapture4(TIM4);	// 读取定时器的计数值（设置了72分频，时钟频率72mhz，所以一个计数值为1um）				//读取CCR4也可以清CC4IF标志位\r\n  			TIM_OC4PolarityConfig(TIM4,TIM_ICPolarity_Rising);				//CC4P=0	设置为上升沿捕获\r\n			arr_dval[count++] = Dval; // 测试\r\n			if(RmtSta&0X10)							//判断是否有高电平捕获标志位\r\n			{\r\n 				if(RmtSta&0X80)//接收到了引导码\r\n				{\r\n					\r\n					if(Dval>300&&Dval<800)			//560为标准值,560us\r\n					{\r\n						RmtRec<<=1;					//左移一位.\r\n						RmtRec|=0;					//接收到0	   \r\n					}else if(Dval>1400&&Dval<1800)	//1680为标准值,1680us\r\n					{\r\n						RmtRec<<=1;					//左移一位.\r\n						RmtRec|=1;					//接收到1\r\n					}else if(Dval>2200&&Dval<2600)	//得到按键键值增加的信息 2500为标准值2.5ms\r\n					{\r\n						RmtCnt++; 					//按键次数增加1次\r\n						RmtSta&=0XF0;				//清空计时器		\r\n					}\r\n 				}else if(Dval>4200&&Dval<4700)		//4500为标准值4.5ms\r\n				{\r\n					RmtSta|=1<<7;					//标记成功接收到了引导码\r\n					RmtCnt=0;						//清除按键次数计数器\r\n				}						 \r\n			}\r\n			RmtSta&=~(1<<4); // 清掉上升沿捕获标志位\r\n		}\r\n	}\r\n	TIM_ClearITPendingBit(TIM4,TIM_IT_Update|TIM_IT_CC4);	 	    \r\n}\r\n```\r\n\r\n#### 代码分析\r\n\r\n1. 按下遥控器down键\r\n\r\n2. 程序检测到高电平\r\n\r\n3. 程序进入中断服务函数\r\n\r\n4. 执行边缘触发中断代码if(TIM_GetITStatus(TIM4,TIM_IT_CC4)!=RESET){。。。}\r\n\r\n   1. 进入if(RDATA){。。。}//上升沿捕获 // 2. 遥控器发送指令后，一开始必定先走这 //\\#define RDATA  PBin(9)   //红外数据输入脚\r\n      1. 设置下降沿触发中断TIM_OC4PolarityConfig(TIM4,TIM_ICPolarity_Falling);             //CC4P=1   设置为下降沿捕获\r\n      2. TIM_SetCounter(TIM4,0);              //清空定时器值\r\n      3. RmtSta|=0X10;               //标记上升沿已经被捕获\r\n\r\n5. 4454um过后，程序检测到一个下降沿，进入中断函数void TIM4_IRQHandler(void)\r\n\r\n6. 执行if(RDATA)else{ ... } else 代码部分 // //下降沿捕获  // 3. 接收到遥控器第一个指令后的第一个下降沿到来，走这\r\n\r\n   1. 读取计数值Dval=TIM_GetCapture4(TIM4);  // 读取定时器的计数值（设置了72分频，时钟频率72mhz，所以一个计数值为1um）       //读取CCR4也可以清CC4IF标志位\r\n\r\n      * 读到4454um，即：Dval=4454\r\n\r\n   2. TIM_OC4PolarityConfig(TIM4,TIM_ICPolarity_Rising);       //CC4P=0   设置为上升沿捕获\r\n\r\n   3. else if(Dval>4200&&Dval<4700)   //4500为标准值4.5ms\r\n\r\n      * 接收到引导码\r\n\r\n      1. RmtSta|=1<<7;          //标记成功接收到了引导码\r\n      2. RmtCnt=0;            //清除按键次数计数器\r\n\r\n7. 如此循环，当检测到不同的dval时，记录不同的逻辑值\r\n\r\n   ```c\r\n   if(RmtSta&0X80)//接收到了引导码\r\n   				{\r\n   					\r\n   					if(Dval>300&&Dval<800)			//560为标准值,560us\r\n   					{\r\n   						RmtRec<<=1;					//左移一位.\r\n   						RmtRec|=0;					//接收到0	   \r\n   					}else if(Dval>1400&&Dval<1800)	//1680为标准值,1680us\r\n   					{\r\n   						RmtRec<<=1;					//左移一位.\r\n   						RmtRec|=1;					//接收到1\r\n   					}else if(Dval>2200&&Dval<2600)	//得到按键键值增加的信息 2500为标准值2.5ms\r\n   					{\r\n   						RmtCnt++; 					//按键次数增加1次\r\n   						RmtSta&=0XF0;				//清空计时器		\r\n   					}\r\n    				}\r\n   ```\r\n\r\n* 此外还有个更新中断，预装载值满就会执行；即每10ms执行\r\n\r\n  ```\r\n  	if(TIM_GetITStatus(TIM4,TIM_IT_Update)!=RESET) // 更新中断，定时器超过预设定的最大计数值，就会走这，设置了10ms\r\n  	{\r\n  		if(RmtSta&0x80)								//上次有数据被接收到了\r\n  		{	\r\n  			RmtSta&=~0X10;							//取消上升沿已经被捕获标记\r\n  			// 传输过程在150ms的时候，标记完成一次采集\r\n  			if((RmtSta&0X0F)==0X00)RmtSta|=1<<6;	//标记已经完成一次按键的键值信息采集\r\n  			// 如果传输过程的总时间大于 140ms，让计数器清空，引导位清空，就不能再进行数据采集\r\n  			if((RmtSta&0X0F)<14)RmtSta++;\r\n  			else\r\n  			{\r\n  				RmtSta&=~(1<<7);					//清空引导标识\r\n  				RmtSta&=0XF0;						//清空计数器	\r\n  			}								 	   	\r\n  		}							    \r\n  	}\r\n  ```\r\n\r\n### 解析中断函数获取到的红外值\r\n\r\n```c\r\n//处理红外键盘\r\n//返回值:\r\n//	 0,没有任何按键按下\r\n//其他,按下的按键键值.\r\nu8 Remote_Scan(void)\r\n{        \r\n	u8 sta=0;       \r\n    u8 t1,t2;  \r\n	printf(\"(RmtRec:%x)\",RmtRec);\r\n	if(RmtSta&(1<<6))//得到一个按键的所有信息了\r\n	{ \r\n	    t1=RmtRec>>24;			//得到地址码\r\n	    t2=(RmtRec>>16)&0xff;	//得到地址反码 \r\n	\r\n 	    if((t1==(u8)~t2)&&t1==REMOTE_ID)//检验遥控识别码(ID)及地址 \r\n	    { \r\n	        t1=RmtRec>>8;\r\n	        t2=RmtRec; 	\r\n	        if(t1==(u8)~t2)sta=t1;//键值正确	 \r\n		}   \r\n		if((sta==0)||((RmtSta&0X80)==0))//按键数据错误/遥控已经没有按下了\r\n		{\r\n		 	RmtSta&=~(1<<6);//清除接收到有效按键标识\r\n			RmtCnt=0;		//清除按键次数计数器\r\n		}\r\n	}  \r\n    return sta;\r\n}\r\n```\r\n\r\n### 测试代码\r\n\r\ndval_0 - 引导码\r\n\r\n(dval_0=4454)(dval_1=526)(dval_2=527)(dval_3=527)(dval_4=528)(dval_5=529)(dval_6=530)(dval_7=532)(dval_8=536)(dval_9=1663)(dval_10=1663)(dval_11=1663)(dval_12=1662)(dval_13=1662)(dval_14=1663)(dval_15=1663)(dval_16=1662)(dval_17=1662)(dval_18=561)(dval_19=1663)(dval_20=561)(dval_21=1662)(dval_22=561)(dval_23=561)(dval_24=561)(dval_25=562)(dval_26=1663)(dval_27=561)(dval_28=1663)(dval_29=561)(dval_30=1663)(dval_31=1663)(dval_32=1663)\r\n\r\n引导码之后，520us左右的值为0；1600us左右的值为1，记录下来\r\n\r\n0000 0000 1111 1111 1010 1000 0101 0111\r\n\r\n结果得到 (RmtRec = ffa857)\r\n\r\n1-16位：控制码\r\n\r\n* 前8后8位为反码\r\n\r\n17-32位：地址码\r\n\r\n* 前8后8位为反码\r\n\r\n所以控制码为：1010 1000 = 十进制168，输出down\r\n\r\n### 主函数\r\n\r\n```c\r\nint main(void){	\r\n	u8 key;	\r\n	u8 i; // 测试\r\n		u8 t=0;	\r\n 	u8 *str=0;\r\n	// u32 FLASH_SIZE;\r\n	delay_init();	    	 //延时函数初始化	  \r\n	NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2); //设置NVIC中断分组2:2位抢占优先级，2位响应优先级 	\r\n	uart_init(115200);\r\n    KEY_Init();\r\n    LED_Init();\r\n	LCD_Init();\r\n    POINT_COLOR=BLUE;\r\n	Remote_Init();			//红外接收初始化	\r\n	LCD_ShowString(30,130,200,16,16,\"KEYVAL:\");	\r\n   	LCD_ShowString(30,150,200,16,16,\"KEYCNT:\");	\r\n   	LCD_ShowString(30,170,200,16,16,\"SYMBOL:\");	  		\r\n	while (1)\r\n	{\r\n		key=Remote_Scan();	\r\n		for (i = 0; i < count; i++)// 测试\r\n		{\r\n			printf(\"(dval_%d=%d)\",i,arr_dval[i]);\r\n		}\r\n		\r\n		if(key)\r\n		{	 \r\n			LCD_ShowNum(86,130,key,3,16);		//显示键值\r\n			LCD_ShowNum(86,150,RmtCnt,3,16);	//显示按键次数		  \r\n			switch(key)\r\n			{\r\n				case 0:str=\"ERROR\";break;			   \r\n				case 162:str=\"POWER\";break;	    \r\n				case 98:str=\"UP\";break;	    \r\n				case 2:str=\"PLAY\";break;		 \r\n				case 226:str=\"ALIENTEK\";break;		  \r\n				case 194:str=\"RIGHT\";break;	   \r\n				case 34:str=\"LEFT\";break;		  \r\n				case 224:str=\"VOL-\";break;		  \r\n				case 168:str=\"DOWN\";break;		   \r\n				case 144:str=\"VOL+\";break;		    \r\n				case 104:str=\"1\";break;		  \r\n				case 152:str=\"2\";break;	   \r\n				case 176:str=\"3\";break;	    \r\n				case 48:str=\"4\";break;		    \r\n				case 24:str=\"5\";break;		    \r\n				case 122:str=\"6\";break;		  \r\n				case 16:str=\"7\";break;			   					\r\n				case 56:str=\"8\";break;	 \r\n				case 90:str=\"9\";break;\r\n				case 66:str=\"0\";break;\r\n				case 82:str=\"DELETE\";break;		 \r\n			}\r\n			LCD_Fill(86,170,116+8*8,170+16,WHITE);	//清楚之前的显示\r\n			LCD_ShowString(86,170,200,16,16,str);	//显示SYMBOL\r\n		}else delay_ms(10);	  \r\n		t++;\r\n		if(t==20)\r\n		{\r\n			t=0;\r\n			LED0=!LED0;\r\n		}\r\n	};\r\n}\r\n```\r\n\r\n# 二十四、DS18B20 温感\r\n\r\n## 简介\r\n\r\nDS18B20 是由 DALLAS 半导体公司推出的一种的“一线总线”接口的温度传感器。与传统的热敏电阻等测温元件相比，它是一种新型的体积小、适用电压宽、与微处理器接口简单的数字化温度传感器。一线总线结构具有简洁且经济的特点，可使用户轻松地组建传感器网络，从而为测量系统的构建引入全新概念，测量温度范围为-55~+125℃ ，精度为±0． 5℃。现场温度直接以“一线总线”的数字方式传输，大大提高了系统的抗干扰性。它能直接读出被测温度，并且可根据实际要求通过简单的编程实现 9~l2 位的数字值读数方式。它工作在 3—5． 5 V 的电压范围，采用多种封装形式，从而使系统设计灵活、方便，设定分辨率及用户设定的报警温度存储在 EEPROM 中，掉电后依然保存。  \r\n\r\n![image-20211019102506151](cloudDisk/markdown/stm32笔记.assets/image-20211019102506151.png)\r\n\r\n![image-20211019105732303](cloudDisk/markdown/stm32笔记.assets/image-20211019105732303.png)\r\n\r\nROM 中的 64 位序列号是出厂前被光记好的，它可以看作是该 DS18B20 的地址序列码，每DS18B20 的 64 位序列号均不相同。 64 位 ROM 的排列是：前 8 位是产品家族码，接着 48 位是DS18B20 的序列号，最后 8 位是前面 56 位的循环冗余校验码(CRC=X8+X5 +X4 +1)。 ROM 作用是使每一个 DS18B20 都各不相同，这样就可实现一根总线上挂接多个。  \r\n\r\n所有的单总线器件要求采用严格的信号时序，以保证数据的完整性。 DS18B20 共有 6 种信号类型：复位脉冲、应答脉冲、写 0、写 1、读 0 和读 1。所有这些信号，除了应答脉冲以外，都由主机发出同步信号。并且发送所有的命令和数据都是字节的低位在前。这里我们简单介绍\r\n这几个信号的时序 :\r\n\r\n**1）复位脉冲和应答脉冲**\r\n单总线上的所有通信都是以初始化序列开始。主机输出低电平，保持低电平时间至少 480us，以产生复位脉冲。接着主机释放总线， 4.7K 的上拉电阻将单总线拉高，延时 15～60 us，并进入接收模式(Rx)。接着 DS18B20 拉低总线 60~240 us，以产生低电平应答脉冲，若为低电平，再延时 480 us。\r\n**2）写时序**\r\n\r\n![image-20211019105630268](cloudDisk/markdown/stm32笔记.assets/image-20211019105630268.png)写时序包括写 0 时序和写 1 时序。所有写时序至少需要 60us，且在 2 次独立的写时序之间至少需要 1us 的恢复时间，两种写时序均起始于主机拉低总线。写 1 时序：主机输出低电平，延时 2us，然后释放总线，延时 60us。写 0 时序：主机输出低电平，延时 60us，然后释放总线，延时 2us。\r\n**3)读时序**\r\n\r\n![image-20211019105621697](cloudDisk/markdown/stm32笔记.assets/image-20211019105621697.png)单总线器件仅在主机发出读时序时，才向主机传输数据，所以，在主机发出读数据命令后，必须马上产生读时序，以便从机能够传输数据。所有读时序至少需要 60us，且在 2 次独立的读时序之间至少需要 1us 的恢复时间。每个读时序都由主机发起，至少拉低总线 1us。主机在读\r\n时序期间必须释放总线，并且在时序起始后的 15us 之内采样总线状态。典型的读时序过程为：主机输出低电平延时 2us，然后主机转入输入模式延时 12us，然后读取单总线当前的电平，然后延时 50us。\r\n\r\n在了解了单总线时序之后，我们来看看 DS18B20 的典型温度读取过程， DS18B20 的典型温度读取过程为：**复位→发 SKIP ROM 命令（0XCC） →发开始转换命令（0X44） →延时→复位→发送 SKIP ROM 命令（0XCC） →发读存储器命令（0XBE） →连续读出两个字节数据(即温度)→结束。**\r\nDS18B20 的介绍就到这里，更详细的介绍，请大家参考 DS18B20 的技术手册  \r\n\r\n## 硬件设计\r\n\r\n![image-20211019105822886](cloudDisk/markdown/stm32笔记.assets/image-20211019105822886.png)\r\n\r\n![image-20211019105831728](cloudDisk/markdown/stm32笔记.assets/image-20211019105831728.png)\r\n\r\n![image-20211019105959684](cloudDisk/markdown/stm32笔记.assets/image-20211019105959684.png)\r\n\r\n## 程序设计\r\n\r\n### ds18b20.c  \r\n\r\n#### 复位DS18B20\r\n\r\n```c\r\n//复位 DS18B20\r\nvoid DS18B20_Rst(void)\r\n{\r\n    DS18B20_IO_OUT(); //SET PA0 OUTPUT\r\n    DS18B20_DQ_OUT=0; //拉低 DQ\r\n    delay_us(750); //拉低 750us\r\n    DS18B20_DQ_OUT=1; //DQ=1\r\n    delay_us(15); //15US\r\n}\r\n```\r\n\r\n\r\n\r\n```c\r\n//IO方向设置\r\n#define DS18B20_IO_IN()  {GPIOG->CRH&=0XFFFF0FFF;GPIOG->CRH|=8<<12;} // 上拉/下拉输入\r\n#define DS18B20_IO_OUT() {GPIOG->CRH&=0XFFFF0FFF;GPIOG->CRH|=3<<12;} // 推挽输出\r\n////IO操作函数											   \r\n#define	DS18B20_DQ_OUT PGout(11) //数据端口	PA0 // io输出\r\n#define	DS18B20_DQ_IN  PGin(11)  //数据端口	PA0 // 读取io\r\n```\r\n\r\n#### 等待 DS18B20 的回应\r\n\r\n```C\r\n//等待 DS18B20 的回应\r\n//返回 1:未检测到 DS18B20 的存在\r\n//返回 0:存在\r\nu8 DS18B20_Check(void)\r\n{\r\n    u8 retry=0;\r\n    DS18B20_IO_IN();//SET PA0 INPUT\r\n    while (DS18B20_DQ_IN&&retry<200)\r\n    {\r\n        retry++;\r\n        delay_us(1);\r\n    };\r\n    if(retry>=200)return 1;\r\n    else retry=0;\r\n    while (!DS18B20_DQ_IN&&retry<240)\r\n    {\r\n        retry++;\r\n        delay_us(1);\r\n    };\r\n    if(retry>=240)return 1;\r\n    return 0;\r\n}\r\n```\r\n\r\n#### 读一个位\r\n\r\n```c\r\n//从 DS18B20 读取一个位\r\n//返回值： 1/0\r\nu8 DS18B20_Read_Bit(void) // read one bit\r\n{\r\n    u8 data;\r\n    DS18B20_IO_OUT();//SET PA0 OUTPUT\r\n    DS18B20_DQ_OUT=0;\r\n    delay_us(2);\r\n    DS18B20_DQ_OUT=1;\r\n    DS18B20_IO_IN();//SET PA0 INPUT\r\n    delay_us(12);\r\n    if(DS18B20_DQ_IN)data=1;\r\n    else data=0;\r\n    delay_us(50);\r\n    return data;\r\n}\r\n```\r\n\r\n#### 读一个字节\r\n\r\n```c\r\n//从 DS18B20 读取一个字节\r\n//返回值：读到的数据\r\nu8 DS18B20_Read_Byte(void) // read one byte\r\n{\r\n    u8 i,j,dat;\r\n    dat=0;\r\n    for (i=1;i<=8;i++)\r\n    {\r\n        j=DS18B20_Read_Bit();\r\n        dat=(j<<7)|(dat>>1);\r\n    }\r\n    return dat;\r\n}\r\n```\r\n\r\n#### 写一个字节（一般写指令）\r\n\r\n```c\r\n//写一个字节到 DS18B20\r\n//dat：要写入的字节\r\nvoid DS18B20_Write_Byte(u8 dat)\r\n{\r\n    u8 j;\r\n    u8 testb;\r\n    DS18B20_IO_OUT();//SET PA0 OUTPUT;\r\n    for (j=1;j<=8;j++)\r\n    {\r\n        testb=dat&0x01;\r\n        dat=dat>>1;\r\n        if (testb)\r\n        { \r\n            DS18B20_DQ_OUT=0;// Write 1\r\n            delay_us(2);\r\n            DS18B20_DQ_OUT=1;\r\n            delay_us(60);\r\n        }\r\n        else\r\n        { \r\n            DS18B20_DQ_OUT=0;// Write 0\r\n            delay_us(60);\r\n            DS18B20_DQ_OUT=1;\r\n            delay_us(2);\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n#### 初始化DS18B20\r\n\r\n```C\r\n//初始化 DS18B20 的 IO 口 DQ 同时检测 DS 的存在\r\n//返回 1:不存在\r\n//返回 0:存在\r\nu8 DS18B20_Init(void)\r\n{\r\n    GPIO_InitTypeDef GPIO_InitStructure;\r\n    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOG, ENABLE); //使能 PG 口时钟\r\n    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_11; //PORTG.11 推挽输出\r\n    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP; //推挽输出\r\n    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;\r\n    GPIO_Init(GPIOG, &GPIO_InitStructure); //初始化 GPIO\r\n    GPIO_SetBits(GPIOG,GPIO_Pin_11); //输出 1\r\n    DS18B20_Rst();\r\n    return DS18B20_Check();\r\n}\r\n```\r\n\r\n#### 读取温度值\r\n\r\n```\r\n//从 ds18b20 得到温度值\r\n//精度： 0.1C\r\n//返回值：温度值 （-550~1250）\r\nshort DS18B20_Get_Temp(void)\r\n{\r\n    u8 temp;\r\n    u8 TL,TH;\r\n    short tem;\r\n    DS18B20_Start (); // ds1820 start convert\r\n    DS18B20_Rst();\r\n    DS18B20_Check();\r\n    DS18B20_Write_Byte(0xcc);// skip rom\r\n    DS18B20_Write_Byte(0xbe);// convert\r\n    TL=DS18B20_Read_Byte(); // LSB\r\n    TH=DS18B20_Read_Byte(); // MSB\r\n    if(TH>7)\r\n    {\r\n        TH=~TH;\r\n        TL=~TL;\r\n        temp=0; //温度为负\r\n    }else temp=1; //温度为正\r\n    tem=TH; //获得高八位\r\n    tem<<=8;\r\n    tem+=TL; //获得底八位\r\n    tem=(float)tem*0.625; //转换\r\n    if(temp)return tem; //返回温度值\r\n    else return -tem;\r\n}\r\n```\r\n\r\n该部分代码就是根据我们前面介绍的单总线操作时序来读取 DS18B20 的温度值的， DS18B20的温度通过 DS18B20_Get_Temp 函数读取，该函数的返回值为带符号的短整形数据，返回值的范围为-550~1250，其实就是温度值扩大了 10 倍。  \r\n\r\n#### 主函数\r\n\r\n```c\r\nint main(void){	\r\n	short temp;\r\n	delay_init();	    	 //延时函数初始化	  \r\n	NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2); //设置NVIC中断分组2:2位抢占优先级，2位响应优先级 	\r\n	uart_init(115200);\r\n    KEY_Init();\r\n    LED_Init();\r\n	LCD_Init();\r\n	DS18B20_Init();\r\n    POINT_COLOR=BLUE;\r\n    LCD_ShowString(0,0,14*16,16,16,\"temperature: \");\r\n	while (1)\r\n	{\r\n		temp = DS18B20_Get_Temp();\r\n        if (temp<0)\r\n        {\r\n            LCD_ShowChar(0,16,\'-\',16,0);\r\n        }else{\r\n            LCD_ShowChar(0,16,\' \',16,0);\r\n        }\r\n        LCD_ShowxNum(16,16,temp/10,3,16,0);\r\n        LCD_ShowChar(48,16,\'.\',16,0);\r\n        LCD_ShowNum(64,16,temp%10,1,16);\r\n        LCD_ShowChar(80,16,\'C\',16,0);\r\n		printf(\"temp: %d \\n\",temp);\r\n		delay_ms(500);\r\n\r\n	};\r\n}\r\n```\r\n\r\n\r\n\r\n# 二十五、DHT11 温湿感  \r\n\r\n## 简介\r\n\r\nDHT11 是一款湿温度一体化的数字传感器。该传感器包括一个电阻式测湿元件和一个 NTC测温元件，并与一个高性能 8 位单片机相连接。通过单片机等微处理器简单的电路连接就能够实时的采集本地湿度和温度。 DHT11 与单片机之间能采用简单的单总线进行通信，仅仅需要一个 I/O 口。传感器内部湿度和温度数据 40Bit 的数据一次性传给单片机，数据采用校验和方式\r\n进行校验，有效的保证数据传输的准确性。 DHT11 功耗很低， 5V 电源电压下，工作平均最大电流 0.5mA。  \r\n\r\nDHT11 的技术参数如下：\r\n⚫ 工作电压范围： 3.3V-5.5V\r\n⚫ 工作电流 ：平均 0.5mA\r\n⚫ 输出：单总线数字信号\r\n⚫ 测量范围：湿度 20~90％RH，温度 0~50℃\r\n⚫ 精度 ：湿度±5%，温度±2℃\r\n⚫ 分辨率 ：湿度 1%，温度 1℃\r\nDHT11 的管脚排列如图 34.1.1 所示：  \r\n\r\n![image-20211020132817405](cloudDisk/markdown/stm32笔记.assets/image-20211020132817405.png)\r\n\r\nHT11 数字湿温度传感器采用单总线数据格式。即，单个数据引脚端口完成输入输出双向传输。其数据包由 5Byte（40Bit）组成。数据分小数部分和整数部分，一次完整的数据传输为40bit，高位先出。 DHT11 的数据格式为： 8bit 湿度整数数据+8bit 湿度小数数据+8bit 温度整数数据+8bit 温度小数数据+8bit 校验和。其中校验和数据为前四个字节相加。  \r\n\r\n传感器数据输出的是未编码的二进制数据。数据(湿度、温度、整数、小数)之间应该分开处理。例如，某次从 DHT11 读到的数据如图 34.1.2 所示：  \r\n\r\n![image-20211020133056237](cloudDisk/markdown/stm32笔记.assets/image-20211020133056237.png)\r\n\r\n由以上数据就可得到湿度和温度的值，计算方法：\r\n\r\n```mathematica\r\n湿度= byte4 . byte3=45.0 (％RH)  \r\n温度= byte2 . byte1=28.0 ( ℃)\r\n校验= byte4+ byte3+ byte2+ byte1=73(=湿度+温度)(校验正确)\r\n```\r\n\r\nDHT11 的数据格式是十分简单的， DHT11 和 MCU 的一次通信最大为 3ms 左右，建议主机连续读取时间间隔不要小于 100ms。  \r\n\r\n![image-20211020133813977](cloudDisk/markdown/stm32笔记.assets/image-20211020133813977.png)\r\n\r\n首先主机发送开始信号，即：拉低数据线，保持 t1（至少 18ms）时间，然后拉高数据线 t2（20~40us）时间，然后读取 DHT11 的响应，正常的话， DHT11 会拉低数据线，保持 t3（40~50us）时间，作为响应信号，然后 DHT11 拉高数据线，保持 t4（40~50us）时间后，开始输出数据。  \r\n\r\n![image-20211020134024491](cloudDisk/markdown/stm32笔记.assets/image-20211020134024491.png)\r\n\r\n## 硬件设计\r\n\r\n本章实验功能简介：开机的时候先检测是否有 DHT11 存在，如果没有，则提示错误。只有在检测到 DHT11 之后才开始读取温湿度值，并显示在 LCD 上，如果发现了 DHT11，则程序每隔 100ms 左右读取一次数据，并把温湿度显示在 LCD 上。同样我们也是用 DS0 来指示程序正在运行  \r\n\r\n![image-20211020134141890](cloudDisk/markdown/stm32笔记.assets/image-20211020134141890.png)\r\n\r\n## 软件设计\r\n\r\n### dht11.c 文件  \r\n\r\n#### 复位 DHT11  \r\n\r\n```c\r\n#include \"dht11.h\"\r\n#include \"delay.h\"\r\n//复位 DHT11\r\nvoid DHT11_Rst(void)\r\n{\r\n    DHT11_IO_OUT(); //SET OUTPUT\r\n    DHT11_DQ_OUT=0; //拉低 DQ\r\n    delay_ms(20); //拉低至少 18ms\r\n    DHT11_DQ_OUT=1; //DQ=1\r\n    delay_us(30); //主机拉高 20~40us\r\n}\r\n```\r\n\r\n#### 等待 DHT11 的回应  \r\n\r\n```c\r\n//等待 DHT11 的回应\r\n//返回 1:未检测到 DHT11 的存在\r\n//返回 0:存在\r\nu8 DHT11_Check(void)\r\n{\r\n    u8 retry=0;\r\n    DHT11_IO_IN();//SET INPUT\r\n    while (DHT11_DQ_IN&&retry<100) //DHT11 会拉低 40~80us\r\n    {\r\n        retry++;\r\n        delay_us(1);\r\n    };\r\n    if(retry>=100)return 1;\r\n    else retry=0;\r\n    while (!DHT11_DQ_IN&&retry<100)//DHT11 拉低后会再次拉高 40~80us\r\n    {\r\n        retry++;\r\n        delay_us(1);\r\n    };\r\n    if(retry>=100)return 1;\r\n    return 0;\r\n}\r\n```\r\n\r\n#### 从 DHT11 读取一个位  \r\n\r\n```c\r\n//从 DHT11 读取一个位\r\n//返回值： 1/0\r\nu8 DHT11_Read_Bit(void)\r\n{\r\n    u8 retry=0;\r\n    while(DHT11_DQ_IN&&retry<100)//等待变为低电平\r\n    {\r\n        retry++;\r\n        delay_us(1);\r\n    }\r\n    retry=0;\r\n    while(!DHT11_DQ_IN&&retry<100)//等待变高电平\r\n    {\r\n        retry++;\r\n        delay_us(1);\r\n    }\r\n    delay_us(40);//等待 40us\r\n    if(DHT11_DQ_IN)return 1;\r\n    else return 0;\r\n}\r\n```\r\n\r\n#### 从 DHT11 读取一个字节  \r\n\r\n```c\r\n//从 DHT11 读取一个字节\r\n//返回值：读到的数据\r\nu8 DHT11_Read_Byte(void)\r\n{\r\n    u8 i,dat;\r\n    dat=0;\r\n    for (i=0;i<8;i++)\r\n    {\r\n        dat<<=1;\r\n        dat|=DHT11_Read_Bit();\r\n    }\r\n    return dat;\r\n}\r\n```\r\n\r\n```c\r\n//从 DHT11 读取一次数据\r\n//temp:温度值(范围:0~50° )\r\n//humi:湿度值(范围:20%~90%)\r\n//返回值： 0,正常;1,读取失败\r\nu8 DHT11_Read_Data(u8 *temp,u8 *humi)\r\n{\r\n    u8 buf[5];\r\n    u8 i;\r\n    DHT11_Rst();\r\n    if(DHT11_Check()==0)\r\n    {\r\n        for(i=0;i<5;i++)//读取 40 位数据\r\n        {\r\n            buf[i]=DHT11_Read_Byte();\r\n        }\r\n        if((buf[0]+buf[1]+buf[2]+buf[3])==buf[4])\r\n        {\r\n            *humi=buf[0];\r\n            *temp=buf[2];\r\n        }\r\n    }else return 1;\r\n    return 0;\r\n}\r\n```\r\n\r\n#### 初始化\r\n\r\n```c\r\n//初始化 DHT11 的 IO 口 DQ 同时检测 DHT11 的存在\r\n//返回 1:不存在\r\n//返回 0:存在\r\nu8 DHT11_Init(void)\r\n{\r\n    GPIO_InitTypeDef GPIO_InitStructure;\r\n    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOG, ENABLE); //使能 PG 端口时钟\r\n    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_11; //PG11 端口配置\r\n    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP; //推挽输出\r\n    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;\r\n    GPIO_Init(GPIOG, &GPIO_InitStructure); //初始化 IO 口\r\n    GPIO_SetBits(GPIOG,GPIO_Pin_11); //PG11 输出高\r\n    DHT11_Rst(); //复位 DHT11\r\n    return DHT11_Check(); //等待 DHT11 的回应\r\n}\r\n```\r\n\r\n\r\n\r\n### 主函数\r\n\r\n```c\r\nint main(void)\r\n{\r\n    u8 t=0;\r\n    u8 temperature;\r\n    u8 humidity;\r\n    delay_init(); //延时函数初始化\r\n    NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);//设置中断优先级分组为组 2\r\n    uart_init(115200); //串口初始化为 115200\r\n    LED_Init(); //初始化与 LED 连接的硬件接口\r\n    LCD_Init(); //初始化 LCD\r\n    POINT_COLOR=RED; //设置字体为红色\r\n    LCD_ShowString(30,50,200,16,16,\"ELITE STM32\");\r\n    LCD_ShowString(30,70,200,16,16,\"DHT11 TEST\");\r\n    LCD_ShowString(30,90,200,16,16,\"ATOM@ALIENTEK\");\r\n    LCD_ShowString(30,110,200,16,16,\"2015/1/16\");\r\n    while(DHT11_Init()) //DHT11 初始化\r\n    {\r\n        LCD_ShowString(30,130,200,16,16,\"DHT11 Error\");\r\n        delay_ms(200);\r\n        LCD_Fill(30,130,239,130+16,WHITE);\r\n        delay_ms(200);\r\n    }\r\n    LCD_ShowString(30,130,200,16,16,\"DHT11 OK\");\r\n    POINT_COLOR=BLUE;//设置字体为蓝色\r\n    LCD_ShowString(30,150,200,16,16,\"Temp: C\");\r\n    LCD_ShowString(30,170,200,16,16,\"Humi: %\");\r\n    while(1)\r\n    {\r\n        if(t%10==0) //每 100ms 读取一次\r\n        {\r\n            DHT11_Read_Data(&temperature,&humidity); //读取温湿度值\r\n            LCD_ShowNum(30+40,150,temperature,2,16); //显示温度\r\n            LCD_ShowNum(30+40,170,humidity,2,16); //显示湿度\r\n        }\r\n        delay_ms(10);\r\n        t++;\r\n        if(t==20)\r\n        {\r\n            t=0;\r\n            LED0=!LED0;\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n\r\n\r\n# 二十六、HC-SR04超声波模块测距\r\n\r\n## 主要参数\r\n\r\n1：使用电压：DC—5V\r\n2：静态电流：小于2mA\r\n3：电平输出：高5V\r\n4：电平输出：底0V\r\n5：感应角度：不大于15度\r\n6：探测距离：2cm-450cm\r\n7:   高精度 可达0.2cm\r\n\r\n## 工作原理\r\n\r\n1. 采用IO口TRIG触发测距，给至少10us的高电平信号来启动模块。\r\n2. 模块自动发送8个40khz的方波，自动检测是否有信号返回。\r\n3. 如果有信号返回，通过IO口ECHO输出一个高电平，高电平持续的时间就是超声波从发射到返回的时间。通过公式计算测试距离=(高电平时间*声速(340M/S))/2。\r\n\r\n![image-20211020141532044](cloudDisk/markdown/stm32笔记.assets/image-20211020141532044-16347105328231.png)\r\n\r\n![image-20211020141546642](cloudDisk/markdown/stm32笔记.assets/image-20211020141546642.png)\r\n\r\n\r\n\r\n![image-20211020141556441](cloudDisk/markdown/stm32笔记.assets/image-20211020141556441.png)\r\n\r\n![image-20211020141632468](cloudDisk/markdown/stm32笔记.assets/image-20211020141632468.png)\r\n\r\n## 硬件设计\r\n\r\n上拉输入PB0/Tim3_CH3     Echo\r\n\r\n推挽输出PB1     Trig \r\n\r\n![image-20211020190751417](cloudDisk/markdown/stm32笔记.assets/image-20211020190751417.png)\r\n\r\n## 程序设计\r\n\r\n### 初始化函数\r\n\r\n```c\r\nvoid HC_SR04_init(void){\r\n    // 初始化 上拉输入PB8/Tim4_CH3     Echo\r\n    // 推挽输出PB1     Trig \r\n    GPIO_InitTypeDef GPIO_InitStruct;\r\n    TIM_TimeBaseInitTypeDef  TIM_TimeBaseStructure;\r\n	TIM_ICInitTypeDef  TIM_ICInitStructure;  \r\n    NVIC_InitTypeDef NVIC_InitStructure;\r\n\r\n    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB,ENABLE); //使能PORTB时钟 \r\n    GPIO_InitStruct.GPIO_Speed = GPIO_Speed_50MHz;\r\n    GPIO_InitStruct.GPIO_Mode = GPIO_Mode_IPD;\r\n    GPIO_InitStruct.GPIO_Pin = GPIO_Pin_8;\r\n    GPIO_Init(GPIOB,&GPIO_InitStruct);\r\n    GPIO_InitStruct.GPIO_Mode = GPIO_Mode_Out_PP;\r\n    GPIO_InitStruct.GPIO_Pin = GPIO_Pin_1;\r\n    GPIO_Init(GPIOB,&GPIO_InitStruct);\r\n    GPIO_ResetBits(GPIOB,GPIO_Pin_1);\r\n  // 初始化Tim4_CH3\r\n    RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM4,ENABLE);	//TIM4时钟使能 \r\n    TIM_TimeBaseStructure.TIM_Period = 1000-1; //设定计数器自动重装值 最大1ms溢出  \r\n	TIM_TimeBaseStructure.TIM_Prescaler =(72-1); 	//预分频器,1M的计数频率,1us加1.	   \r\n	TIM_TimeBaseStructure.TIM_ClockDivision = TIM_CKD_DIV1; //设置时钟分割:TDTS = Tck_tim\r\n	TIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Up;  //TIM向上计数模式\r\n	TIM_TimeBaseInit(TIM4, &TIM_TimeBaseStructure); //根据指定的参数初始化TIMx\r\n\r\n    TIM_ICInitStructure.TIM_Channel = TIM_Channel_3;  // 选择输入端 IC4映射到TI3上\r\n    TIM_ICInitStructure.TIM_ICPolarity = TIM_ICPolarity_Rising;	//上升沿捕获\r\n    TIM_ICInitStructure.TIM_ICSelection = TIM_ICSelection_DirectTI;\r\n    TIM_ICInitStructure.TIM_ICPrescaler = TIM_ICPSC_DIV1;	 //配置输入分频,不分频 \r\n    TIM_ICInitStructure.TIM_ICFilter = 0x03;//IC4F=0011 配置输入滤波器 8个定时器时钟周期滤波\r\n    TIM_ICInit(TIM4, &TIM_ICInitStructure);//初始化定时器输入捕获通道\r\n\r\n    TIM_Cmd(TIM4,DISABLE ); 	//使能定时器4\r\n\r\n    NVIC_InitStructure.NVIC_IRQChannel = TIM4_IRQn;  //TIM4中断\r\n    NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 1;  //先占优先级0级\r\n    NVIC_InitStructure.NVIC_IRQChannelSubPriority = 3;  //从优先级3级\r\n    NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE; //IRQ通道被使能\r\n    NVIC_Init(&NVIC_InitStructure);  //根据NVIC_InitStruct中指定的参数初始化外设NVIC寄存器	\r\n\r\n    TIM_ITConfig( TIM4,TIM_IT_Update,ENABLE);//不允许更新中断 ,允许CC4IE捕获中断				 \r\n\r\n    TIM_ClearFlag(TIM4, TIM_FLAG_Update);   //清除更新中断，免得一打开中断立即产生中断\r\n\r\n}\r\n```\r\n\r\n### 打开定时器\r\n\r\n```c\r\nvoid openTimerForHc(){ // 打开定时器\r\n    TIM_SetCounter(TIM4,0);//清除计数\r\n    msHcCount = 0;\r\n    TIM_Cmd(TIM4, ENABLE);  //使能TIMx外设\r\n}\r\n```\r\n\r\n### 关闭定时器\r\n\r\n```c\r\nvoid closeTimerForHc(){\r\n    TIM_Cmd(TIM4, DISABLE); \r\n}\r\n```\r\n\r\n### 定时器3中断函数\r\n\r\n定义一个全局变量，存放定时器溢出次数\r\n\r\n```c\r\nu16 msHcCount = 0;//ms计数\r\n```\r\n\r\n```c\r\n//定时器4中断服务程序\r\nvoid TIM4_IRQHandler(void)   //TIM4中断\r\n{\r\n        if (TIM_GetITStatus(TIM4, TIM_IT_Update) != RESET)  //检查TIM4更新中断发生与否\r\n        {\r\n                TIM_ClearITPendingBit(TIM4, TIM_IT_Update  );  //清除TIMx更新中断标志 \r\n                msHcCount++;\r\n        }\r\n}\r\n```\r\n\r\n### 获取定时器的时间，根据溢出次数计算\r\n\r\n```c\r\n//获取定时器时间\r\nu32 GetEchoTimer(void)\r\n{\r\n    u32 t = 0;\r\n    t = msHcCount*1000;//得到S\r\n    t += TIM_GetCounter(TIM4);//得到US\r\n        // TIM3->CNT = 0;  //将TIM4计数寄存器的计数值清零\r\n    TIM_SetCounter(TIM4,0);\r\n    delay_ms(50);\r\n    return t;\r\n}\r\n```\r\n\r\n### 获取超声波数据\r\n\r\n```c\r\n//一次获取超声波测距数据 两次测距之间需要相隔一段时间，隔断回响信号\r\n//为了消除余震的影响，取五次数据的平均值进行加权滤波。\r\nfloat Hcsr04GetLength(void )\r\n{\r\n		u32 t = 0;\r\n		int i = 0;\r\n		float lengthTemp = 0;\r\n		float sum = 0;\r\n		while(i != 5)\r\n		{\r\n            GPIO_SetBits(GPIOB,GPIO_Pin_1);    //发送口高电平输出\r\n            delay_us(20);\r\n            GPIO_ResetBits(GPIOB,GPIO_Pin_1);\r\n            while (!GPIO_ReadInputDataBit(GPIOB,GPIO_Pin_8)) // 等待高电平\r\n			openTimerForHc();        //打开定时器\r\n\r\n			\r\n			while (GPIO_ReadInputDataBit(GPIOB,GPIO_Pin_8));\r\n\r\n			closeTimerForHc();        //关闭定时器\r\n			t = GetEchoTimer();        //获取时间,分辨率为1US\r\n			lengthTemp = ((float)t/58.0);//cm\r\n			sum = lengthTemp + sum ;\r\n\r\n            i++;\r\n	    }\r\n		lengthTemp = sum/5.0;\r\n		return lengthTemp;\r\n}\r\n```\r\n\r\n### 主函数\r\n\r\n```c\r\nint main(void){	\r\n    u8 key;\r\n    float length;\r\n	delay_init();	    	 //延时函数初始化	  \r\n	NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2); //设置NVIC中断分组2:2位抢占优先级，2位响应优先级 	\r\n	uart_init(115200);\r\n    KEY_Init();\r\n    // LED_Init();\r\n    HC_SR04_init();\r\n    LCD_Init();\r\n    POINT_COLOR=BLUE;\r\n    LCD_ShowString(0,0,14*16,16,16,\"distance: \");\r\n    LCD_ShowString(0,48,14*16,16,16,\"Press KEY0 to measure the \");\r\n    LCD_ShowString(0,62,14*16,16,16,\"distance.\");\r\n	while (1)\r\n	{\r\n        // delay_ms(800);\r\n        key = KEY_Scan(0);\r\n        if (key == KEY0)\r\n        {\r\n            length = Hcsr04GetLength();\r\n            LCD_ShowxNum(0,16,length,4,16,0);\r\n            LCD_ShowChar(4*12,16,\'.\',16,0);\r\n            LCD_ShowxNum(5*12,16,(u32)(length*1000)%1000,3,16,0);\r\n            LCD_ShowString(9*12,16,32,16,16,\"cm\");\r\n            // printf(\"distance:%.3f\\n \",length);\r\n        }\r\n	};\r\n}\r\n```\r\n\r\n# 二十七、雨滴传感器\r\n\r\n## 简介\r\n\r\n雨滴传感器，它是一个模拟（数字）输入模块，也叫雨水、雨量传感器。可用于各种天气状况的监测，检测是否下雨及雨量的大小，转成数字信号（DO）和模拟信号（AO）输出，并广泛应用于汽车自动刮水系统、智能灯光系统和智能天窗系统等。\r\n\r\nAO模拟输出，可以连接单片机的模拟IO口检测滴在上面的雨量大小。\r\n\r\nDO数字输出，可以连接单片机的数字IO口检测是否有雨。\r\n\r\n**雨滴传感器特性**\r\n\r\n1、传感器采用高品质FR-04双面材料，超大面积5.0*4.0CM,并用镀镍处理表面，具有对抗氧化，导电性，及寿命方面更优越的性能；\r\n\r\n2、小板PCB尺寸：3.2cm x 1.4cm\r\n\r\n3、设有固定螺栓孔，方便安装\r\n\r\n4、工作电压3.3V-5V\r\n\r\n5、使用宽电压LM393比较器输出，信号干净，波形好，驱动能力强，超过15mA；\r\n\r\n6、输出形式：数字开关量输出（0和1）和模拟量AO电压输出；\r\n\r\n7、配电位器调节灵敏度；\r\n\r\n**接口说明**\r\n\r\n把雨滴传感器连接到扩展板A1号模拟管脚\r\n\r\n1、VCC:接电源正极（3-5V）\r\n\r\n2、GND:接电源负极\r\n\r\n3、DO:TTL开关信号输出\r\n\r\n4、AO:模拟信号输出\r\n\r\n![image-20211020194742575](cloudDisk/markdown/stm32笔记.assets/image-20211020194742575.png)\r\n\r\n**校准雨量传感器**\r\n为了获得雨量传感器的准确读数，建议您首先对其进行校准。\r\n\r\n该模块具有内置的电位计，用于校准数字输出（DO）。\r\n\r\n通过旋转电位器的旋钮，可以设置阈值。因此，当水量超过阈值时，状态LED将点亮，数字输出（DO）将输出为低电平。\r\n\r\n现在要校准传感器，在感应垫上洒一些水，然后顺时针调整电位计，以使状态LED亮起，然后逆时针调整电位计，直至LED熄灭。\r\n\r\n就是这样，您的传感器现在已校准并可以使用。\r\n\r\n## 硬件设计\r\n\r\n![image-20211020194830164](cloudDisk/markdown/stm32笔记.assets/image-20211020194830164.png)\r\n\r\nPF6 模拟输入    AO\r\n\r\nPF5 数字输入   DO\r\n\r\n## 程序设计\r\n\r\n### 初始化\r\n\r\n```c\r\n// 初始化\r\nvoid yudiSensor_init(){\r\n    // 初始化\r\n    // PF6 模拟输入    AO\r\n    // PF5 数字输入   DO\r\n    ADC_InitTypeDef ADC_InitStruct;\r\n    GPIO_InitTypeDef GPIO_InitStruct;\r\n    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOF, ENABLE);	 //使能Pc端口时钟\r\n    GPIO_InitStruct.GPIO_Mode = GPIO_Mode_IPU;\r\n    GPIO_InitStruct.GPIO_Pin = GPIO_Pin_5;\r\n    GPIO_InitStruct.GPIO_Speed = GPIO_Speed_50MHz;\r\n    GPIO_Init(GPIOF,&GPIO_InitStruct);\r\n    GPIO_InitStruct.GPIO_Mode = GPIO_Mode_AIN;\r\n    GPIO_InitStruct.GPIO_Pin = GPIO_Pin_6;\r\n    GPIO_Init(GPIOF,&GPIO_InitStruct);\r\n\r\n\r\n	// 1） 开启 PA 口时钟和 ADC3 时钟\r\n	RCC_APB2PeriphClockCmd(RCC_APB2Periph_ADC3,ENABLE);\r\n	// 2） 复位 ADC3，同时设置 ADC3 分频因子。\r\n	ADC_DeInit(ADC3);\r\n	RCC_ADCCLKConfig(RCC_PCLK2_Div6); // 72MHz的六分频，12MHz\r\n	// 3） 初始化 ADC3 参数， 设置 ADC3 的工作模式以及规则序列的相关信息。\r\n	ADC_InitStruct.ADC_ContinuousConvMode = DISABLE; //AD 单次转换模式\r\n	ADC_InitStruct.ADC_DataAlign = ADC_DataAlign_Right; //ADC 数据右对齐\r\n	ADC_InitStruct.ADC_ExternalTrigConv = ADC_ExternalTrigConv_None;\r\n//转换由软件而不是外部触发启动\r\n	ADC_InitStruct.ADC_Mode = ADC_Mode_Independent; //ADC 工作模式:独立模式\r\n	ADC_InitStruct.ADC_NbrOfChannel = 1; //顺序进行规则转换的 ADC 通道的数目 1\r\n	ADC_InitStruct.ADC_ScanConvMode = DISABLE; //AD 单通道模式\r\n	ADC_Init(ADC3, &ADC_InitStruct);\r\n\r\n	// 5） 使能 ADC 并校准。\r\n	ADC_Cmd(ADC3, ENABLE); //使能指定的 ADC3\r\n	ADC_ResetCalibration(ADC3); // 执行复位校准\r\n	while(ADC_GetResetCalibrationStatus(ADC3)); //等待复位校准结束\r\n	ADC_StartCalibration(ADC3); //开始指定 ADC1 的校准状态\r\n	while(ADC_GetCalibrationStatus(ADC3)); //等待校 AD 准结束 \r\n}\r\n```\r\n\r\n### 采样模块输出的模拟电压\r\n\r\n```c\r\n// 采样雨滴传感器的输出电压\r\nu16 getSample(void){\r\n	u16 result;\r\n    // printf(\"sampleMethod; \");\r\n	// 6） 读取 ADC 值。\r\n	// 我们这里是规则序列中的第 4 个转换，同时采样周期为 239.5，所以设置为\r\n	ADC_RegularChannelConfig(ADC3, ADC_Channel_4, 1, ADC_SampleTime_239Cycles5 );\r\n	// 软件开启 ADC 转换\r\n	ADC_SoftwareStartConvCmd(ADC3, ENABLE);//使能指定的 ADC4 的软件转换启动功能\r\n	while(!ADC_GetFlagStatus(ADC3, ADC_FLAG_EOC));//等待转换结束\r\n	// 获取转换 ADC 转换结果数据\r\n	result = ADC_GetConversionValue(ADC3);\r\n	// printf(\"采样结果：%d\\n\",result);\r\n	return result;\r\n}\r\n```\r\n\r\n### 读取模块的数字输出\r\n\r\n```c\r\nu8 isRainning(){\r\n    if (GPIO_ReadInputDataBit(GPIOF,GPIO_Pin_5))\r\n    {\r\n        return 0;\r\n    }else{\r\n        return 1;\r\n    }\r\n}\r\n```\r\n\r\n### 主函数\r\n\r\n```c\r\nint main(void){	\r\n    u16 sam;\r\n    // float length;\r\n	delay_init();	    	 //延时函数初始化	  \r\n	NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2); //设置NVIC中断分组2:2位抢占优先级，2位响应优先级 	\r\n	uart_init(115200);\r\n    KEY_Init();\r\n    LED_Init();\r\n    yudiSensor_init();\r\n    LCD_Init();\r\n    POINT_COLOR=BLUE;\r\n    LCD_ShowString(0,0,14*16,16,16,\"Rainning Sensor: \");\r\n	while (1)\r\n	{\r\n        sam = getSample();\r\n        printf(\"analog value:%d; \\n\",sam);\r\n        printf(\"%d\\n \",isRainning());\r\n        if (isRainning())\r\n        {\r\n            LCD_ShowString(0,16,22*16,16,16,\"It\'s rainning.    \");\r\n        }else{\r\n            LCD_ShowString(0,16,22*16,16,16,\"It\'s not raining.\");\r\n        }\r\n        delay_ms(100);\r\n	};\r\n}\r\n```\r\n\r\n# 二十八、舵机\r\n\r\n![image-20211025165920723](cloudDisk/markdown/stm32笔记.assets/image-20211025165920723.png)\r\n\r\n红 - vcc\r\n\r\n橙 - 信号 - pb5\r\n\r\n棕 - gnd\r\n\r\n## 1. **确定PWM频率**\r\n\r\n* PWM的周期（频率）就是ARR寄存器值与PSC寄存器值相乘得来\r\n* 输出50hz频率的PWM(周期20ms)\r\n  1. 确定TIMx的时钟\r\n     * 除非APB1的时钟分频数设置为1，否则通用定时器TIMx的时钟是APB1时钟的2倍，这时的TIMx时钟为72MHz\r\n  2. 用这个TIMx时钟72MHz除以（PSC+1），得到定时器每隔多少秒加一\r\n     * 这里给PSC赋7199，计算得定时器每隔0.0001秒加一，即此时频率为10KHz\r\n  3. 再把这个值乘以（ARR+1）得出PWM频率\r\n     * 假如ARR值为0，即0.0001*（199+1），则输出PWM频率为50hz\r\n\r\n## 2. **怎么**确定PWM的占空比\r\n\r\n![image-20210816004751679](cloudDisk/markdown/stm32笔记.assets/image-20210816004751679.png)\r\n\r\n* 占空比概念：**是一个脉冲周期内，高电平的时间与整个周期时间的比例**\r\n  * 单位： **%** (0%-100%)\r\n  * **比方说周期的时间是10ms，脉宽时间是8ms 那么低电平时间就是2ms 总的占空比 8/8+2= 80%**\r\n\r\n* TIMx_CCR1—TIMx_CCR4确定定时器的CH1—CH4四路PWM的占空比。直接给该寄存器赋0—65535值即可确定占空比。\r\n* 函数方式：void TIM_SetCompare2(TIM_TypeDef* TIMx, uint16_t Compare2)；  \r\n\r\n* 占空比计算方法：\r\n  * TIMx_CCRx的值(上面函数的第二个参数)除以ARR寄存器的值即为占空比，因为占空比在0—100%之间，所以一般TIMx_CCRx寄存器值不能超过ARR寄存器的值，否则可能会引起PWM的频率或占空比的准确性。\r\n\r\n```c\r\n#include \"stm32f10x.h\"\r\n#include \"delay.h\"\r\n#include \"usart.h\"\r\n#include \"lcd.h\"\r\n#include \"led.h\"\r\n#include \"sys.h\" \r\n#include \"key.h\"\r\nvoid nvicInit(void){\r\n	NVIC_InitTypeDef NVIC_InitStructure;\r\n	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;\r\n	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0x02; // 设置抢占优先级2\r\n	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0x02; //子优先级 2\r\n	NVIC_InitStructure.NVIC_IRQChannel = TIM3_IRQn;\r\n	NVIC_Init(&NVIC_InitStructure);\r\n}\r\n\r\nvoid Timer3Init(u16 arr, u16 psc){\r\n	TIM_TimeBaseInitTypeDef TIM_TimeBaseInitStruct;\r\n	TIM_TimeBaseInitStruct.TIM_Period = arr;\r\n	TIM_TimeBaseInitStruct.TIM_Prescaler =psc;\r\n	TIM_TimeBaseInitStruct.TIM_ClockDivision = TIM_CKD_DIV1;\r\n	TIM_TimeBaseInitStruct.TIM_CounterMode = TIM_CounterMode_Up;\r\n	RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM3, ENABLE); //使能定时器 3 时钟\r\n	TIM_TimeBaseInit(TIM3, &TIM_TimeBaseInitStruct);  \r\n\r\n}\r\nvoid pwmTim3Ch2Init(void){\r\n	GPIO_InitTypeDef GPIO_InitStruct;\r\n	TIM_OCInitTypeDef TIM_OCInitStruct;\r\n	// 1）以及复用功能时钟，配置 PB5 为复用输出。  \r\n	RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO, ENABLE); //复用时钟使能 \r\n	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB,ENABLE);\r\n	GPIO_InitStruct.GPIO_Mode = GPIO_Mode_AF_PP; //复用推挽输出\r\n	GPIO_InitStruct.GPIO_Pin = GPIO_Pin_5;\r\n	GPIO_InitStruct.GPIO_Speed = GPIO_Speed_50MHz;\r\n	GPIO_Init(GPIOB,&GPIO_InitStruct);	\r\n	// 2） 设置 TIM3_CH2 重映射到 PB5 上。  \r\n	GPIO_PinRemapConfig(GPIO_PartialRemap_TIM3, ENABLE);\r\n	// 3） 开启 TIM3 时钟, 初始化 TIM3,设置 TIM3 的 ARR 和 PSC。 \r\n    // 50hz\r\n	Timer3Init(7199,199);\r\n	// 4） 设置 TIM3_CH2 的 PWM 模式，使能 TIM3 的 CH2 输出。\r\n	TIM_OCInitStruct.TIM_OCMode = TIM_OCMode_PWM2; //选择 PWM 模式 2\r\n	TIM_OCInitStruct.TIM_OutputState = TIM_OutputState_Enable; //比较输出使能\r\n	TIM_OCInitStruct.TIM_OCPolarity = TIM_OCPolarity_High; //输出极性高\r\n	TIM_OC2Init(TIM3, &TIM_OCInitStruct); // //初始化 TIM3 OC2\r\n	// 5） 使能 TIM3。  \r\n	TIM_Cmd(TIM3, ENABLE); //使能 TIM3 \r\n\r\n}\r\n\r\nint main(void){	\r\n	u8 k;\r\n	delay_init();	    	 //延时函数初始化	  \r\n	NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2); //设置NVIC中断分组2:2位抢占优先级，2位响应优先级 	\r\n	uart_init(115200);\r\n    KEY_Init();\r\n    // LED_Init();\r\n    pwmTim3Ch2Init();\r\n    // LCD_Init();\r\n    // POINT_COLOR=BLUE;\r\n    // LCD_ShowString(0,0,14*16,16,16,\"Rainning Sensor: \");\r\n	\r\n	while (1)\r\n	{\r\n		k = KEY_Scan(0);\r\n		if(k == KEY0){\r\n			TIM_SetCompare2(TIM3,7020);\r\n		}else if (k == KEY1)\r\n		{\r\n			TIM_SetCompare2(TIM3,6300);\r\n		}\r\n		\r\n	}; \r\n}\r\n```\r\n\r\n\r\n\r\n# 二十九、esp8266 01s\r\n\r\nhttps://wenku.baidu.com/link?url=j4rHOGhq9Y2OjAqF_mT9WHkuAwS4ezoyZTDcQE6nJDAAZGshy74jBX0k6yzoOZwn7Lc4Kz-MZYvTz3I2QcF07hG-L6J7LjISRmgdzIJJs2S\r\n\r\n## 写在前面\r\n\r\n今天开始调试ESP8266模块，想要使用它以串口AT命令的方式发送GET请求，用来上报信息给服务器端。在查找资料和实验的过程中发现网上的讲解并不是详细，东拼西凑看了几篇才走下来，在此写一个尽量“清楚明白”的文章，欢迎大家一起交流。\r\n\r\n## 好的建议\r\n\r\n1.建议大家现在每次都记事本上写AT命令，然后复制到串口助手上去，这样：\r\n\r\n不会误操作：有的串口助手会将回车当作发送指令，容易误动作。\r\n记录可以保留：调过AT指令的朋友们都知道，我们为了实现一个操作可能会做多次有顺序的AT指令，这时，保留正确的操作指令和顺序是非常重要的。\r\n2.建议大家保留手敲\\r\\n的习惯，关闭串口助手的“加回车换行”的选项：\r\n这个选项几乎所有串口助手都会带，我建议大家不要勾选，而是手敲\\r\\n来代替，输入了什么就发送了什么，这样十分有利于将正确的AT指令转移到单片机中，笔者曾经调GSM模块的时候，很多坑就是栽在这里了。\r\n\r\n## 正式开始\r\n\r\n以下操作均关闭”加回车换行”选项\r\n0） 与模块试连接：(可选)\r\n  AT\\r\\n\r\n  响应：OK\\r\\n\r\n可用于检验模块工作是否正常，波特率是否正确\r\n**1） 设置 wifi 模式：**\r\n  AT+CWMODE=1\\r\\n\r\n  响应：OK\\r\\n\r\n设置为STA模式，对应表如下：\r\n\r\n![image-20211030233111717](cloudDisk/markdown/stm32笔记.assets/image-20211030233111717.png)\r\n**2） 重启生效：**\r\n  AT+RST\\r\\n\r\n  响应：OK\\r\\n\r\n一次重启后就不需要重启了（有的模块貌似不重启也行，这个大家就看着来吧)\r\n\r\n**3） 连接路由：**\r\n  AT+CWJAP=“ssid”,“password”\\r\\n\r\n  响应：OK\\r\\n(有的模块回的是CONNECT OK\\r\\n)\r\n稍等1-2秒中，会回一个GOT IP，看到这个就正式连上路由器了。\r\n\r\n**4） 查询设备IP（可选）：**\r\n  AT+CIFSR\\r\\n\r\n  响应：192.168.3.106\\r\\n\r\n\r\n**5） 连接到服务器：**\r\n  AT+CIPSTART=“TCP”,“192.168.2.178”,8888\\r\\n\r\n  响应：OK\\r\\n\r\n传入协议、服务器 IP、端口号，HTTP协议是TCP协议的封装，所以这里写TCP即可。\r\n\r\n**6）开启透传模式：**\r\n  AT+CIPMODE=1\\r\\n\r\n  响应：OK\\r\\n\r\n**7）通知模块开始数据传输：**\r\n  AT+CIPSEND\\r\\n\r\n  响应：\r\n这一步操作后，模块会回复一个“>”，代表接下来的所有串口数码均为数据，不解析成指令。\r\n\r\n**8） 发送数据：**\r\n  GET /Api/sensor_info_update?id=1&bty=30&temp=0698\\r\\n\\r\\n\r\n  响应：服务器返回的数据\r\n几点注意：\r\n1.这是用我搭的服务器测试，上面的http头少写了也并没有报任何错误，貌似也没什么影响，其它博主写的完整版举例为：\r\n\r\n```\r\nGET /api/dgnjd8954 HTTP/1.1\\r\\n\r\nContent-Type: application/json;charset=utf-8\\r\\n\r\nHost: www.liefyuan.top\\r\\n\r\nConnection: Keep Alive\\r\\n\\r\\n\r\n```\r\n\r\n2.尤其注意GET之后的空格，空格是有意义的\r\n3.注意结尾是两个\\r\\n!!!\r\n4.在这里就可以多次与服务器交互了，因为现在是透传模式。\r\n5.有趣的是这个TCP表现的真的很像HTTP，服务器关闭再开启，8266不用进行重连操作，直接在透传界面发数据就可以了。\r\n\r\n**9）退出透传：**\r\n\r\n  \\+\\+\\+\r\n  响应：无\r\n\r\n注意：这里没有\\r\\n了，就是发送+++就行了\r\n\r\n**10）还想再开始透传咋办：**\r\n  从步骤7执行.\r\n\r\nAT+CWJAP_DEF=\"PHICOMM\",\"qweqweqwe123\"\r\n\r\nAT+CWJAP_DEF=\"AVENGERS\",\"ASSEMBLE\"\r\n\r\n\r\nAT+CIPSTART=\"TCP\",\"192.168.1.100\",8500\r\n\r\nAT+CIPSTART=\"TCP\",\"192.168.248.86\",8500\r\n\r\n### 完整流程及演示效果\r\n\r\n记事本中：\r\n\r\n![image-20211030233321209](cloudDisk/markdown/stm32笔记.assets/image-20211030233321209.png)\r\n\r\n串口助手中：\r\n\r\n![image-20211030233333644](cloudDisk/markdown/stm32笔记.assets/image-20211030233333644.png)\r\n\r\n服务器后台：\r\n\r\n![image-20211030233348480](cloudDisk/markdown/stm32笔记.assets/image-20211030233348480.png)\r\n\r\n\r\n\r\n### 发送get请求\r\n\r\n#### 服务器端\r\n\r\n```java\r\n@WebServlet(\"/esp01sTest\")\r\npublic class TestEsp01sServlet extends HttpServlet {\r\n    @Override\r\n    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\r\n        System.out.println(\"hello world\");\r\n        resp.getWriter().write(\"111\");\r\n    }\r\n```\r\n\r\n```xml\r\n        <configuration>\r\n          <port>8500</port>\r\n          <path>/</path>\r\n        </configuration>\r\n```\r\n\r\n#### 串口助手\r\n\r\n```\r\nAT+CIPSTART=\"TCP\",\"192.168.248.86\",8500\r\n\r\nCONNECT\r\n\r\nOK\r\nAT+CIPMODE=1\r\n\r\n\r\nOK\r\nAT+CIPSEND\r\n\r\n\r\nOK\r\n\r\n>111\r\n```\r\n\r\n## 通过网页控制舵机转动\r\n\r\n* 登录到服务器管理界面 - 》发送get请求带参使舵机动作 -》服务器接收请求 -》服务器将当前状态存入数据库\r\n\r\n* stm32不断的通过串口和esp32-01s通讯向服务器发送get请求，此时服务器读取数据库，判断得到的数据响应\r\n  * 如果返回的值为false，不动作\r\n  * 如果为true，令舵机动作\r\n\r\n### 硬件设计\r\n\r\n\r\n\r\n### 软件设计\r\n\r\n#### 1、实现stm32与esp01串口通讯\r\n\r\n\r\n\r\n配置路由器\r\n\r\n![image-20211123213053968](cloudDisk/markdown/stm32笔记.assets/image-20211123213053968.png)\r\n\r\n\r\n\r\n1. 配置esp01s为客户端模式\r\n2. \r\n\r\n\r\n\r\n#### AT指令\r\n\r\n```\r\n\r\n```\r\n\r\n\r\n\r\n\r\n\r\n# 三十、RC522\r\n\r\n## 简介\r\n\r\n**一、** ***\\*主要指标\\****\r\n\r\nl 容量为8K位EEPROM\r\n\r\nl 分为16个扇区，每个扇区为4块，每块16个字节,以块为存取单位\r\n\r\nl 每个扇区有独立的一组密码及访问控制\r\n\r\nl 每张卡有唯一序列号，为32位\r\n\r\nl 具有防冲突机制，支持多卡操作\r\n\r\nl 无电源，自带天线，内含加密控制逻辑和通讯逻辑电路\r\n\r\nl 数据保存期为10年，可改写10万次，读无限次\r\n\r\nl 工作温度：-20℃~50℃(湿度为90%)\r\n\r\nl 工作频率：13.56MHZ\r\n\r\nl 通信速率：106 KBPS\r\n\r\nl 读写距离：10 cm以内（与读写器有关）\r\n\r\n**二、** ***\\*存储结构\\****\r\n\r\n1、 M1卡分为16个扇区，每个扇区由4块（块0、块1、块2、块3）组成，（我们也将16个扇区的64个块按绝对地址编号为0~63，存贮结构如下图所示：\r\n\r\n![image-20211027154245010](cloudDisk/markdown/stm32笔记.assets/image-20211027154245010.png)\r\n\r\n2、 第0扇区的块0（即绝对地址0块），它用于存放厂商代码，已经固化，不可更改。\r\n\r\n3、 每个扇区的块0、块1、块2为***\\*数据块\\****，可用于存贮数据。\r\n\r\n  ***\\*数据块\\****可作两种应用：\r\n\r\n★ 用作一般的数据保存，可以进行***\\*读\\****、***\\*写\\****操作。\r\n\r\n★ 用作数据值，可以进行***\\*初始化值、加值、减值、读值\\****操作。\r\n\r\n4、 每个扇区的块3为***\\*控制块\\****，包括了密码A、存取控制、密码B。具体结构如下：\r\n\r\n![image-20211027154546784](cloudDisk/markdown/stm32笔记.assets/image-20211027154546784.png)\r\n\r\n5、 每个扇区的密码和存取控制都是独立的，可以根据实际需要设定各自的密码及存取控制。存取控制为4个字节，共32位，扇区中的每个块（包括数据块和控制块）的存取条件是由密码和存取控制共同决定的，在***\\*存取控制\\****中每个块都有相应的***\\*三个控制位\\****,定义如下：\r\n\r\n![image-20211027154612999](cloudDisk/markdown/stm32笔记.assets/image-20211027154612999.png)\r\n\r\n三个控制位以正和反两种形式存在于存取控制字节中，决定了该块的访问权限（如  \r\n\r\n 进行减值操作必须验证KEY A，进行加值操作必须验证KEY B，等等）。三个控制\r\n\r\n 位在存取控制字节中的位置，以块0为例：\r\n\r\n \r\n\r\n  对块0的控制：\r\n\r\n![image-20211027154640056](cloudDisk/markdown/stm32笔记.assets/image-20211027154640056.png)\r\n\r\n6、***\\*数据块\\****（块0、块1、块2）的存取控制如下：\r\n\r\n![image-20211027154706721](cloudDisk/markdown/stm32笔记.assets/image-20211027154706721.png)\r\n\r\n 例如：当块0的存取控制位C10 C20 C30=1 0 0时，验证密码A或密码B正确后可读；\r\n\r\n​    验证密码B正确后可写；不能进行加值、减值操作。\r\n\r\n \r\n\r\n  7、***\\*控制块\\****块3的存取控制与***\\*数据块\\****（块0、1、2）不同，它的存取控制如下：\r\n\r\n![image-20211027154726783](cloudDisk/markdown/stm32笔记.assets/image-20211027154726783.png)\r\n\r\n例如：当块3的存取控制位C13 C23 C33=1 0 0时，表示：\r\n\r\n​      密码A：不可读，验证KEYA或KEYB正确后，可写（更改）。\r\n\r\n​     存取控制：验证KEYA或KEYB正确后，可读、可写。\r\n\r\n​      密码B：验证KEYA或KEYB正确后，可读、可写。\r\n\r\n**三、** ***\\*工作原理\\****\r\n\r\n卡片的电气部分只由一个天线和ASIC组成。\r\n\r\n天线：卡片的天线是只有几组绕线的线圈，很适于封装到IS0卡片中。\r\n\r\nASIC：卡片的ASIC由一个高速（106KB波特率）的RF接口，一个控制单元和一个\r\n\r\n   8K位EEPROM组成。\r\n\r\n工作原理：读写器向M1卡发一组固定频率的电磁波，卡片内有一个LC串联谐振电路，其频率与读写器发射的频率相同，在电磁波的激励下，LC谐振电路产生共振，从而使电容内有了电荷，在这个电容的另一端，接有一个单向导通的电子泵，将电容内的电荷送到另一个电容内储存，当所积累的电荷达到2V时，此电容可做为电源为其它电路提供工作电压，将卡内数据发射出去或接取读写器的数据。\r\n\r\n \r\n\r\n**四、** ***\\*M1射频卡与读写器的通讯\\****\r\n\r\n![image-20211027154828983](cloudDisk/markdown/stm32笔记.assets/image-20211027154828983.png)\r\n\r\n***\\*复位应答\\****（Answer to request）\r\n\r\nM1射频卡的通讯协议和通讯波特率是定义好的，当有卡片进入读写器的操作范围时，读写器以特定的协议与它通讯，从而确定该卡是否为M1射频卡，即验证卡片的卡型。\r\n\r\n \r\n\r\n***\\*防冲突机制\\**** (Anticollision Loop)\r\n\r\n当有多张卡进入读写器操作范围时，防冲突机制会从其中选择一张进行操作，未选中的则处于空闲模式等待下一次选卡，该过程会返回被选卡的序列号。\r\n\r\n \r\n\r\n***\\*选择卡片\\****(Select Tag)\r\n\r\n选择被选中的卡的序列号，并同时返回卡的容量代码。\r\n\r\n \r\n\r\n***\\*三次互相确认\\****(3 Pass Authentication)\r\n\r\n选定要处理的卡片之后，读写器就确定要访问的扇区号，并对该扇区密码进行密码校验，在三次相互认证之后就可以通过加密流进行通讯。（在选择另一扇区时，则必须进行另一扇区密码校验。）\r\n\r\n \r\n\r\n***\\*对数据块的操作\\**** \r\n\r\n***\\*读\\**** (Read)：读一个块；\r\n\r\n***\\*写\\**** ***\\*(\\****Write）：写一个块；\r\n\r\n***\\*加\\****（Increment）：对数值块进行加值；\r\n\r\n***\\*减\\****（Decrement）：对数值块进行减值；\r\n\r\n***\\*存储\\****（Restore）：将块中的内容存到数据寄存器中；\r\n\r\n***\\*传输\\****（Transfer）：将数据寄存器中的内容写入块中；\r\n\r\n***\\*中止\\****（Halt）：将卡置于暂停工作状态；\r\n\r\n## 模块使用手册\r\n\r\n第一步：将 RFID 模块与 MSP430F149 最小系统板采用杜邦线连接；  \r\n\r\n![image-20211027155512229](cloudDisk/markdown/stm32笔记.assets/image-20211027155512229.png)\r\n\r\n第二步： 程序通过 BSL 下载到 MSP430F149 中；\r\n第三步： 将串口线 USB-RS232 连接计算机与开发板；\r\n第四步：打开串口调试手（正确设置波特率以及串口号）；\r\n第五步：按 MSP430F149 最小系统板上的复位键，则串口调试手出现\r\n如下画面  \r\n\r\n![image-20211027155535261](cloudDisk/markdown/stm32笔记.assets/image-20211027155535261.png)\r\n\r\n第六步：在串口发送区，输入 A 点击发送，为自动寻卡模式；若输入\r\nF 点击发送则为单次寻卡模式；\r\n第七步：将卡片放到读卡模块上，则可以看到读出卡的 ID 号。  \r\n\r\n![image-20211027155554838](cloudDisk/markdown/stm32笔记.assets/image-20211027155554838.png)\r\n\r\n地址字节\r\n\r\n![image-20211021175525084](cloudDisk/markdown/stm32笔记.assets/image-20211021175525084.png)\r\n\r\n\r\n\r\n## RC522命令集\r\n\r\n![image-20211021175146340](cloudDisk/markdown/stm32笔记.assets/image-20211021175146340.png)\r\n\r\n黑字命令是来对RC522本身进行操作的\r\n\r\n红字命令是以RC522为媒介，对卡片进行操作\r\n\r\n## 基于14443-A命令集\r\n\r\n![image-20211021175408715](cloudDisk/markdown/stm32笔记.assets/image-20211021175408715.png)\r\n\r\n## 核心代码\r\n\r\n### 1、基本函数\r\n\r\n读写寄存器、复位、开关天线、挂机、空闲\r\n\r\n```c\r\n/////////////////////////////////////////////////////////////////////\r\n//功    能：读RC632寄存器\r\n//参数说明：Address[IN]:寄存器地址\r\n//返    回：读出的值\r\n/////////////////////////////////////////////////////////////////////\r\nunsigned char ReadRawRC(unsigned char Address)\r\n```\r\n\r\n```c\r\n/////////////////////////////////////////////////////////////////////\r\n//功    能：写RC632寄存器\r\n//参数说明：Address[IN]:寄存器地址\r\n//          value[IN]:写入的值\r\n/////////////////////////////////////////////////////////////////////\r\nvoid WriteRawRC(unsigned char Address, unsigned char value)\r\n```\r\n\r\n```c\r\n/////////////////////////////////////////////////////////////////////\r\n//功    能：复位RC522\r\n//返    回: 成功返回MI_OK\r\n/////////////////////////////////////////////////////////////////////\r\nchar PcdReset(void){...}\r\n```\r\n\r\n```c\r\n/////////////////////////////////////////////////////////////////////\r\n//开启天线  \r\n//每次启动或关闭天险发射之间应至少有1ms的间隔\r\n/////////////////////////////////////////////////////////////////////\r\nvoid PcdAntennaOn()\r\n\r\n```\r\n\r\n```c\r\n/////////////////////////////////////////////////////////////////////\r\n//关闭天线\r\n/////////////////////////////////////////////////////////////////////\r\nvoid PcdAntennaOff()\r\n\r\n```\r\n\r\n```c\r\n////////////////////////////////////////////////////////////////////\r\n//功    能：命令卡片进入休眠状态\r\n//返    回: 成功返回MI_OK\r\n/////////////////////////////////////////////////////////////////////\r\nchar PcdHalt(void)\r\n```\r\n\r\n\r\n\r\n### 2、传输数据\r\n\r\n```c\r\n//功    能：通过RC522和ISO14443卡通讯\r\n//参数说明：Command[IN]:RC522命令字\r\n//          pInData[IN]:通过RC522发送到卡片的数据\r\n//          InLenByte[IN]:发送数据的字节长度\r\n//          pOutData[OUT]:接收到的卡片返回数据\r\n//          *pOutLenBit[OUT]:返回数据的位长度\r\nchar PcdComMF522(unsigned char Command, \r\n                 unsigned char *pInData, \r\n                 unsigned char InLenByte,\r\n                 unsigned char *pOutData, \r\n                 unsigned int  *pOutLenBit){ ... }\r\n```\r\n\r\nFIFO函数，将数据传给RC522，让自身完成某种操作\r\n\r\n将数据传给RC522，命令522将数据再传递给卡片\r\n\r\n```c\r\n/////////////////////////////////////////////////////////////////////\r\n//MF522命令字\r\n/////////////////////////////////////////////////////////////////////\r\n#define PCD_IDLE              0x00               //取消当前命令\r\n#define PCD_AUTHENT           0x0E               //验证密钥\r\n#define PCD_RECEIVE           0x08               //接收数据\r\n#define PCD_TRANSMIT          0x04               //发送数据\r\n#define PCD_TRANSCEIVE        0x0C               //发送并接收数据\r\n#define PCD_RESETPHASE        0x0F               //复位\r\n#define PCD_CALCCRC           0x03               //CRC计算\r\n```\r\n\r\n\r\n\r\n```c\r\n//功    能：寻卡\r\n//参数说明: req_code[IN]:寻卡方式\r\n//                0x52 = 寻感应区内所有符合14443A标准的卡\r\n//                0x26 = 寻未进入休眠状态的卡\r\n//          	  pTagType[OUT]：卡片类型代码\r\n//                0x4400 = Mifare_UltraLight\r\n//                0x0400 = Mifare_One(S50)\r\n//                0x0200 = Mifare_One(S70)\r\n//                0x0800 = Mifare_Pro(X)\r\n//                0x4403 = Mifare_DESFire\r\n//返    回: 成功返回MI_OK\r\n/////////////////////////////////////////////////////////////////////\r\nchar PcdRequest(unsigned char req_code,unsigned char *pTagType)\r\n{\r\n   char status;  \r\n   unsigned int  unLen;\r\n   unsigned char ucComMF522Buf[MAXRLEN]; \r\n   ClearBitMask(Status2Reg,0x08);\r\n   WriteRawRC(BitFramingReg,0x07);\r\n\r\n   SetBitMask(TxControlReg,0x03);\r\n \r\n   ucComMF522Buf[0] = req_code;\r\n\r\n   status = PcdComMF522(PCD_TRANSCEIVE,ucComMF522Buf,1,ucComMF522Buf,&unLen);\r\n\r\n   if ((status == MI_OK) && (unLen == 0x10))\r\n   {    \r\n       *pTagType     = ucComMF522Buf[0];\r\n       *(pTagType+1) = ucComMF522Buf[1];\r\n   }\r\n   else\r\n   {   status = MI_ERR;   }\r\n   \r\n   return status;\r\n}\r\n```\r\n\r\n```c\r\n/////////////////////////////////////////////////////////////////////\r\n//功    能：防冲撞\r\n//参数说明: pSnr[OUT]:卡片序列号，4字节\r\n//返    回: 成功返回MI_OK\r\n/////////////////////////////////////////////////////////////////////  \r\nchar PcdAnticoll(unsigned char *pSnr)\r\n{\r\n    char status;\r\n    unsigned char i,snr_check=0;\r\n    unsigned int  unLen;\r\n    unsigned char ucComMF522Buf[MAXRLEN]; \r\n    \r\n\r\n    ClearBitMask(Status2Reg,0x08);\r\n    WriteRawRC(BitFramingReg,0x00);\r\n    ClearBitMask(CollReg,0x80);\r\n \r\n    ucComMF522Buf[0] = PICC_ANTICOLL1;\r\n    ucComMF522Buf[1] = 0x20;\r\n\r\n    status = PcdComMF522(PCD_TRANSCEIVE,ucComMF522Buf,2,ucComMF522Buf,&unLen);\r\n\r\n    if (status == MI_OK)\r\n    {\r\n    	 for (i=0; i<4; i++)\r\n         {   \r\n             *(pSnr+i)  = ucComMF522Buf[i];\r\n             snr_check ^= ucComMF522Buf[i];\r\n         }\r\n         if (snr_check != ucComMF522Buf[i])\r\n         {   status = MI_ERR;    }\r\n    }\r\n    \r\n    SetBitMask(CollReg,0x80);\r\n    return status;\r\n}\r\n\r\n```\r\n\r\n```c\r\n/////////////////////////////////////////////////////////////////////\r\n//功    能：选定卡片\r\n//参数说明: pSnr[IN]:卡片序列号，4字节\r\n//返    回: 成功返回MI_OK\r\n/////////////////////////////////////////////////////////////////////\r\nchar PcdSelect(unsigned char *pSnr)\r\n{\r\n    char status;\r\n    unsigned char i;\r\n    unsigned int  unLen;\r\n    unsigned char ucComMF522Buf[MAXRLEN]; \r\n    \r\n    ucComMF522Buf[0] = PICC_ANTICOLL1;\r\n    ucComMF522Buf[1] = 0x70;\r\n    ucComMF522Buf[6] = 0;\r\n    for (i=0; i<4; i++)\r\n    {\r\n    	ucComMF522Buf[i+2] = *(pSnr+i);\r\n    	ucComMF522Buf[6]  ^= *(pSnr+i);\r\n    }\r\n    CalulateCRC(ucComMF522Buf,7,&ucComMF522Buf[7]);\r\n  \r\n    ClearBitMask(Status2Reg,0x08);\r\n\r\n    status = PcdComMF522(PCD_TRANSCEIVE,ucComMF522Buf,9,ucComMF522Buf,&unLen);\r\n    \r\n    if ((status == MI_OK) && (unLen == 0x18))\r\n    {   status = MI_OK;  }\r\n    else\r\n    {   status = MI_ERR;    }\r\n\r\n    return status;\r\n}\r\n\r\n```\r\n\r\n### 认证\r\n\r\n![image-20211021190842300](cloudDisk/markdown/stm32笔记.assets/image-20211021190842300.png)\r\n\r\n## 存储就结构\r\n\r\n![image-20211021191630324](cloudDisk/markdown/stm32笔记.assets/image-20211021191630324.png)\r\n\r\n### 控制字节 block3\r\n\r\n来控制block0-2的读写\r\n\r\n![image-20211021191904231](cloudDisk/markdown/stm32笔记.assets/image-20211021191904231.png)\r\n\r\n\r\n\r\n### 控制方式\r\n\r\n\r\n\r\n![image-20211021192157072](cloudDisk/markdown/stm32笔记.assets/image-20211021192157072.png)\r\n\r\n### 普通区控制\r\n\r\nx = bit\r\n\r\ny = block\r\n\r\n![image-20211021192630110](cloudDisk/markdown/stm32笔记.assets/image-20211021192630110.png)\r\n\r\n\r\n\r\n## 读写流程\r\n\r\n![image-20211021192900340](cloudDisk/markdown/stm32笔记.assets/image-20211021192900340.png)\r\n\r\n\r\n\r\n## 附录\r\n\r\n### rc522.h\r\n\r\n```h\r\n#ifndef __RC522_H\r\n#define __RC522_H	\r\n#include \"sys.h\" \r\n#include \"stm32f10x.h\"\r\n\r\n\r\n//MF522命令字\r\n\r\n#define PCD_IDLE              0x00               //取消当前命令\r\n#define PCD_AUTHENT           0x0E               //验证密钥\r\n#define PCD_RECEIVE           0x08               //接收数据\r\n#define PCD_TRANSMIT          0x04               //发送数据\r\n#define PCD_TRANSCEIVE        0x0C               //发送并接收数据\r\n#define PCD_RESETPHASE        0x0F               //复位\r\n#define PCD_CALCCRC           0x03               //CRC计算\r\n\r\n\r\n//Mifare_One卡片命令字\r\n\r\n#define PICC_REQIDL           0x26               //寻天线区内未进入休眠状态\r\n#define PICC_REQALL           0x52               //寻天线区内全部卡\r\n#define PICC_ANTICOLL1        0x93               //防冲撞\r\n#define PICC_ANTICOLL2        0x95               //防冲撞\r\n#define PICC_AUTHENT1A        0x60               //验证A密钥\r\n#define PICC_AUTHENT1B        0x61               //验证B密钥\r\n#define PICC_READ             0x30               //读块\r\n#define PICC_WRITE            0xA0               //写块\r\n#define PICC_DECREMENT        0xC0               //扣款\r\n#define PICC_INCREMENT        0xC1               //充值\r\n#define PICC_RESTORE          0xC2               //调块数据到缓冲区\r\n#define PICC_TRANSFER         0xB0               //保存缓冲区中数据\r\n#define PICC_HALT             0x50               //休眠\r\n\r\n\r\n//MF522 FIFO长度定义\r\n\r\n#define DEF_FIFO_LENGTH       64                 //FIFO size=64byte\r\n#define MAXRLEN  18\r\n\r\n\r\n//MF522寄存器定义\r\n\r\n// PAGE 0\r\n#define     RFU00                 0x00    \r\n#define     CommandReg            0x01    \r\n#define     ComIEnReg             0x02    \r\n#define     DivlEnReg             0x03    \r\n#define     ComIrqReg             0x04    \r\n#define     DivIrqReg             0x05\r\n#define     ErrorReg              0x06    \r\n#define     Status1Reg            0x07    \r\n#define     Status2Reg            0x08    \r\n#define     FIFODataReg           0x09\r\n#define     FIFOLevelReg          0x0A\r\n#define     WaterLevelReg         0x0B\r\n#define     ControlReg            0x0C\r\n#define     BitFramingReg         0x0D\r\n#define     CollReg               0x0E\r\n#define     RFU0F                 0x0F\r\n// PAGE 1     \r\n#define     RFU10                 0x10\r\n#define     ModeReg               0x11\r\n#define     TxModeReg             0x12\r\n#define     RxModeReg             0x13\r\n#define     TxControlReg          0x14\r\n#define     TxAutoReg             0x15\r\n#define     TxSelReg              0x16\r\n#define     RxSelReg              0x17\r\n#define     RxThresholdReg        0x18\r\n#define     DemodReg              0x19\r\n#define     RFU1A                 0x1A\r\n#define     RFU1B                 0x1B\r\n#define     MifareReg             0x1C\r\n#define     RFU1D                 0x1D\r\n#define     RFU1E                 0x1E\r\n#define     SerialSpeedReg        0x1F\r\n// PAGE 2    \r\n#define     RFU20                 0x20  \r\n#define     CRCResultRegM         0x21\r\n#define     CRCResultRegL         0x22\r\n#define     RFU23                 0x23\r\n#define     ModWidthReg           0x24\r\n#define     RFU25                 0x25\r\n#define     RFCfgReg              0x26\r\n#define     GsNReg                0x27\r\n#define     CWGsCfgReg            0x28\r\n#define     ModGsCfgReg           0x29\r\n#define     TModeReg              0x2A\r\n#define     TPrescalerReg         0x2B\r\n#define     TReloadRegH           0x2C\r\n#define     TReloadRegL           0x2D\r\n#define     TCounterValueRegH     0x2E\r\n#define     TCounterValueRegL     0x2F\r\n// PAGE 3      \r\n#define     RFU30                 0x30\r\n#define     TestSel1Reg           0x31\r\n#define     TestSel2Reg           0x32\r\n#define     TestPinEnReg          0x33\r\n#define     TestPinValueReg       0x34\r\n#define     TestBusReg            0x35\r\n#define     AutoTestReg           0x36\r\n#define     VersionReg            0x37\r\n#define     AnalogTestReg         0x38\r\n#define     TestDAC1Reg           0x39  \r\n#define     TestDAC2Reg           0x3A   \r\n#define     TestADCReg            0x3B   \r\n#define     RFU3C                 0x3C   \r\n#define     RFU3D                 0x3D   \r\n#define     RFU3E                 0x3E   \r\n#define     RFU3F		  		        0x3F\r\n\r\n\r\n//和MF522通讯时返回的错误代码\r\n\r\n#define 	MI_OK                 0\r\n#define 	MI_NOTAGERR           (1)\r\n#define 	MI_ERR                (2)\r\n\r\n#define	SHAQU1	0X01\r\n#define	KUAI4	0X04\r\n#define	KUAI7	0X07\r\n#define	REGCARD	0xa1\r\n#define	CONSUME	0xa2\r\n#define READCARD	0xa3\r\n#define ADDMONEY	0xa4\r\n\r\n//\r\n//#define  spi_cs 1;\r\n//sbit  spi_ck=P0^6;\r\n//sbit  spi_mosi=P0^7;\r\n//sbit  spi_miso=P4^1;\r\n//sbit  spi_rst=P2^7;\r\n#define SPIReadByte()	SPIWriteByte(0)\r\nu8 SPIWriteByte(u8 byte);\r\nvoid SPI1_Init(void);\r\n\r\n#define SET_SPI_CS  (GPIOF->BSRR=0X01)\r\n#define CLR_SPI_CS  (GPIOF->BRR=0X01)\r\n\r\n\r\n\r\n#define SET_RC522RST  GPIOF->BSRR=0X02\r\n#define CLR_RC522RST  GPIOF->BRR=0X02\r\n\r\n\r\n/***********************RC522 函数宏定义**********************/\r\n#define          RC522_CS_Enable()         GPIO_ResetBits ( GPIOA, GPIO_Pin_4 )\r\n#define          RC522_CS_Disable()        GPIO_SetBits ( GPIOA, GPIO_Pin_4 )\r\n\r\n#define          RC522_Reset_Enable()      GPIO_ResetBits( GPIOB, GPIO_Pin_0 )\r\n#define          RC522_Reset_Disable()     GPIO_SetBits ( GPIOB, GPIO_Pin_0 )\r\n\r\n#define          RC522_SCK_0()             GPIO_ResetBits( GPIOA, GPIO_Pin_5 )\r\n#define          RC522_SCK_1()             GPIO_SetBits ( GPIOA, GPIO_Pin_5 )\r\n\r\n#define          RC522_MOSI_0()            GPIO_ResetBits( GPIOA, GPIO_Pin_7 )\r\n#define          RC522_MOSI_1()            GPIO_SetBits ( GPIOA, GPIO_Pin_7 )\r\n\r\n#define          RC522_MISO_GET()          GPIO_ReadInputDataBit ( GPIOA, GPIO_Pin_6 )\r\n\r\nvoid             RC522_Handel               (void);\r\nvoid             RC522_Init                 ( void );                       //初始化\r\nvoid             PcdReset                   ( void );                       //复位\r\nvoid             M500PcdConfigISOType       ( u8 type );                    //工作方式\r\nchar             PcdRequest                 ( u8 req_code, u8 * pTagType ); //寻卡\r\nchar             PcdAnticoll                ( u8 * pSnr);                   //读卡号\r\n\r\nchar             PcdSelect                  ( u8 * pSnr );\r\nchar             PcdAuthState               ( u8 ucAuth_mode, u8 ucAddr, u8 * pKey, u8 * pSnr );\r\nchar             PcdWrite                   ( u8 ucAddr, u8 * pData );\r\nchar             PcdRead                    ( u8 ucAddr, u8 * pData );\r\nvoid ShowID(u16 x,u16 y, u8 *p, u16 charColor, u16 bkColor);	 //显示卡的卡号，以十六进制显示\r\nvoid PcdAntennaOff(void);\r\nvoid PcdAntennaOn(void);\r\n\r\n#endif\r\n\r\n\r\n```\r\n\r\n\r\n\r\n### rc522.c\r\n\r\n```c\r\n#include \"sys.h\"\r\n#include \"rc522.h\"\r\n#include \"delay.h\"\r\n#include \"usart.h\"\r\n#include \"lcd.h\"\r\n//\r\n// M1卡分为16个扇区，每个扇区由四个块（块0、块1、块2、块3）组成\r\n// 将16个扇区的64个块按绝对地址编号为：0~63\r\n// 第0个扇区的块0（即绝对地址0块），用于存放厂商代码，已经固化不可更改 \r\n// 每个扇区的块0、块1、块2为数据块，可用于存放数据\r\n// 每个扇区的块3为控制块（绝对地址为:块3、块7、块11.....）包括密码A，存取控制、密码B等\r\n\r\n/*******************************\r\n*连线说明：\r\n*1--SDA  <----->PA4\r\n*2--SCK  <----->PA5\r\n*3--MOSI <----->PA7\r\n*4--MISO <----->PA6\r\n*5--悬空\r\n*6--GND <----->GND\r\n*7--RST <----->PB0\r\n*8--VCC <----->VCC\r\n************************************/\r\n\r\n/*全局变量*/\r\nunsigned char CT[2];//卡类型\r\nunsigned char SN[4]; //卡号\r\nunsigned char RFID[16];			//存放RFID \r\nunsigned char lxl_bit=0;\r\nunsigned char card1_bit=0;\r\nunsigned char card2_bit=0;\r\nunsigned char card3_bit=0;\r\nunsigned char card4_bit=0;\r\nunsigned char total=0;\r\nunsigned char lxl[4]={196,58,104,217};\r\nunsigned char card_1[4]={83,106,11,1};\r\nunsigned char card_2[4]={208,121,31,57};\r\nunsigned char card_3[4]={176,177,143,165};\r\nunsigned char card_4[4]={5,158,10,136};\r\nu8 KEY[6]={0xff,0xff,0xff,0xff,0xff,0xff};\r\nu8 AUDIO_OPEN[6] = {0xAA, 0x07, 0x02, 0x00, 0x09, 0xBC};\r\nunsigned char RFID1[16]={0x00,0x00,0x00,0x00,0x00,0x00,0xff,0x07,0x80,0x29,0xff,0xff,0xff,0xff,0xff,0xff};\r\n/*函数声明*/\r\nunsigned char status;\r\nunsigned char s=0x08;\r\n\r\n#define   RC522_DELAY()  delay_us( 20 )\r\n\r\nvoid RC522_Handel(void)\r\n{\r\n    u8 i;\r\n    status = PcdRequest(PICC_REQALL,CT);//寻卡\r\n    //printf(\"\\r\\nstatus>>>>>>%d\\r\\n\", status);\r\n    if(status==MI_OK)//寻卡成功\r\n    {\r\n         status=MI_ERR;\r\n         status = PcdAnticoll(SN);//防冲撞\r\n         printf(\"(id: %x %x %x %x)\",SN[0],SN[1],SN[2],SN[3]); // 卡号    \r\n    }\r\n    if (status==MI_OK)//防衝撞成功\r\n    {\r\n        status=MI_ERR;		\r\n        ShowID(0,200,SN,BLUE,WHITE); //在液晶屏上显示卡的ID号\r\n        \r\n        if((SN[0]==lxl[0])\r\n	        &&(SN[1]==lxl[1])\r\n	        &&(SN[2]==lxl[2])\r\n	        &&(SN[3]==lxl[3]))\r\n        {\r\n            lxl_bit=1;\r\n            printf(\"\\r\\nThe User is:card_0\\r\\n\");\r\n        }\r\n        if((SN[0]==card_1[0])\r\n	        &&(SN[1]==card_1[1])\r\n	        &&(SN[2]==card_1[2])\r\n	        &&(SN[3]==card_1[3]))\r\n        {\r\n            card1_bit=1;\r\n            printf(\"\\r\\nThe User is:card_1\\r\\n\");\r\n            \r\n        }\r\n        if((SN[0]==card_2[0])\r\n	        &&(SN[1]==card_2[1])\r\n	        &&(SN[2]==card_2[2])\r\n	        &&(SN[3]==card_2[3]))\r\n        {\r\n            card2_bit=1;\r\n            printf(\"\\r\\nThe User is:card_2\\r\\n\");\r\n        }\r\n        \r\n        if((SN[0]==card_3[0])\r\n	        &&(SN[1]==card_3[1])\r\n	        &&(SN[2]==card_3[2])\r\n	        &&(SN[3]==card_3[3]))\r\n        {\r\n            card3_bit=1;\r\n            printf(\"\\r\\nThe User is:card_3\\r\\n\");\r\n        }\r\n        if((SN[0]==card_4[0])\r\n	        &&(SN[1]==card_4[1])\r\n	        &&(SN[2]==card_4[2])\r\n	        &&(SN[3]==card_4[3]))\r\n        {\r\n            card4_bit=1;\r\n            printf(\"\\r\\nThe User is:card_4\\r\\n\");\r\n        }\r\n        //total=card1_bit+card2_bit+card3_bit+card4_bit+lxl_bit;\r\n        status =PcdSelect(SN);\r\n    }\r\n    else\r\n    {\r\n       // TODO \r\n    }\r\n	if(status==MI_OK)//選卡成功\r\n	{\r\n		status=MI_ERR;\r\n		status =PcdAuthState(0x60,0x00,KEY,SN);\r\n	}\r\n    if(status==MI_OK)//驗證成功\r\n    {\r\n        printf(\"successAuth!\");\r\n        status=MI_ERR;\r\n        status=PcdRead(0x00,RFID);\r\n        printf(\"the data is: \");\r\n        for (i = 0; i < 16; i++)\r\n        {\r\n            printf(\" %x \",RFID[i]);\r\n        }\r\n        \r\n    }\r\n    if(status==MI_OK)//讀卡成功\r\n    {\r\n        status=MI_ERR;\r\n        delay_ms(100);\r\n    }	\r\n}\r\n\r\nvoid RC522_Init ( void )\r\n{\r\n	SPI1_Init();\r\n	\r\n	RC522_Reset_Disable();\r\n	\r\n	RC522_CS_Disable();\r\n    \r\n    PcdReset ();\r\n    \r\n	M500PcdConfigISOType ( \'A\' );//设置工作方式\r\n}\r\n\r\nvoid SPI1_Init(void)	\r\n{\r\n	GPIO_InitTypeDef GPIO_InitStructure;\r\n 	RCC_APB2PeriphClockCmd(	RCC_APB2Periph_GPIOA | RCC_APB2Periph_GPIOB, ENABLE );//PORTB时钟使能 \r\n	\r\n	// CS\r\n    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_4;	 \r\n    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP; 		 //推挽输出\r\n    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;		 //IO口速度为50MHz\r\n    GPIO_Init(GPIOA, &GPIO_InitStructure);					 //根据设定参数初始化PF0、PF1\r\n    \r\n    // SCK\r\n    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_5;	 \r\n    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP; 		 //推挽输出\r\n    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;		 //IO口速度为50MHz\r\n    GPIO_Init(GPIOA, &GPIO_InitStructure);\r\n    \r\n    // MISO\r\n    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_6;	 \r\n    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING; 		 //推挽输出\r\n    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;		 //IO口速度为50MHz\r\n    GPIO_Init(GPIOA, &GPIO_InitStructure);\r\n    \r\n    // MOSI\r\n    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_7;	 \r\n    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP; 		 //推挽输出\r\n    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;		 //IO口速度为50MHz\r\n    GPIO_Init(GPIOA, &GPIO_InitStructure);\r\n    \r\n    // RST\r\n    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0;	 \r\n    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP; 		 //推挽输出\r\n    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;		 //IO口速度为50MHz\r\n    GPIO_Init(GPIOB, &GPIO_InitStructure);\r\n}\r\n\r\n\r\n/*\r\n * 函数名：SPI_RC522_SendByte\r\n * 描述  ：向RC522发送1 Byte 数据\r\n * 输入  ：byte，要发送的数据\r\n * 返回  : RC522返回的数据\r\n * 调用  ：内部调用\r\n */\r\nvoid SPI_RC522_SendByte ( u8 byte )\r\n{\r\n	u8 counter;\r\n	for(counter = 0; counter < 8; counter++)\r\n	{     \r\n		if ( byte & 0x80 )\r\n			RC522_MOSI_1 ();\r\n		else \r\n			RC522_MOSI_0 ();\r\n		\r\n		RC522_DELAY();\r\n\r\n		RC522_SCK_0 ();\r\n		\r\n		RC522_DELAY();\r\n		\r\n		RC522_SCK_1();\r\n		\r\n		RC522_DELAY();\r\n		\r\n		byte <<= 1; \r\n	} \r\n}\r\n\r\n\r\n/*\r\n * 函数名：SPI_RC522_ReadByte\r\n * 描述  ：从RC522发送1 Byte 数据\r\n * 输入  ：无\r\n * 返回  : RC522返回的数据\r\n * 调用  ：内部调用\r\n */\r\nu8 SPI_RC522_ReadByte ( void )\r\n{\r\n	u8 counter;\r\n	u8 SPI_Data;\r\n	for(counter=0;counter<8;counter++)\r\n	{\r\n		SPI_Data <<= 1;\r\n		\r\n		RC522_SCK_0 ();\r\n		\r\n		RC522_DELAY();\r\n		\r\n		if ( RC522_MISO_GET() == 1)\r\n			SPI_Data |= 0x01;\r\n			\r\n		RC522_DELAY();\r\n		\r\n		RC522_SCK_1 ();\r\n		\r\n		RC522_DELAY();\r\n	}\r\n	return SPI_Data;\r\n}\r\n\r\n\r\n/*\r\n * 函数名：ReadRawRC\r\n * 描述  ：读RC522寄存器\r\n * 输入  ：ucAddress，寄存器地址\r\n * 返回  : 寄存器的当前值\r\n * 调用  ：内部调用\r\n */\r\nu8 ReadRawRC ( u8 ucAddress )\r\n{\r\n	u8 ucAddr, ucReturn;\r\n	\r\n	ucAddr = ( ( ucAddress << 1 ) & 0x7E ) | 0x80;\r\n	\r\n	RC522_CS_Enable();\r\n	\r\n	SPI_RC522_SendByte ( ucAddr );\r\n	\r\n	ucReturn = SPI_RC522_ReadByte ();\r\n	\r\n	RC522_CS_Disable();\r\n\r\n	return ucReturn;\r\n}\r\n\r\n\r\n/*\r\n * 函数名：WriteRawRC\r\n * 描述  ：写RC522寄存器\r\n * 输入  ：ucAddress，寄存器地址\r\n *         ucValue，写入寄存器的值\r\n * 返回  : 无\r\n * 调用  ：内部调用\r\n */\r\nvoid WriteRawRC ( u8 ucAddress, u8 ucValue )\r\n{  \r\n	u8 ucAddr;\r\n\r\n	ucAddr = ( ucAddress << 1 ) & 0x7E;\r\n	\r\n	RC522_CS_Enable();\r\n	\r\n	SPI_RC522_SendByte ( ucAddr );\r\n	\r\n	SPI_RC522_SendByte ( ucValue );\r\n	\r\n	RC522_CS_Disable();	\r\n}\r\n\r\n\r\n/*\r\n * 函数名：SetBitMask\r\n * 描述  ：对RC522寄存器置位\r\n * 输入  ：ucReg，寄存器地址\r\n *         ucMask，置位值\r\n * 返回  : 无\r\n * 调用  ：内部调用\r\n */\r\nvoid SetBitMask ( u8 ucReg, u8 ucMask )  \r\n{\r\n    u8 ucTemp;\r\n\r\n    ucTemp = ReadRawRC ( ucReg );\r\n	\r\n    WriteRawRC ( ucReg, ucTemp | ucMask );         // set bit mask\r\n}\r\n\r\n\r\n/*\r\n * 函数名：ClearBitMask\r\n * 描述  ：对RC522寄存器清位\r\n * 输入  ：ucReg，寄存器地址\r\n *         ucMask，清位值\r\n * 返回  : 无\r\n * 调用  ：内部调用\r\n */\r\nvoid ClearBitMask ( u8 ucReg, u8 ucMask )  \r\n{\r\n    u8 ucTemp;\r\n\r\n    ucTemp = ReadRawRC ( ucReg );\r\n	\r\n    WriteRawRC ( ucReg, ucTemp & ( ~ ucMask) );  // clear bit mask\r\n}\r\n\r\n\r\n/*\r\n * 函数名：PcdAntennaOn\r\n * 描述  ：开启天线 \r\n * 输入  ：无\r\n * 返回  : 无\r\n * 调用  ：内部调用\r\n */\r\nvoid PcdAntennaOn ( void )\r\n{\r\n    u8 uc;\r\n\r\n    uc = ReadRawRC ( TxControlReg );\r\n	\r\n    if ( ! ( uc & 0x03 ) )\r\n			SetBitMask(TxControlReg, 0x03);\r\n}\r\n\r\n\r\n/*\r\n * 函数名：PcdAntennaOff\r\n * 描述  ：开启天线 \r\n * 输入  ：无\r\n * 返回  : 无\r\n * 调用  ：内部调用\r\n */\r\nvoid PcdAntennaOff ( void )\r\n{\r\n    ClearBitMask ( TxControlReg, 0x03 );\r\n}\r\n\r\n\r\n/*\r\n * 函数名：PcdRese\r\n * 描述  ：复位RC522 \r\n * 输入  ：无\r\n * 返回  : 无\r\n * 调用  ：外部调用\r\n */\r\nvoid PcdReset ( void )\r\n{\r\n    RC522_Reset_Disable();\r\n\r\n    delay_us ( 1 );\r\n\r\n    RC522_Reset_Enable();\r\n\r\n    delay_us ( 1 );\r\n\r\n    RC522_Reset_Disable();\r\n\r\n    delay_us ( 1 );\r\n\r\n    WriteRawRC ( CommandReg, 0x0f );\r\n\r\n    while ( ReadRawRC ( CommandReg ) & 0x10 );\r\n\r\n    delay_us ( 1 );\r\n\r\n    WriteRawRC ( ModeReg, 0x3D );            //定义发送和接收常用模式 和Mifare卡通讯，CRC初始值0x6363\r\n\r\n    WriteRawRC ( TReloadRegL, 30 );          //16位定时器低位    \r\n    WriteRawRC ( TReloadRegH, 0 );			     //16位定时器高位\r\n\r\n    WriteRawRC ( TModeReg, 0x8D );				   //定义内部定时器的设置\r\n\r\n    WriteRawRC ( TPrescalerReg, 0x3E );			 //设置定时器分频系数\r\n\r\n    WriteRawRC ( TxAutoReg, 0x40 );				   //调制发送信号为100%ASK	\r\n}\r\n\r\n\r\n/*\r\n * 函数名：M500PcdConfigISOType\r\n * 描述  ：设置RC522的工作方式\r\n * 输入  ：ucType，工作方式\r\n * 返回  : 无\r\n * 调用  ：外部调用\r\n */\r\nvoid M500PcdConfigISOType ( u8 ucType )\r\n{\r\n	if ( ucType == \'A\')                     //ISO14443_A\r\n	{\r\n		ClearBitMask ( Status2Reg, 0x08 );\r\n		\r\n		WriteRawRC ( ModeReg, 0x3D );//3F\r\n		\r\n		WriteRawRC ( RxSelReg, 0x86 );//84\r\n		\r\n		WriteRawRC( RFCfgReg, 0x7F );   //4F\r\n		\r\n		WriteRawRC( TReloadRegL, 30 );//tmoLength);// TReloadVal = \'h6a =tmoLength(dec) \r\n		\r\n		WriteRawRC ( TReloadRegH, 0 );\r\n		\r\n		WriteRawRC ( TModeReg, 0x8D );\r\n		\r\n		WriteRawRC ( TPrescalerReg, 0x3E );\r\n		\r\n		delay_us ( 2 );\r\n		\r\n		PcdAntennaOn ();//开天线\r\n	}\r\n}\r\n\r\n\r\n/*\r\n * 函数名：PcdComMF522\r\n * 描述  ：通过RC522和ISO14443卡通讯\r\n * 输入  ：ucCommand，RC522命令字\r\n *         pInData，通过RC522发送到卡片的数据\r\n *         ucInLenByte，发送数据的字节长度\r\n *         pOutData，接收到的卡片返回数据\r\n *         pOutLenBit，返回数据的位长度\r\n * 返回  : 状态值\r\n *         = MI_OK，成功\r\n * 调用  ：内部调用\r\n */\r\nchar PcdComMF522 ( u8 ucCommand, u8 * pInData, u8 ucInLenByte, u8 * pOutData, u32 * pOutLenBit )		\r\n{\r\n    char cStatus = MI_ERR;\r\n    u8 ucIrqEn   = 0x00;\r\n    u8 ucWaitFor = 0x00;\r\n    u8 ucLastBits;\r\n    u8 ucN;\r\n    u32 ul;\r\n\r\n    switch ( ucCommand )\r\n    {\r\n       case PCD_AUTHENT:		//Mifare认证\r\n          ucIrqEn   = 0x12;		//允许错误中断请求ErrIEn  允许空闲中断IdleIEn\r\n          ucWaitFor = 0x10;		//认证寻卡等待时候 查询空闲中断标志位\r\n          break;\r\n			 \r\n       case PCD_TRANSCEIVE:		//接收发送 发送接收\r\n          ucIrqEn   = 0x77;		//允许TxIEn RxIEn IdleIEn LoAlertIEn ErrIEn TimerIEn\r\n          ucWaitFor = 0x30;		//寻卡等待时候 查询接收中断标志位与 空闲中断标志位\r\n          break; \r\n       default:\r\n         break; \r\n    }\r\n   \r\n    WriteRawRC ( ComIEnReg, ucIrqEn | 0x80 );		//IRqInv置位管脚IRQ与Status1Reg的IRq位的值相反 \r\n    ClearBitMask ( ComIrqReg, 0x80 );			//Set1该位清零时，CommIRqReg的屏蔽位清零\r\n    WriteRawRC ( CommandReg, PCD_IDLE );		//写空闲命令\r\n    SetBitMask ( FIFOLevelReg, 0x80 );			//置位FlushBuffer清除内部FIFO的读和写指针以及ErrReg的BufferOvfl标志位被清除\r\n    \r\n    for ( ul = 0; ul < ucInLenByte; ul ++ )\r\n		  WriteRawRC ( FIFODataReg, pInData [ ul ] );    		//写数据进FIFOdata\r\n			\r\n    WriteRawRC ( CommandReg, ucCommand );					//写命令\r\n   \r\n    \r\n    if ( ucCommand == PCD_TRANSCEIVE )\r\n			SetBitMask(BitFramingReg,0x80);  				//StartSend置位启动数据发送 该位与收发命令使用时才有效\r\n    \r\n    ul = 1000;//根据时钟频率调整，操作M1卡最大等待时间25ms\r\n		\r\n    do 														//认证 与寻卡等待时间	\r\n    {\r\n         ucN = ReadRawRC ( ComIrqReg );							//查询事件中断\r\n         ul --;\r\n    } while ( ( ul != 0 ) && ( ! ( ucN & 0x01 ) ) && ( ! ( ucN & ucWaitFor ) ) );		//退出条件i=0,定时器中断，与写空闲命令\r\n		\r\n    ClearBitMask ( BitFramingReg, 0x80 );					//清理允许StartSend位\r\n		\r\n    if ( ul != 0 )\r\n    {\r\n		if ( ! (( ReadRawRC ( ErrorReg ) & 0x1B )) )			//读错误标志寄存器BufferOfI CollErr ParityErr ProtocolErr\r\n		{\r\n			cStatus = MI_OK;\r\n			\r\n			if ( ucN & ucIrqEn & 0x01 )					//是否发生定时器中断\r\n			  cStatus = MI_NOTAGERR;   \r\n				\r\n			if ( ucCommand == PCD_TRANSCEIVE )\r\n			{\r\n				ucN = ReadRawRC ( FIFOLevelReg );			//读FIFO中保存的字节数\r\n				\r\n				ucLastBits = ReadRawRC ( ControlReg ) & 0x07;	//最后接收到得字节的有效位数\r\n				\r\n				if ( ucLastBits )\r\n					* pOutLenBit = ( ucN - 1 ) * 8 + ucLastBits;   	//N个字节数减去1（最后一个字节）+最后一位的位数 读取到的数据总位数\r\n				else\r\n					* pOutLenBit = ucN * 8;   					//最后接收到的字节整个字节有效\r\n				\r\n				if ( ucN == 0 )	\r\n                    ucN = 1;    \r\n				\r\n				if ( ucN > MAXRLEN )\r\n					ucN = MAXRLEN;   \r\n				\r\n				for ( ul = 0; ul < ucN; ul ++ )\r\n				  pOutData [ ul ] = ReadRawRC ( FIFODataReg );   \r\n			}		\r\n        }\r\n			else\r\n				cStatus = MI_ERR;   \r\n//			printf(ErrorReg);\r\n    }\r\n   \r\n   SetBitMask ( ControlReg, 0x80 );           // stop timer now\r\n   WriteRawRC ( CommandReg, PCD_IDLE ); \r\n	\r\n   return cStatus;\r\n\r\n}\r\n\r\n\r\n/*\r\n * 函数名：PcdRequest\r\n * 描述  ：寻卡\r\n * 输入  ：ucReq_code，寻卡方式\r\n *                     = 0x52，寻感应区内所有符合14443A标准的卡\r\n *                     = 0x26，寻未进入休眠状态的卡\r\n *         pTagType，卡片类型代码\r\n *                   = 0x4400，Mifare_UltraLight\r\n *                   = 0x0400，Mifare_One(S50)\r\n *                   = 0x0200，Mifare_One(S70)\r\n *                   = 0x0800，Mifare_Pro(X))\r\n *                   = 0x4403，Mifare_DESFire\r\n * 返回  : 状态值\r\n *         = MI_OK，成功\r\n * 调用  ：外部调用\r\n */\r\nchar PcdRequest ( u8 ucReq_code, u8 * pTagType )\r\n{\r\n    char cStatus;  \r\n    u8 ucComMF522Buf [ MAXRLEN ]; \r\n    u32 ulLen;\r\n\r\n    ClearBitMask ( Status2Reg, 0x08 );	//清理指示MIFARECyptol单元接通以及所有卡的数据通信被加密的情况\r\n    WriteRawRC ( BitFramingReg, 0x07 );	//	发送的最后一个字节的 七位\r\n    SetBitMask ( TxControlReg, 0x03 );	//TX1,TX2管脚的输出信号传递经发送调制的13.56的能量载波信号\r\n\r\n    ucComMF522Buf [ 0 ] = ucReq_code;		//存入 卡片命令字\r\n\r\n    cStatus = PcdComMF522 ( PCD_TRANSCEIVE,	ucComMF522Buf, 1, ucComMF522Buf, & ulLen );	//寻卡  \r\n\r\n    if ( ( cStatus == MI_OK ) && ( ulLen == 0x10 ) )	//寻卡成功返回卡类型 \r\n    {    \r\n       * pTagType = ucComMF522Buf [ 0 ];\r\n    //    printf(\"(0: %x)\",ucComMF522Buf [ 0 ]);\r\n       * ( pTagType + 1 ) = ucComMF522Buf [ 1 ];\r\n    //    printf(\"(1: %x)\",ucComMF522Buf [ 1 ]);\r\n    }\r\n     \r\n    else\r\n     cStatus = MI_ERR;\r\n\r\n    return cStatus;\r\n \r\n}\r\n\r\n\r\n/*\r\n * 函数名：PcdAnticoll\r\n * 描述  ：防冲撞\r\n * 输入  ：pSnr，卡片序列号，4字节\r\n * 返回  : 状态值\r\n *         = MI_OK，成功\r\n * 调用  ：外部调用\r\n */\r\nchar PcdAnticoll ( u8 * pSnr )\r\n{\r\n    char cStatus;\r\n    u8 uc, ucSnr_check = 0;\r\n    u8 ucComMF522Buf [ MAXRLEN ]; \r\n	u32 ulLen;\r\n\r\n    ClearBitMask ( Status2Reg, 0x08 );		//清MFCryptol On位 只有成功执行MFAuthent命令后，该位才能置位\r\n    WriteRawRC ( BitFramingReg, 0x00);		//清理寄存器 停止收发\r\n    ClearBitMask ( CollReg, 0x80 );			//清ValuesAfterColl所有接收的位在冲突后被清除\r\n   \r\n    ucComMF522Buf [ 0 ] = 0x93;	//卡片防冲突命令\r\n    ucComMF522Buf [ 1 ] = 0x20;\r\n   \r\n    cStatus = PcdComMF522 ( PCD_TRANSCEIVE, ucComMF522Buf, 2, ucComMF522Buf, & ulLen);//与卡片通信\r\n	\r\n    if ( cStatus == MI_OK)		//通信成功\r\n    {\r\n		for ( uc = 0; uc < 4; uc ++ )\r\n        {\r\n            * ( pSnr + uc )  = ucComMF522Buf [ uc ];			//读出UID\r\n            ucSnr_check ^= ucComMF522Buf [ uc ];\r\n        }\r\n			\r\n        if ( ucSnr_check != ucComMF522Buf [ uc ] )\r\n        		cStatus = MI_ERR;    \r\n				 \r\n    }\r\n    \r\n    SetBitMask ( CollReg, 0x80 );\r\n\r\n    return cStatus;\r\n	\r\n}\r\n\r\n\r\n/*\r\n * 函数名：CalulateCRC\r\n * 描述  ：用RC522计算CRC16\r\n * 输入  ：pIndata，计算CRC16的数组\r\n *         ucLen，计算CRC16的数组字节长度\r\n *         pOutData，存放计算结果存放的首地址\r\n * 返回  : 无\r\n * 调用  ：内部调用\r\n */\r\nvoid CalulateCRC ( u8 * pIndata, u8 ucLen, u8 * pOutData )\r\n{\r\n    u8 uc, ucN;\r\n\r\n    ClearBitMask(DivIrqReg,0x04);\r\n	\r\n    WriteRawRC(CommandReg,PCD_IDLE);\r\n	\r\n    SetBitMask(FIFOLevelReg,0x80);\r\n	\r\n    for ( uc = 0; uc < ucLen; uc ++)\r\n	    WriteRawRC ( FIFODataReg, * ( pIndata + uc ) );   \r\n\r\n    WriteRawRC ( CommandReg, PCD_CALCCRC );\r\n	\r\n    uc = 0xFF;\r\n	\r\n    do \r\n    {\r\n        ucN = ReadRawRC ( DivIrqReg );\r\n        uc --;\r\n    } while ( ( uc != 0 ) && ! ( ucN & 0x04 ) );\r\n		\r\n    pOutData [ 0 ] = ReadRawRC ( CRCResultRegL );\r\n    pOutData [ 1 ] = ReadRawRC ( CRCResultRegM );\r\n	\r\n}\r\n\r\n\r\n/*\r\n * 函数名：PcdSelect\r\n * 描述  ：选定卡片\r\n * 输入  ：pSnr，卡片序列号，4字节\r\n * 返回  : 状态值\r\n *         = MI_OK，成功\r\n * 调用  ：外部调用\r\n */\r\nchar PcdSelect ( u8 * pSnr )\r\n{\r\n	char ucN;\r\n	u8 uc;\r\n	u8 ucComMF522Buf [ MAXRLEN ]; \r\n	u32  ulLen;\r\n	\r\n	ucComMF522Buf [ 0 ] = PICC_ANTICOLL1;\r\n	ucComMF522Buf [ 1 ] = 0x70;\r\n	ucComMF522Buf [ 6 ] = 0;\r\n	\r\n	for ( uc = 0; uc < 4; uc ++ )\r\n	{\r\n		ucComMF522Buf [ uc + 2 ] = * ( pSnr + uc );\r\n		ucComMF522Buf [ 6 ] ^= * ( pSnr + uc );\r\n	}\r\n	CalulateCRC ( ucComMF522Buf, 7, & ucComMF522Buf [ 7 ] );\r\n	\r\n	ClearBitMask ( Status2Reg, 0x08 );\r\n	\r\n	ucN = PcdComMF522 ( PCD_TRANSCEIVE, ucComMF522Buf, 9, ucComMF522Buf, & ulLen );\r\n	\r\n	if ( ( ucN == MI_OK ) && ( ulLen == 0x18 ) )\r\n		ucN = MI_OK;  \r\n	else\r\n		ucN = MI_ERR;    \r\n	return ucN;\r\n}\r\n\r\n\r\n/*\r\n * 函数名：PcdAuthState\r\n * 描述  ：验证卡片密码\r\n * 输入  ：ucAuth_mode，密码验证模式\r\n *                     = 0x60，验证A密钥\r\n *                     = 0x61，验证B密钥\r\n *         u8 ucAddr，块地址\r\n *         pKey，密码\r\n *         pSnr，卡片序列号，4字节\r\n * 返回  : 状态值\r\n *         = MI_OK，成功\r\n * 调用  ：外部调用\r\n */\r\nchar PcdAuthState ( u8 ucAuth_mode, u8 ucAddr, u8 * pKey, u8 * pSnr )\r\n{\r\n	char cStatus;\r\n	u8 uc, ucComMF522Buf [ MAXRLEN ];\r\n	u32 ulLen;\r\n	\r\n	ucComMF522Buf [ 0 ] = ucAuth_mode;\r\n	ucComMF522Buf [ 1 ] = ucAddr;\r\n	\r\n	for ( uc = 0; uc < 6; uc ++ )\r\n		ucComMF522Buf [ uc + 2 ] = * ( pKey + uc );   \r\n	\r\n	for ( uc = 0; uc < 6; uc ++ )\r\n		ucComMF522Buf [ uc + 8 ] = * ( pSnr + uc );   \r\n	\r\n	cStatus = PcdComMF522 ( PCD_AUTHENT, ucComMF522Buf, 12, ucComMF522Buf, & ulLen );\r\n	\r\n	if ( ( cStatus != MI_OK ) || ( ! ( ReadRawRC ( Status2Reg ) & 0x08 ) ) )\r\n	{\r\n	//			if(cStatus != MI_OK)\r\n	//					printf(\"666\")	;		\r\n	//			else\r\n	//				printf(\"888\");\r\n	cStatus = MI_ERR; \r\n	}\r\n	return cStatus;\r\n}\r\n\r\n\r\n/*\r\n * 函数名：PcdWrite\r\n * 描述  ：写数据到M1卡一块\r\n * 输入  ：u8 ucAddr，块地址\r\n *         pData，写入的数据，16字节\r\n * 返回  : 状态值\r\n *         = MI_OK，成功\r\n * 调用  ：外部调用\r\n */\r\nchar PcdWrite ( u8 ucAddr, u8 * pData )\r\n{\r\n	char cStatus;\r\n	u8 uc, ucComMF522Buf [ MAXRLEN ];\r\n	u32 ulLen;\r\n	\r\n	ucComMF522Buf [ 0 ] = PICC_WRITE;\r\n	ucComMF522Buf [ 1 ] = ucAddr;\r\n	\r\n	CalulateCRC ( ucComMF522Buf, 2, & ucComMF522Buf [ 2 ] );\r\n	\r\n	cStatus = PcdComMF522 ( PCD_TRANSCEIVE, ucComMF522Buf, 4, ucComMF522Buf, & ulLen );\r\n	\r\n	if ( ( cStatus != MI_OK ) || ( ulLen != 4 ) || ( ( ucComMF522Buf [ 0 ] & 0x0F ) != 0x0A ) )\r\n		cStatus = MI_ERR;   \r\n	\r\n	if ( cStatus == MI_OK )\r\n	{\r\n		memcpy(ucComMF522Buf, pData, 16);\r\n		for ( uc = 0; uc < 16; uc ++ )\r\n			ucComMF522Buf [ uc ] = * ( pData + uc );  \r\n		\r\n		CalulateCRC ( ucComMF522Buf, 16, & ucComMF522Buf [ 16 ] );\r\n		\r\n		cStatus = PcdComMF522 ( PCD_TRANSCEIVE, ucComMF522Buf, 18, ucComMF522Buf, & ulLen );\r\n		\r\n		if (( cStatus != MI_OK ) || ( ulLen != 4 ) || (( ucComMF522Buf [0] & 0x0F ) != 0x0A ))\r\n			cStatus = MI_ERR;   \r\n	\r\n	} \r\n	return cStatus;\r\n}\r\n\r\n\r\n/*\r\n * 函数名：PcdRead\r\n * 描述  ：读取M1卡一块数据\r\n * 输入  ：u8 ucAddr，块地址\r\n *         pData，读出的数据，16字节\r\n * 返回  : 状态值\r\n *         = MI_OK，成功\r\n * 调用  ：外部调用\r\n */\r\nchar PcdRead ( u8 ucAddr, u8 * pData )\r\n{\r\n	char cStatus;\r\n	u8 uc, ucComMF522Buf [ MAXRLEN ]; \r\n	u32 ulLen;\r\n	\r\n	ucComMF522Buf [ 0 ] = PICC_READ;\r\n	ucComMF522Buf [ 1 ] = ucAddr;\r\n	\r\n	CalulateCRC ( ucComMF522Buf, 2, & ucComMF522Buf [ 2 ] );\r\n	\r\n	cStatus = PcdComMF522 ( PCD_TRANSCEIVE, ucComMF522Buf, 4, ucComMF522Buf, & ulLen );\r\n	\r\n	if ((cStatus == MI_OK) && (ulLen == 0x90))\r\n	{\r\n		for (uc = 0; uc < 16; uc ++)\r\n			*(pData + uc) = ucComMF522Buf[uc];   \r\n	}\r\n	else\r\n		cStatus = MI_ERR;   \r\n	return cStatus;\r\n}\r\n\r\n\r\n/*\r\n * 函数名：PcdHalt\r\n * 描述  ：命令卡片进入休眠状态\r\n * 输入  ：无\r\n * 返回  : 状态值\r\n *         = MI_OK，成功\r\n * 调用  ：外部调用\r\n */\r\nchar PcdHalt( void )\r\n{\r\n    u8 ucComMF522Buf [ MAXRLEN ]; \r\n    u32  ulLen;\r\n\r\n    ucComMF522Buf [ 0 ] = PICC_HALT;\r\n    ucComMF522Buf [ 1 ] = 0;\r\n\r\n    CalulateCRC ( ucComMF522Buf, 2, & ucComMF522Buf [ 2 ] );\r\n    PcdComMF522 ( PCD_TRANSCEIVE, ucComMF522Buf, 4, ucComMF522Buf, & ulLen );\r\n\r\n    return MI_OK;\r\n	\r\n}\r\n\r\n\r\nvoid IC_CMT ( u8 * UID, u8 * KEY, u8 RW, u8 * Dat )\r\n{\r\n    u8 ucArray_ID [ 4 ] = { 0 };//先后存放IC卡的类型和UID(IC卡序列号)\r\n\r\n    PcdRequest ( 0x52, ucArray_ID );//寻卡\r\n\r\n    PcdAnticoll ( ucArray_ID );//防冲撞\r\n\r\n    PcdSelect ( UID );//选定卡\r\n\r\n    PcdAuthState ( 0x60, 0x10, KEY, UID );//校验\r\n\r\n    if ( RW )//读写选择，1是读，0是写\r\n        PcdRead ( 0x10, Dat );\r\n\r\n    else \r\n        PcdWrite ( 0x10, Dat );\r\n     \r\n    PcdHalt ();	 \r\n	 \r\n}\r\n\r\nvoid ShowID(u16 x,u16 y, u8 *p, u16 charColor, u16 bkColor)	 //显示卡的卡号，以十六进制显示\r\n{\r\n	u8 num[9];\r\n	u8 i;\r\n\r\n/* 	for(i=0;i<4;i++)\r\n	{\r\n		num[i*2]=p[i]/16;\r\n		num[i*2]>9?(num[i*2]+=\'7\'):(num[i*2]+=\'0\');\r\n		num[i*2+1]=p[i]%16;\r\n		num[i*2+1]>9?(num[i*2+1]+=\'7\'):(num[i*2+1]+=\'0\');\r\n	}\r\n	num[8]=0;\r\n    \r\n    LCD_ShowString(6,110,110,16,16,num); */\r\n    printf(\"ID>>>%s\\r\\n\", num);\r\n\r\n}\r\n\r\n\r\n```\r\n\r\n# 三十一、摄像头模块\r\n\r\n## 简介\r\n\r\n### 框图\r\n\r\n![image-20211116000037772](cloudDisk/markdown/stm32笔记.assets/image-20211116000037772.png)\r\n\r\nOV7725 传感器包括如下一些功能模块。\r\n1.感光整列（Image Array）\r\nOV7725 总共有 656*488 个像素，其中 640*480 个有效（即有效像素为 30W）。\r\n2.时序发生器（Video Timing Generator）\r\n时序发生器具有的功能包括：整列控制和帧率发生（7 种不同格式输出）、内部信号发生器\r\n和分布、帧率时序、自动曝光控制、输出外部时序（VSYNC、 HREF/HSYNC 和 PCLK）。\r\n3.模拟信号处理（Analog Processing）\r\n模拟信号处理所有模拟功能，并包括：自动增益（AGC）和自动白平衡（AWB）。\r\n4.A/D 转换（A/D）  \r\n\r\n原始的信号经过模拟处理器模块之后 ，分 G 和 BR 两路进入一个 10 位的 A/D 转换器，\r\nA/D 转换器工作在 12M 频率，与像素频率完全同步（转换的频率和帧率有关）。\r\n除 A/D 转换器外，该模块还有以下三个功能：\r\n⚫ 黑电平校正（BLC)\r\n⚫ U/V 通道延迟\r\n⚫ A/D 范围控制\r\nA/D 范围乘积和 A/D 的范围控制共同设置 A/D 的范围和最大值，允许用户根据应用调整图\r\n片的亮度。\r\n5.测试图案发生器（Test Pattern Generator）\r\n测试图案发生器功能包括：八色彩色条图案、渐变至黑白彩色条图案和输出脚移位“1”。\r\n6.数字处理器（DSP）\r\n这个部分控制由原始信号插值到 RGB 信号的过程，并控制一些图像质量：\r\n⚫ 边缘锐化（二维高通滤波器）\r\n⚫ 颜色空间转换（ 原始信号到 RGB 或者 YUV/YCbYCr)\r\n⚫ RGB 色彩矩阵以消除串扰\r\n⚫ 色相和饱和度的控制\r\n⚫ 可编程的伽玛\r\n⚫ 十位到八位数据转换\r\n7.缩放功能（Image Scaler）\r\n这个模块按照预先设置的要求输出数据格式，能将 YUV/RGB 信号从 VGA 缩小到 CIF 以\r\n下的任何尺寸。\r\n8.数字视频接口（Digital Video Port）\r\n通过寄存器 COM2[1:0]，调节 IOL/IOH 的驱动电流，以适应用户的负载。\r\n9.SCCB 接口（SCCB Interface）\r\nSCCB 接口控制图像传感器芯片的运行，详细使用方法参照光盘的《 OmniVision\r\nTechnologies Seril Camera Control Bus(SCCB) Specification》这个文档\r\nOV7725 的寄存器通过 SCCB 时序访问并设置， SCCB 时序和 IIC 时序十分类似，在本章我\r\n们不做介绍，请大家参考光盘的 SCCB 相关文档。接下来我们介绍一下 OV7725 的图像数据输\r\n出格式及时序分析。首先我们简单介绍几个定义：\r\nVGA，即分辨率为 640*480 的输出模式；\r\nQVGA， 即分辨率为 320*240 的输出格式；\r\nQQVGA，即分辨率为 160*120 的输出格式；\r\nPCLK，即像素时钟，一个 PCLK 时钟，输出一个像素(或半个像素)。\r\nVSYNC，即帧同步信号。\r\nHREF /HSYNC，即行同步信号。    \r\n\r\n### 时序分析\r\n\r\n![image-20211116000301972](cloudDisk/markdown/stm32笔记.assets/image-20211116000301972.png)\r\n\r\n比如摄像头分辨率640*480，需要输出的格式为RGB565，此格数两个字节表示一个像素点，输出一行640个像素点，需要传输1280个字节，等待1280个PCLK时钟周期；输出一行数据后，会产生一个HREF下降沿行结束信号，输出一整张图片，总共会产生480个HREF下降沿脉冲\r\n\r\n#### 帧时序\r\n\r\n![image-20211116001058161](cloudDisk/markdown/stm32笔记.assets/image-20211116001058161.png)\r\n\r\n当传输了 480 个 HREF 周期（480× tLINE）后刚好完成\r\n一个 VSYNC（帧）数据传输，等 8 tLINE 后会产生一个 VSYNC 上升沿表示一帧数据传输完成  程序中我们就可以根据 VSYNC 上升沿来判断一帧图像数据传输完成。 注意，图中的 HSYNC\r\n和 HREF 其实是同一个引脚产生的信号，只是在不同场合下面，使用不同的信号方式，我们本\r\n章用到的是 HREF。  \r\n\r\n### AL422B - FIFO缓存\r\n\r\n![image-20211116002214884](cloudDisk/markdown/stm32笔记.assets/image-20211116002214884.png)\r\n\r\n![image-20211116002323118](cloudDisk/markdown/stm32笔记.assets/image-20211116002323118.png)\r\n\r\n![image-20211116002103805](cloudDisk/markdown/stm32笔记.assets/image-20211116002103805.png)\r\n\r\n由于OV7725的输出时钟高达24Mhz，本stm32捕捉不到该数据，且输出的一帧数据达640x2x480=614400字节，本stm32放不下，所以引入fifo缓存\r\n\r\n#### fifo写时序\r\n\r\n![image-20211116001904178](cloudDisk/markdown/stm32笔记.assets/image-20211116001904178-16369931446481.png)\r\n\r\n#### fifo读时序\r\n\r\n![image-20211116002012625](cloudDisk/markdown/stm32笔记.assets/image-20211116002012625.png)\r\n\r\n### stm32读写数据流程\r\n\r\n摄像头模块存储图像数据的过程为：等待 OV7725 帧同步信号→FIFO 写指针复位→FIFO写使能→等待第二个 OV7725 帧同步信号→FIFO 写禁止。通过以上 5 个步骤，我们就可以完成1 帧图像数据在 AL422B 的存储。  \r\n\r\n![image-20211116002526846](../炒股/image-20211116002526846.png)\r\n\r\n\r\n\r\n1. stm32控制ov77225，让它传数据，给它一个高电平信号![image-20211116002914980](cloudDisk/markdown/stm32笔记.assets/image-20211116002914980.png)\r\n2. 允许让FIFO开始接收数据，当单片机检测到ov7725的VSYNC有高电平信号时，说明一帧图像接收完成，此时关闭FIFO接收端（不希望数据被覆盖）\r\n\r\n![image-20211116003419838](cloudDisk/markdown/stm32笔记.assets/image-20211116003419838.png)\r\n\r\n3. 读取fifo数据，此时可以把传输速度调慢，且让stm32一行行读取图片数据\r\n\r\n### 原理图\r\n\r\n![image-20211116003833093](cloudDisk/markdown/stm32笔记.assets/image-20211116003833093.png)\r\n\r\n![image-20211116003912699](cloudDisk/markdown/stm32笔记.assets/image-20211116003912699.png)\r\n\r\n本章，我们将使用 ALIENTEK OV7725 摄像头模块的以 QVGA 模式（分辨率 320/*240），直接输出显示到我们 LCD 上，或者以 VGA 模式（分辨率 640*320）截取中间 320*240 输出显示。注意：摄像头模块自带的 FIFO（AL422B）是没办法缓存一帧的 VGA 图像的，如果使用VGA 全屏分辨率输出，那么你必须在 FIFO 写满之前开始读 FIFO 数据，保证数据不被覆盖。  \r\n\r\n## 硬件设计\r\n\r\n本章实验功能简介：开机后，检测和初始化摄像头模块。对于 OV7725： 初始化成功后需先通过 KEY0 和 KEY1 选择为 QVGA 或 VGA 输出模式， 然后 LCD 才会显示拍摄到的画面。\r\n正常显示拍摄画面后我们可以通过 KEY0 设置光照模式、通过 KEY1 设置色饱和度，通过KEY_UP 设置对比度，通过 TPAD 设置特效（总共 7 种特效）。通过串口，我们可以查看当前的帧率（这里是指 LCD 显示的帧率，而不是指 OV7725 的输出帧率），同时可以借助 USMART设置 OV7725 的寄存器，方便大家调试。 DS0 指示程序运行状态。  \r\n\r\n![image-20211116004805336](cloudDisk/markdown/stm32笔记.assets/image-20211116004805336.png)\r\n\r\n注意，其中有几个信号线和其他外设共用了， OV_SCL 与 JOY_CLK 共用 PD3，所以摄像头和手柄不可以同时使用； FIFO_WEN 和 FIFO_RCLK 则和 JTAG 的信号线 JTDO 和 JTRST 共用了，所以使用摄像头的时候，不能使用 JTAG 模式调试，而应该选择 SW 模式（SW 模式不需要用到 JTDO 和 JTRST）； OV_VSYNC 和 PWM_DAC 共用了 PA8，所以他们也不可以同时使用。  \r\n\r\n![image-20211116004850811](cloudDisk/markdown/stm32笔记.assets/image-20211116004850811.png)\r\n\r\n# 三十二、步进电机\r\n\r\n## 简介\r\n\r\n步进电机是一种将电脉冲转化为角位移的执行机构。通俗一点讲：当步进驱动器接收到一个脉冲信号，它就驱动步进电机按设定的方向转动一个固定的角度（及步进角）。您可以通过**控制脉冲个数**来控制**角位移量**，从而达到准确定位的目的；同时您可以通过**控制脉冲频率**来控制电机转动的**速度和加速度**，从而达到调速的目的。\r\n\r\n步进电机28BYJ48型四相八拍电机，电压为DC5V—DC12V。当对步进电机施加一系列连续不断的控制脉冲时，它可以连续不断地转动。**每一个脉冲信号对应步进电机的某一相或两相绕组的通电状态改变一次，也就对应转子转过一定的角度（一个步距角）**。当通电状态的改变完成一个循环时，转子转过一个齿距。四相步进电机可以在不同的通电方式下运行，常见的**通电方式有单（单相绕组通电）四拍（A-B-C-D-A。。。），双（双相绕组通电）四拍（AB-BC-CD-DA-AB-。。。），八拍（A-AB-B-BC-C-CD-D-DA-A。。。）**\r\n\r\n![image-20211119162129378](cloudDisk/markdown/stm32笔记.assets/image-20211119162129378.png)\r\n\r\n红线接电源5V，橙色电线接P1.3口，黄色电线接P1.2口，粉色电线接P1.1口，蓝色接P1.0口。\r\n\r\n由于单片机接口信号不够大需要通过ULN2003放大再连接到相应的电机接口，如下：\r\n\r\n![image-20211119162227356](cloudDisk/markdown/stm32笔记.assets/image-20211119162227356.png)\r\n\r\n![image-20211119162235397](cloudDisk/markdown/stm32笔记.assets/image-20211119162235397.png)\r\n\r\n\r\n\r\n顺序刚好相反\r\n\r\n所以可以定义旋转相序\r\nuchar code CCW[8]={0x08,0x0c,0x04,0x06,0x02,0x03,0x01,0x09};  //逆时钟旋转相序表\r\nuchar code CW[8]={0x09,0x01,0x03,0x02,0x06,0x04,0x0c,0x08};  //正时钟旋转相序表\r\n\r\n![image-20211119162353039](cloudDisk/markdown/stm32笔记.assets/image-20211119162353039.png)\r\n\r\n![image-20211119162820212](cloudDisk/markdown/stm32笔记.assets/image-20211119162820212.png)\r\n\r\n改步进电机的 相数：4，齿数：8，选用单双相轮流通电方式\r\n\r\n步距角 = 360 / (4\\*8\\*2) = 5.625\r\n\r\n## 硬件设计\r\n\r\n| 引脚 | STM32 | 线   |\r\n| ---- | ----- | ---- |\r\n| in1  | PA0   | 蓝   |\r\n| in2  | PC15  | 粉   |\r\n| in3  | PC14  | 黄   |\r\n| in4  | PC13  | 橙   |\r\n\r\n![image-20211119171554717](cloudDisk/markdown/stm32笔记.assets/image-20211119171554717.png)\r\n\r\n## 软件设计\r\n\r\n### 头文件\r\n\r\n```c\r\n#ifndef __MOTOR_H\r\n#define __MOTOR_H	 \r\n#include \"sys.h\"\r\n#include \"stm32f10x.h\"\r\n#define SPA0 GPIO_SetBits(GPIOA,GPIO_Pin_0);\r\n#define SPC15 GPIO_SetBits(GPIOC,GPIO_Pin_15);\r\n#define SPB7 GPIO_SetBits(GPIOB,GPIO_Pin_7);\r\n#define SPA15 GPIO_SetBits(GPIOA,GPIO_Pin_15);\r\n#define SPC14 GPIO_SetBits(GPIOC,GPIO_Pin_14);\r\n#define SPC13 GPIO_SetBits(GPIOC,GPIO_Pin_13);\r\n\r\n#define RPA0 GPIO_ResetBits(GPIOA,GPIO_Pin_0);\r\n#define RPC15 GPIO_ResetBits(GPIOC,GPIO_Pin_15);\r\n#define RPC14 GPIO_ResetBits(GPIOC,GPIO_Pin_14);\r\n#define RPC13 GPIO_ResetBits(GPIOC,GPIO_Pin_13);\r\nvoid stepMotor_init(void);\r\nvoid driverWhell_roll(u8 orientation, u16 speed);\r\nvoid moter_roll(u8 orientation, u16 speed);\r\nvoid motor_angle(u16 angle, u8 orientation, u16 speed);\r\nvoid reset_raozu(void);\r\n#endif\r\n\r\n\r\n```\r\n\r\n\r\n\r\n### 相序\r\n\r\n```c\r\n// 逆时针相序\r\nu8 CCW[8] = {0X08,0X0C,0X04,0X06,0X02,0X03,0X01,0X09};\r\n// 顺时针相序\r\nu8 CW[8] = {0X09,0X01,0X03,0X02,0X06,0X04,0X0C,0X08};\r\n```\r\n\r\n###  初始化\r\n\r\n```c\r\nvoid stepMotor_init(void){\r\n	GPIO_InitTypeDef GPIO_InitStruct;\r\n/*PWR->CR |= 1<<8;\r\n	RCC->BDCR &= 0XFFFFFFFEE;\r\n	BKP->CR &= 0XFFFFFFFE;\r\n	PWR->CR &= 0XFFFFFEFF;\r\n	*/\r\n	\r\n	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA|RCC_APB2Periph_GPIOC,ENABLE);\r\n	\r\n	GPIO_PinRemapConfig(GPIO_Remap_SWJ_JTAGDisable,ENABLE);\r\n	GPIO_InitStruct.GPIO_Speed = GPIO_Speed_50MHz;\r\n	GPIO_InitStruct.GPIO_Mode = GPIO_Mode_Out_PP; // 推挽输出\r\n	GPIO_InitStruct.GPIO_Pin = GPIO_Pin_0;\r\n	GPIO_Init(GPIOA,&GPIO_InitStruct);	// PA0\r\n  GPIO_InitStruct.GPIO_Pin = GPIO_Pin_15;\r\n	GPIO_Init(GPIOC,&GPIO_InitStruct);	// PC15\r\n\r\n	GPIO_InitStruct.GPIO_Pin = GPIO_Pin_14;\r\n	GPIO_Init(GPIOC,&GPIO_InitStruct);	// PC14\r\n	GPIO_InitStruct.GPIO_Pin = GPIO_Pin_13;\r\n	GPIO_Init(GPIOC,&GPIO_InitStruct);	// PC13\r\n\r\n\r\n}\r\n```\r\n\r\n### 复位绕组\r\n\r\n```c\r\nvoid reset_raozu(void){\r\n\r\n		RPC13;\r\n	RPC14;\r\n\r\n	RPC15;\r\n	RPA0;\r\n}\r\n```\r\n\r\n### 传入十六进制，控制绕组通电\r\n\r\n```c\r\n// 设置哪个绕组通电\r\nvoid set_raozu(u8 code){\r\n	switch(code){\r\n		case 0x08:\r\n			SPC13;\r\n			RPC14;\r\n\r\n			RPC15;\r\n			RPA0;\r\n			break;\r\n		case 0x0C:\r\n			SPC13;\r\n			SPC14;\r\n\r\n		\r\n			RPC15;\r\n			RPA0;\r\n			break;\r\n		case 0x04:\r\n\r\n					SPC14;\r\n			RPC13;\r\n\r\n			RPC15;\r\n			RPA0;\r\n			break;\r\n		case 0x06:\r\n		SPC14;\r\n		RPC13;\r\n		SPC15;\r\n			RPA0;\r\n			break;\r\n		case 0x02:\r\n			SPC15;\r\n		\r\n			RPC13;\r\n			RPC14;\r\n\r\n		\r\n			RPA0;\r\n			break;\r\n		case 0x03:\r\n			SPC15;\r\n			SPA0;\r\n		\r\n			RPC13;\r\n			RPC14;\r\n	\r\n		\r\n			break;\r\n		case 0x01:\r\n			SPA0;\r\n		\r\n			RPC13;\r\n			RPC14;\r\n		\r\n		\r\n			RPC15;\r\n			break;\r\n		case 0x09:\r\n			SPA0;\r\n		\r\n			SPC13;\r\n			RPC14;\r\n		\r\n\r\n		\r\n			RPC15;\r\n			break;\r\n	}\r\n}\r\n```\r\n\r\n### 传动轴转一周\r\n\r\n```c\r\n// 设置哪个绕组通电\r\nvoid set_raozu(u8 code){\r\n	switch(code){\r\n		case 0x08:\r\n			SPC13;\r\n			RPC14;\r\n\r\n			RPC15;\r\n			RPA0;\r\n			break;\r\n		case 0x0C:\r\n			SPC13;\r\n			SPC14;\r\n\r\n		\r\n			RPC15;\r\n			RPA0;\r\n			break;\r\n		case 0x04:\r\n\r\n					SPC14;\r\n			RPC13;\r\n\r\n			RPC15;\r\n			RPA0;\r\n			break;\r\n		case 0x06:\r\n		SPC14;\r\n		RPC13;\r\n		SPC15;\r\n			RPA0;\r\n			break;\r\n		case 0x02:\r\n			SPC15;\r\n		\r\n			RPC13;\r\n			RPC14;\r\n\r\n		\r\n			RPA0;\r\n			break;\r\n		case 0x03:\r\n			SPC15;\r\n			SPA0;\r\n		\r\n			RPC13;\r\n			RPC14;\r\n	\r\n		\r\n			break;\r\n		case 0x01:\r\n			SPA0;\r\n		\r\n			RPC13;\r\n			RPC14;\r\n		\r\n		\r\n			RPC15;\r\n			break;\r\n		case 0x09:\r\n			SPA0;\r\n		\r\n			SPC13;\r\n			RPC14;\r\n		\r\n\r\n		\r\n			RPC15;\r\n			break;\r\n	}\r\n}\r\n```\r\n\r\n### 主轴转一周\r\n\r\n```c\r\n// 主轴转一周\r\n// 参数1：\r\n//  	0：正传\r\n//    1：逆转\r\n// 参数2：\r\n// 速度：1 - 255\r\nvoid moter_roll(u8 orientation, u16 speed)\r\n{\r\n	u8 r;\r\n	u8 N=64;       \r\n  if(orientation)\r\n  {\r\n		for(r=0;r<N;r++)\r\n		{\r\n			driverWhell_roll(1, speed);  \r\n		}\r\n	}else{\r\n	 	for(r=0;r<N;r++)\r\n		{\r\n			driverWhell_roll(0, speed);  \r\n		}\r\n	}\r\n	reset_raozu();\r\n}\r\n```\r\n\r\n### 主轴角度旋转\r\n\r\n```x\r\nvoid motor_angle(u16 angle, u8 orientation, u16 speed){\r\n	u8 i;\r\n	u16 j, times;\r\n	times = angle / 0.7035;\r\n\r\n	if(orientation){\r\n		for(j=0; j<times; j++){\r\n			for(i=0;i<8;i++)// 旋转0.7035°\r\n			 {\r\n				 set_raozu(CCW[i]);\r\n				 delay_ms(1); \r\n				 delay_us(speed); \r\n			 }\r\n	 }\r\n	}else{\r\n		for(j=0; j<times; j++){\r\n			//printf(\"j\");\r\n			for(i=0;i<8;i++)// 旋转0.7035°\r\n			 {\r\n				 set_raozu(CW[i]);\r\n				 delay_ms(1);\r\n				 delay_us(speed);\r\n				 //printf(\"i\");\r\n			 }\r\n	 }\r\n	}\r\n	reset_raozu();\r\n}\r\n```\r\n\r\n# 三十三、HC-SR501 人体红外感应模块\r\n\r\n## 简介\r\n\r\n完美版HC-SR501是基于红外线技术的自动控制模块，采用德国原装进口LHI778探头设计，灵敏度高，可靠性强，超低电压工作模式，广泛应用于各类自动感应电器设备，尤其是干电池供电的自动控制产品。 \r\n\r\n![image-20211123195233902](cloudDisk/markdown/stm32笔记.assets/image-20211123195233902.png)\r\n\r\n功能特点：\r\n\r\n1.全自动感应：**当有人进入其感应范围则输入高电平，人离开感应范围则自动延时关闭高电平。输出低电平。**\r\n2.光敏控制(可选）：模块预留有位置，可设置光敏控制，白天或光线强时不感应。光敏控制为可选功能,出厂时未安装光敏电阻。如果需要，请另行购买光敏电阻自己安装。\r\n\r\n3.两种触发方式：L不可重复，H可重复。可跳线选择，默认为H。\r\n  A.不可重复触发方式：即感应输出高电平后，延时时间一结束，输出将自动从高电平变为低电平。\r\n  B.可重复触发方式： 即感应输出高电平后，在延时时间段内，如果有人体在其感应范围内活动，其输出将一直保持高电平，直到人离开后才延时将高电平变为低电平(感应模块检测到人 体的每一次活动后会自动顺延一个延时时间段，并且以最后一次活动的时间为延时时间的起始点)。\r\n4.具有感应封锁时间(默认设置：3-4秒)：感应 模块在每一次感应输出后(高电平变为低电平)，可以紧跟着设置一个封锁时间，在此时间段内感应器不接收任何感应信号。此功能可以实现(感应输出时间和封锁 时间)两者的间隔工作，可应用于间隔探测产品；同时此功能可有效抑制负载切换过程中产生的各种干扰。\r\n5.工作电压范围宽：默认工作电压DC5V至20V\r\n6.微功耗：静态电流65微安，特别适合干电池供电的电器产品。\r\n7.输出高电平信号：可方便与各类电路实现对接。\r\n\r\n使用说明：\r\n\r\n1感应模块通电后有一分钟左右的初始化时间，在此时间模块会间隔地输出0-3次，一分钟后进入待机状态。\r\n\r\n\\2. 应尽量避免灯光等干扰源近距离直射模块表面的透镜，以免引进干扰信号产生误动作；使用环境尽量避\r\n免流动的风，风也会对感应器造成干扰。\r\n\r\n\\3. 感应模块采用双元探头，探头的窗口为长方形，双元（A元B元）位于较长方向的两端，当人体从左到右\r\n或从右到左走过时,红外光谱到达双元的时间、距离有差值，差值越大，感应越灵敏，当人体从正面走向探\r\n头或从上到下或从下到上方向走过时，双元检测不到红外光谱距离的变化，无差值，因此感应不灵敏或不工作；所以安装感应器时应使探头双元的方向与人体活动最多的方向尽量相平行，保证人体经过时先后被\r\n探头双元所感应。为了增加感应角度范围，本模块采用圆形透镜，也使得探头四面都感应，但左右两侧仍\r\n然比上下两个方向感应范围大、灵敏度强，安装时仍须尽量按以上要求。\r\n\r\n热释电传感器基本知识和使用中的常见问题\r\n\r\n 热释电红外传感器是一种能检测人或动物发射的红外线而输出电信号的传感器。早在1938年，有人提出过利用热释电效应探测红外辐射，但并未受到重视，直到 六十年代，随着激光、红外技术的迅速发展，才又推动了对热释电效应的研究和对热释电晶体的应用。热释电晶体已广泛用于红外光谱仪、红外遥感以及热辐射探测 器，它可以作为红外激光的一种较理想的探测器。它目标正在被广泛的应用到各种自动化控制装置中。除了在我们熟知的楼道自动开关、防盗报警上得到应用外，在 更多的领域应用前景看好。比如：在房间无人时会自动停机的空调机、饮水机。电视机能判断无人观看或观众已经睡觉后自动关机的机构。开启监视器或自动门铃上 的应用。结合摄影机或数码照相机自动记录动物或人的活动等等……。您可以根据自己的奇思妙想，结合其它电路开发出更加优秀的新产品。或自动化控制装置。\r\n\r\n热释电传感器基本知识：\r\n\r\n  热释电效应同压电效应类似，是指由于温度的变化而引起晶体表面荷电的现象。热释电传感器是对温度敏感的传感器。它由陶瓷氧化物或压电晶体元件组成，在元件 两个表面做成电极，在传感器监测范围内温度有ΔT的变化时，热释电效应会在两个电极上会产生电荷ΔQ，即在两电极之间产生一微弱的电压ΔV。由于它的输出 阻抗极高，在传感器中有一个场效应管进行阻抗变换。热释电效应所产生的电荷ΔQ会被空气中的离子所结合而消失，即当环境温度稳定不变时，ΔT=0，则传感 器无输出。当人体进入检测区，因人体温度与环境温度有差别，产生ΔT，则有ΔT输出；若人体进入检测区后不动，则温度没有变化，传感器也没有输出了。所以 这种传感器检测人体或者动物的活动传感。 由实验证明，传感器不加光学透镜(也称菲涅尔透镜)，其检测距离小于2m，而加上光学透镜后，其检测距离可大于7m。\r\n\r\n使用中应注意以下几点：\r\n\r\n   一、直流工作电压必须符合我们要求的数值，过高和过低都会影响模块性能，而且要求电源必须经过良好的稳压滤波，例如电脑USB电源、手机充电器电源、比较 旧的9V的层叠电池都无法满足模块工作要求，建议客户**用变压器的电源并经过三端稳压芯片稳压后再通过220UF和0.1UF的电容滤波后供电。**\r\n\r\n   二、调试时人体尽量远离感应区域，有时虽然人体不在模块的正前方，但是人体离模块太近时模块也能感应到造成一直有输出，还有调试时人体不要触摸电路部分也 会影响模块工作，比较科学的办法是将输出端接一个LED或者是万用表，把模块用报纸盖住，人离开这个房间，等2分钟后看看模块是否还是一直有输出？\r\n\r\n   三、模块不接负载时能正常工作，接上负载后工作紊乱，一种原因是因为电源容量很小负载比较耗电，负载工作时引起的电压波动导致模块误动作，另一种原因是负 载得电工作时会产生干扰，例如继电器或者电磁铁等感性负载会产生反向电动势，315M发射板工作时会有电磁辐射等都会影响模块。解决办法如下：A、电源部 分加电感滤波。B、采用负载和模块使用不同的电压的方法，例如：负载使用24V工作电压，模块使用12V工作电压，其间用三端稳压器隔离。C: 使用更大容量的电源。\r\n\r\n   四、人体感应模块只能工作在室内并且工作环境应该避免阳光、强烈灯光直接照射，如果工作环境有强大的射频干扰，可以采用屏蔽措施。若遇有强烈气流干扰，关闭门窗或阻止对流。感应区尽量避免正对着发热电器和物体以及容易被风吹动的杂物和衣物。\r\n\r\n   五、人体感应模块建议安装在密封的盒里，否则可能一直会有输出信号。\r\n\r\n   六、如果要求人体感应模块的探测角度小于90度时，可以用不透明胶纸遮挡镜片或裁剪缩小镜片来实现。\r\n\r\n   七、人体感应模块采用双元探头，人体的手脚和头部运动方向与感应灵敏度有着密切的联系，而且红外模块的特性决定了无法精确控制感应距离。\r\n\r\n   八、模块中的探头（PIR）可以装焊在电路板的另一面。也可将探头用双芯屏蔽线延长，长度应在20厘米以内为好。\r\n\r\n \r\n\r\n![image-20211123201212124](cloudDisk/markdown/stm32笔记.assets/image-20211123201212124.png)\r\n\r\n![image-20211123201244440](cloudDisk/markdown/stm32笔记.assets/image-20211123201244440.png)\r\n\r\n![image-20211123201253915](cloudDisk/markdown/stm32笔记.assets/image-20211123201253915.png)\r\n\r\n## 硬件设计\r\n\r\nPA0 - 中间线\r\n\r\n### 软件设计\r\n\r\n参考外部中断 \r\n\r\n\r\n\r\n# 三十四、移植LVGL\r\n\r\n## 34.1、前言\r\n\r\nlittlevgl是一个小型开源嵌入式 GUI 库(简称LVGL)，界面精美,消耗资源小，可移植度高，支持响应式布局，全库采用纯 c 语言开发，移植上手简单。\r\nlittleVGL 的主要特性如下:\r\n• 具有非常丰富的内置控件,像 buttons, charts, lists, sliders, images 等\r\n• 高级图形效果：动画，反锯齿，透明度，平滑滚动\r\n• 支持多种输入设备,像 touchpad, mouse, keyboard, encoder 等\r\n• 支持多语言的 UTF-8 编码\r\n• 支持多个和多种显示设备，例如同步显示在多个彩色屏或单色屏上\r\n• 完全自定制的图形元素\r\n• 硬件独立于任何微控制器或显示器\r\n• 可以缩小到最小内存 (64 kB Flash, 16 kB RAM)\r\n• 支持操作系统、外部储存和 GPU（非必须）\r\n• 仅仅单个帧缓冲设备就可以呈现高级视觉特效\r\n• 使用 C 编写以获得最大兼容性(兼容 C++)\r\n• 支持 PC 模拟器\r\n• 为加速 GUI 设计,提供教程,案例和主题,支持响应式布局\r\n• 提供了在线和离线文档\r\n• 基于自由和开源的 MIT 协议\r\n效果图以及更多详细的说明请见官网\r\nlittlevgl中文官网：https://littlevgl.cn/\r\nlittlevgl英文官网：https://lvgl.io/\r\n\r\n## 34.2、学习资料\r\n\r\n- 官方文档：https://docs.lvgl.io/latest/en/html/index.html(注:官网打不开的话可能会需要梯子)\r\n\r\n- Github: https://github.com/lvgl/lvgl\r\n\r\n## 34.3、移植前的准备工作\r\n\r\n#### 开发环境：\r\n\r\n- Keil MDK5 v5.28\r\n- ARM Compiler 6.0版本或以上\r\n\r\n关于编译器，老版本的5.x编译器也能编译，但是新的6版本的编译器在编译速度与效率上有很大的提升，并且解决了一些莫名其妙的bug，强烈建议升级到6版本的编译器。笔者使用的版本是v6.14.1。\r\n\r\n**硬件**：\r\n\r\n* STM32开发板\r\n* 屏幕一块（单色点阵屏或者是LCD彩屏都可以）\r\n\r\n笔者使用的开发板是正点原子的战舰V3开发板，芯片是STM32F103ZET6，72M主频+512k flash+64k ram，这样的性能足够跑LVGL了，当然，你的芯片性能越高肯定越好。哦，板上还外挂了一颗1M字节的SRAM，这对提升性能很有帮助。如果你用的不是这款芯片或者这块开发板，那也没关系，笔者会详细指出移植过程中不同的芯片移植需要注意的地方。\r\n\r\n**获取源码**：\r\n源码地址：https://github.com/lvgl/lvgl\r\n源码有很多的发行版，不同的发行版对应着不同的LVGL版本，注意不同的版本之间是不同的，比如版本V6与版本V7之间就变化很大，具体的版本变化信息可以看它的release note，这里我以v7.1.0版本为例来移植，并且今后的学习都会使用这个版本。\r\n\r\n![image-20211129154142675](cloudDisk/markdown/stm32笔记.assets/image-20211129154142675.png)\r\n\r\n打开下载好的文件夹\r\n\r\n我们重点关注src/目录和lv_conf_template.h, lvgl.h 这几个文件，其它的暂时不用管。![image-20211129154212099](cloudDisk/markdown/stm32笔记.assets/image-20211129154212099.png)\r\n\r\n我们重点关注src/目录和lv_conf_template.h, lvgl.h 这几个文件，其它的暂时不用管。\r\n\r\n**准备模板工程：**\r\n\r\n* 为你的开发板准备好一个模板工程\r\n  要求：这个模板工程至少能够驱动一块屏幕(做GUI必须得有屏幕呀= =)\r\n  如果你的屏幕带有触摸功能，那你的工程还需要有触摸屏的驱动，其实触摸屏驱动需要但非必须，没有触摸功能的话你也可以做一些展示的界面。事实上LVGL也支持键盘，鼠标，触控板等外设，因为在LVGL核心那里，它会将这些全部抽象为输入设备，它只需要从输入设备那里取得数据，并不关心你所用的是何种设备。\r\n\r\n当然，触摸屏已经用得相当广泛，笔者使用的屏幕同样是正点原子家开发板配套的屏幕，型号：4.3英寸MCU屏，800*480分辨率，带电容触摸功能，其接口为16位并口，驱动IC：NT35510，触摸控制IC：GT9147，触摸控制接口为IIC。\r\n因此我需要提前准备好并且测试好这些驱动，对于屏幕控制器，除了初始化API（就是函数），还需要提供填充LCD的API，像这样：\r\n\r\n```c\r\nLCD_Color_Fill(x1,y1,x2,y2,(u16*)color_p);\r\n```\r\n\r\n(x1,y1), (x2,y2)为俩坐标点，color_p为显存指针，该API要实现的功能为：将显存区域内的像素数据点，依次填充到以(x1,y1)为起点， (x2,y2)为重点的对角矩形区域内。\r\n注意，这个API是LVGL渲染屏幕的唯一API，哈哈哈简单吧。同样LVGL内部也不关心使用的何种屏幕，他们之间仅通过一个填充色块儿的API耦合，这种高内聚、低耦合的模块儿化设计思想是非常值得我们学习借鉴的。\r\n\r\n## 34.4、开始移植\r\n\r\n#### ①修改MDK工程(默认你已经会使用keil了)\r\n\r\n用keil mdk打开我们的模板工程，添加4个Groups:GUI_core, GUI_drv, GUI_demo, GUI_app，这些组用于添加我们的c代码到工程中，不同的组名意味着会存放不同功能的c代码。(注意：工程中的组与实际文件目录并不相同)\r\n\r\n- GUI_core：GUI核心文件层\r\n- GUI_drv：GUI驱动设备层，包括显示设备与输入设备\r\n- GUI_demo：存放官方demo\r\n- GUI_app：存放我们自己写的GUI应用\r\n  修改后的工程结构：\r\n\r\n![image-20211129154527970](cloudDisk/markdown/stm32笔记.assets/image-20211129154527970.png)\r\n\r\n#### ②添加源文件\r\n\r\n在项目的根路径下新建GUI目录，以及GUI_app目录，然后将准备工作第三步下载到的源码直接解压到GUI/目录下，然后把解压出来的文件夹改名为lvgl；在GUI/目录下新建lvgl_driver目录，然后：\r\n\r\n```c\r\n//从GUI\\lvgl\\examples\\porting\\目录拷贝：\r\nlv_port_disp_template.c\r\nlv_port_disp_template.h\r\nlv_port_indev_template.c\r\nlv_port_indev_template.h\r\n// 到GUI/lvgl_driver/目录下并分别改名为：\r\nlv_port_disp.c\r\nlv_port_disp.h\r\nlv_port_indev.c\r\nlv_port_indev.h\r\n\r\n//添加：\r\ndma.c\r\ndma.h\r\n//这两个文件时我编写的使用DMA进行加速的代码，如果你不使用DMA请忽略\r\n```\r\n\r\n然后把GUI/lvgl/lv_conf_template.h拷贝到GUI/目录下并改名为lv_conf.h。\r\n修改后的目录结构：\r\n\r\n![image-20211129192728404](cloudDisk/markdown/stm32笔记.assets/image-20211129192728404.png)\r\n\r\n![image-20211129195309627](cloudDisk/markdown/stm32笔记.assets/image-20211129195309627.png)\r\n\r\n![image-20211129195316690](cloudDisk/markdown/stm32笔记.assets/image-20211129195316690.png)\r\n\r\n#### ③添加源文件到工程中\r\n\r\n在GUI_core组中添加以下文件夹中所有的.c文件：\r\n\r\n```c\r\nGUI/lvgl/src/lv_core\r\nGUI/lvgl/src/lv_draw\r\nGUI/lvgl/src/lv_font\r\nGUI/lvgl/src/lv_hal\r\nGUI/lvgl/src/lv_misc\r\nGUI/lvgl/src/lv_themes\r\nGUI/lvgl/src/lv_widgets\r\n//注意不要添加 GUI/lvgl/src/lv_gpu中的文件，除非你用到了相关功能\r\n```\r\n\r\n在GUI_drv组中添加以下.c文件：\r\n\r\n```c\r\nGUI/lvgl_driver/dma.c\r\nGUI/lvgl_driver/lv_port_disp.c\r\nGUI/lvgl_driver/lv_port_indev.c\r\n```\r\n\r\n#### ④添加头文件路径\r\n\r\n![image-20211129195603844](cloudDisk/markdown/stm32笔记.assets/image-20211129195603844.png)\r\n\r\n#### ⑤修改配置文件\r\n\r\n打开GUI/lv_conf.h\r\n首先第十行设置为#if 1 使能整个配置文件\r\n找到以下几个宏定义并修改\r\n\r\n```c\r\n#define LV_HOR_RES_MAX          (480)//定义屏幕的最大水平分辨率\r\n#define LV_VER_RES_MAX          (800)//定义屏幕的最大垂直分辨率\r\n//修改为你的屏幕分辨率即可\r\n\r\n/* Color depth:\r\n * - 1:  1 byte per pixel\r\n * - 8:  RGB332\r\n * - 16: RGB565\r\n * - 32: ARGB8888\r\n */\r\n#define LV_COLOR_DEPTH     16\r\n//定义颜色深度，如果是单色屏的话就改为1\r\n\r\n#  define LV_MEM_SIZE    (30U * 1024U)\r\n//给LVGL分配内存的大小，至少需要2k\r\n```\r\n\r\n这个文件很重要，控制着整个LVGL的功能，但我们暂时就先修改这几个参数，其它参数暂时保持默认即可。等到我们深入了解了LVGL或者需要用到其它特性时再去研究修改也无妨。\r\n然后我们需要修改GUI/lvgl_driver/目录下的lv_port_disp.c, lv_port_disp.h,lv_port_indev.c, lv_port_indev.h这4个文件，这里直接给处修改好之后的文件。\r\n\r\n* lv_port_disp.c\r\n\r\n```c\r\n#if 1\r\n#include \"lv_port_disp.h\"\r\n#include \"LCD.h\"\r\n#include \"dma.h\"\r\n\r\n#define COLOR_BUF_SIZE (LV_HOR_RES_MAX*LV_VER_RES_MAX)\r\n//分配到外部 1MB sram 的最起始处\r\nstatic lv_color_t *color_buf;\r\n\r\nstatic void disp_flush(lv_disp_drv_t * disp_drv, const lv_area_t * area, lv_color_t * color_p);\r\n\r\nvoid lv_port_disp_init(void)\r\n{\r\n    static lv_disp_buf_t disp_buf;\r\n    color_buf = (lv_color_t *)0X68000000;//显示缓冲区初始化\r\n    lv_disp_buf_init(&disp_buf, color_buf, NULL,COLOR_BUF_SIZE);\r\n    lv_disp_drv_t disp_drv;\r\n    lv_disp_drv_init(&disp_drv);\r\n\r\n    //注册显示驱动回调\r\n    disp_drv.flush_cb = disp_flush;\r\n    \r\n    //注册显示缓冲区\r\n    disp_drv.buffer = &disp_buf;\r\n    \r\n    //注册显示驱动到 lvgl 中\r\n    lv_disp_drv_register(&disp_drv);\r\n}\r\n\r\n//把指定区域的显示缓冲区内容写入到屏幕上,你可以使用 DMA 或者其他的硬件加速器\r\n//在后台去完成这个操作但是在完成之后,你必须得调用 lv_disp_flush_ready()\r\nstatic void disp_flush(lv_disp_drv_t * disp_drv, const lv_area_t * area, lv_color_t * color_p)\r\n{\r\n    //把指定区域的显示缓冲区内容写入到屏幕\r\n    //LCD_Color_Fill(area->x1,area->y1,area->x2,area->y2,(u16*)color_p);//TODO\r\n    DMA_Fill_Color(area->x1,area->y1,area->x2,area->y2,(u16*)color_p);\r\n    lv_disp_flush_ready(disp_drv);//最后必须得调用,通知 lvgl 库你已经 flushing 拷贝完成了\r\n}\r\n\r\n#else /* Enable this file at the top */\r\n/* This dummy typedef exists purely to silence -Wpedantic. */\r\ntypedef int keep_pedantic_happy;\r\n#endif\r\n```\r\n\r\n- lv_port_disp.h\r\n\r\n```c\r\n#if 1\r\n#ifndef LV_PORT_DISP_H\r\n#define LV_PORT_DISP_H\r\n\r\n#ifdef __cplusplus\r\nextern \"C\" {\r\n#endif\r\n\r\n#include \"lvgl/lvgl.h\"\r\n\r\nvoid lv_port_disp_init(void);\r\n\r\n#ifdef __cplusplus\r\n} /* extern \"C\" */\r\n#endif\r\n\r\n#endif /*LV_PORT_DISP_TEMPL_H*/\r\n#endif /*Disable/Enable content*/\r\n```\r\n\r\n- lv_port_indev.c\r\n\r\n```c\r\n#if 1\r\n#include \"lv_port_indev.h\"\r\n#include \"Touch.h\"\r\n\r\nstatic bool touchpad_read(lv_indev_drv_t * indev_drv, lv_indev_data_t * data);\r\n\r\nvoid lv_port_indev_init(void)\r\n{\r\n    lv_indev_drv_t indev_drv;\r\n\r\n    /*Register a touchpad input device*/\r\n    lv_indev_drv_init(&indev_drv);\r\n    indev_drv.type = LV_INDEV_TYPE_POINTER;\r\n    indev_drv.read_cb = touchpad_read;\r\n    lv_indev_drv_register(&indev_drv);\r\n}\r\n\r\nstatic bool touchpad_read(lv_indev_drv_t * indev_drv, lv_indev_data_t * data)\r\n{\r\n		static uint16_t last_x = 0;\r\n		static uint16_t last_y = 0;\r\n		Tp_dev.scan();\r\n		if(Tp_dev.sta&0x80)//触摸按下了\r\n		{\r\n			last_x = Tp_dev.X[0];\r\n			last_y = Tp_dev.Y[0];//竖屏\r\n			\r\n			data->point.x = last_x;\r\n			data->point.y = last_y;\r\n			data->state = LV_INDEV_STATE_PR;\r\n		}else{\r\n			data->point.x = last_x;\r\n			data->point.y = last_y;\r\n			data->state = LV_INDEV_STATE_REL;\r\n		}\r\n    return false;\r\n}\r\n\r\n#else /* Enable this file at the top */\r\n\r\n/* This dummy typedef exists purely to silence -Wpedantic. */\r\ntypedef int keep_pedantic_happy;\r\n#endif\r\n```\r\n\r\n- lv_port_indev.h\r\n\r\n```c\r\n#if 1\r\n#ifndef LV_PORT_INDEV_H\r\n#define LV_PORT_INDEV_H\r\n\r\n#ifdef __cplusplus\r\nextern \"C\" {\r\n#endif\r\n\r\n#include \"lvgl/lvgl.h\"\r\n\r\nvoid lv_port_indev_init(void);\r\n\r\n#ifdef __cplusplus\r\n} /* extern \"C\" */\r\n#endif\r\n\r\n#endif /*LV_PORT_INDEV_TEMPL_H*/\r\n#endif /*Disable/Enable content*/\r\n```\r\n\r\n#### ⑥完善main函数\r\n\r\n至此，移植工作基本完成，接下来只需要完善main函数，初始化LVGL，便可放心玩耍。\r\n修改main.c如下：\r\n\r\n```c\r\n#include \"include_config.h\"\r\n#include \"sys.h\"\r\n#include \"delay.h\" \r\n#include \"dma.h\"\r\n#include \"lvgl.h\"\r\n#include \"lv_port_disp.h\"\r\n#include \"lv_port_indev.h\"\r\n\r\nvoid tim_lv_tick(void);\r\nvoid lvgl_first_demo_start(void);\r\nvoid setup()\r\n{\r\n	JTAG_Set(SWD_ENABLE);   //关闭JTAG,只用SWD\r\n	delay_init(72);\r\n	led_init();\r\n	myuart_init(USART1,1152000,PA(10),PA(9));\r\n	Timer_InitDef TIM_2_conf=\r\n	{\r\n		.TIMx = TIM2,\r\n		.ms   = 1,\r\n		.NVIC_Priority = 0,\r\n		.event_handler = tim_lv_tick,\r\n	};\r\n	timer_init(&TIM_2_conf);\r\n	\r\n	LCD_init(BKOR); //默认竖屏\r\n	if(Tp_dev.init())printf(\"Tp_dev failed!\\r\\n\");\r\n	else printf(\"Tp_dev success!\\r\\n\");\r\n	\r\n	FSMC_SRAM_Init();\r\n	DMA_fsmc_Init();\r\n}\r\n\r\nint main(void)\r\n{			\r\n	setup();\r\n	printf(\"set up success!\\r\\n\");\r\n\r\n	lv_init(); //lvgl 系统初始化\r\n	lv_port_disp_init(); //lvgl 显示接口初始化,放在 lv_init()的后面\r\n	lv_port_indev_init(); //lvgl 输入接口初始化,放在 lv_init()的后面\r\n\r\n\r\n	lvgl_first_demo_start();\r\n	while(1)\r\n	{\r\n		lv_task_handler();\r\n	}\r\n}\r\n\r\nvoid tim_lv_tick()\r\n{\r\n	lv_tick_inc(1);//lvgl 的 1ms 心跳\r\n}\r\n\r\n\r\nstatic void btn_event_cb(lv_obj_t * btn, lv_event_t event)\r\n{\r\n    if(event == LV_EVENT_CLICKED) {\r\n        static uint8_t cnt = 0;\r\n        cnt++;\r\n\r\n        /*Get the first child of the button which is the label and change its text*/\r\n        lv_obj_t * label = lv_obj_get_child(btn, NULL);\r\n        lv_label_set_text_fmt(label, \"Button: %d\", cnt);\r\n    }\r\n}\r\nvoid lvgl_first_demo_start(void)\r\n{\r\n    lv_obj_t * btn = lv_btn_create(lv_scr_act(), NULL);     /*Add a button the current screen*/\r\n    lv_obj_set_pos(btn, 10, 10);                            /*Set its position*/\r\n    lv_obj_set_size(btn, 120, 50);                          /*Set its size*/\r\n    lv_obj_set_event_cb(btn, btn_event_cb);                 /*Assign a callback to the button*/\r\n\r\n    lv_obj_t * label = lv_label_create(btn, NULL);          /*Add a label to the button*/\r\n    lv_label_set_text(label, \"Button\");                     /*Set the labels text*/\r\n\r\n\r\n	lv_obj_t * label1 = lv_label_create(lv_scr_act(), NULL);\r\n	lv_label_set_text(label1, \"Hello world!\"); \r\n	lv_obj_align(label1, NULL, LV_ALIGN_CENTER, 0, 0);\r\n	lv_obj_align(btn, label1, LV_ALIGN_OUT_TOP_MID, 0, -10);\r\n}\r\n```\r\n\r\n','2022-06-23 21:31:08','STM32系列专为要求高性能、低成本、低功耗的嵌入式应用设计的ARM Cortex®-M0，M0+，M3, M4和M7内核 （ST\'s product portfolio contains a comprehensive range of microcontrollers, from robust, low-cost 8-bit MCUs up to 32-bit ARM-based Cortex','cloudDisk\\markdown\\0df431adcbef7609e0ba65422edda3cc7dd99ebe.webp','原创','','','\0','STM32  学习笔记','2022-06-23 21:31:08',3,97,NULL,0),(166,'','# 第一个Vue程序\r\n\r\n```html\r\n<body>\r\n<!--view层 模板-->\r\n    <div id=\"app\">\r\n        {{message}}\r\n    </div>\r\n\r\n    <script src=\"vuejs-2.5.16.js\"></script>\r\n    <script>\r\n        var vue = new Vue({\r\n            el: \"#app\",\r\n            /*model：数据*/\r\n            data:{\r\n                message:\"hello world\",\r\n            },\r\n        });\r\n    </script>\r\n</body>\r\n```\r\n\r\n![image-20220526092043213](cloudDisk/markdown/vue笔记.assets/image-20220526092043213.png)\r\n\r\nconsole修改值\r\n\r\n![image-20220526092325705](cloudDisk/markdown/vue笔记.assets/image-20220526092325705.png)\r\n\r\n![image-20220526092329787](cloudDisk/markdown/vue笔记.assets/image-20220526092329787.png)\r\n\r\n# 基本语法\r\n\r\n## v-bind\r\n\r\n![image-20220526092716158](cloudDisk/markdown/vue笔记.assets/image-20220526092716158.png)\r\n\r\n```html\r\n<!--view层 模板-->\r\n    <div id=\"app\">\r\n        <span v-bind:title=\"message\">\r\n            悬停几秒查看动态绑定提示信息\r\n        </span>\r\n    </div>\r\n\r\n    <script src=\"vuejs-2.5.16.js\"></script>\r\n    <script>\r\n        var vue = new Vue({\r\n            el: \"#app\",\r\n            /*model：数据*/\r\n            data:{\r\n                message:\"hello world\",\r\n            },\r\n        });\r\n    </script>\r\n</body>\r\n```\r\n\r\n## v-if\r\n\r\n### 1)\r\n\r\n```html\r\n<body>\r\n<!--view层 模板-->\r\n    <div id=\"app\">\r\n        <h1 v-if=\"ok\">Yes</h1>\r\n        <h1 v-else>No</h1>\r\n    </div>\r\n\r\n    <script src=\"vuejs-2.5.16.js\"></script>\r\n    <script>\r\n        var vue = new Vue({\r\n            el: \"#app\",\r\n            /*model：数据*/\r\n            data:{\r\n                ok: true\r\n            },\r\n        });\r\n    </script>\r\n</body>\r\n```\r\n\r\n![image-20220526093015013](cloudDisk/markdown/vue笔记.assets/image-20220526093015013.png)\r\n\r\n当修改值ok为false\r\n\r\n![image-20220526093056673](cloudDisk/markdown/vue笔记.assets/image-20220526093056673.png)\r\n\r\n\r\n\r\n### 2)\r\n\r\n```HTML\r\n<body>\r\n<!--view层 模板-->\r\n    <div id=\"app\">\r\n        <h1 v-if=\"type===\'A\'\">A</h1>\r\n        <h1 v-else-if=\"type===\'B\'\">B</h1>\r\n        <h1 v-else-if=\"type===\'D\'\">C</h1>\r\n        <h1 v-else>C</h1>\r\n    </div>\r\n\r\n    <script src=\"vuejs-2.5.16.js\"></script>\r\n    <script>\r\n        var vue = new Vue({\r\n            el: \"#app\",\r\n            /*model：数据*/\r\n            data:{\r\n                type: \'A\'\r\n            },\r\n        });\r\n    </script>\r\n</body>\r\n```\r\n\r\n![image-20220526093436145](cloudDisk/markdown/vue笔记.assets/image-20220526093436145.png)\r\n\r\n![image-20220526093456576](cloudDisk/markdown/vue笔记.assets/image-20220526093456576.png)\r\n\r\n## v-for\r\n\r\n### 1）\r\n\r\n```html\r\n<body>\r\n<!--view层 模板-->\r\n    <div id=\"app\">\r\n        <li v-for=\"item in items\">\r\n            {{item.message}}\r\n        </li>\r\n    </div>\r\n\r\n    <script src=\"vuejs-2.5.16.js\"></script>\r\n    <script>\r\n        var vue = new Vue({\r\n            el: \"#app\",\r\n            /*model：数据*/\r\n            data:{\r\n                items: [\r\n                    {message: \"hello world\"},\r\n                    {message: \"world hello\"}\r\n                ]\r\n            },\r\n        });\r\n    </script>\r\n</body>\r\n```\r\n\r\n![image-20220526094008222](cloudDisk/markdown/vue笔记.assets/image-20220526094008222.png)\r\n\r\n\r\n\r\n\r\n\r\n### 3）索引\r\n\r\n```html\r\n<body>\r\n<!--view层 模板-->\r\n    <div id=\"app\">\r\n        <li v-for=\"(item,index) in items\">\r\n            {{item.message}} -- {{index}}\r\n        </li>\r\n    </div>\r\n\r\n    <script src=\"vuejs-2.5.16.js\"></script>\r\n    <script>\r\n        var vue = new Vue({\r\n            el: \"#app\",\r\n            /*model：数据*/\r\n            data:{\r\n                items: [\r\n                    {message: \"hello world\"},\r\n                    {message: \"world hello\"},\r\n                    {message: \"hello vue\"}\r\n                ]\r\n            },\r\n        });\r\n    </script>\r\n</body>\r\n```\r\n\r\n![image-20220526094211175](cloudDisk/markdown/vue笔记.assets/image-20220526094211175.png)\r\n\r\n\r\n\r\n# 事件绑定\r\n\r\n## v-on\r\n\r\n```html\r\n<body>\r\n<!--view层 模板-->\r\n    <div id=\"app\">\r\n        <button v-on:click=\"sayHi\">click me</button>\r\n    </div>\r\n\r\n    <script src=\"vuejs-2.5.16.js\"></script>\r\n    <script>\r\n        var vue = new Vue({\r\n            el: \"#app\",\r\n            /*model：数据*/\r\n            data: {\r\n                message: \"hello vue\"\r\n            },\r\n            methods: { // 定义在vue 的method方法\r\n                sayHi: function () {\r\n                    alert(this.message)\r\n                }\r\n\r\n            }\r\n        });\r\n    </script>\r\n</body>\r\n```\r\n\r\n![image-20220526094715307](cloudDisk/markdown/vue笔记.assets/image-20220526094715307.png)\r\n\r\n\r\n\r\n# vue双向绑定\r\n\r\n![image-20220526100254056](cloudDisk/markdown/vue笔记.assets/image-20220526100254056.png)\r\n\r\n## 1）input\r\n\r\n1. 改变输入框内容，model跟着一起变\r\n\r\n```html\r\n<body>\r\n<!--view层 模板-->\r\n    <div id=\"app\">\r\n        输入文本：<input type=\"text\" v-model=\"message\"><br>\r\n        也可以输入文本：<input type=\"text\" v-model=\"message\"><br>\r\n        <h3>{{message}}</h3><br>\r\n    </div>\r\n\r\n    <script src=\"vuejs-2.5.16.js\"></script>\r\n    <script>\r\n        var vue = new Vue({\r\n            el: \"#app\",\r\n            data: {\r\n                message: \"123123\"\r\n            }\r\n\r\n        });\r\n    </script>\r\n</body>\r\n```\r\n\r\n![image-20220526095458359](cloudDisk/markdown/vue笔记.assets/image-20220526095458359.png)\r\n\r\n\r\n\r\n2. 改变model，页面数据跟着变\r\n\r\n   ![image-20220526095616942](cloudDisk/markdown/vue笔记.assets/image-20220526095616942.png)\r\n\r\n## 2）radio\r\n\r\n```html\r\n<body>\r\n<!--view层 模板-->\r\n    <div id=\"app\">\r\n        性别：\r\n        <input type=\"radio\" name=\"sex\" value=\"男\" v-model=\"tony\">男\r\n        <input type=\"radio\" name=\"sex\" value=\"女\" v-model=\"tony\">女\r\n\r\n        <p>\r\n            选中了谁：{{tony}}\r\n        </p>\r\n    </div>\r\n\r\n    <script src=\"vuejs-2.5.16.js\"></script>\r\n    <script>\r\n        var vue = new Vue({\r\n            el: \"#app\",\r\n            data: {\r\n                tony: \"\"\r\n            }\r\n\r\n        });\r\n    </script>\r\n</body>\r\n```\r\n\r\n![image-20220526100002478](cloudDisk/markdown/vue笔记.assets/image-20220526100002478.png)\r\n\r\n## 3）select\r\n\r\n```html\r\n<body>\r\n<!--view层 模板-->\r\n    <div id=\"app\">\r\n        <select v-model=\"tony\">\r\n            <option value=\"\" disabled>--请选择--</option>\r\n            <option>A</option>\r\n            <option>B</option>\r\n            <option>C</option>\r\n        </select>\r\n\r\n        <p>\r\n            选中了：{{tony}}\r\n        </p>\r\n    </div>\r\n\r\n    <script src=\"vuejs-2.5.16.js\"></script>\r\n    <script>\r\n        var vue = new Vue({\r\n            el: \"#app\",\r\n            data: {\r\n                tony: \"\"\r\n            }\r\n\r\n        });\r\n    </script>\r\n</body>\r\n```\r\n\r\n![image-20220526100526400](cloudDisk/markdown/vue笔记.assets/image-20220526100526400.png)\r\n\r\n# vue组件\r\n\r\n类似thymeleaf中的fragment\r\n\r\n![image-20220526100711517](cloudDisk/markdown/vue笔记.assets/image-20220526100711517.png)\r\n\r\n```html\r\n<body>\r\n<!--view层 模板-->\r\n    <div id=\"app\">\r\n        <tony v-for=\"item in items\" v-bind:hello=\"item\"></tony>\r\n    </div>\r\n\r\n    <script src=\"vuejs-2.5.16.js\"></script>\r\n    <script>\r\n        // 定义一个Vue组件component\r\n        Vue.component(\"tony\", {\r\n            props: [\"hello\"],\r\n            template: \"<li>{{hello}}</li>\"\r\n        });\r\n\r\n        var vue = new Vue({\r\n            el: \"#app\",\r\n            data: {\r\n                items: [\"java\", \"linux\", \"vue\"]\r\n            }\r\n        });\r\n    </script>\r\n</body>\r\n```\r\n\r\n1. 定义tony标签\r\n2. v-for=\"item in items\" 遍历标签\r\n3. 将item数据绑定到hello：v-bind:hello=\"item\"\r\n4. 定义的标签获取数据：props: [\"hello\"],\r\n\r\n![image-20220526101727972](cloudDisk/markdown/vue笔记.assets/image-20220526101727972.png)\r\n\r\n# Vue生命周期\r\n\r\n1. 创建一个Vue实例对象\r\n\r\n2. 创建一个空的Vue实例对象。对象中只有一些默认的生命周期和默认的事件,这时候data和methods中的数据都还没有初始化。\r\n\r\n3. **生命周期钩子：beforeCreate**\r\n\r\n4. 初始化data与methods\r\n\r\n5. **生命周期钩子：created**\r\n\r\n6. 是否指定**“el”**（绑定元素）选项？没有指定的话会选择调用vm.$mount(el)函数\r\n\r\n7. 是否指定\r\n\r\n   “template”\r\n\r\n   （模板）选项？将template编译到\r\n\r\n   render\r\n\r\n   （渲染）函数中 ：将el外部的HTML作为template编译\r\n\r\n   > 6~7 :Vue开始编辑模板。执行Vue中的指令，在内存中生成一个编译好的最终模板字符串。然后将这个模板字符串渲染为内存中的DOM。**注意**：此时DOM只存在于内存中，渲染好的模板并没有真正挂载到页面中去。\r\n\r\n8. **生命周期钩子：beforeMount**\r\n\r\n9. 将内存中渲染好的模板挂载到页面中\r\n\r\n10. 生命周期钩子：mount\r\n\r\n    ，这时候可以操作页面上的DOM节点了\r\n\r\n    > 1~10：创建阶段\r\n\r\n11. loop：—-> 挂载完毕 —-> 修改data —->生命周期钩子：beforeUpdate\r\n\r\n    ，页面中的数据还是旧的，data中的数据却已经修改过了，此时data数据与页面数据尚未同步 —-> 根据data中最新的数据重新渲染DOM树，新的DOM树重新渲染到页面中。 —-> 生命周期钩子：update\r\n\r\n    —->\r\n\r\n    > 11：刷新DOM\r\n\r\n12. 调用vm.$destroy()函数\r\n\r\n13. **生命周期钩子：beforeDestroy**，此时data、methods等等都还处于可用状态，还没有正式销毁。\r\n\r\n14. 解除绑定。销毁子组件以及事件监听器\r\n\r\n15. 生命周期钩子：destroy\r\n\r\n    组件被完全销毁，所有属性函数均不可用。\r\n\r\n    > 12~15：销毁组件\r\n\r\n![img](cloudDisk/markdown/vue笔记.assets/d44d5bcead6d03a6e40bc7d677aac864.jpeg)\r\n\r\n# Axios 异步通信\r\n\r\ndata.json:\r\n\r\n```json\r\n{\r\n  \"name\": \"狂神说Java\",\r\n  \"url\": \"https://bilibili.com/\",\r\n  \"page\": 1,\r\n  \"isNonProfit\": true,\r\n  \"address\": {\r\n    \"street\": \"含光门\",\r\n    \"city\": \"陕西西安\",\r\n    \"country\": \"中国\"\r\n  },\r\n  \"links\": [\r\n    {\r\n      \"name\": \"bilibili\",\r\n      \"ur1\": \"https://space.bilibili.com/95256449\"\r\n    },\r\n    {\r\n      \"name\": \"狂伸说java\",\r\n      \"url\": \"https://blog . kuangstudy. com\"\r\n    },\r\n    {\r\n      \"name\": \"百度\",\r\n      \"url\": \"https ://www. baidu. com/\"\r\n    }\r\n  ]\r\n}\r\n```\r\n\r\ntest.html:\r\n\r\n```html\r\n<!DOCTYPE html>\r\n<html lang=\"en\" xmlns:v-bind=\"http://www.w3.org/1999/xhtml\" xmlns:v-on=\"http://www.w3.org/1999/xhtml\">\r\n<head>\r\n    <meta charset=\"UTF-8\">\r\n    <title>Title</title>\r\n    <!--v-clock: 解决闪烁问题-->\r\n    <style>\r\n        [v-cloak]{\r\n            display: none;\r\n        }\r\n    </style>\r\n</head>\r\n<body>\r\n<!--view层 模板-->\r\n    <div id=\"app\" v-cloak>\r\n        <div>{{info.name}}</div>\r\n        <div>{{info.address.city}}</div>\r\n        <div>{{info.links[0].name}}</div>\r\n        <a v-bind:href=\"info.url\">点我</a>\r\n    </div>\r\n\r\n    <script src=\"vuejs-2.5.16.js\"></script>\r\n    <script src=\"axios-0.18.0.js\"></script>\r\n    <script>\r\n        var vue = new Vue({\r\n            el: \"#app\",\r\n            data(){\r\n                // 请求返回的json结果必须和info一样\r\n                return {\r\n                  info: {\r\n                      \"name\": null,\r\n                      \"address\": {\r\n                          \"street\": null,\r\n                          \"city\": null,\r\n                          \"country\": null\r\n                      },\r\n                      \"links\": [\r\n                          {\r\n                              \"name\": null,\r\n                              \"ur1\": null\r\n                          },\r\n                      ]\r\n                  }\r\n\r\n                }\r\n            },\r\n            mounted(){ // 钩子函数，链式编程 es6新特性\r\n                axios.get(\"data.json\").then(response=>(this.info = response.data));\r\n\r\n            }\r\n        });\r\n    </script>\r\n</body>\r\n</html>\r\n```\r\n\r\n![image-20220526130304292](cloudDisk/markdown/vue笔记.assets/image-20220526130304292.png)\r\n\r\n# 计算属性\r\n\r\n计算出来的结果，保存到属性中，内存中运行，虚拟dom\r\n\r\n![image-20220526131119918](cloudDisk/markdown/vue笔记.assets/image-20220526131119918.png)\r\n\r\n\r\n\r\n```html\r\n<body>\r\n<!--view层 模板-->\r\n    <div id=\"app\" v-cloak>\r\n        <p>currentTime1: {{currentTime1()}}</p>\r\n        <p>currentTime2: {{currentTime2}}</p>\r\n    </div>\r\n\r\n    <script src=\"vuejs-2.5.16.js\"></script>\r\n    <script src=\"axios-0.18.0.js\"></script>\r\n    <script>\r\n        var vue = new Vue({\r\n            el: \"#app\",\r\n            data: {\r\n                message: \"hello world\"\r\n            },\r\n            methods: {\r\n                currentTime1: function () {\r\n                    return Date.now(); // 返回当前时间戳\r\n                }\r\n            },\r\n            computed: { // 计算属性，methods、computed中的方法不能重名，重名只会调用methods中的方法\r\n                //\r\n                currentTime2: function () {\r\n                    this.message;\r\n                    return Date.now(); // 返回当前时间戳\r\n                }\r\n            }\r\n        });\r\n    </script>\r\n```\r\n\r\n![image-20220526131211641](cloudDisk/markdown/vue笔记.assets/image-20220526131211641.png)\r\n\r\n\r\n\r\n# 插槽slot\r\n\r\n![image-20220526131351472](cloudDisk/markdown/vue笔记.assets/image-20220526131351472.png)\r\n\r\n```html\r\n<body>\r\n<!--view层 模板-->\r\n    <div id=\"app\">\r\n        <todo>\r\n            <todo-title slot=\"todo-title\" v-bind:title=\"title\"></todo-title>\r\n            <todo-items slot=\"todo-items\" v-for=\"item in todoItems\" :item=\"item\"></todo-items>\r\n        </todo>\r\n    </div>\r\n\r\n    <script src=\"vuejs-2.5.16.js\"></script>\r\n    <script src=\"axios-0.18.0.js\"></script>\r\n    <script>\r\n        // slot: 插槽\r\n        Vue.component(\"todo\", {\r\n            template:\r\n                \"<div>\" +\r\n                    \"<slot name=\'todo-title\'></slot>\" +\r\n                    \"<ul>\" +\r\n                        \"<slot name=\'todo-items\'></slot>\" +\r\n                    \"</ul>\" +\r\n                \"</div>\"\r\n        });\r\n        Vue.component(\"todo-title\", {\r\n            props: [\"title\"],\r\n            template: \"<div>{{title}}</div>\"\r\n        })\r\n        Vue.component(\"todo-items\", {\r\n            props: [\"item\"],\r\n            template: \"<li>{{item}}</li>\"\r\n        })\r\n\r\n        var vue = new Vue({\r\n            el: \"#app\",\r\n            data: {\r\n                title: \"tony系列课程\",\r\n                todoItems: [\"java\", \"python\", \"c\", \"esp32\"]\r\n            }\r\n        });\r\n    </script>\r\n</body>\r\n```\r\n\r\n![image-20220526132734363](cloudDisk/markdown/vue笔记.assets/image-20220526132734363.png)\r\n\r\n\r\n\r\n# 自定义事件，页面分发\r\n\r\n```html\r\n<body>\r\n<!--view层 模板-->\r\n    <div id=\"app\">\r\n        <todo>\r\n            <todo-title slot=\"todo-title\" v-bind:title=\"title\"></todo-title>\r\n            <todo-items slot=\"todo-items\" v-bind:index=\"index\" v-on:remove=\"removeItem(index)\"\r\n                        v-for=\"(item,index) in todoItems\"  :item=\"item\"></todo-items>\r\n        </todo>\r\n    </div>\r\n\r\n    <script src=\"vuejs-2.5.16.js\"></script>\r\n    <script src=\"axios-0.18.0.js\"></script>\r\n    <script>\r\n        // slot: 插槽\r\n        Vue.component(\"todo\", {\r\n            template:\r\n                \"<div>\" +\r\n                    \"<slot name=\'todo-title\'></slot>\" +\r\n                    \"<ul>\" +\r\n                        \"<slot name=\'todo-items\'></slot>\" +\r\n                    \"</ul>\" +\r\n                \"</div>\"\r\n        });\r\n        Vue.component(\"todo-title\", {\r\n            props: [\"title\"],\r\n            template: \"<div>{{title}}</div>\"\r\n        })\r\n        Vue.component(\"todo-items\", {\r\n            props: [\"item\"],\r\n            template: \"<li>{{item}} <button v-on:click=\'remove\'>删除</button></li>\",\r\n            methods: {\r\n                remove: function (index) {\r\n                    this.$emit(\"remove\", index);\r\n                }\r\n            }\r\n        })\r\n\r\n        var vue = new Vue({\r\n            el: \"#app\",\r\n            data: {\r\n                title: \"tony系列课程\",\r\n                todoItems: [\"java\", \"python\", \"c\", \"esp32\"]\r\n            },\r\n            methods: {\r\n                removeItem: function (index) {\r\n                    this.todoItems.splice(index, 1);\r\n                }\r\n            }\r\n        });\r\n    </script>\r\n</body>\r\n```\r\n\r\n![image-20220526170051662](cloudDisk/markdown/vue笔记.assets/image-20220526170051662.png)\r\n\r\n\r\n\r\n## 实现步骤\r\n\r\n### 1）定义模板\r\n\r\n```html\r\n<div id=\"app\">\r\n    <todo>\r\n        <todo-title></todo-title>\r\n        <todo-items></todo-items>\r\n    </todo>\r\n</div>\r\n\r\n// slot: 插槽\r\nVue.component(\"todo\", {\r\ntemplate:\r\n\"<div>\" +\r\n    \"<slot name=\'todo-title\'></slot>\" +\r\n    \"<ul>\" +\r\n    \"<slot name=\'todo-items\'></slot>\" +\r\n    \"</ul>\" +\r\n    \"</div>\"\r\n});\r\nVue.component(\"todo-title\", {\r\n\r\n})\r\nVue.component(\"todo-items\", {\r\n\r\n})\r\n```\r\n\r\n### 2）绑定数据\r\n\r\n```html\r\n    <div id=\"app\">\r\n        <todo>\r\n            <todo-title slot=\"todo-title\" v-bind:title=\"title\"></todo-title>\r\n            <todo-items slot=\"todo-items\" v-bind:item=\"item\" v-for=\"item in todoItems\"></todo-items>\r\n        </todo>\r\n    </div>\r\n\r\n    <script src=\"vuejs-2.5.16.js\"></script>\r\n    <script src=\"axios-0.18.0.js\"></script>\r\n    <script>\r\n        // slot: 插槽\r\n        Vue.component(\"todo\", {\r\n            template:\r\n                \"<div>\" +\r\n                    \"<slot name=\'todo-title\'></slot>\" +\r\n                    \"<ul>\" +\r\n                        \"<slot name=\'todo-items\'></slot>\" +\r\n                    \"</ul>\" +\r\n                \"</div>\"\r\n        });\r\n        Vue.component(\"todo-title\", {\r\n            props: [\"title\"],\r\n            template:\r\n                \"<div>{{title}}</div>\",\r\n        })\r\n        Vue.component(\"todo-items\", {\r\n            props: [\"item\"],\r\n            template:\r\n                \"<li>{{item}}</li>\"\r\n        })\r\n\r\n        var vue = new Vue({\r\n            el: \"#app\",\r\n            data: {\r\n                title: \"tony系列课程\",\r\n                todoItems: [\"java\", \"python\", \"c\", \"esp32\"]\r\n            },\r\n        });\r\n    </script>\r\n```\r\n\r\n![image-20220526173650091](cloudDisk/markdown/vue笔记.assets/image-20220526173650091.png)\r\n\r\n### 3）绑定删除事件，获取index\r\n\r\n```html\r\n<todo>\r\n    <todo-title slot=\"todo-title\" v-bind:title=\"title\"></todo-title>\r\n    <todo-items slot=\"todo-items\" v-bind:item=\"item\"\r\n                v-for=\"(item, index) in todoItems\" v-bind:index=\"index\"></todo-items>\r\n</todo>\r\n    Vue.component(\"todo-items\", {\r\n            props: [\"item\", \"index\"],\r\n            template:\r\n                \"<li>{{item}}<button v-on:click=\'deleteItem(index)\'>删除</button></li>\",\r\n            methods: {\r\n                deleteItem: function (index) {\r\n                    alert(index);\r\n                }\r\n            }\r\n        })\r\n```\r\n\r\n### 4）删除事件中，调用其他实例中的删除方法\r\n\r\n```html\r\n        <todo>\r\n            <todo-title slot=\"todo-title\" v-bind:title=\"title\"></todo-title>\r\n            <todo-items slot=\"todo-items\" v-bind:item=\"item\" v-bind:index=\"index\"\r\n                        v-for=\"(item, index) in todoItems\" :key=\"index\"\r\n                        v-bind:index=\"index\" v-on:remove=\"deleteItemByIndex(index)\"></todo-items>\r\n        </todo>\r\n\r\n\r\n```\r\n\r\n```html\r\n        Vue.component(\"todo-items\", {\r\n            props: [\"item\", \"index\"],\r\n            template:\r\n                \"<li>{{item}}<button v-on:click=\'deleteItem(index)\'>删除</button></li>\",\r\n            methods: {\r\n                deleteItem: function (index) {\r\n                    this.$emit(\"remove\", index);\r\n                }\r\n            }\r\n        })\r\n\r\n        var vue = new Vue({\r\n            el: \"#app\",\r\n            data: {\r\n                title: \"tony系列课程\",\r\n                todoItems: [\"java\", \"python\", \"c\", \"esp32\"]\r\n            },\r\n            methods: {\r\n                deleteItemByIndex: function (index) {\r\n                    this.todoItems.splice(index, 1);\r\n                }\r\n            }\r\n        });\r\n```\r\n\r\n\r\n\r\n## 难点分析\r\n\r\n```html\r\n<todo-items slot=\"todo-items\" v-bind:item=\"item\" v-bind:index=\"index\"\r\n            v-for=\"(item, index) in todoItems\" :key=\"index\"\r\n             v-on:remove=\"deleteItemByIndex(index)\"></todo-items>\r\n```\r\n\r\n* v-for=\"(item, index) in todoItems\" :key=\"index\" **遍历标签**\r\n* slot=\"todo-items\" **绑定插槽**\r\n* v-bind:item=\"item\" v-bind:index=\"index\" **绑定变量**\r\n* v-on:remove=\"deleteItemByIndex(index)\" **绑定事件**\r\n\r\n```js\r\n        Vue.component(\"todo-items\", {\r\n            props: [\"item\", \"index\"],\r\n            template:\r\n                \"<li>{{item}}<button v-on:click=\'deleteItem(index)\'>删除</button></li>\",\r\n            methods: {\r\n                deleteItem: function (index) {\r\n                    this.$emit(\"remove\", index);\r\n                }\r\n            }\r\n        })\r\n```\r\n\r\n* this.$emit(\"remove\", index); **调用事件**\r\n\r\n```js\r\n        var vue = new Vue({\r\n            el: \"#app\",\r\n            data: {\r\n                title: \"tony系列课程\",\r\n                todoItems: [\"java\", \"python\", \"c\", \"esp32\"]\r\n            },\r\n            methods: {\r\n                deleteItemByIndex: function (index) {\r\n                    this.todoItems.splice(index, 1);\r\n                }\r\n            }\r\n        });\r\n```\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n# 第一个 vue-cli项目\r\n\r\n## 环境配置\r\n\r\n1. 安装node.js\r\n\r\n2. cmd测试是否成功安装：\r\n\r\n   ![image-20220526180213425](cloudDisk/markdown/vue笔记.assets/image-20220526180213425.png)\r\n\r\n   \r\n\r\n3. 安装淘宝镜像加速器\r\n\r\n```\r\nnpm install cnpm -g\r\n```\r\n\r\n![image-20220526180435742](cloudDisk/markdown/vue笔记.assets/image-20220526180435742.png)\r\n\r\n![image-20220526180742602](cloudDisk/markdown/vue笔记.assets/image-20220526180742602.png)\r\n\r\n4. 安装vue-cli\r\n\r\n```\r\ncnpm install vue-cli -g\r\n```\r\n\r\n\r\n\r\n## 新建项目\r\n\r\n1. 到这个文件夹\r\n\r\n![image-20220526181123644](cloudDisk/markdown/vue笔记.assets/image-20220526181123644.png)\r\n\r\n\r\n\r\n\r\n\r\n2. 运行cmd\r\n\r\n![image-20220526181159660](cloudDisk/markdown/vue笔记.assets/image-20220526181159660.png)\r\n\r\n```\r\nvue init webpack myvue\r\n```\r\n\r\n3. ![image-20220526181939758](cloudDisk/markdown/vue笔记.assets/image-20220526181939758.png)\r\n\r\n4. ![image-20220526181945277](cloudDisk/markdown/vue笔记.assets/image-20220526181945277.png)\r\n\r\n5. 安装依赖\r\n\r\n   ![image-20220526182238894](cloudDisk/markdown/vue笔记.assets/image-20220526182238894.png)\r\n\r\n   \r\n\r\n6. 运行项目\r\n\r\n   ```\r\n   npm run dev\r\n   ```\r\n\r\n   ![image-20220526182707755](cloudDisk/markdown/vue笔记.assets/image-20220526182707755.png)\r\n\r\n\r\n\r\n## idea打开项目\r\n\r\n![image-20220526182926669](cloudDisk/markdown/vue笔记.assets/image-20220526182926669.png)\r\n\r\n\r\n\r\n## 安装webpack\r\n\r\nnpm install webpack -g\r\n\r\nnpm install webpack-cli -g\r\n\r\n\r\n\r\n## 打包\r\n\r\n* 模块化编程思想\r\n* 将写的一些js，编译成一个js\r\n\r\n### 1) 创建以下文件\r\n\r\n![image-20220527004451100](cloudDisk/markdown/vue笔记.assets/image-20220527004451100.png)\r\n\r\nhello.js \r\n\r\n```js\r\n// 暴露一个方法\r\nexports.sayHi = function () {\r\n    document.write(\"<h1>tony</h1>\")\r\n}\r\nexports.sayHi1 = function () {\r\n    document.write(\"<h1>tony</h1>\")\r\n}\r\nexports.sayHi2 = function () {\r\n    document.write(\"<h1>tony</h1>\")\r\n}\r\nexports.sayHi3 = function () {\r\n    document.write(\"<h1>tony</h1>\")\r\n}\r\n```\r\n\r\n* 定义方法，导出，能被外部访问到\r\n\r\n\r\n\r\nmain.js\r\n\r\n```js\r\nvar hello = require(\"./hello\");\r\nhello.sayHi();\r\n```\r\n\r\n* 导入hello，可以理解为导入了这个类，创建了对象\r\n\r\n\r\n\r\nwebpack.config.js\r\n\r\n```js\r\nmodule.exports = {\r\n    entry: \"./modules/main.js\",\r\n    output: {\r\n        filename: \"./js/bundle.js\"\r\n    }\r\n}\r\n```\r\n\r\n\r\n\r\n### 2）打包指令\r\n\r\n![image-20220527004725416](cloudDisk/markdown/vue笔记.assets/image-20220527004725416.png)\r\n\r\n\r\n\r\n### 3）测试运行\r\n\r\nindex.html\r\n\r\n```html\r\n<!DOCTYPE html>\r\n<html lang=\"en\">\r\n<head>\r\n    <meta charset=\"UTF-8\">\r\n    <title>Title</title>\r\n</head>\r\n<body>\r\n<!--前端的模块化开发-->\r\n<script src=\"dist/js/bundle.js\"></script>\r\n</body>\r\n</html>\r\n```\r\n\r\n![image-20220527004832541](cloudDisk/markdown/vue笔记.assets/image-20220527004832541.png)\r\n\r\n# Vue: vue-router路由\r\n\r\n## 1）安装路由\r\n\r\n打开之前创建的空项目\r\n\r\n\r\n\r\nnpm install vue-router --save-dev\r\n\r\n若报错，改成：npm install --legacy-peer-deps vue-router@3.5.2\r\n\r\n之后： npm audit fix\r\n\r\n## 2）创建以下文件\r\n\r\n![image-20220527011736822](cloudDisk/markdown/vue笔记.assets/image-20220527011736822.png)\r\n\r\n\r\n\r\nContent.vue\r\n\r\n```vue\r\n<template>\r\n  <h1>内容页</h1>\r\n</template>\r\n\r\n<script>\r\n\r\n    export default {\r\n        name: \"Content\"\r\n    }\r\n</script>\r\n\r\n<style scoped>\r\n\r\n</style>\r\n```\r\n\r\n* 组件\r\n\r\n\r\n\r\nMain.vue\r\n\r\n```vue\r\n<template>\r\n  <h1>首页</h1>\r\n</template>\r\n\r\n<script>\r\n    export default {\r\n        name: \"Main\"\r\n    }\r\n</script>\r\n\r\n<style scoped>\r\n\r\n</style>\r\n```\r\n\r\n* 组件\r\n\r\n\r\n\r\nindex.js\r\n\r\n```js\r\nimport Vue from \'vue\'\r\nimport VueRouter from \'vue-router\'\r\nimport Main from \"../components/Content\";\r\nimport Content from \"../components/Main\";\r\n\r\n// 安装路由\r\nVue.use(VueRouter);\r\n\r\n// 配置导出路由\r\nexport default new VueRouter({\r\n  routes: [\r\n    {\r\n      // 路由路径 @RquestMapping\r\n      path: \'/content\',\r\n      name: \'content\',\r\n      // 路由的组件\r\n      component: Content\r\n    },\r\n    {\r\n      // 路由路径\r\n      path: \'/main\',\r\n      name: \'content\',\r\n      // 路由的组件\r\n      component: Main\r\n    }\r\n  ]\r\n})\r\n```\r\n\r\n* 路由配置\r\n\r\n\r\n\r\nmain.js\r\n\r\n```js\r\nimport Vue from \'vue\'\r\nimport App from \'./App\'\r\nimport router from \'./router\' // 自动扫描里面的路由配置\r\n\r\nVue.config.productionTip = false\r\n\r\n/* eslint-disable no-new */\r\nnew Vue({\r\n  el: \'#app\',\r\n  // 配置路由\r\n  router,\r\n  components: { App },\r\n  template: \'<App/>\'\r\n})\r\n\r\n```\r\n\r\n* router ：配置路由\r\n\r\n\r\n\r\nApp.vue\r\n\r\n```vue\r\n<template>\r\n  <div id=\"app\">\r\n    <router-link to=\"/main\">首页</router-link>\r\n    <router-link to=\"/content\">内容页</router-link>\r\n    <router-view></router-view>\r\n  </div>\r\n</template>\r\n\r\n<script>\r\nexport default {\r\n  name: \'App\',\r\n}\r\n</script>\r\n\r\n<style>\r\n#app {\r\n  font-family: \'Avenir\', Helvetica, Arial, sans-serif;\r\n  -webkit-font-smoothing: antialiased;\r\n  -moz-osx-font-smoothing: grayscale;\r\n  text-align: center;\r\n  color: #2c3e50;\r\n  margin-top: 60px;\r\n}\r\n</style>\r\n\r\n```\r\n\r\n* router-link : 视图跳转\r\n* router-view：视图展示\r\n\r\n## 3) 运行\r\n\r\nnpm run dev\r\n\r\n![image-20220527012013679](cloudDisk/markdown/vue笔记.assets/image-20220527012013679.png)\r\n\r\n# vue + elementui\r\n\r\n创建项目\r\n\r\n```\r\n# 新建项目\r\nvue init webpack hello-vue\r\n# 安装vue-router\r\nnpm install --legacy-peer-deps vue-router@3.5.2\r\n	npm audit fix\r\n# 安装element-ui\r\nnpm i element-ui -S\r\n# 安装依赖\r\nnpm install\r\n# 安装sass加载器\r\ncnpm install sass-loader node-sass --save-dev\r\n# 启动\r\nnpm run dev\r\n```\r\n\r\n解释：\r\n\r\n![image-20220527013006122](cloudDisk/markdown/vue笔记.assets/image-20220527013006122.png)\r\n\r\n* element-ui：https://element.eleme.cn/#/zh-CN/component/installation\r\n\r\n\r\n\r\nsass-loader 报错：https://blog.csdn.net/drhrht/article/details/123372949\r\n\r\n\r\n\r\n## 创建登录页面\r\n\r\n把没有用的初始化东西删掉！\r\n  在源码目录中创建如下结构：\r\n\r\n- assets：用于存放资源文件\r\n- components：用于存放Vue功能组件\r\n- views：用于存放Vue视图组件\r\n- router：用于存放vue-router配置\r\n\r\n\r\n\r\n![在这里插入图片描述](cloudDisk/markdown/vue笔记.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Bhbl9oMTk5NQ==,size_16,color_FFFFFF,t_70.png)\r\n\r\n\r\n\r\n**创建首页视图，在views目录下创建一个名为Main.vue的视图组件：**\r\n\r\n```html\r\n<template>\r\n	<div>首页</div>\r\n</template>\r\n<script>\r\n	export default {\r\n			name:\"Main\"\r\n	}\r\n</script>\r\n<style scoped>\r\n</style>\r\n```\r\n\r\n创建登录页视图在views目录下创建名为Login.vue的视图组件，其中el-*的元素为ElementUI组件；\r\n\r\n```vue\r\n<template>\r\n  <div>\r\n    <el-form ref=\"loginForm\" :model=\"form\" :rules=\"rules\" label-width=\"80px\" class=\"login-box\">\r\n      <h3 class=\"login-title\">欢迎登录</h3>\r\n      <el-form-item label=\"账号\" prop=\"username\">\r\n        <el-input type=\"text\" placeholder=\"请输入账号\" v-model=\"form.username\"/>\r\n      </el-form-item>\r\n      <el-form-item label=\"密码\" prop=\"password\">\r\n        <el-input type=\"password\" placeholder=\"请输入密码\" v-model=\"form.password\"/>\r\n      </el-form-item>\r\n      <el-form-item>\r\n        <el-button type=\"primary\" v-on:click=\"onsubmit(\'loginForm\')\">登录</el-button>\r\n      </el-form-item>\r\n    </el-form>\r\n\r\n    <el-dialog title=\"温馨提示\" :visible.sync=\"dialogVisiable\" width=\"30%\" :before-close=\"handleClose\">\r\n      <span>请输入账号和密码</span>\r\n      <span slot=\"footer\" class=\"dialog-footer\">\r\n          <el-button type=\"primary\" @click=\"dialogVisible = false\">确定</el-button>\r\n        </span>\r\n    </el-dialog>\r\n  </div>\r\n</template>\r\n\r\n<script>\r\n    export default {\r\n        name: \"Login\",\r\n      data(){\r\n          return{\r\n            form:{\r\n              username:\'\',\r\n              password:\'\'\r\n            },\r\n            //表单验证，需要在 el-form-item 元素中增加prop属性\r\n            rules:{\r\n              username:[\r\n                {required:true,message:\"账号不可为空\",trigger:\"blur\"}\r\n              ],\r\n              password:[\r\n                {required:true,message:\"密码不可为空\",tigger:\"blur\"}\r\n              ]\r\n            },\r\n\r\n            //对话框显示和隐藏\r\n            dialogVisible:false\r\n          }\r\n      },\r\n      methods:{\r\n          onSubmit(formName){\r\n            //为表单绑定验证功能\r\n            this.$refs[formName].validate((valid)=>{\r\n              if(valid){\r\n                //使用vue-router路由到指定界面，该方式称为编程式导航\r\n                this.$router.push(\'/main\');\r\n              }else{\r\n                this.dialogVisible=true;\r\n                return false;\r\n              }\r\n            });\r\n          }\r\n      }\r\n    }\r\n</script>\r\n\r\n<style lang=\"scss\" scoped>\r\n  .login-box{\r\n    border:1px solid #DCDFE6;\r\n    width: 350px;\r\n    margin:180px auto;\r\n    padding: 35px 35px 15px 35px;\r\n    border-radius: 5px;\r\n    -webkit-border-radius: 5px;\r\n    -moz-border-radius: 5px;\r\n    box-shadow: 0 0 25px #909399;\r\n  }\r\n  .login-title{\r\n    text-align:center;\r\n    margin: 0 auto 40px auto;\r\n    color: #303133;\r\n  }\r\n</style>\r\n```\r\n\r\n创建路由，在router目录下创建一个名为`index.js`的vue-router路由配置文件\r\n\r\n```js\r\n//导入vue\r\nimport Vue from \'vue\';\r\nimport VueRouter from \'vue-router\';\r\n//导入组件\r\nimport Main from \"../views/Main\";\r\nimport Login from \"../views/Login\";\r\n//使用\r\nVue.use(VueRouter);\r\n//导出\r\nexport default new VueRouter({\r\n  routes: [\r\n    {\r\n      //登录页\r\n      path: \'/main\',\r\n      component: Main\r\n    },\r\n    //首页\r\n    {\r\n      path: \'/login\',\r\n      component: Login\r\n    },\r\n  ]\r\n\r\n})\r\n```\r\n\r\nAPP.vue\r\n\r\n```js\r\n<template>\r\n  <div id=\"app\">\r\n    <router-view></router-view>\r\n  </div>\r\n</template>\r\n\r\n<script>\r\n\r\n\r\nexport default {\r\n  name: \'App\',\r\n\r\n}\r\n</script>\r\n\r\n<style>\r\n#app {\r\n  font-family: \'Avenir\', Helvetica, Arial, sans-serif;\r\n  -webkit-font-smoothing: antialiased;\r\n  -moz-osx-font-smoothing: grayscale;\r\n  text-align: center;\r\n  color: #2c3e50;\r\n  margin-top: 60px;\r\n}\r\n</style>\r\n```\r\n\r\nmain.js\r\n\r\n```js\r\nimport Vue from \'vue\'\r\nimport App from \'./App\'\r\nimport router from \"./router\"\r\n\r\nimport ElementUI from \'element-ui\'\r\nimport \'element-ui/lib/theme-chalk/index.css\'\r\n\r\nVue.use(router)\r\nVue.use(ElementUI)\r\n\r\n/* eslint-disable no-new */\r\nnew Vue({\r\n  el: \'#app\',\r\n  router,\r\n  render:h=>h(App)\r\n})\r\n```\r\n\r\n测试：在浏览器打开 http://localhost:8080/#/login\r\n如果出现错误: 可能是因为sass-loader的版本过高导致的编译错误，当前最高版本是8.0.2，需要退回到7.3.1 ；\r\n去package.json文件里面的 \"sass-loader\"的版本更换成7.3.1，然后重新cnpm install就可以了；\r\n\r\n![image-20220527021610246](cloudDisk/markdown/vue笔记.assets/image-20220527021610246.png)\r\n\r\n## 路由嵌套\r\n\r\n嵌套路由又称子路由，在实际应用中，通常由多层嵌套的组件组合而成。\r\ndemo\r\n\r\n### 1、 创建用户信息组件，在 views/user 目录下创建一个名为 Profile.vue 的视图组件；\r\n\r\nProfile.vue\r\n\r\n```vue\r\n<template>\r\n  <h1>个人信息</h1>\r\n</template>\r\n<script>\r\n  export default {\r\n    name: \"UserProfile\"\r\n  }\r\n</script>\r\n<style scoped>\r\n</style>\r\n```\r\n\r\n\r\n\r\n### 2、在用户列表组件在 views/user 目录下创建一个名为 List.vue 的视图组件；\r\n\r\nList.vue\r\n\r\n```vue\r\n<template>\r\n  <h1>用户列表</h1>\r\n</template>\r\n<script>\r\n  export default {\r\n    name: \"UserList\"\r\n  }\r\n</script>\r\n<style scoped>\r\n</style>\r\n```\r\n\r\n\r\n\r\n### 3、 修改首页视图，我们修改 Main.vue 视图组件，此处使用了 ElementUI 布局容器组件，代码如下：\r\n\r\nMain.vue\r\n\r\n```vue\r\n<template>\r\n    <div>\r\n      <el-container>\r\n        <el-aside width=\"200px\">\r\n          <el-menu :default-openeds=\"[\'1\']\">\r\n            <el-submenu index=\"1\">\r\n              <template slot=\"title\"><i class=\"el-icon-caret-right\"></i>用户管理</template>\r\n              <el-menu-item-group>\r\n                <el-menu-item index=\"1-1\">\r\n                <!--插入的地方-->\r\n                  <router-link to=\"/user/profile\">个人信息</router-link>\r\n                </el-menu-item>\r\n                <el-menu-item index=\"1-2\">\r\n                <!--插入的地方-->\r\n                  <router-link to=\"/user/list\">用户列表</router-link>\r\n                </el-menu-item>\r\n              </el-menu-item-group>\r\n            </el-submenu>\r\n            <el-submenu index=\"2\">\r\n              <template slot=\"title\"><i class=\"el-icon-caret-right\"></i>内容管理</template>\r\n              <el-menu-item-group>\r\n                <el-menu-item index=\"2-1\">分类管理</el-menu-item>\r\n                <el-menu-item index=\"2-2\">内容列表</el-menu-item>\r\n              </el-menu-item-group>\r\n            </el-submenu>\r\n          </el-menu>\r\n        </el-aside>\r\n\r\n        <el-container>\r\n          <el-header style=\"text-align: right; font-size: 12px\">\r\n            <el-dropdown>\r\n              <i class=\"el-icon-setting\" style=\"margin-right: 15px\"></i>\r\n              <el-dropdown-menu slot=\"dropdown\">\r\n                <el-dropdown-item>个人信息</el-dropdown-item>\r\n                <el-dropdown-item>退出登录</el-dropdown-item>\r\n              </el-dropdown-menu>\r\n            </el-dropdown>\r\n          </el-header>\r\n          <el-main>\r\n          <!--在这里展示视图-->\r\n            <router-view />\r\n          </el-main>\r\n        </el-container>\r\n      </el-container>\r\n    </div>\r\n</template>\r\n<script>\r\n    export default {\r\n        name: \"Main\"\r\n    }\r\n</script>\r\n<style scoped lang=\"scss\">\r\n  .el-header {\r\n    background-color: #B3C0D1;\r\n    color: #333;\r\n    line-height: 60px;\r\n  }\r\n  .el-aside {\r\n    color: #333;\r\n  }\r\n</style>\r\n```\r\n\r\n### 4、 配置嵌套路由修改 router 目录下的 index.js 路由配置文件，使用children放入main中写入子模块，代码如下\r\n\r\nindex.js\r\n\r\n```js\r\n//导入vue\r\nimport Vue from \'vue\';\r\nimport VueRouter from \'vue-router\';\r\n//导入组件\r\nimport Main from \"../views/Main\";\r\nimport Login from \"../views/Login\";\r\n//导入子模块\r\nimport UserList from \"../views/user/List\";\r\nimport UserProfile from \"../views/user/Profile\";\r\n\r\n//使用\r\nVue.use(VueRouter);\r\n//导出\r\nexport default new VueRouter({\r\n  routes: [\r\n    {\r\n      //登录页\r\n      path: \'/main\',\r\n      component: Main,\r\n      //  写入子模块\r\n      children: [\r\n        {\r\n          path: \'/user/profile\',\r\n          component: UserProfile,\r\n        }, {\r\n          path: \'/user/list\',\r\n          component: UserList,\r\n        },\r\n      ]\r\n    },\r\n    //首页\r\n    {\r\n      path: \'/login\',\r\n      component: Login\r\n\r\n    },\r\n  ]\r\n})\r\n```\r\n\r\n### 5、 路由嵌套实战效果图\r\n\r\n![在这里插入图片描述](cloudDisk/markdown/vue笔记.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L29rRm9ycmVzdDI3,size_16,color_FFFFFF,t_70#pic_center.png)\r\n\r\n图 路由嵌套效果图\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n## 参数传递\r\n\r\n这里演示如果请求带有参数该怎么传递\r\ndemo\r\n 用的还是上述例子的代码 修改一些代码 这里不放重复的代码了\r\n第一种取值方式\r\n\r\n### 1、 修改路由配置, 主要是router下的index.js中的 path 属性中增加了 :id 这样的占位符\r\n\r\n```js\r\n{\r\n	path: \'/user/profile/:id\', \r\n	name:\'UserProfile\', \r\n	component: UserProfile\r\n}\r\n```\r\n\r\n### 2、传递参数\r\n\r\n 此时我们在Main.vue中的route-link位置处 to 改为了 :to，是为了将这一属性当成对象使用，注意 router-link 中的 name 属性名称 一定要和 路由中的 name 属性名称 匹配，因为这样 Vue 才能找到对应的路由路径；\r\n\r\n```vue\r\n<!--name是组件的名字 params是传的参数 如果要传参数的话就需要用v:bind:来绑定-->\r\n<router-link :to=\"{name:\'UserProfile\',params:{id:1}}\">个人信息</router-link>\r\n```\r\n\r\n### 3、在要展示的组件Profile.vue中接收参数 使用 {{$route.params.id}}来接收\r\n\r\nProfile.vue 部分代码\r\n\r\n```vue\r\n<template>\r\n  <!--  所有的元素必须在根节点下-->\r\n  <div>\r\n    <h1>个人信息</h1>\r\n    {{$route.params.id}}\r\n  </div>\r\n</template>\r\n```\r\n\r\n## 第二种取值方式 使用props 减少耦合\r\n\r\n### 1、修改路由配置 , 主要在router下的index.js中的路由属性中增加了 props: true 属性\r\n\r\n```javascript\r\n{\r\n	path: \'/user/profile/:id\', \r\n	name:\'UserProfile\', \r\n	component: UserProfile, \r\n	props: true\r\n}\r\n```\r\n\r\n### 2、传递参数和之前一样 在Main.vue中修改route-link地址\r\n\r\n```vue\r\n<!--name是组件的名字 params是传的参数 如果要传参数的话就需要用v:bind:来绑定-->\r\n<router-link :to=\"{name:\'UserProfile\',params:{id:1}}\">个人信息</router-link>\r\n```\r\n\r\n### 3、在Profile.vue接收参数为目标组件增加 props 属性\r\n\r\nProfile.vue\r\n\r\n```vue\r\n<template>\r\n  <div>\r\n    个人信息\r\n    {{ id }}\r\n  </div>\r\n</template>\r\n<script>\r\n    export default {\r\n      props: [\'id\'],\r\n      name: \"UserProfile\"\r\n    }\r\n</script>\r\n<style scoped>\r\n</style>\r\n```\r\n\r\n![在这里插入图片描述](cloudDisk/markdown/vue笔记.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L29rRm9ycmVzdDI3,size_16,color_FFFFFF,t_70#pic_center-16535900083065.png)\r\n\r\n## 组件重定向\r\n\r\n重定向的意思大家都明白，但 Vue 中的重定向是作用在路径不同但组件相同的情况下，比如：\r\n在router下面index.js的配置\r\n\r\n```js\r\n{\r\n  path: \'/main\',\r\n  name: \'Main\',\r\n  component: Main\r\n},\r\n{\r\n  path: \'/goHome\',\r\n  redirect: \'/main\'\r\n}\r\n```\r\n\r\n说明：这里定义了两个路径，一个是 /main ，一个是 /goHome，其中 /goHome 重定向到了 /main 路径，由此可以看出重定向不需要定义组件；\r\n\r\n使用的话，只需要在Main.vue设置对应路径即可；\r\n\r\n```vue\r\n<el-menu-item index=\"1-3\">\r\n    <router-link to=\"/goHome\">回到首页</router-link>\r\n</el-menu-item>\r\n```\r\n\r\n\r\n\r\n\r\n\r\n## 路由模式与 404\r\n\r\n路由模式有两种\r\n\r\n- hash：路径带 # 符号，如 http://localhost/#/login\r\n- history：路径不带 # 符号，如 http://localhost/login\r\n\r\n修改路由配置，代码如下：\r\n\r\n```vue\r\nexport default new Router({\r\n  mode: \'history\',\r\n  routes: [\r\n  ]\r\n});\r\n```\r\n\r\n404 demo\r\n\r\n### 1.创建一个NotFound.vue视图组件\r\n\r\nNotFound.vue\r\n\r\n```vue\r\n<template>\r\n    <div>\r\n      <h1>404,你的页面走丢了</h1>\r\n    </div>\r\n</template>\r\n<script>\r\n    export default {\r\n        name: \"NotFound\"\r\n    }\r\n</script>\r\n<style scoped>\r\n</style>\r\n```\r\n\r\n### 2.修改路由配置index.js\r\n\r\n```js\r\nimport NotFound from \'../views/NotFound\'\r\n{\r\n   path: \'*\',\r\n   component: NotFound\r\n}\r\n```\r\n\r\n### 3.效果图\r\n\r\n![在这里插入图片描述](cloudDisk/markdown/vue笔记.assets/20200624142229445.png)\r\n\r\n\r\n\r\n## **路由钩子与异步请求**\r\n\r\nbeforeRouteEnter：在进入路由前执行\r\nbeforeRouteLeave：在离开路由前执行\r\n\r\n\r\n\r\n在Profile.vue中写\r\n\r\n```vue\r\nexport default {\r\n    name: \"UserProfile\",\r\n    beforeRouteEnter: (to, from, next) => {\r\n      console.log(\"准备进入个人信息页\");\r\n      next();\r\n    },\r\n    beforeRouteLeave: (to, from, next) => {\r\n      console.log(\"准备离开个人信息页\");\r\n      next();\r\n    }\r\n  }\r\n```\r\n\r\n参数说明：\r\nto：路由将要跳转的路径信息\r\nfrom：路径跳转前的路径信息\r\nnext：路由的控制参数\r\nnext() 跳入下一个页面\r\nnext(’/path’) 改变路由的跳转方向，使其跳到另一个路由\r\nnext(false) 返回原来的页面\r\nnext((vm)=>{}) 仅在 beforeRouteEnter 中可用，vm 是组件实例\r\n\r\n### **在钩子函数中使用异步请求**\r\n\r\n1、安装 Axios\r\n\r\n```\r\ncnpm install --save vue-axios\r\n```\r\n\r\n2、main.js引用 Axios\r\n\r\n```vue\r\nimport axios from \'axios\'\r\nimport VueAxios from \'vue-axios\'\r\nVue.use(VueAxios, axios)\r\n```\r\n\r\n3、准备数据 ： 只有我们的 static 目录下的文件是可以被访问到的，所以我们就把静态文件放入该目录下。\r\n数据和之前用的json数据一样 需要的去上述axios例子里\r\n\r\n```\r\n// 静态数据存放的位置\r\nstatic/mock/data.json\r\n```\r\n\r\n4.在 beforeRouteEnter 中进行异步请求\r\n\r\nProfile.vue\r\n\r\n```vue\r\nexport default {\r\n    //第二种取值方式\r\n    // props:[\'id\'],\r\n    name: \"UserProfile\",\r\n    //钩子函数 过滤器\r\n    beforeRouteEnter: (to, from, next) => {\r\n      //加载数据\r\n      console.log(\"进入路由之前\")\r\n      next(vm => {\r\n        //进入路由之前执行getData方法\r\n        vm.getData()\r\n      });\r\n    },\r\n    beforeRouteLeave: (to, from, next) => {\r\n      console.log(\"离开路由之前\")\r\n      next();\r\n    },\r\n    //axios\r\n    methods: {\r\n      getData: function () {\r\n        this.axios({\r\n          method: \'get\',\r\n          url: \'http://localhost:8080/static/mock/data.json\'\r\n        }).then(function (response) {\r\n          console.log(response)\r\n        })\r\n      }\r\n    }\r\n  }\r\n```\r\n\r\n5.路由钩子和axios结合图\r\n\r\n![在这里插入图片描述](cloudDisk/markdown/vue笔记.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L29rRm9ycmVzdDI3,size_16,color_FFFFFF,t_70#pic_center-16535905931998.png)\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n','2022-06-23 21:35:00','Vue.js（读音 /vjuː/, 类似于 view） 是一套构建用户界面的渐进式框架。\r\n\r\nVue 只关注视图层， 采用自底向上增量开发的设计。\r\n\r\nVue 的目标是通过尽可能简单的 API 实现响应的数据绑定和组合的视图组件。','cloudDisk\\markdown\\2022-6-23-213410vue.png','原创','','','\0','Vue 学习笔记','2022-06-23 21:35:00',0,98,NULL,0),(167,'','# 一、基本操作\r\n\r\n## 视频帧读取\r\n\r\n```python\r\nimport cv2\r\nvc = cv2.VideoCapture(\"test.mp4\")\r\nif vc.isOpened():\r\n    open, frame = vc.read()\r\nelse:\r\n    open = False\r\nwhile open:\r\n    ret, frame = vc.read()\r\n    if frame is None: break\r\n    if ret == True:\r\n        gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)\r\n        cv2.imshow(\"result\", gray)\r\n        if cv2.waitKey(100) & 0xFF==27:\r\n            break\r\nvc.release()\r\ncv2.destroyWindow()\r\n\r\n```\r\n\r\n## 图片裁剪\r\n\r\n```python\r\nimport cv2\r\nimg = cv2.imread(\"test.jpg\",1)\r\ncat = img[0:200, 0:200]\r\ncv2.imshow(\"name\", cat)\r\ncv2.waitKey(0)\r\ncv2.destroyAllWindows()\r\n```\r\n\r\n\r\n\r\n## 颜色通道提取及合并\r\n\r\n```python\r\nimport cv2\r\nimg = cv2.imread(\"test.jpg\", 1)\r\nb,g,r = cv2.split(img) # 图片分割成3通道\r\n# print(b.shape,g.shape,r.shape) # (1080, 1920) (1080, 1920) (1080, 1920)\r\n# print(img.shape) # (1080, 1920, 3)\r\nimg_merge = cv2.merge((b,g,r)) # 通道合并\r\ncv2.imshow(\"test.jpg\",img_merge)\r\ncv2.waitKey(0)\r\ncv2.destroyAllWindows()\r\n```\r\n\r\n## 显示单个通道\r\n\r\n```python\r\nimport cv2\r\nimg = cv2.imread(\"test.jpg\", 1)\r\n# 只显示红色通道\r\nimg_copy_1 = img.copy()\r\nimg_copy_1[:,:, 0] = 0\r\nimg_copy_1[:,:, 1] = 0\r\n# 只显示红色通道\r\nimg_copy_2 = img.copy()\r\nimg_copy_2[:,:, 0] = 0\r\nimg_copy_2[:,:, 2] = 0\r\n# 只显示红色通道\r\nimg_copy_3 = img.copy()\r\nimg_copy_3[:,:, 1] = 0\r\nimg_copy_3[:,:, 2] = 0\r\ncv2.imshow(\"B\",img_copy_1)\r\ncv2.waitKey(0)\r\ncv2.imshow(\"G\",img_copy_2)\r\ncv2.waitKey(0)\r\ncv2.imshow(\"R\",img_copy_3)\r\ncv2.waitKey(0)\r\ncv2.destroyAllWindows()\r\n```\r\n\r\n## 边界填充\r\n\r\n指定上下左右的一个大小值，上下左右各向外扩多少\r\n\r\n```python\r\ntop_size, bottom_size, left_size, right_size = (50, 50, 50, 50)\r\n```\r\n\r\n\r\n\r\n![image-20211106220720370](cloudDisk/markdown/OpenCV笔记.assets/image-20211106220720370.png)\r\n\r\n```python\r\nimport cv2\r\nimport matplotlib.pyplot as plt\r\n# 边界填充\r\nimg = cv2.imread(\"test.jpg\")\r\ntop_size, bottom_size, left_size, right_size = (50, 50, 50, 50)\r\nreplicate = cv2.copyMakeBorder(img, top_size, bottom_size, left_size, right_size, borderType=cv2.BORDER_REPLICATE)\r\nreflect = cv2.copyMakeBorder(img, top_size, bottom_size, left_size, right_size, borderType=cv2.BORDER_REFLECT)\r\nreflect101 = cv2.copyMakeBorder(img, top_size, bottom_size, left_size, right_size, borderType=cv2.BORDER_REFLECT_101)\r\nwrap = cv2.copyMakeBorder(img, top_size, bottom_size, left_size, right_size, borderType=cv2.BORDER_WRAP)\r\nconstant = cv2.copyMakeBorder(img, top_size, bottom_size, left_size, right_size, borderType=cv2.BORDER_CONSTANT,value=0)\r\n\r\n\r\nplt.subplot(231), plt.imshow(img, \"gray\"), plt.title(\"ORIGINAL\")\r\nplt.subplot(232), plt.imshow(replicate, \"gray\"), plt.title(\"REPLICATE\")\r\nplt.subplot(233), plt.imshow(reflect, \"gray\"), plt.title(\"REFLECT\")\r\nplt.subplot(234), plt.imshow(reflect101, \"gray\"), plt.title(\"REFLECT_101\")\r\nplt.subplot(235), plt.imshow(wrap, \"gray\"), plt.title(\"WRAP\")\r\nplt.subplot(236), plt.imshow(constant, \"gray\"), plt.title(\"CONSTANT\")\r\n\r\nplt.show()\r\n\r\n```\r\n\r\n![image-20211106221027681](cloudDisk/markdown/OpenCV笔记.assets/image-20211106221027681.png)\r\n\r\n外扩200像素\r\n\r\n![image-20211106221142958](cloudDisk/markdown/OpenCV笔记.assets/image-20211106221142958.png)\r\n\r\n## 数值计算\r\n\r\n### 图片像素颜色值加10\r\n\r\n```python\r\nimport cv2\r\nimport matplotlib.pyplot as plt\r\n# 数值计算\r\nimg1 = cv2.imread(\"img1.jpg\")\r\nimg2 = cv2.imread(\"img2.jpg\")\r\n\r\nimg = img1 + 10\r\nprint(img1[:5,:,0]) # 只显示前5\r\nprint()\r\nprint(img[:5,:,0]) # 只显示前5\r\ncv2.imshow(\"img\",img)\r\ncv2.waitKey(0)\r\ncv2.destroyAllWindows()\r\n```\r\n\r\n![image-20211106222941851](cloudDisk/markdown/OpenCV笔记.assets/image-20211106222941851.png)\r\n\r\n![image-20211106222954297](cloudDisk/markdown/OpenCV笔记.assets/image-20211106222954297.png)\r\n\r\n### 两图片的像素颜色值相加\r\n\r\n```python\r\nimport cv2\r\nimport matplotlib.pyplot as plt\r\n# 数值计算\r\nimg1 = cv2.imread(\"img1.jpg\")\r\nimg2 = cv2.imread(\"img2.jpg\")\r\n\r\nimg = img1 + img2\r\nprint(img[:5,:,0]) # 只显示前5\r\ncv2.imshow(\"img\",img)\r\ncv2.waitKey(0)\r\ncv2.destroyAllWindows()\r\n```\r\n\r\n![image-20211106223155762](cloudDisk/markdown/OpenCV笔记.assets/image-20211106223155762.png)\r\n\r\n像素值超出255，会进行取余运算 %256\r\n\r\n![image-20211106223135320](cloudDisk/markdown/OpenCV笔记.assets/image-20211106223135320.png)\r\n\r\n#### add函数\r\n\r\n```python\r\nimport cv2\r\nimport matplotlib.pyplot as plt\r\n# 数值计算\r\nimg1 = cv2.imread(\"img1.jpg\")\r\nimg2 = cv2.imread(\"img2.jpg\")\r\n\r\nimg = cv2.add(img1, img2)\r\nprint(img[:5,:,0]) # 只显示前5\r\ncv2.imshow(\"img\",img)\r\ncv2.waitKey(0)\r\ncv2.destroyAllWindows()\r\n```\r\n\r\n![image-20211106223407760](cloudDisk/markdown/OpenCV笔记.assets/image-20211106223407760.png)\r\n\r\n两者相加不会进行取模运算，而是像素值255封顶\r\n\r\n![image-20211106223348041](cloudDisk/markdown/OpenCV笔记.assets/image-20211106223348041.png)\r\n\r\n### 图像缩放\r\n\r\n#### 固定像素长宽\r\n\r\n```python\r\nimport cv2\r\n\r\nimg1 = cv2.imread(\"img1.jpg\")\r\nimg2 = cv2.imread(\"img2.jpg\")\r\n\r\nres = cv2.resize(img1, (500, 500))\r\nprint(res.shape)\r\n\r\ncv2.imshow(\"res\",res)\r\ncv2.waitKey(0)\r\ncv2.destroyAllWindows()\r\n```\r\n\r\n![image-20211106224219983](cloudDisk/markdown/OpenCV笔记.assets/image-20211106224219983.png)\r\n\r\n#### 比例缩放\r\n\r\n```python\r\nimport cv2\r\n\r\nimg1 = cv2.imread(\"img1.jpg\")\r\nimg2 = cv2.imread(\"img2.jpg\")\r\n\r\nres = cv2.resize(img1, (0, 0), fx=0.5, fy=0.2)\r\nprint(res.shape)\r\n\r\ncv2.imshow(\"res\",res)\r\ncv2.waitKey(0)\r\ncv2.destroyAllWindows()\r\n```\r\n\r\nx 方向上 x0.5\r\n\r\ny 方向上 x0.2\r\n\r\n![image-20211106224436465](cloudDisk/markdown/OpenCV笔记.assets/image-20211106224436465.png)\r\n\r\n### 图片融合\r\n\r\n```python\r\ncv2.addWeighted(img1, 0.4, img2, 0.6, 0)\r\n```\r\n\r\n* 参数1：图片对象1\r\n* 参数2：图片对象1所占权重\r\n\r\n* 参数3：图片对象2\r\n* 参数4：图片对象2所占权重\r\n* 参数5：偏置项，提亮多少，亮度上的微调\r\n\r\n```python\r\nimport cv2\r\n\r\nimg1 = cv2.imread(\"img1.jpg\")\r\nimg2 = cv2.imread(\"img2.jpg\")\r\n\r\nres = cv2.addWeighted(img1, 0.4, img2, 0.6, 0)\r\n\r\ncv2.imshow(\"res\",res)\r\ncv2.waitKey(0)\r\ncv2.destroyAllWindows()\r\n```\r\n\r\n![image-20211106224856262](cloudDisk/markdown/OpenCV笔记.assets/image-20211106224856262.png)\r\n\r\n\r\n\r\n# 二、阈值和平滑操作\r\n\r\n## 图像阈值\r\n\r\n![image-20211106225304162](cloudDisk/markdown/OpenCV笔记.assets/image-20211106225304162.png)\r\n\r\n```python\r\nimport cv2\r\nimport matplotlib.pyplot as plt\r\nimg1 = cv2.imread(\"img1.jpg\",0) # 灰度图\r\n\r\nret, thresh1 = cv2.threshold(img1, 127, 255, cv2.THRESH_BINARY)\r\nret, thresh2 = cv2.threshold(img1, 127, 255, cv2.THRESH_BINARY_INV)\r\nret, thresh3 = cv2.threshold(img1, 127, 255, cv2.THRESH_TRUNC)\r\nret, thresh4 = cv2.threshold(img1, 127, 255, cv2.THRESH_TOZERO)\r\nret, thresh5 = cv2.threshold(img1, 127, 255, cv2.THRESH_TOZERO_INV)\r\n\r\ntitles = [\"Original Image\", \"BINARY\", \"BINARY_INV\", \"TRUNC\", \"TOZERO\", \"TOZERO_INV\"]\r\nimages = [img1, thresh1, thresh2, thresh3, thresh4, thresh5]\r\n\r\nfor i in range(6):\r\n    plt.subplot(2, 3, i+1), plt.imshow(images[i], \"gray\")\r\n    plt.title(titles[i])\r\n    plt.xticks([]), plt.yticks([])\r\nplt.show()\r\n```\r\n\r\n![image-20211106231129170](cloudDisk/markdown/OpenCV笔记.assets/image-20211106231129170.png)\r\n\r\n* cv2.threshold(img1, 127, 255, cv2.THRESH_BINARY)\r\n  * 像素值大于127，改为255，否则为0 （值越大越亮）\r\n* cv2.threshold(img1, 127, 255, cv2.THRESH_BINARY_INV)\r\n  * 像素值大于127，改为0，否则为255 （值越大越亮）\r\n* cv2.threshold(img1, 127, 255, cv2.THRESH_TRUNC)\r\n  * 像素值大于127，改为255，否则不变\r\n  * 比较亮的地方更亮，比较暗的地方不变\r\n* cv2.threshold(img1, 127, 255, cv2.THRESH_TOZERO)\r\n  * 像素值大于127，不变，否则改为0\r\n  * 比较亮的地方不变，比较暗的地方变黑\r\n* cv2.threshold(img1, 127, 255, cv2.THRESH_TOZERO_INV)\r\n  * 像素值大于127，改为0，否则不变\r\n  * 比较亮的地方变黑，比较暗的地方不变\r\n\r\n## 自适应阈值处理\r\n\r\n上述阈值处理对于色彩均衡的图像来说结果较为理想，但对于色彩不均衡的图像来说，只使用一个阈值，无法得到较理想的阈值分割结果。自适应阈值处理通过计算**每个像素点周围临近的加权平均值获得阈值**，能够**更好的处理由光照变化带来影响的图像**。\r\n\r\n```python\r\ndst = cv2.adaptiveThreshold(src, maxValue, adaptiveMethod, thresholdType, blockSize, C)\r\n\'\'\'\r\nsrc：输入图像。该图像须是8位单通道图像\r\nmaxValue：最大值\r\nadaptiveMethod：自适应方法\r\nthresholdType：阈值处理方式\r\nblockSize：像素在计算其阈值时参考的邻域尺寸大小，通常为3，5，7\r\nC：常量\r\n\'\'\'\r\n```\r\n\r\n阈值处理方法须为 cv2.THRESH_BINARY 或 cv2.THRESH_BINARY_INV\r\n\r\n自适应方法有 cv2.ADAPTIVE_THRESH_MEAN_C 和 cv2.ADAPTIVE_THRESH_GAUSSIAN_C 。前者领域所有像素点的权重值一致；后者与邻域各个像素点到中心点的距离有关，通过高斯方程获得各点的权重。\r\n\r\n```python\r\nimport matplotlib.pyplot as plt\r\nimport numpy as np\r\nimport cv2 as cv\r\n\r\nimg = cv.imread(r\'exc.png\')\r\nimgray = cv.cvtColor(img, cv.COLOR_BGR2GRAY)\r\nt, rst = cv.threshold(imgray,127,255,cv.THRESH_BINARY)\r\nathdMEAN = cv.adaptiveThreshold(imgray,255,cv.ADAPTIVE_THRESH_MEAN_C,cv.THRESH_BINARY,5,3)\r\nathdGAUS = cv.adaptiveThreshold(imgray,255,cv.ADAPTIVE_THRESH_GAUSSIAN_C,cv.THRESH_BINARY,5,3)\r\ntitles = [\'Original\',\'Glbal Thresholding(v=127)\',\'AdaptiveMean\',\'AdaptiveGaussian\']\r\nimages = [imgray,rst,athdMEAN,athdGAUS]\r\nfor i in range(4):\r\n    plt.subplot(2,2,i+1)\r\n    plt.imshow(images[i],\'gray\')\r\n    plt.title(titles[i])\r\n    plt.xticks([]), plt.yticks([])\r\nplt.show()\r\n```\r\n\r\n\r\n\r\n![image-20211112095141812](cloudDisk/markdown/OpenCV笔记.assets/image-20211112095141812.png)\r\n\r\n## 图像平滑\r\n\r\n### 均值滤波\r\n\r\n![image-20211107121210874](cloudDisk/markdown/OpenCV笔记.assets/image-20211107121210874.png)\r\n\r\n```python\r\nimport cv2\r\nimport matplotlib.pyplot as plt\r\nimg1 = cv2.imread(\"img1.jpg\")\r\ncv2.imshow(\"img\", img1)\r\ncv2.waitKey(0)\r\ncv2.destroyAllWindows()\r\n\r\n# 均值滤波\r\n# 每 3x3 的像素矩阵，取平均值\r\nblur = cv2.blur(img1, (3, 3))\r\ncv2.imshow(\"blur\", blur)\r\nprint(blur)\r\ncv2.waitKey(0)\r\ncv2.destroyAllWindows()\r\n```\r\n\r\n### 方框滤波\r\n\r\n#### normalize=True 基本和均值滤波一样\r\n\r\n```python\r\nimport cv2\r\nimport matplotlib.pyplot as plt\r\nimg1 = cv2.imread(\"img1.jpg\")\r\ncv2.imshow(\"img\", img1)\r\ncv2.waitKey(0)\r\ncv2.destroyAllWindows()\r\n\r\n# 方框滤波\r\n# 基本和均值一样，可以选择归一化\r\nbox = cv2.boxFilter(img1, -1, (10,10), normalize=True)\r\ncv2.imshow(\"box\", box)\r\nprint(box)\r\ncv2.waitKey(0)\r\ncv2.destroyAllWindows()\r\n```\r\n\r\n![image-20211107121639055](cloudDisk/markdown/OpenCV笔记.assets/image-20211107121639055.png)\r\n\r\n#### normalize=False 像素颜色值越界则取255\r\n\r\n```python\r\nimport cv2\r\nimport matplotlib.pyplot as plt\r\nimg1 = cv2.imread(\"img1.jpg\")\r\ncv2.imshow(\"img\", img1)\r\ncv2.waitKey(0)\r\ncv2.destroyAllWindows()\r\n\r\n# 方框滤波\r\n# 基本和均值一样，可以选择归一化\r\nbox = cv2.boxFilter(img1, -1, (3,3), normalize=False)\r\ncv2.imshow(\"box\", box)\r\nprint(box)\r\ncv2.waitKey(0)\r\ncv2.destroyAllWindows()\r\n```\r\n\r\n![image-20211107121549630](cloudDisk/markdown/OpenCV笔记.assets/image-20211107121549630.png)\r\n\r\n\r\n\r\n### 高斯滤波\r\n\r\n![image-20211107122659016](cloudDisk/markdown/OpenCV笔记.assets/image-20211107122659016.png)\r\n\r\n```python\r\nimport cv2\r\nimport matplotlib.pyplot as plt\r\nimg1 = cv2.imread(\"img1.jpg\")\r\n\r\n# 高斯滤波\r\n# 高斯模糊的卷积核里的数值是满足高斯分布的，相当于更重视中间的\r\naussian = cv2.GaussianBlur(img1, (5, 5), 1)\r\ncv2.imshow(\"aussian\", aussian)\r\ncv2.waitKey(0)\r\ncv2.destroyAllWindows()\r\n```\r\n\r\n### 中值滤波\r\n\r\n* 像素颜色值矩阵，取其中的一个中间值，其他像素值改为这个\r\n\r\n```python\r\nimport matplotlib.pyplot as plt\r\nimg1 = cv2.imread(\"img1.jpg\")\r\ncv2.imshow(\"img\", img1)\r\ncv2.waitKey(0)\r\n\r\n# 中值滤波\r\n# 相当于用中值代替\r\nmedian = cv2.medianBlur(img1, 5)\r\n\r\ncv2.imshow(\"median\", median)\r\ncv2.waitKey(0)\r\ncv2.destroyAllWindows()\r\n```\r\n\r\n* 有噪音的时候，用这个比较好\r\n\r\n### 全部展示\r\n\r\n![image-20211107125251119](cloudDisk/markdown/OpenCV笔记.assets/image-20211107125251119.png)\r\n\r\n```python\r\nimport cv2\r\nimport numpy as np\r\nimport matplotlib.pyplot as plt\r\nimg1 = cv2.imread(\"img1.jpg\")\r\nimg1 = cv2.resize(img1, (0,0), fx=0.4, fy=0.4)\r\nblur = cv2.blur(img1, (3, 3))\r\naussian = cv2.GaussianBlur(img1, (5, 5), 1)\r\nmedian = cv2.medianBlur(img1, 5)\r\n\r\nres1 = np.hstack((img1, blur))\r\nres2 = np.hstack((aussian, median))\r\nres = np.vstack((res1, res2))\r\ncv2.imshow(\"img\", res)\r\ncv2.waitKey(0)\r\ncv2.destroyAllWindows()\r\n```\r\n\r\n# 三、形态学\r\n\r\n## 腐蚀操作\r\n\r\n输入图片\r\n\r\n![image-20211107130703906](cloudDisk/markdown/OpenCV笔记.assets/image-20211107130703906.png)\r\n\r\n腐蚀操作\r\n\r\n* cv2.erode(img1, kernel, iterations=1)\r\n  * kernel - 卷积核\r\n    * 影响程度\r\n  * iterations - 迭代次数\r\n\r\n```python\r\nimport cv2\r\nimport numpy as np\r\nimport matplotlib.pyplot as plt\r\nimg1 = cv2.imread(\"test02.png\")\r\n\r\n# 腐蚀操作\r\nkernel = np.ones((3,3), np.uint8) # 使用 3x3 的 filter\r\nerode = cv2.erode(img1, kernel, iterations=1)\r\n\r\ncv2.imshow(\"img\", img1)\r\ncv2.waitKey(0)\r\ncv2.imshow(\"erode\", erode)\r\ncv2.waitKey(0)\r\ncv2.destroyAllWindows()\r\n```\r\n\r\n![image-20211107130719926](cloudDisk/markdown/OpenCV笔记.assets/image-20211107130719926.png)\r\n\r\n分析\r\n\r\n* 卷积核选用 3x3； np.ones((3,3), np.uint8)\r\n  * [[1 1 1]\r\n    [1 1 1]\r\n    [1 1 1]]\r\n* 当这个卷积核框中全白或全黑的地方时，不变\r\n* 当这个卷积核框中有黑有白的地方时，都变黑色\r\n\r\n\r\n\r\n**使用30x30的核，腐蚀两次**\r\n\r\n```python\r\nimport cv2\r\nimport numpy as np\r\nimport matplotlib.pyplot as plt\r\nimg1 = cv2.imread(\"test02.png\")\r\n\r\n# 腐蚀操作\r\nkernel = np.ones((30,30), np.uint8) # 使用 30x30 的 filter\r\nerode_1 = cv2.erode(img1, kernel, iterations=1)\r\nerode_2 = cv2.erode(img1, kernel, iterations=2)\r\nres = np.hstack((img1, erode_1, erode_2))\r\ncv2.imshow(\"res\", res)\r\ncv2.waitKey(0)\r\ncv2.destroyAllWindows()\r\n```\r\n\r\n![image-20211107131247626](cloudDisk/markdown/OpenCV笔记.assets/image-20211107131247626.png)\r\n\r\n\r\n\r\n## 膨胀操作\r\n\r\n腐蚀操作的逆过程\r\n\r\n输入图片\r\n\r\n![image-20211107131534377](cloudDisk/markdown/OpenCV笔记.assets/image-20211107131534377.png)\r\n\r\n```python\r\nimport cv2\r\nimport numpy as np\r\nimport matplotlib.pyplot as plt\r\nimg1 = cv2.imread(\"test02.png\")\r\n\r\n# 腐蚀操作\r\nkernel = np.ones((3,3), np.uint8) # 使用 30x30 的 filter\r\nerode = cv2.erode(img1, kernel, iterations=1)\r\n\r\n# 膨胀操作\r\nkernel = np.ones((11,11), np.uint8) # 使用 30x30 的 filter\r\ndilate = cv2.dilate(erode, kernel, iterations=1)\r\n\r\ncv2.imshow(\"dilate\", dilate)\r\ncv2.waitKey(0)\r\ncv2.destroyAllWindows()\r\n```\r\n\r\n![image-20211107131811660](cloudDisk/markdown/OpenCV笔记.assets/image-20211107131811660.png)\r\n\r\n* 分析\r\n  * 卷积核选用 11x11\r\n  * 当这个卷积核框中全白或全黑的地方时，不变\r\n  * 当这个卷积核框中有黑有白的地方时，都变白色\r\n\r\n\r\n\r\n**使用30x30的核，膨胀两次**\r\n\r\n```python\r\nimport cv2\r\nimport numpy as np\r\nimport matplotlib.pyplot as plt\r\nimg1 = cv2.imread(\"test02.png\")\r\n\r\n# 腐蚀操作\r\nkernel = np.ones((3,3), np.uint8) # 使用 30x30 的 filter\r\nerode = cv2.erode(img1, kernel, iterations=1)\r\n\r\n# 膨胀操作\r\nkernel = np.ones((30,30), np.uint8) # 使用 30x30 的 filter\r\ndilate_1 = cv2.dilate(erode, kernel, iterations=1)\r\ndilate_2 = cv2.dilate(erode, kernel, iterations=2)\r\nres = np.hstack((erode, dilate_1, dilate_2))\r\ncv2.imshow(\"res\", res)\r\ncv2.waitKey(0)\r\ncv2.destroyAllWindows()\r\n```\r\n\r\n![image-20211107132428857](cloudDisk/markdown/OpenCV笔记.assets/image-20211107132428857.png)\r\n\r\n## 开运算与闭运算\r\n\r\n输入图片\r\n\r\n![image-20211107130703906](cloudDisk/markdown/OpenCV笔记.assets/image-20211107130703906.png)\r\n\r\n### 1、 开：先腐蚀，再膨胀\r\n\r\n```python\r\nimport cv2\r\nimport numpy as np\r\nimport matplotlib.pyplot as plt\r\nimg1 = cv2.imread(\"test02.png\")\r\n\r\n# 开：先腐蚀，再膨胀\r\nkernel = np.ones((3,3), np.uint8)\r\nopening = cv2.morphologyEx(img1, cv2.MORPH_OPEN, kernel)\r\ncv2.imshow(\"opening\", opening)\r\ncv2.waitKey(0)\r\ncv2.destroyAllWindows()\r\n```\r\n\r\n```\r\nimport cv2\r\nimport numpy as np\r\nimport matplotlib.pyplot as plt\r\nimg1 = cv2.imread(\"test02.png\")\r\n\r\n# 开：先腐蚀，再膨胀\r\nkernel = np.ones((3,3), np.uint8)\r\nopening = cv2.morphologyEx(img1, cv2.MORPH_OPEN, kernel)\r\ncv2.imshow(\"opening\", opening)\r\ncv2.waitKey(0)\r\ncv2.destroyAllWindows()\r\n```\r\n\r\n![image-20211107133524655](cloudDisk/markdown/OpenCV笔记.assets/image-20211107133524655.png)\r\n\r\n### 2、 闭：先膨胀，再腐蚀\r\n\r\n```python\r\nimport cv2\r\nimport numpy as np\r\nimport matplotlib.pyplot as plt\r\nimg1 = cv2.imread(\"test02.png\")\r\n\r\n# 开：先腐蚀，再膨胀\r\nkernel = np.ones((3,3), np.uint8)\r\nclosing = cv2.morphologyEx(img1, cv2.MORPH_CLOSE, kernel)\r\ncv2.imshow(\"closing\", closing)\r\ncv2.waitKey(0)\r\ncv2.destroyAllWindows()\r\n```\r\n\r\n![image-20211107133628822](cloudDisk/markdown/OpenCV笔记.assets/image-20211107133628822.png)\r\n\r\n## 梯度运算\r\n\r\n* **梯度 = 膨胀 - 腐蚀**\r\n\r\n输入图片\r\n\r\n![image-20211107130703906](cloudDisk/markdown/OpenCV笔记.assets/image-20211107130703906.png)\r\n\r\n膨胀以及腐蚀：\r\n\r\n![image-20211107134502290](cloudDisk/markdown/OpenCV笔记.assets/image-20211107134502290.png)\r\n\r\n梯度 = 膨胀 - 腐蚀：\r\n\r\n```python\r\nimport cv2\r\nimport numpy as np\r\nimport matplotlib.pyplot as plt\r\nimg1 = cv2.imread(\"test02.png\")\r\n\r\n# 梯度 = 膨胀 - 腐蚀\r\nkernel = np.ones((5,5), np.uint8)\r\ndilate = cv2.dilate(img1, kernel, iterations=2)\r\nerode = cv2.erode(img1, kernel, iterations=2)\r\nres = np.hstack((dilate, erode))\r\n\r\ngradient = cv2.morphologyEx(img1, cv2.MORPH_GRADIENT, kernel)\r\n\r\ncv2.imshow(\"gradient\", gradient)\r\n# cv2.imshow(\"res\", res)\r\ncv2.waitKey(0)\r\ncv2.destroyAllWindows()\r\n\r\n```\r\n\r\n![image-20211107134535130](cloudDisk/markdown/OpenCV笔记.assets/image-20211107134535130.png)\r\n\r\n## 礼帽与黑帽\r\n\r\n* **礼帽 = 原始输入 - 开运算结果**\r\n* **黑帽 = 闭运算 - 原始输入**\r\n\r\n### 礼帽\r\n\r\n原始输入：\r\n\r\n![image-20211107130703906](cloudDisk/markdown/OpenCV笔记.assets/image-20211107130703906.png)\r\n\r\n开运算结果：\r\n\r\n![image-20211107133524655](cloudDisk/markdown/OpenCV笔记.assets/image-20211107133524655.png)\r\n\r\n礼帽：\r\n\r\n```python\r\nimport cv2\r\nimport numpy as np\r\nimport matplotlib.pyplot as plt\r\nimg1 = cv2.imread(\"test02.png\")\r\n\r\n# 礼帽\r\nkernel = np.ones((3,3), np.uint8)\r\ntophat = cv2.morphologyEx(img1, cv2.MORPH_TOPHAT, kernel)\r\n\r\ncv2.imshow(\"tophat\", tophat)\r\n\r\ncv2.waitKey(0)\r\ncv2.destroyAllWindows()\r\n```\r\n\r\n![image-20211107135623189](cloudDisk/markdown/OpenCV笔记.assets/image-20211107135623189.png)\r\n\r\n### 黑帽\r\n\r\n闭运算结果：\r\n\r\n![image-20211107133628822](cloudDisk/markdown/OpenCV笔记.assets/image-20211107133628822.png)\r\n\r\n原始输入：\r\n\r\n![image-20211107130703906](cloudDisk/markdown/OpenCV笔记.assets/image-20211107130703906.png)\r\n\r\n黑帽：\r\n\r\n```python\r\nimport cv2\r\nimport numpy as np\r\nimport matplotlib.pyplot as plt\r\nimg1 = cv2.imread(\"test02.png\")\r\n\r\n# 礼帽\r\nkernel = np.ones((3,3), np.uint8)\r\ntophat = cv2.morphologyEx(img1, cv2.MORPH_BLACKHAT, kernel)\r\n\r\ncv2.imshow(\"tophat\", tophat)\r\n\r\ncv2.waitKey(0)\r\ncv2.destroyAllWindows()\r\n```\r\n\r\n![image-20211107135838486](cloudDisk/markdown/OpenCV笔记.assets/image-20211107135838486.png)\r\n\r\n# 四、梯度计算\r\n\r\n## Sobel算子\r\n\r\n### 简介\r\n\r\n![image-20211107141510148](cloudDisk/markdown/OpenCV笔记.assets/image-20211107141510148.png)\r\n\r\ncv2.Sobel(src, ddepth, dx, dy, ksize)\r\n\r\n* ddepth: 图像的深度\r\n* dx和dy分别表示水平和竖直方向\r\n* ksize是Sobel算子的大小\r\n\r\n### 测试\r\n\r\n输入图片：\r\n\r\n![image-20211107130703906](cloudDisk/markdown/OpenCV笔记.assets/image-20211107130703906.png)\r\n\r\n```python\r\nimport cv2\r\nimport numpy as np\r\nimport matplotlib.pyplot as plt\r\nimg1 = cv2.imread(\"test02.png\")\r\n\r\nsobelx = cv2.Sobel(img1, cv2.CV_64F, 1, 0, ksize=3)\r\n\r\ncv2.imshow(\"sobelx\", sobelx)\r\ncv2.waitKey(0)\r\ncv2.destroyAllWindows()\r\n```\r\n\r\n![image-20211107142040274](cloudDisk/markdown/OpenCV笔记.assets/image-20211107142040274.png)\r\n\r\n* **分析**\r\n  * ![image-20211107142329947](cloudDisk/markdown/OpenCV笔记.assets/image-20211107142329947.png)\r\n  * 白到黑是正数，黑到白就是负数了，所有的负数会被截断成0，所以要取绝对值\r\n\r\n**进行转换，负数取绝对值**\r\n\r\n```python\r\nimport cv2\r\nimport numpy as np\r\nimport matplotlib.pyplot as plt\r\nimg1 = cv2.imread(\"test02.png\")\r\n\r\nsobelx = cv2.Sobel(img1, cv2.CV_64F, 1, 0, ksize=3)\r\nsobelx = cv2.convertScaleAbs(sobelx)\r\ncv2.imshow(\"sobelx\", sobelx)\r\ncv2.waitKey(0)\r\ncv2.destroyAllWindows()\r\n```\r\n\r\n![image-20211107142608034](cloudDisk/markdown/OpenCV笔记.assets/image-20211107142608034.png)\r\n\r\n**分别进行计算x，y；之后求和**\r\n\r\n```python\r\nimport cv2\r\nimport numpy as np\r\nimport matplotlib.pyplot as plt\r\nimg1 = cv2.imread(\"test02.png\")\r\n\r\n# 分别计算x和y，再求和\r\nsobelx = cv2.Sobel(img1, cv2.CV_64F, 1, 0, ksize=3)\r\nsobelx = cv2.convertScaleAbs(sobelx)\r\nsobely = cv2.Sobel(img1, cv2.CV_64F, 0, 1, ksize=3)\r\nsobely = cv2.convertScaleAbs(sobely)\r\n\r\n# 求和\r\nsobelxy = cv2.addWeighted(sobelx, 0.5, sobely, 0.5, 0)\r\n\r\ncv2.imshow(\"sobelxy\", sobelxy)\r\ncv2.waitKey(0)\r\ncv2.destroyAllWindows()\r\n```\r\n\r\n![image-20211107143200941](cloudDisk/markdown/OpenCV笔记.assets/image-20211107143200941.png)\r\n\r\n**不建议直接计算**\r\n\r\n```python\r\nsobelxy = cv2.Sobel(img1, cv2.CV_64F, 1, 1, ksize=3)\r\n```\r\n\r\n效果没那么好\r\n\r\n### 图片取轮廓\r\n\r\n```python\r\nimport cv2\r\nimport numpy as np\r\nimport matplotlib.pyplot as plt\r\nimg1 = cv2.imread(\"img1.jpg\", 0)\r\nimg1 = cv2.resize(img1, (0,0), fx=0.4, fy=0.4)\r\n\r\n# 分别计算x和y，再求和\r\nsobelx = cv2.Sobel(img1, cv2.CV_64F, 1, 0, ksize=3)\r\nsobelx = cv2.convertScaleAbs(sobelx)\r\nsobely = cv2.Sobel(img1, cv2.CV_64F, 0, 1, ksize=3)\r\nsobely = cv2.convertScaleAbs(sobely)\r\n\r\n# 求和\r\nsobelxy = cv2.addWeighted(sobelx, 0.5, sobely, 0.5, 0)\r\n\r\nres = np.hstack((img1, sobelxy))\r\ncv2.imshow(\"res\", res)\r\ncv2.waitKey(0)\r\ncv2.destroyAllWindows()\r\n```\r\n\r\n![image-20211107144348909](cloudDisk/markdown/OpenCV笔记.assets/image-20211107144348909.png)\r\n\r\n\r\n\r\n## Scharr算子\r\n\r\n![image-20211107144606242](cloudDisk/markdown/OpenCV笔记.assets/image-20211107144606242.png)\r\n\r\n相比sobel算子，捕捉到的梯度信息更多\r\n\r\n## laplacian算子\r\n\r\n![image-20211107144745488](cloudDisk/markdown/OpenCV笔记.assets/image-20211107144745488.png)\r\n\r\n相比sobel算子，捕捉到的梯度信息更少\r\n\r\n## 不同算子的差异\r\n\r\n```python\r\nimport cv2\r\nimport numpy as np\r\nimport matplotlib.pyplot as plt\r\nimg1 = cv2.imread(\"img1.jpg\", 0)\r\nimg1 = cv2.resize(img1, (0,0), fx=0.3, fy=0.3)\r\n\r\n# 不同算子的差异\r\nsobelx = cv2.Sobel(img1, cv2.CV_64F, 1, 0, ksize=3)\r\nsobelx = cv2.convertScaleAbs(sobelx)\r\nsobely = cv2.Sobel(img1, cv2.CV_64F, 0, 1, ksize=3)\r\nsobely = cv2.convertScaleAbs(sobely)\r\nsobelxy = cv2.addWeighted(sobelx, 0.5, sobely, 0.5, 0)\r\n\r\nscharrx = cv2.Scharr(img1, cv2.CV_64F, 1, 0)\r\nscharrx = cv2.convertScaleAbs(scharrx)\r\nscharry = cv2.Sobel(img1, cv2.CV_64F, 0, 1)\r\nscharry = cv2.convertScaleAbs(scharry)\r\nscharrxy = cv2.addWeighted(scharry, 0.5, scharrx, 0.5, 0)\r\n\r\nlaplacian = cv2.Laplacian(img1, cv2.CV_64F)\r\nlaplacian = cv2.convertScaleAbs(laplacian)\r\n\r\nres = np.hstack((sobelxy, scharrxy, laplacian))\r\ncv2.imshow(\"res\", res)\r\ncv2.waitKey(0)\r\ncv2.destroyAllWindows()\r\n```\r\n\r\n![image-20211107145528236](cloudDisk/markdown/OpenCV笔记.assets/image-20211107145528236.png)\r\n\r\n# 五、Canny边缘检测\r\n\r\n1. 使用高斯滤波器，以平滑图像滤除噪声\r\n2. 计算图像中每个像素点的梯度强度和方向\r\n3. 应用非极大值（Non-Maximum Suppression）抑制，以消除边缘检测带来的杂散响应\r\n4. 应用双阈值（Double-Threshold）检测来确定真实的和潜在的边缘\r\n5. 通过抑制孤立的弱边缘最终完成边缘检测\r\n\r\n## 1、高斯滤波器\r\n\r\n![image-20211107154555080](cloudDisk/markdown/OpenCV笔记.assets/image-20211107154555080.png)\r\n\r\n## 2、梯度和方向\r\n\r\nsobel算子\r\n\r\n![image-20211107154619239](cloudDisk/markdown/OpenCV笔记.assets/image-20211107154619239.png)\r\n\r\n## 3、非极大值抑制\r\n\r\n![image-20211107154747915](cloudDisk/markdown/OpenCV笔记.assets/image-20211107154747915.png)\r\n\r\n![image-20211107155115127](cloudDisk/markdown/OpenCV笔记.assets/image-20211107155115127.png)\r\n\r\n## 4、双阈值检测\r\n\r\n![image-20211107155333561](cloudDisk/markdown/OpenCV笔记.assets/image-20211107155333561.png)\r\n\r\n## 代码\r\n\r\n* cv2.Canny(img1, 50, 150)\r\n  * 参数1：src\r\n  * 参数2：最小阈值\r\n    * 越小，检测到的信息越多\r\n  * 参数3：最大阈值\r\n    * 越大，检测到的信息越多\r\n\r\n```python\r\nimport cv2\r\nimport numpy as np\r\nimport matplotlib.pyplot as plt\r\nimg1 = cv2.imread(\"img1.jpg\", 0)\r\nimg1 = cv2.resize(img1, (0,0), fx=0.3, fy=0.3)\r\n\r\nv1 = cv2.Canny(img1, 100, 150)\r\nv2 = cv2.Canny(img1, 50, 150)\r\n\r\nres = np.hstack((v1, v2))\r\ncv2.imshow(\"res\", res)\r\ncv2.waitKey(0)\r\ncv2.destroyAllWindows()\r\n```\r\n\r\n![image-20211107160338917](cloudDisk/markdown/OpenCV笔记.assets/image-20211107160338917.png)\r\n\r\n# 六、图像金字塔\r\n\r\n![image-20211107160730002](cloudDisk/markdown/OpenCV笔记.assets/image-20211107160730002.png)\r\n\r\n## 高斯金字塔：向下采样（缩小）\r\n\r\n![image-20211107161001701](cloudDisk/markdown/OpenCV笔记.assets/image-20211107161001701.png)\r\n\r\n## 高斯金字塔：向上采样方法（方法）\r\n\r\n![image-20211107161106662](cloudDisk/markdown/OpenCV笔记.assets/image-20211107161106662.png)\r\n\r\n![image-20211107163841294](cloudDisk/markdown/OpenCV笔记.assets/image-20211107163841294.png)\r\n\r\n```python\r\nimport cv2\r\nimport numpy as np\r\nimport matplotlib.pyplot as plt\r\nimg1 = cv2.imread(\"img1.jpg\", 0)\r\nimg1 = cv2.resize(img1, (0,0), fx=0.3, fy=0.3)\r\nprint(img1.shape) # (324, 576)\r\n\r\n# 向上采样\r\nup = cv2.pyrUp(img1)\r\nprint(\"up_shape:\", up.shape)\r\n# 向下采样\r\ndown = cv2.pyrDown(img1)\r\nprint(\"down_shape:\", down.shape)\r\n\r\ncv2.imshow(\"up\", up)\r\ncv2.imshow(\"down\", down)\r\ncv2.waitKey(0)\r\ncv2.destroyAllWindows()\r\n```\r\n\r\n![image-20211107193301526](cloudDisk/markdown/OpenCV笔记.assets/image-20211107193301526.png)\r\n\r\n![image-20211107193321291](cloudDisk/markdown/OpenCV笔记.assets/image-20211107193321291.png)\r\n\r\n## 拉普拉斯金字塔\r\n\r\nLi = Gi - PyrUp(PyrDown(Gi))\r\n\r\n```python\r\nimport cv2\r\nimport numpy as np\r\nimport matplotlib.pyplot as plt\r\nimg1 = cv2.imread(\"img1.jpg\", 0)\r\nimg1 = cv2.resize(img1, (0,0), fx=0.3, fy=0.3)\r\nprint(img1.shape) # (324, 576)\r\n\r\ndown = cv2.pyrDown(img1)\r\ndown_up = cv2.pyrUp(down)\r\nl_1 = img1 - down_up\r\n\r\ncv2.imshow(\"l_1\", l_1)\r\ncv2.waitKey(0)\r\ncv2.destroyAllWindows()\r\n```\r\n\r\n![image-20211107194833470](cloudDisk/markdown/OpenCV笔记.assets/image-20211107194833470.png)\r\n\r\n## 图像轮廓\r\n\r\n![image-20211107195119390](cloudDisk/markdown/OpenCV笔记.assets/image-20211107195119390.png)\r\n\r\n输入图片\r\n\r\n![image-20211107200037774](cloudDisk/markdown/OpenCV笔记.assets/image-20211107200037774.png)\r\n\r\n二值化\r\n\r\n```python\r\nimport cv2\r\nimport numpy as np\r\nimport matplotlib.pyplot as plt\r\nimg1 = cv2.imread(\"img1.jpg\")\r\ngrey = cv2.cvtColor(img1, cv2.COLOR_BGR2GRAY)\r\nret, thresh = cv2.threshold(grey, 127, 255, cv2.THRESH_BINARY)\r\n\r\ncv2.imshow(\"thresh\", thresh)\r\ncv2.waitKey(0)\r\ncv2.destroyAllWindows()\r\n```\r\n\r\n![image-20211107200052130](cloudDisk/markdown/OpenCV笔记.assets/image-20211107200052130.png)\r\n\r\n绘制轮廓\r\n\r\n```python\r\nimport cv2\r\nimport numpy as np\r\nimport matplotlib.pyplot as plt\r\nimg1 = cv2.imread(\"img1.jpg\")\r\n# 二值化\r\ngrey = cv2.cvtColor(img1, cv2.COLOR_BGR2GRAY)\r\nret, thresh = cv2.threshold(grey, 127, 255, cv2.THRESH_BINARY)\r\n\r\ncontours, hierarchy = cv2.findContours(thresh, cv2.RETR_TREE, cv2.CHAIN_APPROX_NONE)\r\n# 绘制轮廓\r\ndraw_img = img1.copy()\r\n# 传入绘制图像，轮廓，轮廓索引(-1: 全部轮廓)，颜色模式，线条厚度\r\n# 注意需要copy，要不然原图会变\r\nres = cv2.drawContours(draw_img, contours, -1, (0, 0, 255), 2)\r\n\r\ncv2.imshow(\"res\", res)\r\ncv2.waitKey(0)\r\ncv2.destroyAllWindows()\r\n```\r\n\r\n![image-20211107204504317](cloudDisk/markdown/OpenCV笔记.assets/image-20211107204504317.png)\r\n\r\n## 轮廓特征\r\n\r\n```python\r\nimport cv2\r\nimport numpy as np\r\nimport matplotlib.pyplot as plt\r\nimg1 = cv2.imread(\"img1.jpg\")\r\n# 二值化\r\ngrey = cv2.cvtColor(img1, cv2.COLOR_BGR2GRAY)\r\nret, thresh = cv2.threshold(grey, 127, 255, cv2.THRESH_BINARY)\r\n\r\ncontours, hierarchy = cv2.findContours(thresh, cv2.RETR_TREE, cv2.CHAIN_APPROX_NONE)\r\ncnt = contours[0]\r\n# 面积\r\narea = cv2.contourArea(cnt)\r\nprint(area)\r\n# 周长\r\nlength = cv2.arcLength(cnt, True)\r\nprint(length)\r\n\r\n# cv2.imshow(\"res\", res)\r\ncv2.waitKey(0)\r\ncv2.destroyAllWindows()\r\n```\r\n\r\n![image-20211107205047861](cloudDisk/markdown/OpenCV笔记.assets/image-20211107205047861.png)\r\n\r\n## 轮廓近似\r\n\r\n![image-20211107205107350](cloudDisk/markdown/OpenCV笔记.assets/image-20211107205107350.png)\r\n\r\n输入图片：\r\n\r\n![image-20211107211613191](cloudDisk/markdown/OpenCV笔记.assets/image-20211107211613191.png)\r\n\r\n```python\r\nimport cv2\r\nimport numpy as np\r\nimport matplotlib.pyplot as plt\r\nimg1 = cv2.imread(\"test03.png\")\r\n# 二值化\r\ngrey = cv2.cvtColor(img1, cv2.COLOR_BGR2GRAY)\r\nret, thresh = cv2.threshold(grey, 127, 255, cv2.THRESH_BINARY)\r\n\r\ncontours, hierarchy = cv2.findContours(thresh, cv2.RETR_TREE, cv2.CHAIN_APPROX_NONE)\r\ncnt = contours[0]\r\n\r\n# 近似\r\nepsilon = 0.05 * cv2.arcLength(cnt, True) # 系数越小，越接近原来的轮廓\r\napprox = cv2.approxPolyDP(cnt, epsilon, True)\r\n\r\ndraw_img = img1.copy()\r\nres = cv2.drawContours(draw_img, [approx], -1, (0, 0, 255), 2)\r\n\r\ncv2.imshow(\"res\", res)\r\ncv2.waitKey(0)\r\ncv2.destroyAllWindows()\r\n```\r\n\r\n![image-20211107211624618](cloudDisk/markdown/OpenCV笔记.assets/image-20211107211624618.png)\r\n\r\n## 边界矩形\r\n\r\n输入图片：\r\n![image-20211107211613191](cloudDisk/markdown/OpenCV笔记.assets/image-20211107211613191.png)\r\n\r\n```python\r\nimport cv2\r\nimport numpy as np\r\nimport matplotlib.pyplot as plt\r\nimg1 = cv2.imread(\"test03.png\")\r\n# 二值化\r\ngrey = cv2.cvtColor(img1, cv2.COLOR_BGR2GRAY)\r\nret, thresh = cv2.threshold(grey, 127, 255, cv2.THRESH_BINARY)\r\n\r\ncontours, hierarchy = cv2.findContours(thresh, cv2.RETR_TREE, cv2.CHAIN_APPROX_NONE)\r\ncnt = contours[0]\r\n\r\nx, y, w, h = cv2.boundingRect(cnt) # 获取cnt的边界信息\r\nimg1 = cv2.rectangle(img1, (x, y), (x+w, y+h), (0, 255, 0), 2)\r\n\r\ncv2.imshow(\"img1\", img1)\r\ncv2.waitKey(0)\r\ncv2.destroyAllWindows()\r\n```\r\n\r\n![image-20211107212005043](cloudDisk/markdown/OpenCV笔记.assets/image-20211107212005043.png)\r\n\r\n计算轮廓面积与边界矩形比 \r\n\r\n```python\r\nimport cv2\r\nimport numpy as np\r\nimport matplotlib.pyplot as plt\r\nimg1 = cv2.imread(\"test03.png\")\r\n# 二值化\r\ngrey = cv2.cvtColor(img1, cv2.COLOR_BGR2GRAY)\r\nret, thresh = cv2.threshold(grey, 127, 255, cv2.THRESH_BINARY)\r\n\r\ncontours, hierarchy = cv2.findContours(thresh, cv2.RETR_TREE, cv2.CHAIN_APPROX_NONE)\r\ncnt = contours[0]\r\narea = cv2.contourArea(cnt)\r\n\r\nx, y, w, h = cv2.boundingRect(cnt) # 获取cnt的边界信息\r\nimg1 = cv2.rectangle(img1, (x, y), (x+w, y+h), (0, 255, 0), 2)\r\n\r\n# 轮廓面积与边界矩形比\r\nrect_area = w * h\r\nextent = float(area) / rect_area\r\nprint(\"轮廓面积与边界矩形比\", extent) # 轮廓面积与边界矩形比 0.7121473273827844\r\n# cv2.imshow(\"img1\", img1)\r\n# cv2.waitKey(0)\r\n# cv2.destroyAllWindows()\r\n```\r\n\r\n## 模板匹配\r\n\r\n模板匹配和卷积原理很像，模板在原图上从原点开始滑动，计算模板与（图像被模板覆盖的地方）的差异程度，这个差别程度的计算方法在opencv里有6种，然后每次计算的结果放入一个矩阵里，作为结果输出。加入原图是AXB大小，而模板是axb大小，则输出结果的矩阵是（A-a+1）x（B-b+1）\r\n\r\n![image-20211107213235640](cloudDisk/markdown/OpenCV笔记.assets/image-20211107213235640.png)\r\n\r\n* 带归一化的，结果更可靠\r\n\r\n输入图片1：\r\n\r\n![image-20211107221129693](cloudDisk/markdown/OpenCV笔记.assets/image-20211107221129693.png)\r\n\r\n输入图片2：\r\n![image-20211107221153033](cloudDisk/markdown/OpenCV笔记.assets/image-20211107221153033.png)\r\n\r\n```python\r\nimport cv2\r\nimport numpy as np\r\nimport matplotlib.pyplot as plt\r\nimg = cv2.imread(\"img1.jpg\")\r\nimg1 = cv2.imread(\"img1.jpg\", 0)\r\nimg1_eye = cv2.imread(\"img1_eye.png\", 0)\r\n\r\nres = cv2.matchTemplate(img1, img1_eye, 1)\r\nprint(res.shape) # (1039, 1867)\r\nmin_val, max_val, min_loc, max_loc = cv2.minMaxLoc(res)\r\nprint(min_val) # 0.15620635449886322\r\nprint(max_val) # 1.0\r\nprint(min_loc) # (1290, 226)\r\nprint(max_loc) # (7, 44)\r\n\r\n# 绘制矩形\r\nimg = cv2.rectangle(img, (min_loc[0], min_loc[1]), (min_loc[0]+img1_eye.shape[0],min_loc[1]+img1_eye.shape[1]), (0, 0, 255), 2)\r\n\r\ncv2.imshow(\"img\", img)\r\ncv2.waitKey(0)\r\ncv2.destroyAllWindows()\r\n```\r\n\r\n![image-20211107221236528](cloudDisk/markdown/OpenCV笔记.assets/image-20211107221236528.png)\r\n\r\n## 匹配多个对象\r\n\r\n输入图片1：\r\n\r\n![image-20211107232031496](cloudDisk/markdown/OpenCV笔记.assets/image-20211107232031496.png)\r\n\r\n输入图片2，匹配模板：\r\n\r\n![image-20211107232100148](cloudDisk/markdown/OpenCV笔记.assets/image-20211107232100148-16362984604451.png)\r\n\r\n```python\r\nimport cv2\r\nimport numpy as np\r\nimport matplotlib.pyplot as plt\r\nimg = cv2.imread(\"chaojimali.jpg\")\r\nimg1 = cv2.imread(\"chaojimali.jpg\", 0)\r\ntemplate = cv2.imread(\"chaojimali_jinbi.png\", 0)\r\nh, w = template.shape[:2]\r\n\r\nres = cv2.matchTemplate(img1, template, cv2.TM_CCOEFF_NORMED)\r\nthreshold = 0.8\r\n# 取匹配程度大于80%的坐标\r\nloc = np.where(res >= threshold)\r\n\r\nfor pt in zip(*loc[::-1]): # *表示可选参数\r\n    bottom_right = (pt[0] + w, pt[1] + h)\r\n    cv2.rectangle(img, pt, bottom_right, (0, 0, 255), 2)\r\n\r\ncv2.imshow(\"img\", img)\r\ncv2.waitKey(0)\r\ncv2.destroyAllWindows()\r\n```\r\n\r\n输出：\r\n\r\n![image-20211107232123441](cloudDisk/markdown/OpenCV笔记.assets/image-20211107232123441.png)\r\n\r\n# 七、直方图与傅里叶变化\r\n\r\n\r\n\r\n![image-20211108125043023](cloudDisk/markdown/OpenCV笔记.assets/image-20211108125043023.png)\r\n\r\n![image-20211108125101037](cloudDisk/markdown/OpenCV笔记.assets/image-20211108125101037.png)\r\n\r\n### **绘制直方图（灰色）：**\r\n\r\n```python\r\nimport cv2\r\nimport numpy as np\r\nimport matplotlib.pyplot as plt\r\nimg = cv2.imread(\"img1.jpg\", 0)\r\nhist = cv2.calcHist([img], [0], None, [256], [0, 256])\r\nprint(hist.shape) # (256, 1)\r\nplt.hist(img.ravel(), 256)\r\nplt.show()\r\n```\r\n\r\n![image-20211108125328768](cloudDisk/markdown/OpenCV笔记.assets/image-20211108125328768.png)\r\n\r\n### **直方图三通道：**\r\n\r\n```python\r\nimport cv2\r\nimport numpy as np\r\nimport matplotlib.pyplot as plt\r\nimg = cv2.imread(\"img1.jpg\")\r\ncolor = (\"b\", \"g\", \"r\")\r\nfor i,col in enumerate(color):\r\n    hist = cv2.calcHist([img], [i], None, [256], [0, 256])\r\n    plt.plot(hist,color = col)\r\n    plt.xlim([0,256])\r\nplt.show()\r\n```\r\n\r\n![image-20211108125759469](cloudDisk/markdown/OpenCV笔记.assets/image-20211108125759469.png)\r\n\r\n### **mask（掩码）：**\r\n\r\n* 两部分组成：黑和白\r\n\r\n![image-20211108130023929](cloudDisk/markdown/OpenCV笔记.assets/image-20211108130023929.png)\r\n\r\n```python\r\nimport cv2\r\nimport numpy as np\r\nimport matplotlib.pyplot as plt\r\nimg = cv2.imread(\"img1.jpg\", 0)\r\nimg = cv2.resize(img, (0, 0), fx=0.35, fy=0.35)\r\n\r\n# 创建mask\r\nmask = np.zeros(img.shape[:2], np.uint8)\r\nprint(mask.shape)\r\nmask[100:300, 100:400] = 255 # x=100 - x=300；y=100 - y=400 置为白色\r\n\r\n# mask 和 img 相与，mask有黑的部分，则将img也置为黑\r\nfull_hist = cv2.calcHist([img], [0], None, [256], [0, 256])\r\nmask_hist = cv2.calcHist([img], [0], mask, [256], [0, 256])\r\n\r\nplt.subplot(221), plt.imshow(img, \"gray\")\r\nplt.subplot(222), plt.imshow(mask, \"gray\")\r\nplt.subplot(223), plt.imshow(mask_hist, \"gray\")\r\nplt.subplot(224), plt.plot(full_hist), plt.plot(mask_hist)\r\nplt.xlim([0, 256])\r\nplt.show()\r\n```\r\n\r\n![image-20211108131542586](cloudDisk/markdown/OpenCV笔记.assets/image-20211108131542586.png)\r\n\r\n### 均衡化处理\r\n\r\n![image-20211109110425389](cloudDisk/markdown/OpenCV笔记.assets/image-20211109110425389.png)\r\n\r\n![image-20211109110456596](cloudDisk/markdown/OpenCV笔记.assets/image-20211109110456596.png)\r\n\r\n* 概率 = 像素个数 / 总像素个数\r\n* 累计概率 = 当前的概率 + 上一个灰度值的概率\r\n\r\n1. 读入一张图\r\n\r\n   ![image-20211109111929060](cloudDisk/markdown/OpenCV笔记.assets/image-20211109111929060.png)\r\n\r\n```python\r\nimport cv2\r\nimport numpy as np\r\nimport matplotlib.pyplot as plt\r\nimg = cv2.imread(\"img1.jpg\", 0)\r\nimg = cv2.resize(img, (0, 0), fx=0.35, fy=0.35)\r\nplt.hist(img.ravel(), 256)\r\nplt.show()\r\n\r\nequ = cv2.equalizeHist(img)\r\nplt.hist(equ.ravel(), 256)\r\nplt.show()\r\nres = np.hstack((img, equ))\r\n\r\ncv2.imshow(\"res\", res)\r\ncv2.waitKey(0)\r\ncv2.destroyAllWindows()\r\n```\r\n\r\n![image-20211109112346182](cloudDisk/markdown/OpenCV笔记.assets/image-20211109112346182.png)\r\n\r\n![image-20211109112327512](cloudDisk/markdown/OpenCV笔记.assets/image-20211109112327512.png)\r\n\r\n\r\n\r\n### 自适应直方图均衡化\r\n\r\n* 输入图片分割成8x8小块，分别进行均衡化\r\n* 自适应均衡化减小了过调问题\r\n\r\n```python\r\nimport cv2\r\nimport numpy as np\r\nimport matplotlib.pyplot as plt\r\nimg = cv2.imread(\"img1.jpg\", 0)\r\nimg = cv2.resize(img, (0, 0), fx=0.35, fy=0.35)\r\nplt.hist(img.ravel(), 256)\r\nplt.show()\r\n\r\nclahe = cv2.createCLAHE(clipLimit=2.0, tileGridSize=(8, 8))\r\nres_clahe = clahe.apply(img)\r\n\r\nres = np.hstack((img, res_clahe))\r\n\r\ncv2.imshow(\"res\", res)\r\ncv2.waitKey(0)\r\ncv2.destroyAllWindows()\r\n```\r\n\r\n![image-20211109114726520](cloudDisk/markdown/OpenCV笔记.assets/image-20211109114726520.png)\r\n\r\n\r\n\r\n## 傅里叶变化\r\n\r\n### 傅里叶变化作用\r\n\r\n* 高频：变化剧烈的灰度分量，例如边界\r\n* 低频：变化缓慢的灰度分量，例如一片大海\r\n\r\n滤波\r\n\r\n* 低通滤波器：只保留低频，会使得图片模糊\r\n* 高通滤波器：只保留高频，会使得图像细节提高\r\n\r\n![image-20211109124228646](cloudDisk/markdown/OpenCV笔记.assets/image-20211109124228646.png)\r\n\r\n### 空间域转频率域\r\n\r\n频率高的都往中心靠\r\n\r\n```python\r\nimport cv2\r\nimport numpy as np\r\nimport matplotlib.pyplot as plt\r\nimg = cv2.imread(\"img1.jpg\", 0)\r\nimg = cv2.resize(img, (0, 0), fx=0.35, fy=0.35)\r\n# unit8 转化为float32\r\nimg_float32 = np.float32(img)\r\n\r\ndft = cv2.dft(img_float32, flags=cv2.DFT_COMPLEX_OUTPUT)\r\ndft_shift = np.fft.fftshift(dft)\r\n# 得到的灰度图能表示的形式\r\nmagnitude_spectrum = 20 * np.log(cv2.magnitude(dft_shift[:, :, 0], dft_shift[:, :, 1]))\r\n\r\nplt.subplot(121), plt.imshow(img, cmap=\"gray\")\r\nplt.title(\"input image\"), plt.xticks([]), plt.yticks([])\r\nplt.subplot(122), plt.imshow(magnitude_spectrum, cmap=\"gray\")\r\nplt.title(\"magnitude spectrum\"), plt.xticks([]), plt.yticks([])\r\nplt.show()\r\n```\r\n\r\n\r\n\r\n![ ](cloudDisk/markdown/OpenCV笔记.assets/image-20211109125327485.png)\r\n\r\n### 低通和高通滤波\r\n\r\n```python\r\nimport cv2 as cv\r\nimport numpy as np\r\nimport matplotlib.pyplot as plt\r\nimg = cv.imread(\"img1.jpg\")\r\nimg = cv.resize(img, (0, 0), fx=0.45, fy=0.45)\r\n# 使用灰度图像\r\nimg = cv.cvtColor(img, cv.COLOR_RGB2GRAY)\r\n# uint8转换为float32\r\nimg_float32 = np.float32(img)\r\n# 傅里叶转换为复数\r\ndft = cv.dft(img_float32, flags=cv.DFT_COMPLEX_OUTPUT)\r\n# 将低频从左上角转换到中心\r\ndft_shift = np.fft.fftshift(dft)\r\n\r\n# 在这里进行低通滤波\r\nrows, cols = img.shape\r\nc_row, c_col = int(rows / 2), int(cols / 2)\r\nmask_low = np.zeros_like(dft_shift, np.uint8)\r\nmask_low[c_row - 30:c_row + 30, c_col - 50:c_col + 50] = 1\r\n# 使用低通滤波\r\nfshift_low = dft_shift * mask_low\r\n# 转换为可以显示的图片（fshift_low），fshift_low中包含实部和虚部\r\nmagnitude_spectrum_low = 20 * np.log(cv.magnitude(fshift_low[:, :, 0], fshift_low[:, :, 1]))\r\n\r\nf_ishift_low = np.fft.ifftshift(fshift_low)\r\nimg_back_low = cv.idft(f_ishift_low)\r\nimg_back_low = cv.magnitude(img_back_low[:, :, 0], img_back_low[:, :, 1])\r\n\r\n# 使用plt低通滤波后的图像\r\nplt.subplot(121)\r\nplt.imshow(img_back_low, cmap=\'gray\')\r\nplt.title(\'Output Image\')\r\nplt.xticks([])\r\nplt.yticks([])\r\n# 展示低通滤波后的频谱图\r\nplt.subplot(122)\r\nplt.imshow(magnitude_spectrum_low, cmap=\'gray\')\r\nplt.title(\'magnitude_spectrum\')\r\nplt.xticks([])\r\nplt.yticks([])\r\nplt.show()\r\n```\r\n\r\n![image-20211110214531966](cloudDisk/markdown/OpenCV笔记.assets/image-20211110214531966.png)\r\n\r\n```python\r\nimport cv2 as cv\r\nimport numpy as np\r\nimport matplotlib.pyplot as plt\r\nimg = cv.imread(\"img1.jpg\")\r\nimg = cv.resize(img, (0, 0), fx=0.45, fy=0.45)\r\n# 使用灰度图像\r\nimg = cv.cvtColor(img, cv.COLOR_RGB2GRAY)\r\n# uint8转换为float32\r\nimg_float32 = np.float32(img)\r\n# 傅里叶转换为复数\r\ndft = cv.dft(img_float32, flags=cv.DFT_COMPLEX_OUTPUT)\r\n# 将低频从左上角转换到中心\r\ndft_shift = np.fft.fftshift(dft)\r\n\r\n# 在这里进行高通滤波\r\nrows, cols = img.shape\r\nc_row, c_col = int(rows / 2), int(cols / 2)\r\nmask_high = np.ones_like(dft_shift, np.uint8)\r\nmask_high[c_row - 30:c_row + 30, c_col - 50:c_col + 50] = 0\r\n# 使用高通滤波\r\nfshift_high = dft_shift * mask_high\r\n# 转换为可以显示的图片（fshift_high），fshift_high中包含实部和虚部\r\nmagnitude_spectrum_high = 20 * np.log(cv.magnitude(fshift_high[:, :, 0], fshift_high[:, :, 1]))\r\n\r\nf_ishift_high = np.fft.ifftshift(fshift_high)\r\nimg_back_high = cv.idft(f_ishift_high)\r\nimg_back_high = cv.magnitude(img_back_high[:, :, 0], img_back_high[:, :, 1])\r\n\r\n# 使用plt高通滤波后的图像\r\nplt.subplot(121)\r\nplt.imshow(img_back_high, cmap=\'gray\')\r\nplt.title(\'Output Image\')\r\nplt.xticks([])\r\nplt.yticks([])\r\n# 展示高通滤波后的频谱图\r\nplt.subplot(122)\r\nplt.imshow(magnitude_spectrum_high, cmap=\'gray\')\r\nplt.title(\'magnitude_spectrum\')\r\nplt.xticks([])\r\nplt.yticks([])\r\nplt.show()\r\n```\r\n\r\n![image-20211110214625529](cloudDisk/markdown/OpenCV笔记.assets/image-20211110214625529.png)\r\n\r\n# 项目实战\r\n\r\n## 信用卡数字识别\r\n\r\n![image-20211110215358065](cloudDisk/markdown/OpenCV笔记.assets/image-20211110215358065.png)\r\n\r\n模板匹配：\r\n\r\n![image-20211110215555257](cloudDisk/markdown/OpenCV笔记.assets/image-20211110215555257.png)\r\n\r\n### 1、图像显示\r\n\r\n```python\r\ndef imshow(img_name, img):\r\n    cv2.imshow(img_name, img)\r\n    cv2.waitKey(0)\r\n    cv2.destroyAllWindows()\r\n```\r\n\r\n### 2、轮廓排序函数\r\n\r\n```python\r\ndef sort_contours(conts):\r\n    boundingBoxes = [cv2.boundingRect(c) for c in conts] # x, y, w, h\r\n\r\n    # 遍历的时候会将 zip(conts, boundingBoxes) 作为参数传入lambda表达式，将boundingBoxes[0]作为key 进行排序\r\n    # zip(*) 解压\r\n    # zip()  封装\r\n    (conts, boundingBoxes) = zip(*sorted(zip(conts, boundingBoxes), key=lambda b: b[1][0], reverse=False))\r\n    return conts, boundingBoxes\r\n```\r\n\r\n### 3、引入图像，进行处理\r\n\r\n```python\r\nimg_bgr = cv2.imread(\"demo1.png\")\r\ncv2.resize(img_bgr, (200, 150))\r\nimg = cv2.imread(\"demo1.png\", 0)\r\ncv2.resize(img, (200, 150))\r\nimg_temp_bgr = cv2.imread(\"demo1_temp.png\")\r\nimg_temp = cv2.imread(\"demo1_temp.png\", 0)\r\n\r\ndigits = operate_img_temp(img_temp_bgr, img_temp)\r\noperate_img(img_bgr, img)\r\n```\r\n\r\n### 4、处理模板\r\n\r\n```python\r\ndef operate_img_temp(img_temp_bgr, img_temp):\r\n    ############### 处理模板 ######################\r\n    # 模板二值化\r\n    ret, img_temp_bin = cv2.threshold(img_temp, 127, 255, cv2.THRESH_BINARY_INV)\r\n    # 模板边缘检测\r\n    # 函数接受的是二值图，cv2.RETR_EXTERBAL只检测外轮廓；cv2.CHAIN_APPROX_SIMPLE保留终点坐标(知道轮廓位置)\r\n    contours, hierarchy = cv2.findContours(img_temp_bin.copy(), cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)\r\n    # 对边界矩形排序，按照x排序\r\n    contours = sort_contours(contours)[0]\r\n    # 显示contour\r\n    draw_contours = cv2.drawContours(img_temp_bgr, contours, -1, (0, 0, 255), 3)\r\n    digits = {}\r\n    for (i, c) in enumerate(contours):\r\n        x, y, w, h = cv2.boundingRect(c)\r\n        roi = img_temp[y:y + h, x:x + w]\r\n        roi = cv2.resize(roi, (50, 80))\r\n        cv2.bitwise_not(roi, roi)\r\n        # imshow(\"roi\", roi)\r\n        # 将每个裁剪的对象，对应上数字\r\n        digits[i] = roi\r\n    # imshow(\"img\", draw_contours)\r\n    return digits\r\n    # print(np.array(contours).shape)  # 10\r\n```\r\n\r\n### 5、处理图像\r\n\r\n```python\r\ndef operate_img(img_bgr, img):\r\n    # 二值化\r\n    ret, thresh = cv2.threshold(img, 127, 255, cv2.THRESH_BINARY)\r\n    # imshow(\"img\", img_bgr)\r\n\r\n    # 指定一个核(filter), 为突出字体部分，所以核的大小核字体差不多\r\n    sqKernel = cv2.getStructuringElement(cv2.MORPH_RECT, (5, 5))\r\n    rectKernel = cv2.getStructuringElement(cv2.MORPH_RECT, (8, 8))\r\n\r\n    # 礼帽操作，突出更亮的部分，更亮的部分和核的大小应匹配\r\n    tophat = cv2.morphologyEx(img, cv2.MORPH_TOPHAT, sqKernel)\r\n    # imshow(\"tophat\", tophat)\r\n\r\n    # sobel算子（取轮廓）\r\n    gradx = cv2.Sobel(tophat, cv2.CV_32F, 1, 0, ksize=-1) # ksize=-1相当于指定3x3的核\r\n    gradx = cv2.convertScaleAbs(gradx)\r\n    (minVal, maxVal) = np.min(gradx), np.max(gradx)\r\n    gradx = (255 * ((gradx - minVal) / (maxVal - minVal)))\r\n    gradx = gradx.astype(\"uint8\")\r\n\r\n    # 通过闭操作（先膨胀，再腐蚀）将数字连在一起\r\n    gradx = cv2.morphologyEx(gradx, cv2.MORPH_CLOSE, rectKernel)\r\n    # imshow(\"sobelx\", gradx)\r\n\r\n    # THRESH_OTSU自动寻找合适的阈值，适合双峰，需要把阈值参数设置为0\r\n    # THRESH_OTSU 自适应阈值处理\r\n    thresh = cv2.threshold(gradx, 0, 255, cv2.THRESH_BINARY | cv2.THRESH_OTSU)[1]\r\n\r\n    # 再次执行一次闭操作\r\n    thresh = cv2.morphologyEx(thresh, cv2.MORPH_CLOSE, rectKernel)\r\n    # imshow(\"sobelx\", gradx)\r\n\r\n    # 计算轮廓\r\n    contours, hierarchy = cv2.findContours(thresh.copy(), cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)\r\n    img_bgr_copy = img_bgr.copy()\r\n    cv2.drawContours(img_bgr_copy, contours, -1, (0, 0, 255), 3)\r\n    # imshow(\"res\", img_bgr_copy)\r\n\r\n    locs = []\r\n    all_numbers = []\r\n    # 遍历轮廓\r\n    for (i, c) in enumerate(contours):\r\n        (x, y, w, h) = cv2.boundingRect(c)\r\n        if w<30 or w>80 or h<18: continue\r\n        # img_bgr = cv2.rectangle(img_bgr, (x, y), (x + w, y + h), (0, 0, 255), 2)\r\n        locs.append((x, y, w, h))\r\n    # print(locs)\r\n    # 轮廓排序\r\n    output = sorted(locs, key=lambda b: b[0], reverse=False)\r\n    # print(output)\r\n    # imshow(\"res_\", img_bgr)\r\n\r\n    # 遍历每组轮廓\r\n    for (i, (gx, gy, gw, gh)) in enumerate(output):\r\n        print(gx, gy)\r\n        group = img[gy-5:gy+gh+5, gx-5:gx+gw+5]\r\n        # imshow(\"group\", group)\r\n        # 处理每组轮廓\r\n        # 二值化\r\n        ret, thresh = cv2.threshold(group, 127, 255, cv2.THRESH_BINARY)\r\n        # imshow(\"thresh\", thresh)\r\n\r\n        # 检测轮廓\r\n        contours, hierarchy = cv2.findContours(thresh.copy(), cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)\r\n        group_copy = group.copy()\r\n        # cv2.drawContours(group_copy, contours, -1, (0, 0, 255), 3)\r\n        # imshow(\"group_copy\", group_copy)\r\n\r\n        # 轮廓排序\r\n        contours = sort_contours(contours)[0]\r\n\r\n        # 计算每个轮廓的值 for ... in ...\r\n        group_num = []\r\n        for (i, cont) in enumerate(contours):\r\n            x, y, w, h = cv2.boundingRect(cont)\r\n            # 截取每个组中的每个数字\r\n            num = thresh[y:y + h, x:x + w]\r\n            # 数字缩放，和模板一个大小\r\n            num = cv2.resize(num, (50, 80))\r\n            scores = []\r\n            # 模板匹配, 当前数字和模板进行匹配，匹配出来的得分存在scores中\r\n            for temp_num, temp_img in digits.items():\r\n                # 模板匹配\r\n                res = cv2.matchTemplate(num, temp_img, cv2.TM_CCORR_NORMED)\r\n                min_val, max_val, min_loc, max_loc = cv2.minMaxLoc(res)\r\n                scores.append(max_val)\r\n            group_num.append(str(scores.index(max(scores))))\r\n            # print(max(scores)) # 匹配最高的分数\r\n            # print(scores.index(max(scores))) # 识别到的数字\r\n            # all_numbers.append(str(scores.index(max(scores))))\r\n        img_bgr = cv2.rectangle(img_bgr, (gx-5, gy-5), (gx + gw+5, gy + gh+5), (0, 0, 255), 2)\r\n        cv2.putText(img_bgr, \"\".join(group_num), (gx, gy - 15), cv2.FONT_HERSHEY_SIMPLEX, 0.65, (0, 0, 255), 2)\r\n        print(\"\".join(group_num))\r\n\r\n    imshow(\"result\", img_bgr)\r\n```\r\n\r\n![image-20211112142112172](cloudDisk/markdown/OpenCV笔记.assets/image-20211112142112172.png)\r\n\r\n\r\n\r\n## 文档扫描\r\n\r\n素材\r\n\r\n![image-20211112225310946](cloudDisk/markdown/OpenCV笔记.assets/image-20211112225310946.png)\r\n\r\n![image-20211112225220135](cloudDisk/markdown/OpenCV笔记.assets/image-20211112225220135.png)\r\n\r\n![demo2.3](cloudDisk/markdown/OpenCV笔记.assets/demo2.3-16368146873361.png)\r\n\r\n### 导入图片\r\n\r\n```python\r\n# 读取图像\r\nimg1 = cv2.imread(\"demo2.1.png\")\r\nimg2 = cv2.imread(\"demo2.2.png\")\r\n# 坐标也会相同改变, 图像改变了多少\r\nratio = img1.shape[0] / 500\r\ncopy_img1 = img1.copy()\r\n\r\nimg1 = resize(img1, height=500)\r\n```\r\n\r\n```python\r\n# 输入变换高，也同样一起变化宽\r\ndef resize(image, width=None, height=None, inter=cv2.INTER_AREA):\r\n    dim = None\r\n    (h, w) = image.shape[:2]\r\n    if width is None and height is None:\r\n        return image\r\n    if width is None:\r\n        r = height / float(h)\r\n        dim = (int(w * r), height)\r\n    else:\r\n        r = width / float(w)\r\n        dim = (width, int(h * r))\r\n    resized = cv2.resize(image, dim, interpolation=inter)\r\n    return resized\r\n```\r\n\r\nresize函数的作用是按照原图像相同长宽比，当给定长（height）或者宽（width）时将原图resize成与原图像同比例的大小。\r\n\r\n### step1: 边缘检测\r\n\r\n```python\r\nprint(\"step1: 边缘检测\")\r\ngray = cv2.cvtColor(img1, cv2.COLOR_BGR2GRAY) # 转为灰度图\r\ngray = cv2.GaussianBlur(gray, (5, 5), 0) # 高斯滤波去噪点\r\nedged = cv2.Canny(gray, 50, 200) # 边缘检测\r\nimshow(\"edged\", edged)\r\n```\r\n\r\n![image-20211113010558495](cloudDisk/markdown/OpenCV笔记.assets/image-20211113010558495.png)\r\n\r\n![image-20211113224523118](cloudDisk/markdown/OpenCV笔记.assets/image-20211113224523118.png)\r\n\r\n### step2: 获取轮廓\r\n\r\n```python\r\nprint(\"step2: 轮廓检测\")\r\ncontours, hierarchy = cv2.findContours(edged.copy(), cv2.RETR_LIST, cv2.CHAIN_APPROX_SIMPLE) # 检测所有轮廓\r\n\r\n# 轮廓排序，按照面积\r\ncontours = sorted(contours, key=cv2.contourArea, reverse=True)[:5]\r\n# draw_contours = cv2.drawContours(img1.copy(), contours, -1, (0, 0, 255), 1)\r\n# imshow(\"edged\", draw_contours)\r\n# 遍历轮廓\r\nscreenCnt = \"\"\r\nfor c in contours:\r\n    # 计算轮廓近似\r\n    peri = cv2.arcLength(c, True)\r\n    # C便是输入的点集\r\n    # epsilon表示从原始轮廓近似轮廓的最大距离，它是一个准确的参数。就是轮廓近似精度，一般取长度的百分比\r\n    # True表示封闭的\r\n    approx = cv2.approxPolyDP(c, 0.02 * peri, True)\r\n\r\n    # 4个点的时候拿出来，说明是个矩形\r\n    if len(approx) == 4:\r\n        screenCnt = approx\r\n        break\r\n# 显示结果\r\ncv2.drawContours(img1, [screenCnt], -1, (0,255,0), 2)\r\nimshow(\"outline\", img1)\r\n```\r\n\r\n* approx = cv2.approxPolyDP(c, 0.02*peri, True)\r\n  * 0.02 * peri     轮廓近似精度，一般取长度的百分比\r\n  * True表示封闭的\r\n* 轮廓近似的返回值是能够包含图像的点的集合。既然是逐个点确定，又包含了整个图像，那一定是从最大的轮廓开始。当返回值的长度为4，即返回点的个数为4时，说明确定的就是能将最外面的最大轮廓包围的四边形的四个顶点。显示图像如图所示：![image-20211113010953434](cloudDisk/markdown/OpenCV笔记.assets/image-20211113010953434.png)\r\n\r\n![image-20211113011036316](cloudDisk/markdown/OpenCV笔记.assets/image-20211113011036316.png)\r\n\r\n![image-20211113224533490](cloudDisk/markdown/OpenCV笔记.assets/image-20211113224533490.png)\r\n\r\n### step3：变换\r\n\r\n#### 自定义函数1：order_points\r\n\r\n```python\r\ndef order_points(pts):\r\n    # 一共4个坐标点\r\n   # 给定了四个坐标点，因为变换矩阵有8个未知数。\r\n   rect = np.zeros((4, 2), dtype = \"float32\")\r\n\r\n    # 按顺序找到对应坐标0123分别是 左上，右上，右下，左下\r\n   # 计算左上，右下\r\n   s = pts.sum(axis=1)\r\n\r\n   rect[0] = pts[np.argmin(s)]\r\n   rect[2] = pts[np.argmax(s)]\r\n\r\n   # 计算右上和左下\r\n   diff = np.diff(pts, axis = 1)\r\n\r\n   rect[1] = pts[np.argmin(diff)]\r\n   rect[3] = pts[np.argmax(diff)]\r\n\r\n   return rect\r\n```\r\n\r\n* order_point函数用一种方法来分辨这四个定位点分别对应于四边形的那个顶点，简单说就是给四个点起名字。左下（bl）， 右下（br）， 右上（tr）， 左上（tl），并将四个点按顺势者或逆时针依次存放。从那个点开始存放不重要，关键是要通过这四个点的坐标关系确定每一个点分别对应（四边形）的哪一个顶点。\r\n\r\n#### 自定义函数2：four_point_transform\r\n\r\n```python\r\ndef four_point_transform(image, pts):\r\n   # 获取输入坐标点\r\n   # 原始坐标点\r\n   rect = order_points(pts)\r\n   # 4  3\r\n   # 1  2\r\n   (bl, br, tr, tl) = rect\r\n\r\n   # 计算输入的w和h值\r\n   widthA = np.sqrt(((br[0] - bl[0]) ** 2) + ((br[1] - bl[1]) ** 2))\r\n   widthB = np.sqrt(((tr[0] - tl[0]) ** 2) + ((tr[1] - tl[1]) ** 2))\r\n   maxWidth = max(int(widthA), int(widthB))\r\n\r\n   heightA = np.sqrt(((tr[0] - br[0]) ** 2) + ((tr[1] - br[1]) ** 2))\r\n   heightB = np.sqrt(((tl[0] - bl[0]) ** 2) + ((tl[1] - bl[1]) ** 2))\r\n   maxHeight = max(int(heightA), int(heightB))\r\n\r\n   # 变换后对应坐标位置\r\n   # 变换后的坐标点\r\n   # dst对应的是与原图像中轮廓大小相同，只是进行了坐标变换的图像。左上角坐标点为（0，0），图像的长、宽分别为四边形轮廓长、宽最大值的轮廓\r\n   dst = np.array([\r\n      [0, 0],\r\n      [maxWidth - 1, 0],\r\n      [maxWidth - 1, maxHeight - 1],\r\n      [0, maxHeight - 1]], dtype = \"float32\")\r\n\r\n   # 计算变换矩阵\r\n   # 计算从原始坐标到变换后坐标点的变换矩阵\r\n   # 原始图像为一个二维的歪歪扭扭的轮廓，先转化为三维矩阵，再转化成二维的位置纠正后的矩阵\r\n   # 透视变换(Perspective Transformation)是将成像投影到一个新的视平面(Viewing Plane)\r\n   # getPerspectiveTransform第一个参数是原始坐标点，第二个参数是变换之后的坐标点\r\n   # 给定了四个坐标点，变换矩阵M有8个未知数\r\n   M = cv2.getPerspectiveTransform(rect, dst)\r\n   # 利用四组坐标点能够求出变换矩阵M\r\n   warped = cv2.warpPerspective(image, M, (maxWidth, maxHeight))\r\n\r\n   # 返回变换后结果\r\n   return warped\r\n```\r\n\r\n* 进行透视变换了。首先调用函数order_point，使用这四个起好名字的点。根据几个关系利用公式 s = ((x2-x1)2 +(y2-y1)2 )1/2 。因为四个点确定的近似轮廓不一定是矩形，所以分别取长和宽最大长度，\r\n\r\n* 透视变换就是将原始的四个定位点，变换后定位点分别对应dst（左上角的定位点是（0， 0））中的四个定位点坐标。\r\n* 返回值M是由原坐标透视变换到目标坐标点的变换矩阵。\r\n* cv2.warpPerspective(image, M, (maxWidth, maxHeight))\r\n  * 第一个参数是原始图像\r\n  * 第二个参数是变换矩阵（原图片中的小卡片是一个轮廓，变换后图像中小卡片充满了整张图像）\r\n  * 第三个参数是变换后图像的长和宽（场合宽是前面计算出的轮廓长宽取最大值的结果）。\r\n  * 最后该函数返回的结果是透视变换后的图像。\r\n\r\n#### 执行：\r\n\r\n```python\r\n# 透视变化\r\nprint(\"step3: 变换\")\r\n\r\nwraped = four_point_transform(copy_img1, screenCnt.reshape(4, 2) * ratio)\r\nimshow(\"wraped\", wraped)\r\n```\r\n\r\n![image-20211113011823614](cloudDisk/markdown/OpenCV笔记.assets/image-20211113011823614.png)\r\n\r\n![scan](cloudDisk/markdown/OpenCV笔记.assets/scan.jpg)\r\n\r\n### step4：OCR\r\n\r\n```python\r\nfrom PIL import Image\r\nimport pytesseract\r\nimport cv2\r\nimport os\r\n\r\npreprocess = \"blur\" # thresh\r\n\r\nimage = cv2.imread(\"scan.jpg\")\r\ngray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)\r\nif preprocess == \"thresh\":\r\n    gray = cv2.threshold(gray, 0, 255, cv2.THRESH_BINARY | cv2.THRESH_OTSU)[1]\r\n\r\n\r\nif preprocess == \"blur\":\r\n    gray = cv2.medianBlur(gray, 3)\r\n\r\nfilename = \"{}.png\".format(os.getpid())\r\ncv2.imwrite(filename, gray)\r\n\r\ntext = pytesseract.image_to_string(Image.open(filename))\r\nprint(text)\r\nos.remove(filename)\r\n\r\ncv2.imshow(\"Image\", image)\r\n\r\ncv2.imshow(\"Output\", gray)\r\ncv2.waitKey(0)\r\n```\r\n\r\n![image-20211113224632724](cloudDisk/markdown/OpenCV笔记.assets/image-20211113224632724.png)\r\n\r\n\r\n\r\n# 八、角点检测\r\n\r\n![image-20211113232419382](cloudDisk/markdown/OpenCV笔记.assets/image-20211113232457779.png)\r\n\r\n* ksize：一般取3\r\n\r\n```python\r\nimport cv2\r\nimport numpy as np\r\nimport matplotlib.pyplot as plt\r\ndef imshow(img_name, img):\r\n    cv2.imshow(img_name, img)\r\n    cv2.waitKey(0)\r\n    cv2.destroyAllWindows()\r\n\r\n\r\nimg = cv2.imread(\"xiangqi.png\")\r\nprint(\"img.shape\", img.shape)\r\ngray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)\r\n# gray = np.float32(gray)\r\ndst = cv2.cornerHarris(gray, 2, 3, 0.04)\r\nprint(\"dst.shape\", dst.shape)\r\n# v\r\nimg[dst>0.01*dst.max()] = [255,0,0]\r\n\r\nimshow(\"dst\", img)\r\n```\r\n\r\n* img[dst>0.01*dst.max()]=[0,0,255]这段代码是什么意思吧　    dst>0.01*dst.max()这么多返回是满足条件的dst索引值　　根据索引值来设置这个点的颜色\r\n* 这里是设定一个阈值　当大于这个阈值分数的都可以判定为角点　　（好像说跟没说一样是吧）hhhh\r\n  　　　　在看上面我讲的　这里的dst其实就是一个个角度分数R组成的　　　当 λ 1 和 λ 2 都很大，并且 λ 1 ～λ 2 中的时，R 也很大，（λ 1 和 λ 2 中的最小值都大于阈值）说明这个区域是角点。\r\n  　　　　那么这里为什么要大于０．０１×ｄｓｔ.max()呢　注意了这里Ｒ是一个很大的值　我们选取里面最大的Ｒ　然后　只要dst里面的值大于百分之一的Ｒ的最大值　　那么此时这个dst的Ｒ值也是很大的　可以判定他为角点\r\n  　　　　也不一定要０．０１　　　可以根据图像自己选取不过如果太小的话　可能会多圈出几个不同的角点\r\n\r\n# 九、图像特征\r\n\r\n## Scale Invariant Feature Transform (SIFT)\r\n\r\n### 算法原理\r\n\r\n#### 算法特点\r\n\r\n1、具有较好的**稳定性**和**不变性**，能够适应旋转、尺度缩放、亮度的变化，能在一定程度上不受视角变化、仿射变换、噪声的干扰。\r\n2、**区分性**好，能够在海量特征数据库中进行快速准确的区分信息进行匹配\r\n3、**多量性**，就算只有单个物体，也能产生大量特征向量\r\n4、**高速性**，能够快速的进行特征向量匹配\r\n5、**可扩展性**，能够与其它形式的特征向量进行联合\r\n\r\n#### 算法实质\r\n\r\n在不同的尺度空间上查找关键点，并计算出关键点的方向。\r\n\r\n![image-20211115112818332](cloudDisk/markdown/OpenCV笔记.assets/image-20211115112818332.png)\r\n\r\n#### 算法特征匹配流程\r\n\r\n1、**提取关键点**：关键点是一些十分突出的不会因光照、尺度、旋转等因素而消失的点，比如角点、边缘点、暗区域的亮点以及亮区域的暗点。此步骤是搜索所有尺度空间上的图像位置。通过高斯微分函数来识别潜在的具有尺度和旋转不变的点。\r\n\r\n2、定位关键点并确定特征方向：在每个候选的位置上，通过一个拟合精细的模型来确定位置和尺度。关键点的选择依据于它们的稳定程度。然后基于图像局部的梯度方向，分配给每个关键点位置一个或多个方向。所有后面的对图像数据的操作都相对于关键点的方向、尺度和位置进行变换，从而提供对于这些变换的不变性。\r\n\r\n3、**通过各关键点的特征向量**，进行两两比较找出相互匹配的若干对特征点，建立景物间的对应关系。\r\n\r\n#### 尺度空间\r\n\r\n1、概念\r\n尺度空间即试图在图像领域中模拟人眼观察物体的概念与方法。例如：观察一颗树，关键在于我们想要观察是树叶子还是整棵树：如果是一整棵树(相当于大尺度情况下观察)，那么就应该去除图像的细节部分。如果是树叶(小尺度情况下观察)，那么就该观察局部细节特征。\r\nSIFT算法在构建尺度空间时候采取高斯核函数进行滤波，使原始图像保存最多的细节特征，经过高斯滤波后细节特征逐渐减少来模拟大尺度情况下的特征表示。\r\n利用高斯核函数进行滤波的主要原因有两个：\r\n（1）高斯核函数是唯一的尺度不变核函数。\r\n（2）DoG核函数可以近似为LoG函数，这样可以使特征提取更加简单。同时，David. Lowe作者在论文中提出将原始图像进行2倍上采样后滤波能够保留更多的信息便于后续特征提取与匹配。其实尺度空间图像生成就是当前图像与不同尺度核参数σ进行卷积运算后产生的图像。\r\n2、表示\r\nL(x, y, σ) ,定义为原始图像 I(x, y)与一个可变尺度的2维高斯函数G(x, y, σ) 卷积运算。\r\n\r\n![image-20211115114102738](cloudDisk/markdown/OpenCV笔记.assets/image-20211115114102738.png)\r\n\r\n*表示卷积运算，(x,y)代表图像的像素位置。是尺度空间因子，值越小表示图像被平滑的越少，相应的尺度也就越小。大尺度对应于图像的概貌特征，小尺度对应于图像的细节特征。\r\n\r\n#### 高斯金字塔构建\r\n\r\n类似在模拟人眼，降采样模拟焦段，高斯平滑模拟光圈\r\n\r\n**1、概念**\r\n尺度空间在实现时使用高斯金字塔表示，高斯金字塔的构建分为两步：\r\n（1）对图像做高斯平滑；\r\n（2）对图像做降采样。\r\n\r\n![image-20211115114300441](cloudDisk/markdown/OpenCV笔记.assets/image-20211115114300441.png)\r\n\r\n图像的金字塔模型是指将原始图像不断降阶采样，得到一系列大小不一的图像，由大到小，从下到上构成的塔状模型。原图像为金子塔的第一层，每次降采样所得到的新图像为金字塔的一层(每层一张图像)，每个金字塔共n层。为了让尺度体现其连续性，高斯金字塔在简单降采样的基础上加上了高斯滤波。如上图所示，将图像金字塔每层的一张图像使用不同参数做高斯模糊，Octave表示一幅图像可产生的图像组数，Interval表示一组图像包括的图像层数。另外，降采样时，高斯金字塔上一组图像的初始图像(底层图像)是由前一组图像的倒数第三张图像隔点采样得到的。\r\n\r\n**2、表示**\r\n高斯图像金字塔共o组、s层，则有\r\n\r\n![image-20211115114554398](cloudDisk/markdown/OpenCV笔记.assets/image-20211115114554398.png)\r\n\r\nσ：尺度空间坐标；s：sub-level层坐标；σ0：初始尺度；S：每组层数（一般为3~5）\r\n组内和组间尺度：\r\n\r\n![image-20211115114631560](cloudDisk/markdown/OpenCV笔记.assets/image-20211115114631560.png)\r\n\r\ni:金字塔组数；n:每一组的层数\r\n\r\n#### DOG空间极值检测\r\n\r\n1、DOG函数\r\n\r\n![image-20211115114802803](cloudDisk/markdown/OpenCV笔记.assets/image-20211115114802803.png)\r\n\r\n2、DoG高斯差分金字塔\r\n（1）对应DOG算子，需构建DOG金字塔。\r\n可以通过高斯差分图像看出图像上的像素值变化情况。（如果没有变化，也就没有特征。特征必须是变化尽可能多的点。）DOG图像描绘的是目标的轮廓。\r\n\r\n![image-20211115115001562](cloudDisk/markdown/OpenCV笔记.assets/image-20211115115001562.png)\r\n\r\n（2）DOG局部极值检测（找到变化最明显的点）\r\n特征点是由DOG空间的局部极值点组成的。为了寻找DoG函数的极值点，每一个像素点要和它所有的相邻点比较，看其是否比它的图像域和尺度域的相邻点大或者小。特征点是由DOG空间的局部极值点组成的。为了寻找DoG函数的极值点，每一个像素点要和它所有的相邻点比较，看其是否比它的图像域和尺度域的相邻点大或者小。如下图，中间的检测点和它同尺度的8个相邻点和上下相邻尺度对应的9×2个点共26个点比较，以确保在尺度空间和二维图像空间都检测到极值点。\r\n\r\n![image-20211115115129135](cloudDisk/markdown/OpenCV笔记.assets/image-20211115115129135.png)\r\n\r\n（2）去除边缘效应（去边缘干扰点）\r\n在边缘梯度的方向上主曲率值比较大，而沿着边缘方向则主曲率值较小。候选特征点的DoG函数D(x)的主曲率与2×2Hessian矩阵H的特征值成正比。\r\n\r\n![image-20211115115245214](cloudDisk/markdown/OpenCV笔记.assets/image-20211115115245214.png)\r\n\r\n其中，![Dxx,Dxy,Dyy](https://img-blog.csdnimg.cn/20190316212800486.png)是候选点邻域对应位置的差分求得的。\r\nH的特征值α和β代表x和y方向的梯度\r\n\r\n![image-20211115115544367](cloudDisk/markdown/OpenCV笔记.assets/image-20211115115544367.png)\r\n\r\n表示矩阵H对角线元素之和，表示矩阵H的行列式。假设是α较大的特征值，而是β较小的特征值，令![在这里插入图片描述](https://img-blog.csdnimg.cn/2019031621284067.png)，则\r\n\r\n![image-20211115115820375](cloudDisk/markdown/OpenCV笔记.assets/image-20211115115820375.png)\r\n\r\n该值在两特征值相等时达最小。Lowe论文中建议阈值T为1.2，即![在这里插入图片描述](https://img-blog.csdnimg.cn/20190316212852546.png)\r\n时保留关键点，反之剔除\r\n\r\n#### 关键点方向分配\r\n\r\n1、通过尺度不变性求极值点，需要利用图像的局部特征为给每一个关键点分配一个基准方向，使描述子对图像旋转具有不变性。对于在DOG金字塔中检测出的关键点，采集其所在高斯金字塔图像3σ邻域窗口内像素的梯度和方向分布特征。梯度的模值和方向如下：![image-20211115115952672](cloudDisk/markdown/OpenCV笔记.assets/image-20211115115952672.png)\r\n\r\n2、本算法采用梯度直方图统计法，统计以关键点为原点，一定区域内的图像像素点确定关键点方向。在完成关键点的梯度计算后，使用直方图统计邻域内像素的梯度和方向。梯度直方图将0~360度的方向范围分为36个柱，其中每柱10度。如下图所示，直方图的峰值方向代表了关键点的主方向，方向直方图的峰值则代表了该特征点处邻域梯度的方向，以直方图中最大值作为该关键点的主方向。为了增强匹配的鲁棒性，只保留峰值大于主方向峰值80％的方向作为该关键点的辅方向。\r\n\r\n![image-20211115120133805](cloudDisk/markdown/OpenCV笔记.assets/image-20211115120133805.png)\r\n\r\n#### 关键点描述\r\n\r\n对于每一个关键点，都拥有位置、尺度以及方向三个信息。为每个关键点建立一个描述符，用一组向量将这个关键点描述出来，使其不随各种变化而改变，比如光照变化、视角变化等等。这个描述子不但包括关键点，也包含关键点周围对其有贡献的像素点，并且描述符应该有较高的独特性，以便于提高特征点正确匹配的概率。\r\n\r\n![image-20211115120302426](cloudDisk/markdown/OpenCV笔记.assets/image-20211115120302426.png)\r\n\r\nLowe实验结果表明：描述子采用4×4×8＝128维向量表征，综合效果最优（不变性与独特性）。\r\n\r\n#### 关键点匹配\r\n\r\n1、分别对模板图（参考图，reference image）和实时图（观测图，\r\nobservation image）建立关键点描述子集合。目标的识别是通过两点集内关键点描述子的比对来完成。具有128维的关键点描述子的相似性度量采用欧式距离。\r\n3、匹配可采取穷举法完成，但所花费的时间太多。所以一般采用kd树的数据结构来完成搜索。搜索的内容是以目标图像的关键点为基准，搜索与目标图像的特征点最邻近的原图像特征点和次邻近的原图像特征点。\r\nKd树如下如所示，是个平衡二叉树\r\n\r\n![image-20211115120453591](cloudDisk/markdown/OpenCV笔记.assets/image-20211115120453591.png)\r\n\r\n\r\n\r\n\r\n\r\n### 环境配置\r\n\r\n![image-20211114212942673](cloudDisk/markdown/OpenCV笔记.assets/image-20211114212942673.png)\r\n\r\n### sifr函数使用\r\n\r\n```python\r\nimport cv2\r\nimport numpy as np\r\nimport matplotlib.pyplot as plt\r\ndef imshow(img_name, img):\r\n    cv2.imshow(img_name, img)\r\n    cv2.waitKey(0)\r\n    cv2.destroyAllWindows()\r\n\r\n# 读取图片\r\nimg = cv2.imread(\"img1.jpg\")\r\ngray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)\r\n\r\n# 得到特征点\r\nsift = cv2.xfeatures2d.SIFT_create()\r\nkp = sift.detect(gray, None)\r\nimg = cv2.drawKeypoints(gray, kp, img) # 画特征点\r\n\r\nimshow(\"img\", img)\r\n\r\n# 计算特征点\r\nkp, des = sift.compute(gray, kp)\r\nprint(np.array(kp).shape) # (1688,)    1688个特征点\r\nprint(des.shape) # 特征点的相应特征\r\nprint(des[0]) # 具体向量的值\r\n```\r\n\r\n### 特征匹配\r\n\r\n输入1：![image-20211114223726619](cloudDisk/markdown/OpenCV笔记.assets/image-20211114223726619.png)\r\n\r\n输入2；\r\n\r\n![image-20211114223751750](cloudDisk/markdown/OpenCV笔记.assets/image-20211114223751750.png)\r\n\r\n\r\n\r\n#### Brute-Forse 蛮力匹配\r\n\r\n```python\r\nimport cv2\r\nimport numpy as np\r\nimport matplotlib.pyplot as plt\r\ndef imshow(img_name, img):\r\n    cv2.imshow(img_name, img)\r\n    cv2.waitKey(0)\r\n    cv2.destroyAllWindows()\r\n\r\n# 读取图片\r\nimg1 = cv2.imread(\"sift_img1.jpg\")\r\nimg2 = cv2.imread(\"sift_img2.jpg\")\r\nimg1 = cv2.resize(img1, (0, 0), fx=0.13, fy=0.13)\r\nimg2 = cv2.resize(img2, (0, 0), fx=0.13, fy=0.13)\r\nimg1 = cv2.cvtColor(img1, cv2.COLOR_BGR2GRAY)\r\nimg2 = cv2.cvtColor(img2, cv2.COLOR_BGR2GRAY)\r\n\r\n# 得到特征点\r\nsift = cv2.xfeatures2d.SIFT_create()\r\nkp1, des1 = sift.detectAndCompute(img1, None)\r\nkp2, des2 = sift.detectAndCompute(img2, None)\r\n\r\n# crossCheck表示两个特征点要互相匹配，例如A中的第i个特征点与B中第j个特征点最近的，\r\n# 并且B中的第j个特征点到A中的第i个特征点也是\r\n# NORM_L2 ： 归一化数组的（欧几里得距离），如果其他特征计算方法需要考虑不同的匹配计算方式\r\nbf = cv2.BFMatcher(crossCheck=True)\r\n\r\n# 一对一匹配\r\nmatches = bf.match(des1, des2)\r\nmatches = sorted(matches, key=lambda x: x.distance) # 通过接近程度进行排序\r\n\r\nimg3 = cv2.drawMatches(img1, kp1, img2, kp2, matches[0:20], None, flags=2)\r\nimshow(\"res\", img3)\r\n```\r\n\r\n![image-20211114223821441](cloudDisk/markdown/OpenCV笔记.assets/image-20211114223821441.png)\r\n\r\n#### k对最佳匹配\r\n\r\n函数介绍：\r\nbf.knnMatch(des1, des2, k=2)\r\n\r\n输出：\r\nKnnmatch与match的返回值类型一样，都是DMatch类型的数据结构，只不过一组返回的k（此处=2）个DMatch类型。\r\n\r\n找出匹配的特征点并将它们用线连起来\r\n在这里，每一个特征点（设为A）都有最匹配的另外两个特征点在另一张图上，设为B和C。其中AB的距离最短，AC的距离次短。\r\n那么规定，如果AB间的距离小于AC间距离的0.75倍，则认为AB的匹配度远远大于A与其他任何点的匹配度，则将AB两点连起来。\r\n\r\n```python\r\nimport cv2\r\nimport numpy as np\r\nimport matplotlib.pyplot as plt\r\ndef imshow(img_name, img):\r\n    cv2.imshow(img_name, img)\r\n    cv2.waitKey(0)\r\n    cv2.destroyAllWindows()\r\n\r\n# 读取图片\r\nimg1 = cv2.imread(\"sift_img1.jpg\")\r\nimg2 = cv2.imread(\"sift_img2.jpg\")\r\nimg1 = cv2.resize(img1, (0, 0), fx=0.13, fy=0.13)\r\nimg2 = cv2.resize(img2, (0, 0), fx=0.13, fy=0.13)\r\nimg1 = cv2.cvtColor(img1, cv2.COLOR_BGR2GRAY)\r\nimg2 = cv2.cvtColor(img2, cv2.COLOR_BGR2GRAY)\r\n\r\n# 得到特征点\r\nsift = cv2.xfeatures2d.SIFT_create()\r\nkp1, des1 = sift.detectAndCompute(img1, None)\r\nkp2, des2 = sift.detectAndCompute(img2, None)\r\n\r\n# crossCheck表示两个特征点要互相匹配，例如A中的第i个特征点与B中第j个特征点最近的，\r\n# 并且B中的第j个特征点到A中的第i个特征点也是\r\n# NORM_L2 ： 归一化数组的（欧几里得距离），如果其他特征计算方法需要考虑不同的匹配计算方式\r\nbf = cv2.BFMatcher()\r\n\r\n# 一对一匹配\r\nmatches = bf.knnMatch(des1, des2, k=2)\r\n\r\ngood = []\r\nfor m, n in matches:\r\n    if m.distance < 0.75*n.distance:\r\n        good.append([m])\r\n\r\nimg3 = cv2.drawMatchesKnn(img1, kp1, img2, kp2, good, None, flags=2)\r\nimshow(\"res\", img3)\r\n```\r\n\r\n![image-20211114224503479](cloudDisk/markdown/OpenCV笔记.assets/image-20211114224503479.png)\r\n\r\n#### 随机抽样一致算法 （Random sample consensus (RANSAC)）\r\n\r\n![image-20211114230037866](cloudDisk/markdown/OpenCV笔记.assets/image-20211114230037866.png)\r\n\r\n选择初始样本点进行拟合，给定一个容忍范围，不断进行迭代\r\n\r\n1. 首先随机取两个点（图中红色）\r\n2. 相连\r\n3. 设定一个容忍范围n\r\n4. 让红色点相连的直线，两方向平移n的距离\r\n5. 红点及平行线所围成的矩形内，找到所含点的个数\r\n6. 如果点的个数最多，则取该直线\r\n\r\n![image-20211114230053069](cloudDisk/markdown/OpenCV笔记.assets/image-20211114230053069.png)\r\n\r\n![image-20211114230430905](cloudDisk/markdown/OpenCV笔记.assets/image-20211114230430905.png)\r\n\r\n![image-20211114230443869](cloudDisk/markdown/OpenCV笔记.assets/image-20211114230443869.png)\r\n\r\n### 项目实战 - 图像拼接\r\n\r\n1. 读取数据\r\n\r\n   ![image-20211115140821954](cloudDisk/markdown/OpenCV笔记.assets/image-20211115140821954.png)\r\n\r\n   detectAndDescribe()方法\r\n\r\n   1. 转为灰度图\r\n\r\n      ![image-20211115140939104](cloudDisk/markdown/OpenCV笔记.assets/image-20211115140939104.png)\r\n\r\n   2. 建立SIFT生成器\r\n\r\n      ![image-20211115140956466](cloudDisk/markdown/OpenCV笔记.assets/image-20211115140956466.png)\r\n\r\n   3. 检测SIFT特征点，并计算描述子\r\n\r\n      ![image-20211115141026232](cloudDisk/markdown/OpenCV笔记.assets/image-20211115141026232.png)\r\n\r\n   4. 结果转换为numpy数组\r\n\r\n      ![image-20211115141058424](cloudDisk/markdown/OpenCV笔记.assets/image-20211115141058424.png)\r\n\r\n   5. 返回结果特征点集，及对应的描述特征\r\n\r\n      ![image-20211115141131918](cloudDisk/markdown/OpenCV笔记.assets/image-20211115141131918.png)\r\n\r\n2. 匹配两张图片的所有特征点，返回匹配结果\r\n\r\n   ![image-20211115141242676](cloudDisk/markdown/OpenCV笔记.assets/image-20211115141242676.png)\r\n\r\n   方法定义：![image-20211115141323530](cloudDisk/markdown/OpenCV笔记.assets/image-20211115141323530.png)\r\n\r\n   1. 建立暴力匹配器\r\n\r\n      ![image-20211115141347789](cloudDisk/markdown/OpenCV笔记.assets/image-20211115141347789.png)\r\n\r\n   2. 使用KNN检测来自A、B图的特征匹配对，k=2\r\n\r\n      ![image-20211115141434865](cloudDisk/markdown/OpenCV笔记.assets/image-20211115141434865-16369568751431.png)\r\n\r\n   3. 关键点过滤\r\n\r\n      ![image-20211115141521105](cloudDisk/markdown/OpenCV笔记.assets/image-20211115141521105.png)\r\n\r\n      * ratio一般取0.75\r\n      * 找出匹配的特征点并将它们用线连起来在这里，每一个特征点（设为A）都有最匹配的另外两个特征点在另一张图上，设为B和C。其中AB的距离最短，AC的距离次短。\r\n        那么规定，如果AB间的距离小于AC间距离的0.75倍，则认为AB的匹配度远远大于A与其他任何点的匹配度，则将AB两点连起来。\r\n\r\n   4. 当筛选后的匹配对大于4时，计算视角变化矩阵\r\n\r\n      ![image-20211115145327332](cloudDisk/markdown/OpenCV笔记.assets/image-20211115145327332.png)\r\n\r\n   5. 获取匹配对的点坐标\r\n\r\n      ![image-20211115152508346](cloudDisk/markdown/OpenCV笔记.assets/image-20211115152508346.png)\r\n\r\n   6. 计算视角变化矩阵\r\n\r\n      ![image-20211115152535948](cloudDisk/markdown/OpenCV笔记.assets/image-20211115152535948.png)\r\n\r\n      该函数参数：\r\n\r\n      * 第三个参数用于计算单应矩阵的方法。 可以使用以下方法：\r\n      * ​     ＃0  - 使用所有点的常规方法\r\n      * ​     *#CV_RANSAC  - 基于RANSAC的鲁棒方法*\r\n      * ​     *#CV_LMEDS  - 最少中位数的鲁棒方法*\r\n      * 第四个参数取值范围在1到10，绝一个点对的阈值。原图像的点经过变换后点与目标图像上对应点的误差\r\n      * ​     ＃超过误差就认为是异常值\r\n      * ​     ＃返回值中H为变换矩阵.mask是掩模，在线的点\r\n\r\n   7. 返回结果：\r\n\r\n      ![image-20211115152842356](cloudDisk/markdown/OpenCV笔记.assets/image-20211115152842356.png)\r\n\r\n3. 如果结果为空，退出算法\r\n\r\n   ![image-20211115153210671](cloudDisk/markdown/OpenCV笔记.assets/image-20211115153210671.png)\r\n\r\n   1. 提取匹配结果，H是3x3的变化矩阵\r\n\r\n   ![image-20211115153447616](cloudDisk/markdown/OpenCV笔记.assets/image-20211115153447616.png)\r\n\r\n   2. 将图片A进行视角变化，result是对图片变化后的记结果\r\n\r\n   ![image-20211115153555369](cloudDisk/markdown/OpenCV笔记.assets/image-20211115153555369.png)\r\n\r\n   3. 将图片B传入result图片最左端\r\n\r\n      ![image-20211115173850071](cloudDisk/markdown/OpenCV笔记.assets/image-20211115173850071.png)\r\n\r\n    \r\n\r\n   输入：![image-20211115174016724](cloudDisk/markdown/OpenCV笔记.assets/image-20211115174016724.png)\r\n\r\n   ![image-20211115174028755](cloudDisk/markdown/OpenCV笔记.assets/image-20211115174028755.png)\r\n\r\n输出：\r\n\r\n![image-20211115174048003](cloudDisk/markdown/OpenCV笔记.assets/image-20211115174048003.png)\r\n\r\n```python\r\nimport cv2\r\nimport numpy as np\r\nimport matplotlib.pyplot as plt\r\ndef imshow(img_name, img):\r\n    cv2.imshow(img_name, img)\r\n    cv2.waitKey(0)\r\n    cv2.destroyAllWindows()\r\ndef showMatches(imageA, imageB, kpsA, kpsB, matches, status):\r\n    # 将两个图像进行拼接\r\n    # 根据图像的大小，构造全零矩阵\r\n    via = np.zeros((max(imageB.shape[0], imageA.shape[0]), imageA.shape[1] + imageB.shape[1], 3), np.uint8)\r\n    # 将图像A和图像B放到全部都是零的图像中\r\n    via[0:imageA.shape[0], 0:imageA.shape[1]] = imageA\r\n    via[0:imageB.shape[0], imageA.shape[1]:] = imageB\r\n    # 根据matches中的索引，构造出点的位置信息\r\n    for (trainIdx, queryIdx), s in zip(matches, status):\r\n        if s==1:\r\n            ptA = (int(kpsA[queryIdx][0]), int(kpsA[queryIdx][1]))\r\n            ptB = (int(kpsB[trainIdx][0] + imageA.shape[1]), int(kpsB[trainIdx][1]))\r\n            # 使用cv2.line进行画图操作\r\n            cv2.line(via, ptA, ptB, (0, 255, 0), 1)\r\n\r\n    return via\r\n# 读取图片\r\nimgA = cv2.imread(\"pingjie_r.jpg\")\r\nimgB = cv2.imread(\"pingjie_l.jpg\")\r\nimgA = cv2.resize(imgA, (0,0), fx=0.5, fy=0.5)\r\nimgB = cv2.resize(imgB, (0,0), fx=0.5, fy=0.5)\r\n\r\n\r\ngrayA = cv2.cvtColor(imgA, cv2.COLOR_BGR2GRAY)\r\ngrayB = cv2.cvtColor(imgB, cv2.COLOR_BGR2GRAY)\r\n\r\n# 建立SIFT生成器\r\nsift = cv2.xfeatures2d.SIFT_create()\r\n# 检测特征点，并计算描述子\r\nkpA, desA = sift.detectAndCompute(grayA, None)\r\nkpB, desB = sift.detectAndCompute(grayB, None)\r\n\r\n# 转换成NumPy数组\r\nkpA = np.float32([kp.pt for kp in kpA])\r\nkpB = np.float32([kp.pt for kp in kpB])\r\n\r\n# 匹配两张图片的所有特征点 #\r\n\r\n# crossCheck表示两个特征点要互相匹配，例如A中的第i个特征点与B中第j个特征点最近的，\r\n# 并且B中的第j个特征点到A中的第i个特征点也是\r\n# NORM_L2 ： 归一化数组的（欧几里得距离），如果其他特征计算方法需要考虑不同的匹配计算方式\r\nbf = cv2.BFMatcher()\r\n# 一对一匹配\r\nrawMatches = bf.knnMatch(desA, desB, k=2)\r\n\r\nmatches = []\r\nratio = 0.75\r\nfor m in rawMatches:\r\n    # 当最近距离跟次距离比值小于ratio值时，保留次匹配值\r\n    if len(m)==2 and m[0].distance < ratio*m[1].distance:\r\n        # 存储两个点在desA， desB中的索引值\r\n        matches.append((m[0].trainIdx, m[0].queryIdx))\r\n\r\n# 获取匹配大于4时，计算变化矩阵\r\nif len(matches) > 4:\r\n    # 获取匹配对的点坐标\r\n    ptsA = np.float32([kpA[i] for (_, i) in matches])\r\n    ptsB = np.float32([kpB[i] for (i, _) in matches])\r\n\r\n     # 计算视角变化矩阵\r\n    M, status = cv2.findHomography(ptsA, ptsB, cv2.RANSAC, 1)\r\n\r\nif M is not None:\r\n    # 提取匹配结果\r\n    # H是3x3矩阵\r\n    # matches, H, status = M\r\n    # print(H)\r\n    # imshow(\"imgA\", imgA)\r\n    # print(imgA.shape)\r\n    result = cv2.warpPerspective(imgA, M, (imgA.shape[1] + imgB.shape[1], imgB.shape[0]))\r\n    # imshow(\"res\", result)\r\n\r\n    # 将图片B传入result图片最左端\r\n    result[0:imgB.shape[0], 0:imgB.shape[1]] = imgB\r\n    imshow(\"res\", result)\r\n\r\n    via = showMatches(imgA, imgB, kpA, kpB, matches, status)\r\n    imshow(\"via\", via)\r\n```\r\n\r\n\r\n\r\n# 项目实战 - 停车场车位识别\r\n\r\n## 1、输入图片\r\n\r\n![image-20211117153925405](cloudDisk/markdown/OpenCV笔记.assets/image-20211117153925405.png)\r\n\r\n## 2、图像预处理\r\n\r\n```python\r\ndef img_process(image, park):\r\n    # 背景过滤\r\n    white_yellow_image = park.select_rgb_white_yellow(image_bgr)\r\n\r\n    # 灰度处理\r\n    gray_image = park.convert_gray_scale(white_yellow_image)\r\n    # park.show_image(\"gray\", gray_image)\r\n\r\n    # 边缘检测\r\n    image_edge = park.detect_edges(gray_image)\r\n    park.show_image(\"image_edge\", image_edge)\r\n```\r\n\r\n```python\r\ndef select_rgb_white_yellow(self, image):\r\n    # 过滤掉背景\r\n    lower = np.uint8([120, 120, 120])\r\n    upper = np.uint8([255, 255, 255])\r\n    # 低于最小阈值的和高于最大阈值的都会变成0, 介于中间的变为255\r\n    white_mask = cv2.inRange(image, lower, upper)\r\n    # self.show_image(\"white_mask\", white_mask)\r\n\r\n    masked = cv2.bitwise_and(image, image, mask=white_mask)\r\n    # self.show_image(\"masked\", masked)\r\n    return masked\r\n\r\ndef convert_gray_scale(self, image):\r\n    # 转为灰度图\r\n    return cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)\r\n\r\ndef detect_edges(self, image, low_threshold=50, high_threshold=200):\r\n    # 检测边缘\r\n    return cv2.Canny(image, low_threshold, high_threshold)\r\n```\r\n\r\n\r\n\r\n## 3、手动选取有效区域\r\n\r\n```python\r\nregion = park.select_region(process) # 手动选择有效区域\r\n```\r\n\r\n```python\r\ndef select_region(self, image):\r\n    rows, cols = image.shape[:2]\r\n    pt_1 = [cols * 0.05, rows * 0.9]\r\n    pt_2 = [cols * 0.05, rows * 0.65]\r\n    pt_3 = [cols * 0.35, rows * 0.48]\r\n    pt_4 = [cols * 0.55, rows * 0.15]\r\n    pt_5 = [cols * 0.9, rows * 0.15]\r\n    pt_6 = [cols * 0.9, rows * 0.9]\r\n    vertices = np.array([[pt_1, pt_2, pt_3, pt_4, pt_5, pt_6]], dtype=np.int32)\r\n    point_img = image.copy()\r\n    point_img = cv2.cvtColor(point_img, cv2.COLOR_GRAY2BGR)\r\n    for point in vertices[0]:\r\n        cv2.circle(point_img, (point[0], point[1]), 10, (0, 0, 255), 4)\r\n    # self.show_image(\"point\", point_img)\r\n    return self.filter_region(image, vertices)\r\n\r\ndef filter_region(self, image, vertices):\r\n    # 删除掉不需要的部分\r\n    mask = np.zeros_like(image)\r\n    if len(mask.shape) == 2:\r\n        cv2.fillPoly(mask,  vertices, 255)\r\n        # self.show_image(\"mask\", mask)\r\n    return cv2.bitwise_and(image, mask)\r\n```\r\n\r\n![image-20211118010505556](cloudDisk/markdown/OpenCV笔记.assets/image-20211118010505556.png)\r\n\r\n## 4、霍夫变化检测直线\r\n\r\nHoughLinesP( )函数详解\r\n\r\n* 此函数在HoughLines的基础上末尾加了一个代表Probabilistic（概率）的P，表明它可以采用累计概率霍夫变换（PPHT）来找出二值图像中的直线。\r\n* 第一个参数，InputArray类型的image，输入图像，即源图像，需为8位的单通道二进制图像，可以将任意的源图载入进来后由函数修改成此格式后，再填在这里。\r\n* 第二个参数，InputArray类型的lines，经过调用HoughLinesP函数后后存储了检测到的线条的输出矢量，每一条线由具有四个元素的矢量(x_1,y_1, x_2, y_2） 表示，其中，(x_1, y_1)和(x_2, y_2) 是是每个检测到的线段的结束点。\r\n* 第三个参数，double类型的rho， 以像素为单位的距离精度。 另一种形容方式是直线搜索时的进步尺寸的单位半径。\r\n* 第四个参数，double类型的theta，以弧度为单位的角度精度。另一种形容方式是直线搜索时的进步尺寸的单位角度。\r\n* 第五个参数，int类型的threshold，累加平面的阈值参数，即识别某部分为图中的一条直线时它在累加平面中必须达到的值。 大于阈值 threshold 的线段才可以被检测通过并返回到结果中。\r\n* 第六个参数，double类型的minLineLength，有默认值0，表示最低线段的长度，比这个设定参数短的线段就不能被显现出来。\r\n* 第七个参数，double类型的maxLineGap，有默认值0，允许将同一行点与点之间连接起来的最大的距离。\r\n\r\n```python\r\nlines = park.hough_lines(region) # 检测直线\r\nimage_line = park.draw_lines(image_bgr, lines)\r\n```\r\n\r\n```python\r\ndef hough_lines(self, image):\r\n    # 输入的图像需要是边缘检测后的结果\r\n    # minLineLength（线的最短长度，比这小忽略）\r\n    # maxLineCap（两直线间的最大间隔，小于此值，认为是一条直线）\r\n    # rho 和 theta 设置大了，检测结果可能就没那么多了\r\n    # threshold阈值，超过才会被检测到直线，越大结果越少\r\n    return cv2.HoughLinesP(image, rho=0.1, theta=np.pi/10, threshold=15, minLineLength=9, maxLineGap=4)\r\n\r\ndef draw_lines(self, image, lines, color=[0, 0, 255], thickness=2, make_copy=True):\r\n    # 霍夫变化检测到直线\r\n    if make_copy:\r\n        image = np.copy(image)\r\n    cleaned = []\r\n    for line in lines:\r\n        for x1, y1, x2, y2 in line:\r\n            # abs(y2-y1)<=1 判断倾斜程度，如果太斜了，没可能是停车线\r\n            # abs(x2-x1)>=25 and abs(x2-x1)<=55 线的长度\r\n            if abs(y2-y1)<=1 and abs(x2-x1)>=25 and abs(x2-x1)<=55:\r\n                cleaned.append((x1, y1, x2, y2))\r\n                cv2.line(image, (x1, y1), (x2, y2), color, thickness)\r\n    # print(\" No lines detected: \", len(cleaned))\r\n    return image\r\n```\r\n\r\n![image-20211118010519542](cloudDisk/markdown/OpenCV笔记.assets/image-20211118010519542.png)\r\n\r\n## 5、利用检测到的直线进行 区域划分\r\n\r\n```python\r\nblocks = park.identify_blocks(image_bgr, lines)\r\n```\r\n\r\n```python\r\ndef identify_blocks(self, image, lines, make_copy=True):\r\n    if make_copy:\r\n        image = np.copy(image)\r\n    # step1: 过滤部分直线\r\n    cleaned = []\r\n    for line in lines:\r\n        for x1, y1, x2, y2 in line:\r\n            # abs(y2-y1)<=1 判断倾斜程度，如果太斜了，没可能是停车线\r\n            # abs(x2-x1)>=25 and abs(x2-x1)<=55 线的长度\r\n            if abs(y2-y1)<=1 and abs(x2-x1)>=25 and abs(x2-x1)<=55:\r\n                cleaned.append((x1, y1, x2, y2))\r\n    # step2: 对直线按照 x1 进行排序\r\n    import operator\r\n    list1 = sorted(cleaned, key=operator.itemgetter(0, 1))\r\n\r\n    # ste3: 找到多个列，相当于每列是一排车\r\n    # 如果x1，大于了给定的一个容忍范围(当前的和上一根相比)，那把它看作是另外一列\r\n    clusters = {}\r\n    dIndex = 0\r\n    clus_dist = 25\r\n    for i in range(len(list1) - 1):\r\n        distance = abs(list1[i + 1][0] - list1[i][0])\r\n        if distance <= clus_dist:\r\n            if not dIndex in clusters.keys(): clusters[dIndex] = []\r\n            clusters[dIndex].append(list1[i])\r\n            clusters[dIndex].append(list1[i + 1])\r\n        else:\r\n            dIndex += 1 # 换列\r\n    # print(len(clusters)) #  12列\r\n\r\n    # step4: 得到坐标\r\n    rects = {}\r\n    i = 0\r\n    for key in clusters:\r\n        all_list = clusters[key]\r\n        cleaned = list(set(all_list))\r\n        if len(cleaned) > 5: # 每一列的直线个数要大于5，否则不认为是停车列\r\n            cleaned = sorted(cleaned, key=lambda tup: tup[1])\r\n            avg_y1 = cleaned[0][1] # 每一列的第一个y1\r\n            avg_y2 = cleaned[-1][1] # 每一列的最后一个y1\r\n            avg_x1 = 0\r\n            avg_x2 = 0\r\n            # 由于检测到直线的长度，参差不齐，所有取个平均值\r\n            for tup in cleaned:\r\n                avg_x1 += tup[0]\r\n                avg_x2 += tup[2]\r\n            avg_x1 = avg_x1 / len(cleaned)\r\n            avg_x2 = avg_x2 / len(cleaned)\r\n            rects[i] = (avg_x1, avg_y1, avg_x2, avg_y2) # 得到一列的矩形\r\n            i += 1\r\n    # print(\"Num Parking Lanes: \", len(rects))\r\n\r\n    #Step 5: 把列矩形画出来\r\n    buff = 7\r\n    for key in rects:\r\n        tup_topLeft = (int(rects[key][0] - buff), int(rects[key][1]))\r\n        tup_botRight = (int(rects[key][2] + buff), int(rects[key][3]))\r\n        cv2.rectangle(image, tup_topLeft,tup_botRight,(0,255,0),3)\r\n    return image, rects\r\n```\r\n\r\n![image-20211118010539979](cloudDisk/markdown/OpenCV笔记.assets/image-20211118010539979.png)\r\n\r\n## 6、精细划分每个车位\r\n\r\n![image-20211118010321198](cloudDisk/markdown/OpenCV笔记.assets/image-20211118010321198.png)\r\n\r\n## 7、构建神经网络，对图片进行分类\r\n\r\n![image-20211118010422273](cloudDisk/markdown/OpenCV笔记.assets/image-20211118010422273.png)\r\n\r\n完整代码 ：https://github.com/ZhiqiangHo/Opencv-Computer-Vision-Practice-Python-\r\n\r\n\r\n\r\n# 项目实战 - 答题卡扫描\r\n\r\nhttps://www.bilibili.com/video/BV1Vq4y157Gd?p=70\r\n\r\n# 项目实战 - 人脸识别\r\n\r\n## 找人脸\r\n\r\n```python\r\nimport cv2\r\ndef face_detect_demo(img):\r\n    gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)\r\n    # 加载分类器\r\n    face_detect = cv2.CascadeClassifier(\"D:/python/Lib/site-packages/cv2/data/haarcascade_frontalface_default.xml\")\r\n    face = face_detect.detectMultiScale(gray)\r\n    # 参数1：图像\r\n    # 参数2：每次检测完后，遍历的缩放倍数\r\n    # 参数3：检测次数，检测5遍后，确定都有，才框出来\r\n    # 参数4：默认的，填0就好\r\n    # 参数5：人脸最小有多小\r\n    # 参数6：人脸最大有多大\r\n    for x, y, w, h in face:\r\n        cv2.rectangle(img, (x, y), (x+w, y+h), color=(0, 0, 255), thickness=2)\r\n    cv2.imshow(\"face\", img)\r\n\r\n\r\n# 读取图像\r\nimg = cv2.imread(\"face1.png\")\r\n# 检测函数\r\nface_detect_demo(img)\r\n# 等待\r\nwhile True:\r\n    if ord(\'q\') == cv2.waitKey(0):\r\n        break\r\n# 释放内存\r\ncv2.destroyAllWindows()\r\n\r\n```\r\n\r\n## 摄像头找人脸\r\n\r\n```python\r\nimport cv2\r\ndef face_detect_demo(img):\r\n    gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)\r\n    # 加载分类器\r\n    face_detect = cv2.CascadeClassifier(\"D:/python/Lib/site-packages/cv2/data/haarcascade_frontalface_default.xml\")\r\n    face = face_detect.detectMultiScale(gray)\r\n    # 参数1：图像\r\n    # 参数2：每次检测完后，遍历的缩放倍数\r\n    # 参数3：检测次数，检测5遍后，确定都有，才框出来\r\n    # 参数4：默认的，填0就好\r\n    # 参数5：人脸最小有多小\r\n    # 参数6：人脸最大有多大\r\n    for x, y, w, h in face:\r\n        cv2.rectangle(img, (x, y), (x+w, y+h), color=(0, 0, 255), thickness=2)\r\n    cv2.imshow(\"face\", img)\r\n\r\n# 读取摄像头\r\n# 参数0：默认摄像头\r\ncapture = cv2.VideoCapture(0)\r\n\r\nimport time\r\n\r\n# 等待\r\nwhile True:\r\n    flag, frame = capture.read()\r\n    if frame is None:\r\n        break\r\n\r\n    if flag == True:\r\n        gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)\r\n        face_detect_demo(frame)\r\n        if cv2.waitKey(100) & 0xFF==27:\r\n            break\r\n# 释放内存\r\ncv2.destroyAllWindows()\r\ncapture.release()\r\n```\r\n\r\n## 图像保存\r\n\r\n```python\r\nimport cv2\r\ndef face_detect_demo(img):\r\n    gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)\r\n    # 加载分类器\r\n    face_detect = cv2.CascadeClassifier(\"D:/python/Lib/site-packages/cv2/data/haarcascade_frontalface_default.xml\")\r\n    face = face_detect.detectMultiScale(gray)\r\n    # 参数1：图像\r\n    # 参数2：每次检测完后，遍历的缩放倍数\r\n    # 参数3：检测次数，检测5遍后，确定都有，才框出来\r\n    # 参数4：默认的，填0就好\r\n    # 参数5：人脸最小有多小\r\n    # 参数6：人脸最大有多大\r\n    for x, y, w, h in face:\r\n        cv2.rectangle(img, (x, y), (x+w, y+h), color=(0, 0, 255), thickness=2)\r\n    cv2.imshow(\"face\", img)\r\n\r\n# 读取摄像头\r\n# 参数0：默认摄像头\r\ncapture = cv2.VideoCapture(0)\r\n\r\nnum = 1\r\n# 等待\r\nwhile True:\r\n    flag, frame = capture.read()\r\n    if frame is None:\r\n        break\r\n    if flag == True:\r\n        gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)\r\n        face_detect_demo(frame)\r\n        key = cv2.waitKey(100) & 0xFF\r\n        if key == ord(\'s\'): # 保存\r\n            cv2.imwrite(\"face images/\"+str(num)+\"tony.png\", frame)\r\n            num += 1\r\n        elif key == ord(\' \'):\r\n            break\r\n# 释放内存\r\ncv2.destroyAllWindows()\r\ncapture.release()\r\n```\r\n\r\n## 人脸训练\r\n\r\n```python\r\nimport cv2\r\nimport os\r\nfrom PIL import Image\r\nimport numpy as np\r\ndef getImageAndLabels(path):\r\n    # 储存人脸数据\r\n    facesSamples = []\r\n    # 存储姓名数据\r\n    ids = []\r\n    # 存储图片信息\r\n    imagePaths = [os.path.join(path, f) for f in os.listdir(path)]\r\n    # 加载分类器\r\n    face_detector = cv2.CascadeClassifier(\"D:/python/Lib/site-packages/cv2/data/haarcascade_frontalface_alt2.xml\")\r\n    # print(imagePaths)\r\n    # 遍历列表中图片\r\n    for imagePath in imagePaths:\r\n        # 打开图片，灰度化PIL有9种不同模式：1, L, P, RGB, RGBA, CMYK, YCbCR, YCbCr, I, F\r\n        convert = Image.open(imagePath).convert(\'L\')\r\n        # 将图片转化为数组，以黑白深浅\r\n        array = np.array(convert, \"uint8\")\r\n        # 获取图片人脸特征\r\n        faces = face_detector.detectMultiScale(array)\r\n        # 获取每张图片的id和姓名\r\n        id = int(os.path.split(imagePath)[1].split(\'.\')[0])\r\n        # 预防没面容照\r\n        for x, y, w, h in faces:\r\n            ids.append(id)\r\n            facesSamples.append(array[y:y+h, x:x+w])\r\n         # 打印脸部特征和id\r\n    print(\"ids:\", ids)\r\n    print(\"fs:\", facesSamples)\r\n    return facesSamples, ids\r\n\r\nif __name__ == \"__main__\":\r\n    # 图片路径\r\n    path = \"face images\"\r\n    # 获取图像数组和id标签数组和姓名\r\n    faces, ids = getImageAndLabels(path)\r\n    # 加载识别器\r\n    recognizer = cv2.face.LBPHFaceRecognizer_create()\r\n    # 训练\r\n    recognizer.train(faces, np.array(ids))\r\n    # 保存文件\r\n    recognizer.write(\"trainer/trainer.yml\")\r\n```\r\n\r\n## 人脸识别\r\n\r\n','2022-06-23 21:38:17','OpenCV是一个基于Apache2.0许可（开源）发行的跨平台计算机视觉和机器学习软件库，可以运行在Linux、Windows、Android和Mac OS操作系统上。 [1]  它轻量级而且高效——由一系列 C 函数和少量 C++ 类构成，同时提供了Python、Ruby、MATLAB等语言的接口，实现了图像处理和计算机视觉方面的很多通用算法。\r\nOpenCV用C++语言编写，它具有C ++，P','','原创','','','\0','Python-OpenCV 计算机视觉学习笔记','2022-06-23 21:38:17',10,92,NULL,2),(168,'','# 炒股软件：\r\n\r\n同花顺、通达信、东方财富、大智慧。。。\r\n\r\n使用电脑版更好\r\n\r\n使用同花顺演示\r\n\r\n# 股票分类\r\n\r\n![image-20211113014238483](cloudDisk/markdown/炒股笔记.assets/image-20211113014238483-16367389601231.png)\r\n\r\n![image-20211113014325353](cloudDisk/markdown/炒股笔记.assets/image-20211113014325353.png)\r\n\r\n# 股票交易时间\r\n\r\n![image-20211113015000282](cloudDisk/markdown/炒股笔记.assets/image-20211113015000282.png)\r\n\r\n# 涨跌幅\r\n\r\n![image-20211113015406880](cloudDisk/markdown/炒股笔记.assets/image-20211113015406880-16367414741311.png)\r\n\r\n# 分时图\r\n\r\n![image-20211113020640485](cloudDisk/markdown/炒股笔记.assets/image-20211113020640485.png)\r\n\r\n# K线图\r\n\r\n![image-20211113020820596](cloudDisk/markdown/炒股笔记.assets/image-20211113020820596.png)\r\n\r\n# 交易规则\r\n\r\n![image-20211113021556650](cloudDisk/markdown/炒股笔记.assets/image-20211113021556650.png)\r\n\r\n![image-20211113021900046](cloudDisk/markdown/炒股笔记.assets/image-20211113021900046.png)\r\n\r\n','2022-06-23 21:41:25','股票（stock）是股份公司所有权的一部分，也是发行的所有权凭证，是股份公司为筹集资金而发行给各个股东作为持股凭证并借以取得股息和红利的一种有价证券。股票是资本市场的长期信用工具，可以转让，买卖，股东凭借它可以分享公司的利润，但也要承担公司运作错误所带来的风险。每股股票都代表股东对企业拥有一个基本单位的所有权。每家上市公司都会发行股票。\r\n同一类别的每一份股票所代表的公司所有权是相等的。每个股东所拥','cloudDisk/markdown/炒股笔记.assets/image-20211113020820596.png','原创','','','\0','股票知识','2022-06-23 21:41:25',4,99,NULL,0),(169,'','# 一、Java语言跨平台原理\r\n\r\n## ![image-20210706133449615](cloudDisk/markdown/Java笔记.assets\\image-20210706133449615.png)\r\n\r\n# 二、JRE和JDK\r\n\r\n##  2.1 JRE是Java运行环境\r\n\r\n## 2.2 JDK是java开发工具包（包含编译工具javac.exe，y运行工具java.exe）\r\n\r\n![image-20210706133837433](cloudDisk/markdown/Java笔记.assets\\image-20210706133837433.png)\r\n\r\n# 三、JDK下载安装\r\n\r\n![image-20210706134031599](cloudDisk/markdown/Java笔记.assets\\image-20210706134031599.png)\r\n\r\n# 四、常用DOS命令\r\n\r\n![image-20210706134916057](cloudDisk/markdown/Java笔记.assets\\image-20210706134916057.png)\r\n\r\n# 五、path环境变量配置\r\n\r\n![image-20210706135339050](cloudDisk/markdown/Java笔记.assets\\image-20210706135339050.png)\r\n\r\n# 六、常量\r\n\r\n<img src=\"cloudDisk/markdown/Java笔记.assets\\image-20210706140137244.png\" alt=\"image-20210706140137244\" style=\"zoom:80%;\" />\r\n\r\n\r\n\r\n# 七、数据类型\r\n\r\n## 7.1 位和字节\r\n\r\n位（bit）—	计算机存储设备最小信息单元\r\n\r\n字节（byte）— 计算机中最小存储单元\r\n\r\n![image-20210706140444775](cloudDisk/markdown/Java笔记.assets\\image-20210706140444775.png)\r\n\r\n## 7.2 数据类型\r\n\r\n![image-20210706140628921](cloudDisk/markdown/Java笔记.assets\\image-20210706140628921.png)\r\n\r\n## 7.3 取值范围\r\n\r\n![image-20210706140832734](cloudDisk/markdown/Java笔记.assets\\image-20210706140832734.png)\r\n\r\nlong l = 10000000000; 报错，由于常量默认int类型，无法赋值给l；\r\n\r\n解决方法： longl = 10000000000L;\r\n\r\n float f = 13.14; 报错，由于常量默认double类型，无法赋值给F；\r\n\r\n解决方法： float f = 13.14F;  //精度会有损失\r\n\r\n## 7.4 命名规范\r\n\r\n![image-20210706141811886](cloudDisk/markdown/Java笔记.assets\\image-20210706141811886.png)\r\n\r\n## 7.5 类型转换\r\n\r\n数值型的：\r\n\r\n![image-20210706141941587](cloudDisk/markdown/Java笔记.assets\\image-20210706141941587.png)\r\n\r\n强制类型转换：\r\n\r\n![image-20210706142515455](cloudDisk/markdown/Java笔记.assets\\image-20210706142515455.png)\r\n\r\n# 八、运算符\r\n\r\n## 8.1 算数运算符\r\n\r\n![image-20210706142639890](cloudDisk/markdown/Java笔记.assets\\image-20210706142639890.png)\r\n\r\n## 8.2 基本数据类型混合计算\r\n\r\n![image-20210706143004082](cloudDisk/markdown/Java笔记.assets\\image-20210706143004082.png)\r\n\r\n## 8.3 字符串+操作\r\n\r\n![image-20210706143401295](cloudDisk/markdown/Java笔记.assets\\image-20210706143401295.png)\r\n\r\n## 8.4 i++ 和 ++i\r\n\r\nint i = 10;\r\n\r\nSystem.out.println(\"i: \" + i);\r\n\r\nint j = ++i;\r\n\r\nSystem.out.println(\"i \" + i);\r\n\r\nSystem.out.println(\"j: \" + j);\r\n\r\n![image-20210706143846320](cloudDisk/markdown/Java笔记.assets\\image-20210706143846320.png)\r\n\r\n++i 先加再运算\r\n\r\ni++ 先运算最后再加\r\n\r\n## 8.5 关系运算符\r\n\r\n![image-20210706144000584](cloudDisk/markdown/Java笔记.assets\\image-20210706144000584.png)\r\n\r\n## 8.6 逻辑运算符\r\n\r\n![image-20210706144242831](cloudDisk/markdown/Java笔记.assets\\image-20210706144242831.png)\r\n\r\n![image-20210706144626931](cloudDisk/markdown/Java笔记.assets\\image-20210706144626931.png)\r\n\r\n注意：& 与 &&区别：&左右两边都要执行运算，&&前面为false,后面就不运算   \r\n\r\n​			| 与||区别：|左右两边都要执行运算，||前面为ture,后面就不运算   \r\n\r\n## 8.7 三元运算符\r\n\r\n![image-20210706144707824](cloudDisk/markdown/Java笔记.assets\\image-20210706144707824.png)\r\n\r\n# 九、数据输入\r\n\r\n![image-20210706213319755](cloudDisk/markdown/Java笔记.assets\\image-20210706213319755.png)\r\n\r\nimport java.util.Scanner; //导入包\r\npublic class ScannerDemo{\r\n	public static void main(String[] args){\r\n		Scanner sc = new Scanner(System.in); //创建对象\r\n		int i = sc.nextInt(); // 接受数据\r\n		System.out.println(\"x: \" + i);\r\n	}\r\n}\r\n\r\n# 十、switch语句\r\n\r\n![image-20210706221418431](cloudDisk/markdown/Java笔记.assets\\image-20210706221418431.png)\r\n\r\n![image-20210706221658229](cloudDisk/markdown/Java笔记.assets\\image-20210706221658229.png)\r\n\r\n# 十一、Random - 随机数\r\n\r\n![image-20210706222214053](cloudDisk/markdown/Java笔记.assets\\image-20210706222214053.png)\r\n\r\n# 十二、Idea集成开发环境配置\r\n\r\nhttps://www.bilibili.com/video/BV18J411W7cE?p=54&spm_id_from=pageDriver\r\n\r\n![image-20210707001620705](cloudDisk/markdown/Java笔记.assets\\image-20210707001620705.png)\r\n\r\n### 12.1 快捷键\r\n\r\n![image-20210707002207109](cloudDisk/markdown/Java笔记.assets\\image-20210707002207109.png)\r\n\r\n### 12.2 IDEA中删除模块\r\n\r\n![image-20210707002949898](cloudDisk/markdown/Java笔记.assets\\image-20210707002949898.png)\r\n\r\n#### 导入模块\r\n\r\n![image-20210707003029739](cloudDisk/markdown/Java笔记.assets\\image-20210707003029739.png)\r\n','2022-06-23 21:44:18','Java 是由 Sun Microsystems 公司于 1995 年 5 月推出的 Java 面向对象程序设计语言和 Java 平台的总称。由 James Gosling和同事们共同研发，并在 1995 年正式推出。\r\n\r\n后来 Sun 公司被 Oracle （甲骨文）公司收购，Java 也随之成为 Oracle 公司的产品。','cloudDisk/markdown/Java笔记.assets\\image-20210706133449615.png','原创','','','\0','Java 基础（一）','2022-06-23 21:44:18',5,100,NULL,0),(170,'','\r\n# 一、数组\r\n\r\n## 1.1 概述 \r\n\r\n是存储多个相同类型数据的存储模型\r\n\r\n## 1.2 定义\r\n\r\n![image-20210707091902352](cloudDisk/markdown/Java笔记.assets\\image-20210707091902352.png)\r\n\r\n## 1.3 数组初始化 - 动态初始化\r\n\r\n![image-20210707092145358](cloudDisk/markdown/Java笔记.assets\\image-20210707092145358.png)\r\n\r\n## 1.4 数组元素访问\r\n\r\n![image-20210707092441067](cloudDisk/markdown/Java笔记.assets\\image-20210707092441067.png)\r\n\r\n## 1.5 内存分配\r\n\r\n![image-20210707092830773](cloudDisk/markdown/Java笔记.assets\\image-20210707092830773.png)\r\n\r\n![image-20210707092944186](cloudDisk/markdown/Java笔记.assets\\image-20210707092944186.png)\r\n\r\n \r\n\r\n## 1.6 数组初始化 - 静态初始化\r\n\r\n![image-20210707093848828](cloudDisk/markdown/Java笔记.assets\\image-20210707093848828.png)\r\n\r\n## 1.7 数组操作常见问题\r\n\r\n![image-20210707094124331](cloudDisk/markdown/Java笔记.assets\\image-20210707094124331.png)\r\n\r\n![image-20210707094129842](cloudDisk/markdown/Java笔记.assets\\image-20210707094129842.png)\r\n\r\n## 1.8 数组常见操作\r\n\r\n### 	1.81 遍历\r\n\r\n.length 数组方法，取数组长度\r\n\r\n​	![image-20210707094356384](cloudDisk/markdown/Java笔记.assets\\image-20210707094356384.png)\r\n\r\n### 1.82 获取最值\r\n\r\n![image-20210707094550449](cloudDisk/markdown/Java笔记.assets\\image-20210707094550449.png)\r\n\r\n\r\n\r\n# 二、方法\r\n\r\n## 2.1定义\r\n\r\n![image-20210707094911992](cloudDisk/markdown/Java笔记.assets\\image-20210707094911992.png)\r\n\r\n## 2.2调用\r\n\r\n![image-20210707094923611](cloudDisk/markdown/Java笔记.assets\\image-20210707094923611.png)\r\n\r\n## 2.3 带参数方法\r\n\r\n![image-20210707095244272](cloudDisk/markdown/Java笔记.assets\\image-20210707095244272.png)\r\n\r\n![image-20210707095255433](cloudDisk/markdown/Java笔记.assets\\image-20210707095255433.png)\r\n\r\n## 2.3 带参数方法调用\r\n\r\n![image-20210707095331898](cloudDisk/markdown/Java笔记.assets\\image-20210707095331898.png)\r\n\r\n![image-20210707095354464](cloudDisk/markdown/Java笔记.assets\\image-20210707095354464.png)\r\n\r\n## 2.4 形参和实参\r\n\r\n![image-20210707095515578](cloudDisk/markdown/Java笔记.assets\\image-20210707095515578.png)\r\n\r\n## 2.5 返回值\r\n\r\n![image-20210707095610995](cloudDisk/markdown/Java笔记.assets\\image-20210707095610995.png)\r\n\r\n## 2.6 注意事项\r\n\r\n![image-20210707095848579](cloudDisk/markdown/Java笔记.assets\\image-20210707095848579.png)\r\n\r\n![image-20210707100143855](cloudDisk/markdown/Java笔记.assets\\image-20210707100143855.png)\r\n\r\n![image-20210707100223544](cloudDisk/markdown/Java笔记.assets\\image-20210707100223544.png)\r\n\r\n# 三、方法重载\r\n\r\n## 	3.1 特点\r\n\r\n![image-20210707100424143](cloudDisk/markdown/Java笔记.assets\\image-20210707100424143.png)\r\n\r\n![image-20210707100523890](cloudDisk/markdown/Java笔记.assets\\image-20210707100523890.png)\r\n\r\n![image-20210707100724818](cloudDisk/markdown/Java笔记.assets\\image-20210707100724818.png)\r\n\r\n![image-20210707100922517](cloudDisk/markdown/Java笔记.assets\\image-20210707100922517.png)\r\n\r\n## 3.2 方法重载练习\r\n\r\n![image-20210707101119775](cloudDisk/markdown/Java笔记.assets\\image-20210707101119775.png)\r\n\r\n```java\r\npublic class Test {\r\n    public static void main(String[] args) {\r\n        boolean i = compare(10,20);\r\n        System.out.println(i);\r\n        System.out.println(\"------------\");\r\n\r\n        boolean l = compare(10L,10L);\r\n        System.out.println(l);\r\n        System.out.println(\"------------\");\r\n\r\n        boolean b = compare((byte)7,(byte)7);\r\n        System.out.println(b);\r\n        System.out.println(\"------------\");\r\n\r\n        boolean s = compare((short)10,(short)20);\r\n        System.out.println(s);\r\n    }\r\n\r\n    public static boolean compare(int a, int b) {\r\n        System.out.println(\"int\");\r\n        return a == b;\r\n    }\r\n    public static boolean compare(long a, long b) {\r\n        System.out.println(\"long\");\r\n        return a == b;\r\n    }\r\n    public static boolean compare(byte a, byte b) {\r\n        System.out.println(\"byte\");\r\n        return a == b;\r\n    }\r\n    public static boolean compare(short a, short b) {\r\n        System.out.println(\"short\");\r\n        return a == b;\r\n    }\r\n}\r\n```\r\n\r\n## 3.3 参数传递（基本数据类型）\r\n\r\n![image-20210707102633144](cloudDisk/markdown/Java笔记.assets\\image-20210707102633144.png)\r\n\r\n## 3.4 参数传递（引用类型）\r\n\r\n![image-20210707102803981](cloudDisk/markdown/Java笔记.assets\\image-20210707102803981.png)\r\n\r\n\r\n\r\n# 四、Debug\r\n\r\n## 	4.1 Debug概述\r\n\r\n​	![image-20210707103100805](cloudDisk/markdown/Java笔记.assets\\image-20210707103100805.png)\r\n\r\n## 	4.2 操作流程\r\n\r\n![image-20210707103129186](cloudDisk/markdown/Java笔记.assets\\image-20210707103129186.png)\r\n\r\n![image-20210707103138834](cloudDisk/markdown/Java笔记.assets\\image-20210707103138834.png)\r\n\r\n![image-20210707103159648](cloudDisk/markdown/Java笔记.assets\\image-20210707103159648.png)\r\n\r\n![image-20210707103336517](cloudDisk/markdown/Java笔记.assets\\image-20210707103336517.png)\r\n\r\n![image-20210707103350805](cloudDisk/markdown/Java笔记.assets\\image-20210707103350805.png)\r\n\r\n![image-20210707103401758](cloudDisk/markdown/Java笔记.assets\\image-20210707103401758.png)\r\n\r\n![image-20210707103437198](cloudDisk/markdown/Java笔记.assets\\image-20210707103437198.png)\r\n\r\n# 案例\r\n\r\n## 数组倒序\r\n\r\n![image-20210707113537134](cloudDisk/markdown/Java笔记.assets\\image-20210707113537134.png)\r\n\r\n```java\r\npublic class Test<scanner, Scan> {\r\n    public static void main(String[] args) {\r\n        int arr[] = {1,2,3,4,5,6,7,8,9,10,11};\r\n        for(int start=0,end=arr.length-1,temp; start<end; start++,end--){\r\n            temp = arr[start];\r\n            arr[start] = arr[end];\r\n            arr[end] = temp;\r\n        }\r\n        for(int i=0; i<arr.length; i++){\r\n            System.out.println(arr[i]);\r\n        }\r\n    }\r\n}\r\n```\r\n\r\nresult:\r\n\r\n![image-20210707113600920](cloudDisk/markdown/Java笔记.assets\\image-20210707113600920.png)\r\n','2022-06-23 21:49:31','Java 是由 Sun Microsystems 公司于 1995 年 5 月推出的 Java 面向对象程序设计语言和 Java 平台的总称。由 James Gosling和同事们共同研发，并在 1995 年正式推出。\r\n\r\n后来 Sun 公司被 Oracle （甲骨文）公司收购，Java 也随之成为 Oracle 公司的产品。','cloudDisk/markdown/Java笔记.assets\\image-20210707092830773.png','原创','','','\0','Java 基础（二）','2022-06-23 21:49:31',2,100,NULL,0),(171,'','\r\n# 一、类和对象\r\n\r\n## 1.1 类和对象关系\r\n\r\n![image-20210708162152814](cloudDisk/markdown/Java笔记.assets\\image-20210708162152814.png)\r\n\r\n## 1.2 类的定义\r\n\r\n![image-20210708162356583](cloudDisk/markdown/Java笔记.assets\\image-20210708162356583.png)\r\n\r\n```java\r\npublic class Phone {\r\n    // 成员变量\r\n    String brand;\r\n    int price;\r\n\r\n    //成员方法\r\n    public void call() {\r\n        System.out.println(\"打电话\");\r\n    }\r\n    public void message() {\r\n        System.out.println(\"发短信\");\r\n    }\r\n}\r\n```\r\n\r\n## 1.3 对象的使用\r\n\r\n![image-20210708163107225](cloudDisk/markdown/Java笔记.assets\\image-20210708163107225.png)\r\n\r\n```java\r\npublic class TestDemo {\r\n    public static void main(String[] args) {\r\n        // 创建对象\r\n        Phone p = new Phone();\r\n        p.brand = \"小米\";\r\n        p.price = 2999;\r\n\r\n        // 使用成员变量\r\n        System.out.println(p.brand);\r\n        System.out.println(p.price);\r\n\r\n        //使用成员方法\r\n        p.call();\r\n        p.message();\r\n    }\r\n}\r\n```\r\n\r\n## 1.4 成员变量和局部变量\r\n\r\n![image-20210708165934031](cloudDisk/markdown/Java笔记.assets\\image-20210708165934031.png)\r\n\r\n ![image-20210708170106924](cloudDisk/markdown/Java笔记.assets\\image-20210708170106924.png)\r\n\r\n## 1.5 private关键字 - 具有数据安全作用\r\n\r\n![image-20210708170341188](cloudDisk/markdown/Java笔记.assets\\image-20210708170341188.png)\r\n\r\n![image-20210708170354325](cloudDisk/markdown/Java笔记.assets\\image-20210708170354325.png)\r\n\r\n## 1.6 this 关键字 - 类似python里的self\r\n\r\n![image-20210708180916538](cloudDisk/markdown/Java笔记.assets\\image-20210708180916538.png)\r\n\r\n![image-20210708181055522](cloudDisk/markdown/Java笔记.assets\\image-20210708181055522.png)\r\n\r\n## 1.7 封装\r\n\r\n![image-20210708181300863](cloudDisk/markdown/Java笔记.assets\\image-20210708181300863.png)\r\n\r\n## 1.8 构造方法 - 创建对象时执行\r\n\r\n![image-20210708181524957](cloudDisk/markdown/Java笔记.assets\\image-20210708181524957.png)\r\n\r\n![image-20210708181549873](cloudDisk/markdown/Java笔记.assets\\image-20210708181549873.png)\r\n\r\n```java\r\npackage com.test;\r\n\r\npublic class Student {\r\n\r\n    public Student(){\r\n        System.out.println(\"无参构造方法\");\r\n    }\r\n\r\n\r\n}\r\n```\r\n\r\n```java\r\npackage com.test;\r\n\r\npublic class StudentDemo {\r\n    public static void main(String[] args) {\r\n        Student s1 = new Student();\r\n    }\r\n}\r\n```\r\n\r\n### 类中有构造方法时，自动执行，构造方法也可以重载\r\n\r\n#### 重载实例：\r\n\r\n```java\r\npackage com.test;\r\n\r\npublic class Student {\r\n\r\n    public Student(){\r\n        System.out.println(\"无参构造方法\");\r\n    }\r\n\r\n    public Student(int age){\r\n        System.out.println(age);\r\n    }\r\n\r\n    public Student(double height){\r\n        System.out.println(height);\r\n    }\r\n\r\n    public Student(String name, int age){\r\n        System.out.println(name + \'-\' +age);\r\n    }\r\n}\r\n```\r\n\r\n```java\r\npackage com.test;\r\n\r\npublic class StudentDemo {\r\n    public static void main(String[] args) {\r\n        Student s1 = new Student();\r\n\r\n        Student s2 = new Student(18);\r\n\r\n        Student s3 = new Student(165.00);\r\n\r\n        Student s4 = new Student(\"tony\",18);\r\n    }\r\n}\r\n```\r\n\r\nresult:\r\n\r\n无参构造方法\r\n18\r\n165.0\r\ntony-18\r\n\r\n### 注意事项\r\n\r\n![image-20210708183845757](cloudDisk/markdown/Java笔记.assets\\image-20210708183845757.png)\r\n\r\n## 1.9 标准类制作\r\n\r\n![image-20210708184124996](cloudDisk/markdown/Java笔记.assets\\image-20210708184124996.png)\r\n\r\nStudent类：\r\n\r\n```java\r\npackage com.test;\r\n\r\npublic class Student {\r\n    int age;\r\n    String name;\r\n    public Student(){\r\n    }\r\n\r\n    public Student(String name, int age){\r\n        this.name = name;\r\n        this.age = age;\r\n    }\r\n\r\n    public int getAge() {\r\n        return age;\r\n    }\r\n\r\n    public void setAge(int age) {\r\n        this.age = age;\r\n    }\r\n\r\n    public String getName() {\r\n        return name;\r\n    }\r\n\r\n    public void setName(String name) {\r\n        this.name = name;\r\n    }\r\n    public void show(){\r\n        System.out.println(name + \",\" + age);\r\n    }\r\n}\r\n```\r\n\r\n测试类：\r\n\r\n```java\r\npackage com.test;\r\n\r\npublic class StudentDemo {\r\n    public static void main(String[] args) {\r\n        Student s1 = new Student();\r\n        s1.setAge(39);\r\n        s1.setName(\"Pony\");\r\n        s1.show();\r\n        Student s2 = new Student(\"Tony\",18);\r\n        s2.show();\r\n    }\r\n}\r\n```\r\n\r\n\r\n\r\n# 二、 API\r\n\r\n## 1.1 概述\r\n\r\n![image-20210708185036588](cloudDisk/markdown/Java笔记.assets\\image-20210708185036588.png)\r\n\r\n#### 利用API帮助文档，实现scanner输入一串字符串，并输出\r\n\r\n```java\r\npackage test01;\r\n\r\nimport org.w3c.dom.ls.LSOutput;\r\n\r\nimport javax.crypto.spec.PSource;\r\nimport java.util.Scanner;\r\n\r\npublic class ScannerDemo {\r\n    public static void main(String[] args) {\r\n        //创建对象\r\n        Scanner sc = new Scanner(System.in);\r\n\r\n        //接收数据\r\n        System.out.println(\"输入一个字符串\");\r\n        String i = sc.nextLine();\r\n        System.out.println(\"》》》\"+i);\r\n    }\r\n\r\n\r\n}\r\n```\r\n\r\n![image-20210708192552510](cloudDisk/markdown/Java笔记.assets\\image-20210708192552510.png)\r\n\r\n![image-20210708192853027](cloudDisk/markdown/Java笔记.assets\\image-20210708192853027.png)\r\n\r\n# 三、String\r\n\r\n## 3.1 概述\r\n\r\n![image-20210708193452085](cloudDisk/markdown/Java笔记.assets\\image-20210708193452085.png)\r\n\r\n## 3.2 String 构造方法\r\n\r\n![image-20210708193645021](cloudDisk/markdown/Java笔记.assets\\image-20210708193645021.png)\r\n\r\n![image-20210708212059566](cloudDisk/markdown/Java笔记.assets\\image-20210708212059566.png)\r\n\r\n## 3.3 String 对象的特点\r\n\r\n![image-20210708212245997](cloudDisk/markdown/Java笔记.assets\\image-20210708212245997.png)\r\n\r\n![image-20210708212317898](cloudDisk/markdown/Java笔记.assets\\image-20210708212317898.png)\r\n\r\n![image-20210708212654623](cloudDisk/markdown/Java笔记.assets\\image-20210708212654623.png)\r\n\r\n## 3.4 字符串比较\r\n\r\n![image-20210708212839476](cloudDisk/markdown/Java笔记.assets\\image-20210708212839476.png)\r\n\r\n## 3.5 案例 - 用户登录\r\n\r\n```java\r\npackage test02;\r\n\r\nimport java.util.Scanner;\r\n\r\npublic class loginDemo {\r\n    public static void main(String[] args) {\r\n        Scanner l = new Scanner(System.in);\r\n        System.out.print(\"设置您的账号：\");\r\n        String userName = l.nextLine();\r\n        System.out.print(\"设置您的密码：\");\r\n        String passWord = l.nextLine();\r\n        do {\r\n            System.out.print(\"请输入您的账号：\");\r\n            String inputUserName = l.nextLine();\r\n            System.out.print(\"请输入您的密码：\");\r\n            String inputPassword = l.nextLine();\r\n            if (userName.equals(inputUserName) && passWord.equals(inputPassword)){\r\n                System.out.println(\"登录成功！！！\");\r\n                break;\r\n            }\r\n            else {\r\n                System.out.println(\"请重新输入!!!\");\r\n            }\r\n        }\r\n        while(true);\r\n    }\r\n}\r\n```\r\n\r\n## 3.6 遍历字符串\r\n\r\n```java\r\npackage test02;\r\n\r\nimport java.util.Scanner;\r\n\r\npublic class loginDemo {\r\n    public static void main(String[] args) {\r\n        Scanner l = new Scanner(System.in);\r\n        System.out.print(\"输入一个字符串：\");\r\n        String line = l.nextLine();\r\n//        System.out.println(line.charAt(0));\r\n//        System.out.println(line.charAt(1));\r\n//        System.out.println(line.charAt(2));\r\n        for(int i=0; i<line.length(); i++){\r\n            System.out.println(line.charAt(i));\r\n        }\r\n    }\r\n}\r\n\r\n```\r\n\r\n## 3.7 拼接字符串\r\n\r\n![image-20210709095642297](cloudDisk/markdown/Java笔记.assets\\image-20210709095642297.png)\r\n\r\n```java\r\npackage test02;\r\n\r\nimport java.util.Scanner;\r\n\r\npublic class loginDemo {\r\n    public static void main(String[] args) {\r\n        int arr[] = {1,2,3};\r\n        System.out.println(compile(arr));\r\n\r\n    }\r\n    public static String compile(int arr[]){\r\n        String s;\r\n        s = \"[\";\r\n        for(int i=0; i<arr.length; i++) {\r\n            if(i == arr.length-1){\r\n                s += arr[i];\r\n                break;\r\n            }\r\n            s += arr[i] + \",\";\r\n        }\r\n        s += \"]\";\r\n        return s;\r\n    }\r\n}\r\n```\r\n\r\n## 3.8 字符串反转\r\n\r\n![image-20210709100949446](cloudDisk/markdown/Java笔记.assets\\image-20210709100949446.png)\r\n\r\n```java\r\npackage test02;\r\n\r\nimport java.util.Scanner;\r\n\r\npublic class loginDemo {\r\n    public static void main(String[] args) {\r\n        Scanner line = new Scanner(System.in);\r\n        String s = line.nextLine();\r\n        System.out.println(daoxu(s));\r\n\r\n\r\n    }\r\n    public static String daoxu(String s){\r\n        String d=\"\";\r\n        for(int i=s.length()-1; i>=0; i--){\r\n            d += s.charAt(i);\r\n        }\r\n        return d;\r\n    }\r\n}\r\n```\r\n\r\nresult:\r\n\r\nadsfc165\r\n561cfsda\r\n\r\n\r\n\r\n# 四、StringBulider\r\n\r\n## 4.1 概述\r\n\r\n![image-20210709102024474](cloudDisk/markdown/Java笔记.assets\\image-20210709102024474.png)\r\n\r\n![image-20210709102103954](cloudDisk/markdown/Java笔记.assets\\image-20210709102103954.png)\r\n\r\n## 4.2 StringBuilder 构造方法\r\n\r\n![image-20210709102235082](cloudDisk/markdown/Java笔记.assets\\image-20210709102235082.png)\r\n\r\n## 4.3 StringBuiler 添加和反转方法\r\n\r\n![image-20210709102600503](cloudDisk/markdown/Java笔记.assets\\image-20210709102600503.png)\r\n\r\n```java\r\npublic class loginDemo {\r\n    public static void main(String[] args) {\r\n        StringBuilder sb = new StringBuilder();\r\n        sb.append(\"hello\").append(\"world\").append(666);\r\n        System.out.println(sb);\r\n        sb.reverse();\r\n        System.out.println(sb);\r\n    }\r\n\r\n}\r\n```\r\n\r\n4.1 StringBuilder 和 String 相互转换\r\n\r\n![image-20210709103152117](cloudDisk/markdown/Java笔记.assets\\image-20210709103152117.png)\r\n\r\n```java\r\npackage test02;\r\n\r\nimport java.util.Scanner;\r\n\r\npublic class loginDemo {\r\n    public static void main(String[] args) {\r\n        // SB >>> S\r\n        StringBuilder sb = new StringBuilder(\"world\");\r\n        String s = sb.toString();;\r\n        System.out.println(s);\r\n\r\n        // S >>> SB\r\n        String ss = \"hello\";\r\n        StringBuilder ssb = new StringBuilder(ss);\r\n        System.out.println(ssb);\r\n    }\r\n}\r\n```\r\n\r\n# 五、 集合\r\n\r\n## 5.1 集合概念\r\n\r\n![image-20210709132807820](cloudDisk/markdown/Java笔记.assets\\image-20210709132807820.png)\r\n\r\n## 5.2 构造方法和添加方法\r\n\r\n![image-20210709132846720](cloudDisk/markdown/Java笔记.assets\\image-20210709132846720.png)\r\n\r\n```java\r\npackage test02;\r\n\r\nimport java.util.ArrayList;\r\nimport java.util.Scanner;\r\n\r\npublic class loginDemo {\r\n    public static void main(String[] args) {\r\n//        public ArrayList (); // 创建空集合对象\r\n        ArrayList<String> array = new ArrayList<>();\r\n\r\n        //将指定元素追加到此集合末尾\r\n        // public boolean add(E e)\r\n//        System.out.println(array.add(\"hello\")); //\r\n\r\n        array.add(\"hello\");\r\n        array.add(\"world\");\r\n        array.add(\"java\");\r\n\r\n        //在集合中的指定位置插入指定的元素\r\n        // public void add(int index,E element);\r\n//        array.add(1,\"javase\");\r\n//        array.add(3,\"javaee\");\r\n\r\n//        IndexOutOfBoundsException\r\n//        array.add(4,\"javaee\");\r\n\r\n        //输出集合\r\n        System.out.println(array);\r\n    }\r\n}\r\n```\r\n\r\n## 5.3 ArrayList 集合常用方法\r\n\r\n![image-20210709134140715](cloudDisk/markdown/Java笔记.assets\\image-20210709134140715.png)\r\n\r\n```java\r\npackage test02;\r\n\r\nimport java.util.ArrayList;\r\nimport java.util.Scanner;\r\n\r\npublic class loginDemo {\r\n    public static void main(String[] args) {\r\n        ArrayList<String> array = new ArrayList<>();\r\n        array.add(\"hello\");\r\n        array.add(\"world\");\r\n        array.add(\"java\");\r\n\r\n//        public boolean remove(Object o) // 删除指定元素，返回删除是否成功\r\n//        System.out.println(array.remove(\"hello\"));\r\n//        System.out.println(array);\r\n\r\n//        public E remove(int index) // 删除指定索引处的元素，返回被删除的元素\r\n//        System.out.println(array.remove(0));\r\n//        System.out.println(array);\r\n\r\n//        public E set(int index, E element) // 修改指定索引处的元素，锕返回被修改的元素\r\n//        array.set(0,\"你好\");\r\n//        System.out.println(array);\r\n\r\n//        public E get(int index) // 返回指定索引的元素\r\n//        System.out.println(array.get(2));\r\n\r\n//        public int size() // 返回集合中元素的个数\r\n//        System.out.println(array.size());\r\n    }\r\n\r\n\r\n}\r\n```\r\n\r\n## 5.4 存储学生对象并遍历\r\n\r\n![image-20210709140529448](cloudDisk/markdown/Java笔记.assets\\image-20210709140529448.png)\r\n\r\n```java\r\npackage com.test;\r\n\r\nimport java.util.ArrayList;\r\n\r\npublic class StudentDemo {\r\n    public static void main(String[] args) {\r\n        Student s1 = new Student();\r\n        s1.name = \"Tony\";\r\n        s1.age = 21;\r\n        s1.gender = \'男\';\r\n        s1.grade = \"大三\";\r\n        Student s2 = new Student();\r\n        s2.name = \"zxx\";\r\n        s2.age = 21;\r\n        s2.gender = \'女\';\r\n        s2.grade = \"大三\";\r\n        Student s3 = new Student();\r\n        s3.name = \"pony\";\r\n        s3.age = 40;\r\n        s3.gender = \'男\';\r\n        s3.grade = \"大四\";\r\n        ArrayList<Student> students = new ArrayList<>();\r\n        students.add(s1);\r\n        students.add(s2);\r\n        students.add(s3);\r\n        for(int i=0; i<students.size(); i++){\r\n            Student s = students.get(i);\r\n            System.out.println(\"姓名：\"+s.name+\"，年龄：\"+s.age+\"，性别：\"+s.gender+\"，年级：\"+s.grade);\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n```java\r\npackage com.test;\r\n\r\npublic class Student {\r\n    int age;\r\n    String name;\r\n    String grade;\r\n    char gender;\r\n}\r\n```\r\n\r\n## 案例 - 学生管理系统\r\n\r\n![image-20210709143507673](cloudDisk/markdown/Java笔记.assets\\image-20210709143507673.png)\r\n\r\n### 我的答案：\r\n\r\nStudentDemo.java\r\n\r\n```java\r\npackage com.test;\r\n\r\nimport java.util.ArrayList;\r\nimport java.util.Scanner;\r\n\r\npublic class StudentDemo {\r\n    public static void main(String[] args) {\r\n        Scanner scan = new Scanner(System.in);\r\n        ArrayList<Student> students = new ArrayList<>();\r\n        do{\r\n            printfUi();\r\n            int choice = scan.nextInt();\r\n            if(choice == 1){\r\n                addStudent(students);\r\n            }\r\n            else if(choice == 2){\r\n                deleteStdent(students);\r\n            }\r\n            else if(choice == 3){\r\n                resetStdent(students);\r\n            }\r\n            else if(choice == 4){\r\n                showAllStdents(students);\r\n            }\r\n            else if(choice == 5){\r\n                System.out.println(\"谢谢使用！！！\");\r\n                break;\r\n            }\r\n            else {\r\n                System.out.println(\"输入有误，请重新输入。\");\r\n            }\r\n        }\r\n        while (true);\r\n    }\r\n    public static void printfUi(){\r\n        System.out.println(\"-------欢迎来到学生管理系统-------\");\r\n        System.out.println(\"1 添加学生\");\r\n        System.out.println(\"2 删除学生\");\r\n        System.out.println(\"3 修改学生\");\r\n        System.out.println(\"4 查看所有学生\");\r\n        System.out.println(\"5 退出\");\r\n        System.out.println(\"请输入你的选项：\");\r\n    }\r\n        public static void addStudent(ArrayList<Student> students){\r\n            Student std = new Student();\r\n            std.setInfo();\r\n            students.add(std);\r\n            System.out.println(\"学生添加成功！！！\");\r\n        }\r\n        public static void deleteStdent(ArrayList<Student> students){\r\n            boolean flag = true;\r\n            if(students.size() == 0){\r\n                return;\r\n            }\r\n            showAllStdents(students);\r\n            System.out.print(\"请输入需要被删除学生的学号：\");\r\n            Scanner scan = new Scanner(System.in);\r\n            String xh = scan.nextLine();\r\n            for(int i=0; i<students.size(); i++){\r\n                if(xh.equals(students.get(i).getXueHao())){\r\n                    students.remove(i);\r\n                    System.out.println(\"删除成功！！！\");\r\n                    flag = false;\r\n                }\r\n            }\r\n            if (flag){\r\n                System.out.println(\"学号不存在。\");\r\n            }\r\n        }\r\n\r\n        public static void resetStdent(ArrayList<Student> students){\r\n            boolean flag = true;\r\n            if(students.size() == 0){\r\n                return;\r\n            }\r\n            showAllStdents(students);\r\n            System.out.print(\"请输入需要被修改的学生的学号：\");\r\n            Scanner scan = new Scanner(System.in);\r\n            String xh = scan.nextLine();\r\n            for(int i=0; i<students.size(); i++){\r\n                if(xh.equals(students.get(i).getXueHao())){\r\n                    students.get(i).setInfo();\r\n                    flag = false;\r\n                }\r\n            }\r\n            if (flag){\r\n                System.out.println(\"学号不存在。\");\r\n            }\r\n        }\r\n\r\n\r\n        public static void showAllStdents(ArrayList<Student> students){\r\n            if(students.size() == 0){\r\n                System.out.println(\"无任何学生！！！\");\r\n                return;\r\n            }\r\n            System.out.println(\"学号\\t\\t姓名\\t\\t年龄\\t\\t住址\");\r\n            for (int i=0; i<students.size(); i++){\r\n                Student std = students.get(i);\r\n                std.showInfo();\r\n            }\r\n        }\r\n}\r\n```\r\n\r\n\r\n\r\nStudent.java\r\n\r\n```java\r\npackage com.test;\r\n\r\nimport java.util.Scanner;\r\n\r\npublic class Student {\r\n    private String xueHao;\r\n    private String name;\r\n    private String age;\r\n    private String address;\r\n    public void Student(){\r\n    }\r\n    public void showInfo(){\r\n        System.out.println(xueHao+\"\\t\\t\"+name+\"\\t\\t\"+age+\"\\t\\t\"+address);\r\n    }\r\n    public void setInfo(){\r\n        Scanner scan = new Scanner(System.in);\r\n        System.out.print(\"请输入学号：\");\r\n        String xueHao = scan.nextLine();\r\n        System.out.print(\"请输入姓名：\");\r\n        String name = scan.nextLine();\r\n        System.out.print(\"请输入年龄：\");\r\n        String age = scan.nextLine();\r\n        System.out.print(\"请输入地址：\");\r\n        String address = scan.nextLine();\r\n        this.address = address;\r\n        this.name = name;\r\n        this.age = age;\r\n        this.xueHao = xueHao;\r\n    }\r\n    public String getXueHao(){\r\n        return  this.xueHao;\r\n    }\r\n\r\n\r\n}\r\n```\r\n\r\n## 5.5 快捷键 - 快速生成构造方法、get方法、set方法\r\n\r\n### 	ALT + Insert\r\n\r\n![image-20210710092920642](cloudDisk/markdown/Java笔记.assets\\image-20210710092920642.png)\r\n\r\nSystem.exit(status: 0) //JVM退出  java虚拟机退出\r\n\r\n','2022-06-23 21:51:17','Java 是由 Sun Microsystems 公司于 1995 年 5 月推出的 Java 面向对象程序设计语言和 Java 平台的总称。由 James Gosling和同事们共同研发，并在 1995 年正式推出。\r\n\r\n后来 Sun 公司被 Oracle （甲骨文）公司收购，Java 也随之成为 Oracle 公司的产品。','cloudDisk/markdown/Java笔记.assets\\image-20210708162152814.png','原创','','','\0','Java 基础（三）','2022-06-23 21:51:17',1,100,NULL,0),(172,'','# 一、继承\r\n\r\n## 1.1 继承概述\r\n\r\n![image-20210710095144317](cloudDisk/markdown/Java笔记.assets\\image-20210710095144317.png)\r\n\r\n![image-20210710095201368](cloudDisk/markdown/Java笔记.assets\\image-20210710095201368.png)\r\n\r\n![image-20210710095243913](cloudDisk/markdown/Java笔记.assets\\image-20210710095243913.png)\r\n\r\n\r\n\r\n![image-20210710095647473](cloudDisk/markdown/Java笔记.assets\\image-20210710095647473.png)\r\n\r\n## 1.2 继承的利弊\r\n\r\n![image-20210710095840729](cloudDisk/markdown/Java笔记.assets\\image-20210710095840729.png)\r\n\r\n## 1.3 继承的访问特点\r\n\r\n![image-20210710100816647](cloudDisk/markdown/Java笔记.assets\\image-20210710100816647.png)\r\n\r\n## 1.4 super\r\n\r\n![image-20210710101100796](cloudDisk/markdown/Java笔记.assets\\image-20210710101100796.png)\r\n\r\nTest:\r\n\r\nFu.java\r\n\r\n```java\r\npackage com;\r\n\r\npublic class Fu {\r\n    public Fu(){\r\n        System.out.println(\"Fu中无参构造方法被调用\");\r\n    }\r\n    public Fu(int age){\r\n        System.out.println(\"Fu中带参构造方法被调用\");\r\n    }\r\n}\r\n```\r\n\r\nZi.java\r\n\r\n```java\r\npackage com;\r\n\r\nimport java.sql.SQLOutput;\r\n\r\npublic class Zi extends Fu {\r\n    public Zi(){\r\n        System.out.println(\"Zi中无参构造方法被调用\");\r\n    }\r\n    public Zi(int age){\r\n        System.out.println(\"Zi中带参构造方法被调用\");\r\n    }\r\n}\r\n```\r\n\r\nDemo.java\r\n\r\n```java\r\npackage com;\r\n\r\npublic class Demo {\r\n    public static void main(String[] args) {\r\n        Zi z = new Zi();\r\n\r\n        Zi z2 = new Zi(10);\r\n    }\r\n}\r\n```\r\n\r\nresult:\r\n\r\nFu中无参构造方法被调用\r\nZi中无参构造方法被调用\r\nFu中无参构造方法被调用\r\nZi中带参构造方法被调用\r\n\r\n\r\n\r\n## 1.5 super访问特点\r\n\r\n![image-20210710102536896](cloudDisk/markdown/Java笔记.assets\\image-20210710102536896.png)\r\n\r\n![image-20210710102952894](cloudDisk/markdown/Java笔记.assets\\image-20210710102952894.png)\r\n\r\n创建子类对象时，会在一开始默认调用父类的无参构造方法\r\n\r\n但是可以指定了父类的带参构造方法\r\n\r\n```java\r\npublic Zi(){\r\n    super(10);\r\n    System.out.println(\"Zi中无参构造方法被调用\");\r\n}\r\n```\r\n\r\n## 1.6 方法重写\r\n\r\n![image-20210710103734037](cloudDisk/markdown/Java笔记.assets\\image-20210710103734037.png)\r\n\r\n![image-20210710104517509](cloudDisk/markdown/Java笔记.assets\\image-20210710104517509.png)\r\n\r\n```java\r\npublic void call(){\r\n    System.out.println(\"父类打电话\");\r\n}\r\n```\r\n\r\n```java\r\n@Override\r\npublic void call(){\r\n    System.out.println(\"子类打电话\");\r\n}\r\n```\r\n\r\n## 1.7 方法重写注意事项\r\n\r\n![image-20210710104948386](cloudDisk/markdown/Java笔记.assets\\image-20210710104948386.png)\r\n\r\n## 1.8 java中继承的注意事项\r\n\r\n![image-20210710105227830](cloudDisk/markdown/Java笔记.assets\\image-20210710105227830.png)\r\n\r\n![image-20210710105234312](cloudDisk/markdown/Java笔记.assets\\image-20210710105234312.png)\r\n\r\n## 案例 - 猫和狗\r\n\r\n![image-20210710110658150](cloudDisk/markdown/Java笔记.assets\\image-20210710110658150.png)\r\n\r\n![image-20210710110729689](cloudDisk/markdown/Java笔记.assets\\image-20210710110729689.png)\r\n\r\n![image-20210710110506998](cloudDisk/markdown/Java笔记.assets\\image-20210710110506998.png)\r\n\r\nAnimal.java:\r\n\r\n![image-20210710110642797](cloudDisk/markdown/Java笔记.assets\\image-20210710110642797.png)\r\n\r\nCat.java:\r\n\r\n![image-20210710110533762](cloudDisk/markdown/Java笔记.assets\\image-20210710110533762.png)\r\n\r\nDog.java\r\n\r\n![image-20210710110607676](cloudDisk/markdown/Java笔记.assets\\image-20210710110607676.png)\r\n\r\n# 二、包\r\n\r\n## 2.1 包的概述和使用\r\n\r\n![image-20210710111513701](cloudDisk/markdown/Java笔记.assets\\image-20210710111513701.png)\r\n\r\n## 2.2 导包概述和使用\r\n\r\n![image-20210710111901775](cloudDisk/markdown/Java笔记.assets\\image-20210710111901775.png)\r\n\r\n# 三、修饰符\r\n\r\n## 3.1 权限修饰符\r\n\r\n![image-20210710124225695](cloudDisk/markdown/Java笔记.assets\\image-20210710124225695.png)\r\n\r\n## 3.2 final状态修饰符\r\n\r\n![image-20210710124636104](cloudDisk/markdown/Java笔记.assets\\image-20210710124636104.png)\r\n\r\n## 3.3 final修饰局部变量\r\n\r\n![image-20210710125014742](cloudDisk/markdown/Java笔记.assets\\image-20210710125014742.png)\r\n\r\n![image-20210710125027608](cloudDisk/markdown/Java笔记.assets\\image-20210710125027608.png)\r\n\r\n## 3.4 static\r\n\r\n![image-20210710125111657](cloudDisk/markdown/Java笔记.assets\\image-20210710125111657.png)\r\n\r\n![image-20210710125350774](cloudDisk/markdown/Java笔记.assets\\image-20210710125350774.png)\r\n\r\n![image-20210710125421316](cloudDisk/markdown/Java笔记.assets\\image-20210710125421316.png)\r\n\r\n##### 用Static修饰的变量，被所有对象共享，类似C语言里的共有体。\r\n\r\n![image-20210710125507430](cloudDisk/markdown/Java笔记.assets\\image-20210710125507430.png)\r\n\r\n![image-20210710125706682](cloudDisk/markdown/Java笔记.assets\\image-20210710125706682.png)\r\n\r\n## 3.5 static访问特点\r\n\r\n![image-20210710125934495](cloudDisk/markdown/Java笔记.assets\\image-20210710125934495.png)\r\n\r\n# 四、多态\r\n\r\n## 4.1 多态概念\r\n\r\n![image-20210710130117317](cloudDisk/markdown/Java笔记.assets\\image-20210710130117317.png)\r\n\r\n![image-20210710130205862](cloudDisk/markdown/Java笔记.assets\\image-20210710130205862.png)\r\n\r\n![image-20210710130257544](cloudDisk/markdown/Java笔记.assets\\image-20210710130257544.png)\r\n\r\n有Animal和Cat两个类，Cat继承Animal：public class Cat extends Animal\r\n\r\n测试类中，创建一对象：Animal animal = new Cat();\r\n\r\n左边类：Animal	右边类：Cat\r\n\r\nanimal.xxx   访问左边类定义的**变量**，右边类就算重新定义变量，还是访问左边类定义的变量\r\n\r\nanimal.xxx() 左边类没定义xxx()方法就报错；左右边类都定义xxx()方法时，按右边类的方法运行\r\n\r\n## 4.2 多态的利弊\r\n\r\nn个子类都重写了eat()方法 >>> 创建n个子类对象 >>> 调用一个函数(这个函数的参数是子类的对象也可以是父类的对象，函数体会调用这个对象的eat方法) \r\n\r\nAnimal.java\r\n\r\n```java\r\npackage com02;\r\n\r\npublic class Animal {\r\n    public void eat(){\r\n        System.out.println(\"动物吃东西\");\r\n    }\r\n}\r\n```\r\n\r\nCat.java\r\n\r\n```java\r\npackage com02;\r\n\r\npublic class Cat extends Animal {\r\n    @Override\r\n    public void eat() {\r\n        System.out.println(\"猫吃鱼\");\r\n    }\r\n}\r\n```\r\n\r\nDog.java\r\n\r\n```java\r\npackage com02;\r\n\r\npublic class Dog extends Animal {\r\n    @Override\r\n    public void eat() {\r\n        System.out.println(\"狗吃骨头\");\r\n    }\r\n}\r\n```\r\n\r\nAnimalOperator.java\r\n\r\n```java\r\npackage com02;\r\n\r\npublic class AnimalOperator {\r\n    /*\r\n    public void useAnimal(Cat c){ //Cat c = new Cat();\r\n        c.eat();\r\n    }\r\n    public void useAnimal(Dog d){ //Dog d = new Dog();\r\n        d.eat();\r\n    }\r\n    */\r\n    public void useAnimal(Animal a){\r\n        // Animal a = new Cat();\r\n        // Animal a = new Dog();\r\n        a.eat();\r\n\r\n    }\r\n}\r\n```\r\n\r\nAnimalDemo.java\r\n\r\n```java\r\npackage com02;\r\n\r\npublic class AnimalDemo {\r\n    public static void main(String[] args) {\r\n        //创建动物操作的对象，调用方法\r\n        AnimalOperator ao = new AnimalOperator();\r\n        Cat c = new Cat();\r\n        ao.useAnimal(c);\r\n        Dog d = new Dog();\r\n        ao.useAnimal(d);\r\n    }\r\n}\r\n```\r\n\r\n![image-20210711091403928](cloudDisk/markdown/Java笔记.assets\\image-20210711091403928.png)\r\n\r\n## 4.3 多态中的转型\r\n\r\n![image-20210711092238213](cloudDisk/markdown/Java笔记.assets\\image-20210711092238213.png)\r\n\r\nAnimal.java:\r\n\r\n```java\r\npackage com02;\r\n\r\npublic class Animal {\r\n    public void eat(){\r\n        System.out.println(\"动物吃东西\");\r\n    }\r\n}\r\n```\r\n\r\nCat.java:\r\n\r\n```java\r\npackage com02;\r\n\r\npublic class Cat extends Animal {\r\n    @Override\r\n    public void eat() {\r\n        System.out.println(\"猫吃鱼\");\r\n    }\r\n    public void play() {\r\n        System.out.println(\"玩猫\");\r\n    }\r\n}\r\n```\r\n\r\nAnimalDemo.java:\r\n\r\n```java\r\npackage com02;\r\n\r\npublic class AnimalDemo {\r\n    public static void main(String[] args) {\r\n        // 向上转型\r\n        Animal a = new Cat();\r\n        a.eat(); // 由于重写了eat()方法 输出：猫吃鱼\r\n        // a.play(); // 没有重写，play是Cat特有的，报错！\r\n\r\n        // 向下转型\r\n        // 但是可以将父类对象转为子类对象，Animal >>> Cat\r\n        Cat c = (Cat)a;\r\n        c.play();\r\n    }\r\n}\r\n```\r\n\r\n## 4.4 转型内存图\r\n\r\n![image-20210711092728097](cloudDisk/markdown/Java笔记.assets\\image-20210711092728097.png)\r\n\r\n## 多态 - 案例\r\n\r\n![image-20210711092903562](cloudDisk/markdown/Java笔记.assets\\image-20210711092903562.png)\r\n\r\nAnimal.java\r\n\r\n```java\r\npackage com02;\r\n\r\npublic class Animal {\r\n    private String name;\r\n    private int age;\r\n\r\n    public Animal() {\r\n    }\r\n\r\n    public Animal(String name, int age) {\r\n        this.name = name;\r\n        this.age = age;\r\n    }\r\n\r\n    public String getName() {\r\n        return name;\r\n    }\r\n\r\n    public void setName(String name) {\r\n        this.name = name;\r\n    }\r\n\r\n    public int getAge() {\r\n        return age;\r\n    }\r\n\r\n    public void setAge(int age) {\r\n        this.age = age;\r\n    }\r\n\r\n    public void eat(){\r\n        System.out.println(\"动物吃东西\");\r\n    }\r\n}\r\n\r\n```\r\n\r\nCat.java\r\n\r\n```java\r\npackage com02;\r\n\r\npublic class Cat extends Animal {\r\n    @Override\r\n    public void eat() {\r\n        System.out.println(this.getName() + \"猫吃鱼\");\r\n    }\r\n\r\n    public Cat() {\r\n    }\r\n\r\n    public Cat(String name, int age) {\r\n        super(name, age);\r\n    }\r\n}\r\n```\r\n\r\nDog.java\r\n\r\n```java\r\npackage com02;\r\n\r\npublic class Dog extends Animal {\r\n    @Override\r\n    public void eat() {\r\n        System.out.println(this.getName() + \"狗吃骨头\");\r\n    }\r\n\r\n    public Dog() {\r\n    }\r\n\r\n    public Dog(String name, int age) {\r\n        super(name, age);\r\n    }\r\n}\r\n```\r\n\r\nAnimalDemo.java\r\n\r\n```java\r\npackage com02;\r\n/*\r\n    测试类\r\n */\r\npublic class AnimalDemo {\r\n    public static void main(String[] args) {\r\n        Animal a = new Cat();\r\n        a.setAge(23);\r\n        a.setName(\"Pony\");\r\n        System.out.println(a.getName()+\",\"+a.getAge());\r\n        a.eat();\r\n\r\n        a = new Cat(\"pony\",24);\r\n        System.out.println(a.getName()+\",\"+a.getAge());\r\n        a.eat();\r\n\r\n        a = new Dog();\r\n        a.setAge(23);\r\n        a.setName(\"Hath\");\r\n        System.out.println(a.getName()+\",\"+a.getAge());\r\n        a.eat();\r\n\r\n        a = new Dog(\"Hath\",24);\r\n        System.out.println(a.getName()+\",\"+a.getAge());\r\n        a.eat();\r\n    }\r\n}\r\n```\r\n\r\n# 五、抽象类\r\n\r\n## 5.1 抽象类概述\r\n\r\n![image-20210711094428475](cloudDisk/markdown/Java笔记.assets\\image-20210711094428475.png)\r\n\r\n![image-20210711094632377](cloudDisk/markdown/Java笔记.assets\\image-20210711094632377.png)\r\n\r\n![image-20210711094645133](cloudDisk/markdown/Java笔记.assets\\image-20210711094645133.png)\r\n\r\n## 5.2 抽象类特点\r\n\r\n![image-20210711095207097](cloudDisk/markdown/Java笔记.assets\\image-20210711095207097.png)\r\n\r\nAnimal.java\r\n\r\n```java\r\npackage Test03;\r\n\r\npublic abstract class Animal {\r\n    public abstract void eat();\r\n}\r\n```\r\n\r\nCat.java\r\n\r\n```java\r\npackage Test03;\r\n\r\npublic class Cat extends Animal {\r\n    @Override\r\n    public void eat() {\r\n        System.out.println(\"猫吃鱼\");\r\n    }\r\n}\r\n```\r\n\r\nDog.java\r\n\r\n```java\r\npackage Test03;\r\n\r\npublic abstract class Dog extends Animal {\r\n    public abstract void eat();\r\n}\r\n```\r\n\r\nAnimalDemo.java\r\n\r\n```java\r\npackage Test03;\r\n\r\npublic class AnimalDemo {\r\n    public static void main(String[] args) {\r\n        // Animal a = new Animal(); //报错\r\n        Animal a = new Cat(); // 通过多态实例化\r\n    }\r\n\r\n}\r\n\r\n```\r\n\r\n## 5.3 抽象类的成员特点\r\n\r\n![image-20210711100341108](cloudDisk/markdown/Java笔记.assets\\image-20210711100341108.png)\r\n\r\n## 5.4 案例\r\n\r\n![image-20210711100624120](cloudDisk/markdown/Java笔记.assets\\image-20210711100624120.png)\r\n\r\nAnimal.java\r\n\r\n```java\r\npackage Test03;\r\n\r\npublic abstract class Animal {\r\n    private String name;\r\n    private int age;\r\n\r\n    public abstract void eat();\r\n\r\n    public Animal(String name, int age) {\r\n        this.name = name;\r\n        this.age = age;\r\n    }\r\n\r\n    public String getName() {\r\n        return name;\r\n    }\r\n\r\n    public void setName(String name) {\r\n        this.name = name;\r\n    }\r\n\r\n    public int getAge() {\r\n        return age;\r\n    }\r\n\r\n    public void setAge(int age) {\r\n        this.age = age;\r\n    }\r\n\r\n    public Animal() {\r\n    }\r\n}\r\n```\r\n\r\nCat.java\r\n\r\n```java\r\npackage Test03;\r\n\r\npublic class Cat extends Animal {\r\n    @Override\r\n    public void eat() {\r\n        System.out.println(\"猫吃鱼\");\r\n    }\r\n\r\n    public Cat(String name, int age) {\r\n        super(name, age);\r\n    }\r\n\r\n    public Cat() {\r\n    }\r\n}\r\n```\r\n\r\nAnimalDemo.java\r\n\r\n```java\r\npackage Test03;\r\n/*\r\n    测试类\r\n*/\r\npublic class AnimalDemo {\r\n    public static void main(String[] args) {\r\n        // Animal a = new Animal(); //报错\r\n        Animal a = new Cat(); // 通过多态实例化\r\n        a.setName(\"加菲\");\r\n        a.setAge(5);\r\n        System.out.println(a.getName()+\",\"+a.getAge());\r\n        a.eat();\r\n        System.out.println(\"---------\");\r\n\r\n        a = new Cat(\"加菲\",5);\r\n        System.out.println(a.getName()+\",\"+a.getAge());\r\n        a.eat();\r\n    }\r\n\r\n}\r\n```\r\n','2022-06-23 21:52:29','Java 是由 Sun Microsystems 公司于 1995 年 5 月推出的 Java 面向对象程序设计语言和 Java 平台的总称。由 James Gosling和同事们共同研发，并在 1995 年正式推出。\r\n\r\n后来 Sun 公司被 Oracle （甲骨文）公司收购，Java 也随之成为 Oracle 公司的产品。','cloudDisk/markdown/Java笔记.assets\\image-20210710095144317.png','原创','','','\0','Java 基础（四）','2022-06-23 21:52:29',2,100,NULL,0),(173,'','# 一、接口\r\n\r\n## 1.1 接口概述\r\n\r\n![image-20210711101917991](cloudDisk/markdown/Java笔记.assets\\image-20210711101917991.png)\r\n\r\n## 1.2 接口特点\r\n\r\nCat.java\r\n\r\n```java\r\npackage Test03;\r\n\r\npublic class Cat implements Jumpping{\r\n    @Override\r\n    public void jump() {\r\n        System.out.println(\"猫可以跳高了\");\r\n    }\r\n\r\n}\r\n```\r\n\r\nDog.java\r\n\r\n```java\r\npackage Test03;\r\n\r\npublic abstract class Dog implements Jumpping {\r\n    public abstract void jump();\r\n}\r\n```\r\n\r\nJumpping.java\r\n\r\n```java\r\npackage Test03;\r\n\r\npublic interface Jumpping {\r\n    public abstract void jump();\r\n}\r\n```\r\n\r\nJumppingDemo.java\r\n\r\n```java\r\npackage Test03;\r\n\r\npublic class JumppingDemo {\r\n    public static void main(String[] args) {\r\n        // Jumpping j = new Jumpping();\r\n        Jumpping j = new Cat();\r\n        j.jump();\r\n    }\r\n}\r\n```\r\n\r\n![image-20210711103149829](cloudDisk/markdown/Java笔记.assets\\image-20210711103149829.png)\r\n\r\n## 1.3 接口的成员特点\r\n\r\nInter.java\r\n\r\n```java\r\npackage test04;\r\n\r\npublic interface Inter {\r\n    public int num = 10;\r\n    public final int num2 = 20;\r\n    // public static final int num3 = 30;\r\n    int num3 = 30;\r\n\r\n    // public Inter(){} //没有构造方法\r\n\r\n    // public void show(){} //接口中的成员方法不能有方法体，因为默认abstract\r\n\r\n    public abstract void method();\r\n    void show();\r\n}\r\n```\r\n\r\nInterImpl.java\r\n\r\n```java\r\npackage test04;\r\n\r\n//public class InterImpl implements Inter {\r\n//}\r\npublic class InterImpl extends Object implements Inter{\r\n    public InterImpl(){\r\n        super(); //因为没有父类，所有继承的是Object\r\n    }\r\n\r\n    @Override\r\n    public void method() {\r\n        System.out.println(\"method\");\r\n    }\r\n\r\n    @Override\r\n    public void show() {\r\n        System.out.println(\"show\");\r\n    }\r\n}\r\n```\r\n\r\nInterfaceDemo.java\r\n\r\n```java\r\npackage test04;\r\n\r\nimport org.w3c.dom.ls.LSOutput;\r\n\r\npublic class InterfaceDemo {\r\n    public static void main(String[] args) {\r\n        Inter i = new InterImpl();\r\n        // i.num = 20; //默认常量，无法被修改\r\n        System.out.println(i.num);\r\n        // i.num2 = 40;\r\n        System.out.println(i.num2);\r\n        System.out.println(Inter.num); // 可以通过类名调用，因为是static\r\n    }\r\n}\r\n```\r\n\r\n![image-20210711105008418](cloudDisk/markdown/Java笔记.assets\\image-20210711105008418.png)\r\n\r\n## 1.4 案例\r\n\r\n![image-20210711105420852](cloudDisk/markdown/Java笔记.assets\\image-20210711105420852.png)\r\n\r\n##### 抽象类   Animal.java\r\n\r\n```java\r\npackage test05;\r\n\r\npublic abstract class Animal {\r\n    private String name;\r\n    private int age;\r\n    public abstract void eat();\r\n\r\n    public Animal(String name, int age) {\r\n        this.name = name;\r\n        this.age = age;\r\n    }\r\n\r\n    public Animal() {\r\n    }\r\n\r\n    public String getName() {\r\n        return name;\r\n    }\r\n\r\n    public void setName(String name) {\r\n        this.name = name;\r\n    }\r\n\r\n    public int getAge() {\r\n        return age;\r\n    }\r\n\r\n    public void setAge(int age) {\r\n        this.age = age;\r\n    }\r\n}\r\n```\r\n\r\n##### 接口  Jumpping.java\r\n\r\n```java\r\npackage test05;\r\n\r\npublic interface Jumpping {\r\n    void Jump();\r\n\r\n}\r\n```\r\n\r\n##### 狗类  Dog.java\r\n\r\n```java\r\npackage test05;\r\n\r\npublic class Dog extends Animal implements Jumpping{\r\n    public Dog(String name, int age) {\r\n        super(name, age);\r\n    }\r\n\r\n    public Dog() {\r\n    }\r\n\r\n    @Override\r\n    public void eat() {\r\n        System.out.println(\"狗吃骨头\");\r\n    }\r\n\r\n    @Override\r\n    public void Jump() {\r\n        System.out.println(\"狗跳\");\r\n    }\r\n}\r\n```\r\n\r\n##### 测试类  AnimalDemo.java\r\n\r\n```java\r\npackage test05;\r\n\r\nimport java.util.Calendar;\r\n\r\npublic class AnimalDemo {\r\n    public static void main(String[] args) {\r\n        // 现实接口\r\n        Jumpping j = new Dog();\r\n        j.Jump();\r\n        System.out.println(\"------------\");\r\n\r\n        // 实例化抽象类\r\n        Animal a = new Dog();\r\n        a.setName(\"Pony\");\r\n        a.setAge(10);\r\n        System.out.println(a.getName() + \",\" + a.getAge());\r\n        a.eat();\r\n        // a.jump; //报错，因为Animal中没有jump方法\r\n        // 那怎么调用呢？\r\n        Jumpping a_j = (Jumpping)a; // 通过强转\r\n        a_j.Jump();\r\n        System.out.println(\"---------------\");\r\n\r\n//        习惯用法：\r\n        Dog g = new Dog();\r\n        g.setAge(5);\r\n        g.setName(\"Hath\");\r\n        System.out.println(g.getName()+\",\"+g.getAge());\r\n        g.eat();\r\n        g.Jump();\r\n    }\r\n}\r\n```\r\n\r\n## 1.5 接口和类的关系\r\n\r\n![image-20210711112251952](cloudDisk/markdown/Java笔记.assets\\image-20210711112251952.png)\r\n\r\n类与接口多实现\r\n\r\n![image-20210711112459256](cloudDisk/markdown/Java笔记.assets\\image-20210711112459256.png)\r\n\r\n\r\n\r\n接口与接口多继承\r\n\r\n![image-20210711112527599](cloudDisk/markdown/Java笔记.assets\\image-20210711112527599.png)\r\n\r\n## 1.6 抽象类和接口的区别\r\n\r\n![image-20210711112737224](cloudDisk/markdown/Java笔记.assets\\image-20210711112737224.png)\r\n\r\n![image-20210711112954717](cloudDisk/markdown/Java笔记.assets\\image-20210711112954717.png)\r\n\r\n门的开关和报警独立开来的，设计出来的报警门需要继承原始门的开关，且实现报警接口\r\n\r\n![image-20210711113350280](cloudDisk/markdown/Java笔记.assets\\image-20210711113350280.png)\r\n\r\n![image-20210711113405920](cloudDisk/markdown/Java笔记.assets\\image-20210711113405920.png)\r\n\r\n## 案例\r\n\r\n![image-20210711113744646](cloudDisk/markdown/Java笔记.assets\\image-20210711113744646.png)\r\n\r\n![image-20210711113909861](cloudDisk/markdown/Java笔记.assets\\image-20210711113909861.png)\r\n\r\nInterSpeakEnglish.java\r\n\r\n```java\r\npackage test06;\r\n\r\npublic interface InterSpeakEnglish {\r\n    void speakEnglish();\r\n}\r\n```\r\n\r\nPerson.java\r\n\r\n```java\r\npackage test06;\r\n\r\npublic class Person {\r\n    private String name;\r\n    private int age;\r\n    public void eat(){\r\n        System.out.println(this.getName() + \"吃饭\");\r\n    }\r\n\r\n    public Person() {\r\n    }\r\n\r\n    public Person(String name, int age) {\r\n        this.name = name;\r\n        this.age = age;\r\n    }\r\n\r\n    public String getName() {\r\n        return name;\r\n    }\r\n\r\n    public void setName(String name) {\r\n        this.name = name;\r\n    }\r\n\r\n    public int getAge() {\r\n        return age;\r\n    }\r\n\r\n    public void setAge(int age) {\r\n        this.age = age;\r\n    }\r\n}\r\n```\r\n\r\nCoach.java\r\n\r\n```java\r\npackage test06;\r\n\r\npublic abstract class Coach extends Person{\r\n    public abstract void teaching();\r\n\r\n    public Coach() {\r\n    }\r\n\r\n    public Coach(String name, int age) {\r\n        super(name, age);\r\n    }\r\n}\r\n\r\n```\r\n\r\nAthlete.java\r\n\r\n```java\r\npackage test06;\r\n\r\npublic abstract class Athlete extends Person {\r\n    public abstract void learning();\r\n\r\n    public Athlete() {\r\n    }\r\n\r\n    public Athlete(String name, int age) {\r\n        super(name, age);\r\n    }\r\n}\r\n\r\n```\r\n\r\nbasketballCoach.java\r\n\r\n```java\r\npackage test06;\r\n\r\npublic class basketballCoach extends Coach{\r\n    @Override\r\n    public void teaching() {\r\n        System.out.println(this.getName()+\"教打篮球\");\r\n    }\r\n\r\n    public basketballCoach() {\r\n    }\r\n\r\n    public basketballCoach(String name, int age) {\r\n        super(name, age);\r\n    }\r\n}\r\n\r\n```\r\n\r\nbasketballPlayer.java\r\n\r\n```java\r\npackage test06;\r\n\r\npublic class basketballPlayer extends Athlete{\r\n    @Override\r\n    public void learning() {\r\n        System.out.println(this.getName()+\"练习打篮球\");\r\n    }\r\n\r\n    public basketballPlayer() {\r\n    }\r\n\r\n    public basketballPlayer(String name, int age) {\r\n        super(name, age);\r\n    }\r\n}\r\n\r\n```\r\n\r\ntabletennisCoach.java\r\n\r\n```java\r\npackage test06;\r\n\r\npublic class tabletennisCoach extends Coach implements InterSpeakEnglish{\r\n    @Override\r\n    public void teaching() {\r\n        System.out.println(this.getName()+\"教打乒乓球\");\r\n    }\r\n\r\n    @Override\r\n    public void speakEnglish() {\r\n        System.out.println(this.getName()+\"说英语\");\r\n    }\r\n\r\n    public tabletennisCoach() {\r\n    }\r\n\r\n    public tabletennisCoach(String name, int age) {\r\n        super(name, age);\r\n    }\r\n}\r\n\r\n```\r\n\r\ntabletennisPlayer.java\r\n\r\n```java\r\npackage test06;\r\n\r\npublic class tabletennisPlayer extends Athlete implements InterSpeakEnglish{\r\n    @Override\r\n    public void learning() {\r\n        System.out.println(this.getName()+\"练习打乒乓球\");\r\n    }\r\n\r\n    @Override\r\n    public void speakEnglish() {\r\n        System.out.println(this.getName()+\"说英语\");\r\n    }\r\n\r\n    public tabletennisPlayer() {\r\n    }\r\n\r\n    public tabletennisPlayer(String name, int age) {\r\n        super(name, age);\r\n    }\r\n\r\n}\r\n\r\n```\r\n\r\nDemo.java\r\n\r\n```java\r\npackage test06;\r\n\r\npublic class Demo {\r\n    public static void main(String[] args) {\r\n        basketballCoach 篮球教练 = new basketballCoach();\r\n        篮球教练.setName(\"姚明\");\r\n        篮球教练.setAge(30);\r\n\r\n        basketballPlayer 篮球运动员 = new basketballPlayer();\r\n        篮球运动员.setAge(18);\r\n        篮球运动员.setName(\"CXK\");\r\n\r\n        tabletennisCoach 乒乓球教练 = new tabletennisCoach();\r\n        乒乓球教练.setAge(38);\r\n        乒乓球教练.setName(\"Pony\");\r\n\r\n        tabletennisPlayer 乒乓球运动员 = new tabletennisPlayer();\r\n        乒乓球运动员.setAge(19);\r\n        乒乓球运动员.setName(\"Tony\");\r\n\r\n        System.out.println(\"中饭时间\");\r\n        篮球教练.eat();\r\n        篮球运动员.eat();\r\n        乒乓球教练.eat();\r\n        乒乓球运动员.eat();\r\n        System.out.println(\"-------------\");\r\n\r\n        System.out.println(\"训练时间\");\r\n        篮球教练.teaching();\r\n        篮球运动员.learning();\r\n        乒乓球教练.teaching();\r\n        乒乓球运动员.learning();\r\n        System.out.println(\"-------------\");\r\n\r\n        System.out.println(\"乒乓球相关的人，说英语时间\");\r\n        乒乓球教练.speakEnglish();\r\n        乒乓球运动员.speakEnglish();\r\n    }\r\n}\r\n```\r\n\r\nresult:\r\n\r\n中饭时间\r\n姚明吃饭\r\nCXK吃饭\r\nPony吃饭\r\nTony吃饭\r\n\r\n-----------------------\r\n\r\n训练时间\r\n姚明教打篮球\r\nCXK练习打篮球\r\nPony教打乒乓球\r\nTony练习打乒乓球\r\n\r\n--------------------------------\r\n\r\n乒乓球相关的人，说英语时间\r\nPony说英语\r\nTony说英语\r\n\r\n# 二、形参和返回值\r\n\r\n## 1.1 类名作为形参和返回值\r\n\r\n![image-20210712091732855](cloudDisk/markdown/Java笔记.assets\\image-20210712091732855.png)\r\n\r\n## 1.2 抽象类名作为形参和返回值\r\n\r\n![image-20210712092101151](cloudDisk/markdown/Java笔记.assets\\image-20210712092101151.png)\r\n\r\n## 1.3 接口名作为形参和返回值\r\n\r\nPerson.java\r\n\r\n```java\r\npackage test07;\r\n\r\npublic class Person implements SpeakEnglish{\r\n    @Override\r\n    public void speakEnglish() {\r\n        System.out.println(\"人会说英语了\");\r\n    }\r\n}\r\n```\r\n\r\nSpeakEnglish.java\r\n\r\n```java\r\npackage test07;\r\n\r\npublic interface SpeakEnglish {\r\n    void speakEnglish();\r\n}\r\n```\r\n\r\nDemo.java\r\n\r\n```java\r\npackage test07;\r\n\r\npublic class Person implements SpeakEnglish{\r\n    @Override\r\n    public void speakEnglish() {\r\n        System.out.println(\"人会说英语了\");\r\n    }\r\n}\r\n```\r\n\r\n通过多态实例化对象\r\n\r\n![image-20210712092444552](cloudDisk/markdown/Java笔记.assets\\image-20210712092444552.png)\r\n\r\n\r\n\r\n# 三、内部类\r\n\r\n## 1.1 内部类概述\r\n\r\n![image-20210712092857894](cloudDisk/markdown/Java笔记.assets\\image-20210712092857894.png)\r\n\r\n## 1.2 成员内部类\r\n\r\n![image-20210712092939071](cloudDisk/markdown/Java笔记.assets\\image-20210712092939071.png)\r\n\r\n![image-20210712094459038](cloudDisk/markdown/Java笔记.assets\\image-20210712094459038.png)\r\n\r\n![image-20210712094518831](cloudDisk/markdown/Java笔记.assets\\image-20210712094518831.png)\r\n\r\nOuter.java\r\n\r\n```java\r\npackage test08;\r\n\r\nimport javax.crypto.spec.PSource;\r\n\r\npublic class Outer {\r\n    public int age = 10;\r\n    public class Inner {\r\n        public void show(){\r\n            System.out.println(age);\r\n        }\r\n    }\r\n}\r\n```\r\n\r\nInnerDeomo.java\r\n\r\n```java\r\npackage test08;\r\n\r\nimport javax.print.attribute.standard.MediaSize;\r\n\r\npublic class InnerDemo {\r\n    public static void main(String[] args) {\r\n        Outer.Inner oi = new Outer().new Inner();\r\n        oi.show();\r\n    }\r\n}\r\n```\r\n\r\n## 1.3 局部内部类\r\n\r\n![image-20210712095647725](cloudDisk/markdown/Java笔记.assets\\image-20210712095647725.png)\r\n\r\n## 1.4 内部类\r\n\r\n![image-20210712095745255](cloudDisk/markdown/Java笔记.assets\\image-20210712095745255.png)\r\n\r\n![image-20210712095819024](cloudDisk/markdown/Java笔记.assets\\image-20210712095819024.png)\r\n\r\nInter.java\r\n\r\n```\r\npackage test09;\r\n\r\npublic interface Inter {\r\n    void show();\r\n}\r\n```\r\n\r\nOuter.java\r\n\r\n```java\r\npackage test09;\r\n\r\npublic class Outer {\r\n    public void method(){\r\n        /*  这仅仅是个对象\r\n        new Inter(){\r\n            @Override\r\n            public void show() {\r\n                System.out.println(\"内部类\");\r\n            }\r\n        };\r\n        */\r\n\r\n        // 这样对象调用了show方法吗。怎么多次调用？\r\n/*        new Inter(){\r\n            @Override\r\n            public void show() {\r\n                System.out.println(\"内部类\");\r\n            }\r\n        }.show();*/\r\n\r\n        // 把对象赋值给Inter\r\n        Inter inter = new Inter(){\r\n            @Override\r\n            public void show() {\r\n                System.out.println(\"内部类\");\r\n            }\r\n        };\r\n        inter.show();\r\n        inter.show();\r\n\r\n    }\r\n}\r\n```\r\n\r\nDemo.java\r\n\r\n```java\r\npackage test09;\r\n\r\npublic class Demo {\r\n    public static void main(String[] args) {\r\n        Outer outer = new Outer();\r\n        outer.method();\r\n    }\r\n}\r\n```\r\n\r\n## 1.5 内部类在开发中的使用\r\n\r\n![image-20210712101257278](cloudDisk/markdown/Java笔记.assets\\image-20210712101257278.png)\r\n\r\nDog.java\r\n\r\n```java\r\npackage test10;\r\n\r\npublic class Dog implements Jumping{\r\n    @Override\r\n    public void jump() {\r\n        System.out.println(\"狗跳了\");\r\n    }\r\n}\r\n```\r\n\r\nCat.java\r\n\r\n```java\r\npackage test10;\r\n\r\npublic class Cat implements Jumping{\r\n    @Override\r\n    public void jump() {\r\n        System.out.println(\"猫会跳了\");\r\n    }\r\n}\r\n```\r\n\r\nJumping.java\r\n\r\n```java\r\npackage test10;\r\n\r\npublic interface Jumping {\r\n    void jump();\r\n}\r\n```\r\n\r\nJumpingOperator.java\r\n\r\n```java\r\npackage test10;\r\n\r\nimport test05.Jumpping;\r\n\r\npublic class JumpingOperator {\r\n    public void method(Jumping j){\r\n        j.jump();\r\n    }\r\n}\r\n```\r\n\r\nJumpingDemo.java\r\n\r\n```java\r\npackage test10;\r\n\r\npublic class JumpingDemo {\r\n    public static void main(String[] args) {\r\n        // 创建接口操作类对象，调用method方法\r\n        JumpingOperator jo = new JumpingOperator();\r\n        Jumping jc = new Cat();\r\n        jo.method(jc);\r\n\r\n        Jumping jd = new Dog();\r\n        jo.method(jd);\r\n        System.out.println(\"-------------------\");\r\n\r\n        jo.method(new Jumping() {\r\n            @Override\r\n            public void jump() {\r\n                System.out.println(\"猫可跳\");\r\n            }\r\n        });\r\n        jo.method(new Jumping() {\r\n            @Override\r\n            public void jump() {\r\n                System.out.println(\"狗可跳\");\r\n            }\r\n        });\r\n    }\r\n}\r\n```\r\n\r\n# 四、Math\r\n\r\n## 4.1 Math 类概述\r\n\r\n![image-20210712102920991](cloudDisk/markdown/Java笔记.assets\\image-20210712102920991.png)\r\n\r\n![image-20210712102911146](cloudDisk/markdown/Java笔记.assets\\image-20210712102911146.png)\r\n\r\n## 4.2 Math常用方法\r\n\r\n![image-20210712103029988](cloudDisk/markdown/Java笔记.assets\\image-20210712103029988.png)\r\n\r\n# 五、System类常用方法\r\n\r\n![image-20210712104702349](cloudDisk/markdown/Java笔记.assets\\image-20210712104702349.png)\r\n\r\n# 六、Object类\r\n\r\n## 6.1 Object类概述\r\n\r\n![image-20210712104913500](cloudDisk/markdown/Java笔记.assets\\image-20210712104913500.png)\r\n\r\nStudent.java\r\n\r\n```java\r\npackage test12;\r\n\r\npublic class Student {\r\n    private int age;\r\n    private String name;\r\n\r\n    @Override\r\n    // toString继承Object类方法，由于默认的toString方法不便于阅读\r\n    // 所以建议重写，Alt+Ins生成\r\n    public String toString() {\r\n        return \"Student{\" +\r\n                \"age=\" + age +\r\n                \", name=\'\" + name + \'\\\'\' +\r\n                \'}\';\r\n    }\r\n\r\n    public Student() {\r\n    }\r\n\r\n    public Student(int age, String name) {\r\n        this.age = age;\r\n        this.name = name;\r\n    }\r\n\r\n    public int getAge() {\r\n        return age;\r\n    }\r\n\r\n    public void setAge(int age) {\r\n        this.age = age;\r\n    }\r\n\r\n    public String getName() {\r\n        return name;\r\n    }\r\n\r\n    public void setName(String name) {\r\n        this.name = name;\r\n    }\r\n\r\n\r\n}\r\n```\r\n\r\nDemo.java\r\n\r\n```java\r\npackage test12;\r\n\r\npublic class Demo {\r\n    public static void main(String[] args) {\r\n        Student student = new Student();\r\n        student.setAge(20);\r\n        student.setName(\"Tony\");\r\n        System.out.println(student); // 默认是输出student.toString()\r\n        // 由于重写了toString()方法，输出Student{age=20, name=\'Tony\'}\r\n        System.out.println(student.toString());\r\n    }\r\n}\r\n```\r\n\r\n## 6.2 常用方法\r\n\r\n### 	equals\r\n\r\nStudent.java\r\n\r\n```java\r\npublic class Student {\r\n    private int age;\r\n    private String name;\r\n\r\n//    重写方法后输出 true\r\n//    没重写为 false, 由于默认比较地址值\r\n//    Alt+Ins >>> equals >>> default\r\n    @Override\r\n    public boolean equals(Object o) {\r\n        if (this == o) return true;\r\n        if (o == null || getClass() != o.getClass()) return false;\r\n\r\n        Student student = (Student) o;\r\n\r\n        if (age != student.age) return false;\r\n        return name != null ? name.equals(student.name) : student.name == null;\r\n    }\r\n```\r\n\r\nDemo.java\r\n\r\n```java\r\npackage test12;\r\n\r\npublic class Demo {\r\n    public static void main(String[] args) {\r\n        Student s1 = new Student();\r\n        s1.setAge(20);\r\n        s1.setName(\"Tony\");\r\n        Student s2 = new Student();\r\n        s2.setAge(20);\r\n        s2.setName(\"Tony\");\r\n        System.out.println(s1.equals(s2));\r\n    }\r\n}\r\n```\r\n\r\n![image-20210712111510751](cloudDisk/markdown/Java笔记.assets\\image-20210712111510751.png)\r\n\r\n# 七、Arrays -  工具类\r\n\r\n## 7.1 冒泡排序\r\n\r\n![image-20210712111805192](cloudDisk/markdown/Java笔记.assets\\image-20210712111805192.png)\r\n\r\n![image-20210712112013149](cloudDisk/markdown/Java笔记.assets\\image-20210712112013149.png)\r\n\r\nArrayDemo.java\r\n\r\n```java\r\npackage test13;\r\n\r\nimport java.lang.reflect.Array;\r\n\r\npublic class ArrayDemo {\r\n    public static void main(String[] args) {\r\n        int arr[] = {24,69,80,55,13};\r\n       System.out.println(\"排序前：\" + arrayToString(arr));\r\n\r\n        for (int j=0;j<arr.length-1;j++){  //比较n-1次即：arr.length-1次\r\n            for (int i=0; i<arr.length-1-j; i++){\r\n                if(arr[i]>arr[i+1]){\r\n                    int temp = arr[i];\r\n                    arr[i] = arr[i+1];\r\n                    arr[i+1] = temp;\r\n                }\r\n            }\r\n        }\r\n\r\n        System.out.println(\"排序后：\" + arrayToString(arr));\r\n    }\r\n\r\n\r\n    public static String arrayToString(int arr[]){\r\n        StringBuilder sb = new StringBuilder();\r\n        sb.append(\"[\");\r\n        for(int i=0; i<arr.length; i++){\r\n            if(i==arr.length-1){\r\n                sb.append(arr[i]);\r\n            }\r\n            else {\r\n                sb.append(arr[i]).append(\",\");\r\n            }\r\n        }\r\n        sb.append(\"]\");\r\n        String s = sb.toString();\r\n        return s;\r\n    }\r\n}\r\n```\r\n\r\n## 7.2 Arrays 类的概述和常用方法\r\n\r\n![image-20210712115637916](cloudDisk/markdown/Java笔记.assets\\image-20210712115637916.png)\r\n\r\n```java\r\npackage test13;\r\n\r\nimport java.lang.reflect.Array;\r\nimport java.util.Arrays;\r\n\r\npublic class ArrayDemo {\r\n    public static void main(String[] args) {\r\n        int arr[] = {24,69,80,55,13};\r\n       System.out.println(\"排序前：\" + Arrays.toString(arr));\r\n       Arrays.sort(arr);\r\n       System.out.println(\"排序后：\" + Arrays.toString(arr));\r\n    }\r\n}\r\n```\r\n\r\n![image-20210712120022346](cloudDisk/markdown/Java笔记.assets\\image-20210712120022346.png)\r\n\r\n##### 构造方法用private修饰是为了防止外部调用创建对象\r\n\r\n##### 成员用public static修饰，是为了让用户使用类名访问，使用成员方法','2022-06-23 21:55:13','Java 是由 Sun Microsystems 公司于 1995 年 5 月推出的 Java 面向对象程序设计语言和 Java 平台的总称。由 James Gosling和同事们共同研发，并在 1995 年正式推出。\r\n\r\n后来 Sun 公司被 Oracle （甲骨文）公司收购，Java 也随之成为 Oracle 公司的产品。','cloudDisk/markdown/Java笔记.assets\\image-20210711101917991.png','原创','','','\0','Java 基础（五）','2022-06-23 21:55:13',6,100,NULL,0),(174,'','# 一、基本类型包装类\r\n\r\n# 一、包装类\r\n\r\n## 1.1 包装类的描述\r\n\r\n### 常用于基本数据类型与字符串之间的转换\r\n\r\n![image-20210713142145140](cloudDisk/markdown/Java笔记.assets\\image-20210713142145140.png)\r\n\r\n## 1.2 Integer 类的概述和使用\r\n\r\n![image-20210713143943110](cloudDisk/markdown/Java笔记.assets\\image-20210713143943110.png)\r\n\r\n```java\r\npackage test01;\r\n\r\npublic class IntegerDemo {\r\n    public static void main(String[] args) {\r\n//        Integer i1 = new Integer(100);// 根据int值创建Integer对象（过时）\r\n//        System.out.println(i1);\r\n//\r\n//        Integer i2 = new Integer(\"100\"); // 根据String值创建Integer对象（过时）\r\n//        Integer i3 = new Integer(\"abc\"); //NumberformatException\r\n//        System.out.println(i2);\r\n\r\n        Integer i1 = Integer.valueOf(\"100\");\r\n        System.out.println(i1);\r\n\r\n        Integer i2 = Integer.valueOf(\"100\");\r\n        System.out.println(i2);\r\n\r\n//        Integer i3 = Integer.valueOf(\"asd\"); //NumberFormatException\r\n//        System.out.println(i3);\r\n    }\r\n}\r\n```\r\n\r\n## 1.3 int和String的相互转换\r\n\r\n![image-20210713155334002](cloudDisk/markdown/Java笔记.assets\\image-20210713155334002.png)\r\n\r\n```java\r\npackage test01;\r\n\r\npublic class IntegerDemo {\r\n    public static void main(String[] args) {\r\n        // int --- String\r\n        int number = 100;\r\n        // 方式1\r\n        String s1 = \"\" + number;\r\n        System.out.println(s1);\r\n        // 方式2\r\n        //public static String valueOf(int i)\r\n        String s2 = String.valueOf(number);\r\n        System.out.println(s2);\r\n        System.out.println(\"------------\");\r\n\r\n        //String --- int\r\n        String s = \"100\";\r\n        //方式1\r\n        // String --- Interger --- int\r\n        Integer i = Integer.valueOf(s);\r\n        int x = i.intValue();\r\n        System.out.println(x);\r\n        //方式2\r\n        // public static int parseInt(String s)\r\n        int y = Integer.parseInt(s);\r\n        System.out.println(y);\r\n\r\n    }\r\n}\r\n```\r\n\r\n## 案例\r\n\r\n![image-20210713161457639](cloudDisk/markdown/Java笔记.assets\\image-20210713161457639.png)\r\n\r\n```java\r\npackage test01;\r\n\r\npublic class IntegerDemo {\r\n    public static void main(String[] args) {\r\n        String s = \"91 27 46 38 50\";\r\n        String[] s1 = s.split(\" \");\r\n        int[] arr = new int[s1.length];\r\n        for (int i = 0; i < s1.length; i++) {\r\n            arr[i] = Integer.parseInt(s1[i]);\r\n        }\r\n        for (int j = 0; j < arr.length - 1; j++) {\r\n            for (int i = 0; i < j-1; i++) {\r\n                if(arr[i] > arr[i+1]){\r\n                    int temp = arr[i];\r\n                    arr[i] = arr[i+1];\r\n                    arr[i+1] = temp;\r\n                }\r\n            }\r\n        }\r\n        StringBuilder s2 = new StringBuilder();\r\n        s2.append(\"[\");\r\n        for (int i = 0; i < arr.length; i++) {\r\n            if (i == arr.length-1){\r\n                s2.append(arr[i]);\r\n                break;\r\n            }\r\n            s2.append(arr[i]).append(\",\");\r\n        }\r\n        s2.append(\"]\");\r\n        System.out.println(s2);\r\n\r\n    }\r\n}\r\n```\r\n\r\n## 1.4 自动装箱与拆箱\r\n\r\n![image-20210713163000401](cloudDisk/markdown/Java笔记.assets\\image-20210713163000401.png)\r\n\r\n# 二、Data类\r\n\r\n![image-20210713163451596](cloudDisk/markdown/Java笔记.assets\\image-20210713163451596.png)\r\n\r\n## 2.1 Data类的常用方法\r\n\r\n![image-20210713163555492](cloudDisk/markdown/Java笔记.assets\\image-20210713163555492.png)\r\n\r\n![image-20210713163814079](cloudDisk/markdown/Java笔记.assets\\image-20210713163814079.png)\r\n\r\n## 2.2 SimpleDataFormat 类\r\n\r\n![image-20210713164145326](cloudDisk/markdown/Java笔记.assets\\image-20210713164145326.png)\r\n\r\n![image-20210713164156397](cloudDisk/markdown/Java笔记.assets\\image-20210713164156397.png)\r\n\r\n```java\r\npackage test01;\r\n\r\nimport java.text.ParseException;\r\nimport java.text.SimpleDateFormat;\r\nimport java.util.Date;\r\nimport java.util.logging.SimpleFormatter;\r\n\r\npublic class IntegerDemo {\r\n    public static void main(String[] args) throws ParseException {\r\n        // 格式化：从Data到String\r\n        Date d = new Date();\r\n//        SimpleDateFormat sdf = new SimpleDateFormat(); // 2021/7/13 下午4:44\r\n//        String s = sdf.format(d);\r\n        SimpleDateFormat sdf = new SimpleDateFormat(\"y年M月d日 H:m\"); // 2021年7月13日 16:17\r\n        String s = sdf.format(d);\r\n        System.out.println(s);\r\n\r\n        // 解析\r\n        String ss = \"2048-09-04 11:11\";\r\n        SimpleDateFormat sdf2 = new SimpleDateFormat(\"y-M-d H:m\");\r\n        Date dd = sdf2.parse(ss);\r\n        System.out.println(dd); // Fri Sep 04 11:11:00 CST 2048\r\n\r\n    }\r\n\r\n}\r\n```\r\n\r\n## 案例 - 日期工具类\r\n\r\n![image-20210713165822581](cloudDisk/markdown/Java笔记.assets\\image-20210713165822581.png)\r\n\r\nDateDemo.java\r\n\r\n```java\r\npackage test02;\r\n\r\nimport java.text.ParseException;\r\nimport java.util.Date;\r\n\r\npublic class DateDemo {\r\n    public static void main(String[] args) throws ParseException {\r\n        // 把日期转换为指定格式的字符串\r\n//        Date d = new Date();\r\n//        System.out.println(DateUtils.dateToString(d,\"Y-M-d H:m\"));\r\n\r\n        // 解析字符串为指定日期\r\n        Date d = DateUtils.stringToDate(\"2021-7-13 17:20\", \"Y-M-d H:m\");\r\n        System.out.println(d);\r\n    }\r\n}\r\n```\r\n\r\nDateUtils.java\r\n\r\n```java\r\npackage test02;\r\n\r\nimport java.text.ParseException;\r\nimport java.text.SimpleDateFormat;\r\nimport java.util.Date;\r\n\r\npublic final class DateUtils {\r\n    private DateUtils(){}\r\n    public static String dateToString(Date date, String format){\r\n        // 把日期转换为指定格式的字符串\r\n        SimpleDateFormat sdf = new SimpleDateFormat(format);\r\n        String s = sdf.format(date);\r\n        return s;\r\n    }\r\n    public static Date stringToDate(String s, String format) throws ParseException {\r\n        // 解析字符串为指定日期\r\n        SimpleDateFormat sdf = new SimpleDateFormat(format);\r\n        Date d = sdf.parse(s);\r\n        return d;\r\n    }\r\n}\r\n```\r\n\r\n# 三、日期类\r\n\r\n## 3.1 Calendar 类概述\r\n\r\n![image-20210714082652993](cloudDisk/markdown/Java笔记.assets\\image-20210714082652993.png)\r\n\r\n```java\r\npackage test03;\r\n\r\nimport java.util.Calendar;\r\n\r\npublic class CalendarDemo {\r\n    public static void main(String[] args) {\r\n        Calendar c = Calendar.getInstance();\r\n        int year = c.get(Calendar.YEAR);\r\n        int month = c.get(Calendar.MONTH) + 1;\r\n        int date = c.get(Calendar.DATE);\r\n        System.out.println(year + \"年\" + month + \"月\" + date + \"日\");\r\n    }\r\n}\r\n```\r\n\r\n## 3.2 Calendar常用方法\r\n\r\n![image-20210714083359050](cloudDisk/markdown/Java笔记.assets\\image-20210714083359050.png)\r\n\r\n```java\r\npackage test03;\r\n\r\nimport java.util.Calendar;\r\n\r\npublic class CalendarDemo {\r\n    public static void main(String[] args) {\r\n//        Calendar c = Calendar.getInstance();\r\n//        // 5年后，5天前\r\n//        c.add(Calendar.YEAR,5);\r\n//        c.add(Calendar.DATE,-5);\r\n//\r\n//        int year = c.get(Calendar.YEAR);\r\n//        int month = c.get(Calendar.MONTH) + 1;\r\n//        int date = c.get(Calendar.DATE);\r\n//        System.out.println(year + \"年\" + month + \"月\" + date + \"日\");\r\n\r\n        Calendar c = Calendar.getInstance();\r\n        c.set(2048,11,11);\r\n        int year = c.get(Calendar.YEAR);\r\n        int month = c.get(Calendar.MONTH) + 1;\r\n        int date = c.get(Calendar.DATE);\r\n        System.out.println(year + \"年\" + month + \"月\" + date + \"日\");\r\n\r\n\r\n    }\r\n}\r\n```\r\n\r\n## 案例\r\n\r\n![image-20210714083946161](cloudDisk/markdown/Java笔记.assets\\image-20210714083946161.png)\r\n\r\n![image-20210714084111087](cloudDisk/markdown/Java笔记.assets\\image-20210714084111087.png)\r\n\r\n# 四、异常\r\n\r\n## 4.1 异常概述\r\n\r\n![image-20210714084607180](cloudDisk/markdown/Java笔记.assets\\image-20210714084607180.png)\r\n\r\n## 4.2 JVM的默认处理方案\r\n\r\n![image-20210714084838777](cloudDisk/markdown/Java笔记.assets\\image-20210714084838777.png)\r\n\r\n## 4.3 异常处理\r\n\r\n### try...catch...\r\n\r\n![image-20210714084947560](cloudDisk/markdown/Java笔记.assets\\image-20210714084947560.png)\r\n\r\n```java\r\npackage test04;\r\n\r\npublic class Demo {\r\n    public static void main(String[] args) {\r\n        System.out.println(\"开始\");\r\n\r\n        method();\r\n\r\n        System.out.println(\"结束\");\r\n    }\r\n    public static void method(){\r\n        try {\r\n            int[] arr = {1,2,3};\r\n            System.out.println(arr[3]);\r\n        } catch (ArrayIndexOutOfBoundsException e){\r\n            System.out.println(\"访问的数组index不存在\");\r\n            e.printStackTrace();\r\n        }\r\n\r\n\r\n    }\r\n}\r\n```\r\n\r\nresult:\r\n\r\n![image-20210714085549088](cloudDisk/markdown/Java笔记.assets\\image-20210714085549088.png)\r\n\r\n4.4 Throwable 成员方法\r\n\r\n![image-20210714085650602](cloudDisk/markdown/Java笔记.assets\\image-20210714085650602.png)\r\n\r\n```java\r\npackage test04;\r\n\r\npublic class Demo {\r\n    public static void main(String[] args) {\r\n        System.out.println(\"开始\");\r\n\r\n        method();\r\n\r\n        System.out.println(\"结束\");\r\n    }\r\n    public static void method(){\r\n        try {\r\n            int[] arr = {1,2,3};\r\n            System.out.println(arr[3]);\r\n        } catch (ArrayIndexOutOfBoundsException e){\r\n//            System.out.println(\"访问的数组index不存在\");\r\n//            e.printStackTrace();\r\n//            System.out.println(e.getMessage()); // Index 3 out of bounds for length 3\r\n            String s = e.toString();\r\n            System.out.println(s); //java.lang.ArrayIndexOutOfBoundsException: Index 3 out of bounds for length 3\r\n        }\r\n\r\n\r\n\r\n    }\r\n}\r\n```\r\n\r\n## 4.5 编译时异常和运行异常区别\r\n\r\n![image-20210714090124852](cloudDisk/markdown/Java笔记.assets\\image-20210714090124852.png)\r\n\r\n## 4.6 异常处理 - throws\r\n\r\n![image-20210714090829979](cloudDisk/markdown/Java笔记.assets\\image-20210714090829979.png)\r\n\r\n## 4.7 自定义异常\r\n\r\n![image-20210714090958994](cloudDisk/markdown/Java笔记.assets\\image-20210714090958994.png)\r\n\r\n## 4.8 throws 和 throw 区别\r\n\r\n![image-20210714092540171](cloudDisk/markdown/Java笔记.assets\\image-20210714092540171.png)\r\n\r\nScoreException.java\r\n\r\n```java\r\npackage test05;\r\n\r\npublic class ScoreException extends Exception{\r\n    public ScoreException() {\r\n    }\r\n\r\n    public ScoreException(String message) {\r\n        super(message);\r\n    }\r\n\r\n}\r\n```\r\n\r\nStudent.java\r\n\r\n```java\r\npackage test05;\r\n\r\npublic class Student {\r\n    private int score;\r\n    public void setScore(int s) throws ScoreException {\r\n        if(s>100 || s<0){\r\n            // throw new ScoreException();\r\n            throw new ScoreException(\"分数有误\");\r\n        }else {\r\n            System.out.println(\"分数正常\");\r\n        }\r\n    }\r\n}\r\n```\r\n\r\nDemo.java\r\n\r\n```java\r\npackage test05;\r\n\r\nimport java.util.Scanner;\r\n\r\npublic class Demo {\r\n    public static void main(String[] args){\r\n        Student s = new Student();\r\n        Scanner scanner = new Scanner(System.in);\r\n        int score = scanner.nextInt();\r\n        try {\r\n            s.setScore(score);\r\n        } catch (ScoreException e) {\r\n            e.printStackTrace();\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n# 五、Collection\r\n\r\n## 5.1 集合体系结构\r\n\r\n![image-20210714093007056](cloudDisk/markdown/Java笔记.assets\\image-20210714093007056.png)\r\n\r\n![image-20210714112024947](cloudDisk/markdown/Java笔记.assets\\image-20210714112024947.png)\r\n\r\n创建集合对象\r\n\r\n```java\r\npackage test06;\r\n\r\nimport java.util.ArrayList;\r\nimport java.util.Collection;\r\n\r\npublic class CollectionDemo {\r\n    public static void main(String[] args) {\r\n        Collection<String> c = new ArrayList<>();\r\n        c.add(\"hello\");\r\n        c.add(\"world\");\r\n        c.add(\"java\");\r\n        System.out.println(c);\r\n    }\r\n}\r\n```\r\n\r\n## 5.2 Collection 集合常用方法\r\n\r\n![image-20210714112730629](cloudDisk/markdown/Java笔记.assets\\image-20210714112730629.png)\r\n\r\n##### （Alt + 7）打开一个窗口，能看到类的所有信息\r\n\r\n```java\r\npackage test06;\r\n\r\nimport java.util.ArrayList;\r\nimport java.util.Collection;\r\n\r\npublic class CollectionDemo {\r\n    public static void main(String[] args) {\r\n        Collection<String> c = new ArrayList<>();\r\n        c.add(\"hello\");\r\n        c.add(\"world\");\r\n        c.add(\"java\");\r\n        System.out.println(c);\r\n\r\n        System.out.println(\"------remove()-------\");\r\n        System.out.println(\"remove hello\");\r\n        c.remove(\"hello\");\r\n        System.out.println(c);\r\n\r\n        System.out.println(\"-------clear()------\");\r\n        System.out.println(\"clear\");\r\n        c.clear();\r\n        System.out.println(c);\r\n\r\n        System.out.println(\"------contains-------\");\r\n        System.out.println(\"add hello\");\r\n        c.add(\"hello\");\r\n        System.out.println(c);\r\n        System.out.println(c.contains(\"world\"));\r\n        System.out.println(c.contains(\"hello\"));\r\n\r\n        System.out.println(\"------isEmpty-------\");\r\n        System.out.println(\"add hello\");\r\n        c.add(\"hello\");\r\n        System.out.println(c.isEmpty());\r\n        c.clear();\r\n        System.out.println(c.isEmpty());\r\n\r\n        System.out.println(\"------size()-------\");\r\n        System.out.println(\"add hello\");\r\n        c.add(\"hello\");\r\n        System.out.println(c.size());\r\n    }\r\n}\r\n```\r\n\r\n## 5.3 Collection 集合的遍历\r\n\r\n![image-20210714114832785](cloudDisk/markdown/Java笔记.assets\\image-20210714114832785.png)\r\n\r\n```java\r\npackage test06;\r\n\r\nimport java.util.ArrayList;\r\nimport java.util.Collection;\r\nimport java.util.Iterator;\r\n\r\npublic class CollectionDemo {\r\n    public static void main(String[] args) {\r\n        Collection<String> c = new ArrayList<String>();\r\n        c.add(\"hello\");\r\n        c.add(\"world\");\r\n        c.add(\"java\");\r\n        c.add(\"java\");\r\n\r\n        Iterator<String> it = c.iterator();\r\n        while (it.hasNext()){\r\n            String s = it.next();\r\n            System.out.println(s);\r\n        }\r\n\r\n    }\r\n}\r\n```\r\n\r\n## 5.4 集合的使用步骤\r\n\r\n![image-20210714115931560](cloudDisk/markdown/Java笔记.assets\\image-20210714115931560.png)\r\n\r\n## 案例\r\n\r\n![image-20210714120226631](cloudDisk/markdown/Java笔记.assets\\image-20210714120226631.png)\r\n\r\nStudent.java\r\n\r\n```java\r\npackage test07;\r\n\r\npublic class Student {\r\n    private String name;\r\n    private int age;\r\n\r\n    public Student() {\r\n    }\r\n\r\n    public Student(String name, int age) {\r\n        this.name = name;\r\n        this.age = age;\r\n    }\r\n\r\n    public String getName() {\r\n        return name;\r\n    }\r\n\r\n    public void setName(String name) {\r\n        this.name = name;\r\n    }\r\n\r\n    public int getAge() {\r\n        return age;\r\n    }\r\n\r\n    public void setAge(int age) {\r\n        this.age = age;\r\n    }\r\n\r\n    @Override\r\n    public String toString() {\r\n        return \"Student{\" +\r\n                \"name=\'\" + name + \'\\\'\' +\r\n                \", age=\" + age +\r\n                \'}\';\r\n    }\r\n}\r\n```\r\n\r\nColletionDemo.java\r\n\r\n```java\r\npackage test07;\r\n\r\nimport java.util.ArrayList;\r\nimport java.util.Collection;\r\nimport java.util.Iterator;\r\n\r\npublic class CollectionDemo {\r\n    public static void main(String[] args) {\r\n        // 创建集合对象\r\n        Collection<Student> c = new ArrayList<Student>();\r\n\r\n        // 创建学生对象\r\n        Student s1 = new Student(\"Tosh\",30);\r\n        Student s2 = new Student(\"Hach\",40);\r\n        Student s3 = new Student(\"Posh\",45);\r\n\r\n        // 添加到集合\r\n        c.add(s1);\r\n        c.add(s2);\r\n        c.add(s3);\r\n\r\n        // 遍历集合（迭代器方式）\r\n//        Iterator<Student> it = c.iterator();\r\n//        while (it.hasNext()){\r\n//            Student student = it.next();\r\n//            int age = student.getAge();\r\n//            String name = student.getName();\r\n//            System.out.println(\"姓名：\"+ name + \"，年龄：\" + age);\r\n//        }\r\n\r\n        // 重写学生类的toString方法遍历\r\n        Iterator<Student> it = c.iterator();\r\n        while (it.hasNext()){\r\n            Student student = it.next();\r\n            System.out.println(student.toString());\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n# 六、List集合\r\n\r\n## 6.1 List集合概述和特点\r\n\r\n![image-20210714121733417](cloudDisk/markdown/Java笔记.assets\\image-20210714121733417.png)\r\n\r\n```java\r\npackage test08;\r\n\r\nimport java.util.ArrayList;\r\nimport java.util.Iterator;\r\nimport java.util.List;\r\n\r\npublic class ListDemo {\r\n    public static void main(String[] args) {\r\n        List<String> list = new ArrayList<String>();\r\n        list.add(\"hello\");\r\n        list.add(\"world\");\r\n        list.add(\"java\");\r\n        Iterator<String> it = list.iterator();\r\n        while (it.hasNext()){\r\n            String s = it.next();\r\n            System.out.println(s);\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n## 6.2 List集合特有方法\r\n\r\n![image-20210714122321961](cloudDisk/markdown/Java笔记.assets\\image-20210714122321961.png)\r\n\r\n```java\r\npackage test08;\r\n\r\nimport java.util.ArrayList;\r\nimport java.util.Iterator;\r\nimport java.util.List;\r\n\r\npublic class ListDemo {\r\n    public static void main(String[] args) {\r\n        List<String> list = new ArrayList<String>();\r\n        list.add(\"hello\");\r\n        list.add(\"world\");\r\n        list.add(\"java\");\r\n        list.add(1,\"impressive\"); // 在第一个元素之后插入 impressive\r\n        System.out.println(list);\r\n        list.remove(3); // 删除第四个元素：java\r\n        System.out.println(list);\r\n        list.set(2,\"home\"); // 修改第三个元素world 为 home\r\n        System.out.println(list);\r\n        String ss = list.get(1); // 返回第第二元素\r\n        System.out.println(ss);\r\n\r\n        // for循环遍历\r\n        for (int i = 0; i < list.size(); i++) {\r\n            String s = list.get(i);\r\n            System.out.println(s);\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n## 6.3 案例\r\n\r\n![image-20210714123707758](cloudDisk/markdown/Java笔记.assets\\image-20210714123707758.png)\r\n\r\nStudent.java\r\n\r\n```java\r\npackage test09;\r\n\r\npublic class Student {\r\n    private String name;\r\n    private int age;\r\n\r\n    public Student(String name, int age) {\r\n        this.name = name;\r\n        this.age = age;\r\n    }\r\n\r\n    public Student() {\r\n    }\r\n\r\n    public String getName() {\r\n        return name;\r\n    }\r\n\r\n    public void setName(String name) {\r\n        this.name = name;\r\n    }\r\n\r\n    public int getAge() {\r\n        return age;\r\n    }\r\n\r\n    public void setAge(int age) {\r\n        this.age = age;\r\n    }\r\n\r\n    @Override\r\n    public String toString() {\r\n        return \"Student{\" +\r\n                \"name=\'\" + name + \'\\\'\' +\r\n                \", age=\" + age +\r\n                \'}\';\r\n    }\r\n}\r\n```\r\n\r\nListDemo.java\r\n\r\n```java\r\npackage test09;\r\n\r\nimport java.util.ArrayList;\r\nimport java.util.Iterator;\r\nimport java.util.List;\r\n\r\npublic class ListDemo {\r\n    public static void main(String[] args) {\r\n        // 创建List对象\r\n        List<Student> list = new ArrayList<Student>();\r\n\r\n        // 创建学生对象\r\n        Student s1 = new Student(\"poui\",21);\r\n        Student s2 = new Student(\"aspi\",29);\r\n        Student s3 = new Student(\"tpuy\",66);\r\n\r\n        // 添加到集合\r\n        list.add(s1);\r\n        list.add(s2);\r\n        list.add(s3);\r\n\r\n        // 遍历集合\r\n        // 迭代器方法\r\n        Iterator<Student> it = list.iterator();\r\n        while (it.hasNext()){\r\n            Student s = it.next();\r\n            System.out.println(s.toString());\r\n        }\r\n        System.out.println(\"------------\");\r\n        // for循环遍历\r\n        for (int i = 0; i < list.size(); i++) {\r\n            Student s = list.get(i);\r\n            System.out.println(s.toString());\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n## 6.4 并发修改异常\r\n\r\n![image-20210714125942916](cloudDisk/markdown/Java笔记.assets\\image-20210714125942916.png)\r\n\r\n## 6.5 ListIterator\r\n\r\n![image-20210714130251087](cloudDisk/markdown/Java笔记.assets\\image-20210714130251087.png)\r\n\r\n```java\r\npackage test10;\r\n\r\nimport java.util.ArrayList;\r\nimport java.util.List;\r\n\r\npublic class ListIterator {\r\n    public static void main(String[] args) {\r\n        // 创建List对象\r\n        List<String> list = new ArrayList<String>();\r\n\r\n        // 添加元素\r\n        list.add(\"hello\");\r\n        list.add(\"impressive\");\r\n        list.add(\"world\");\r\n\r\n        //通过List集合listIterator()方法得到\r\n//        System.out.println(\"前至后遍历\");\r\n//        java.util.ListIterator<String> lit = list.listIterator();\r\n//        while (lit.hasNext()){\r\n//            String s = lit.next();\r\n//            System.out.println(s);\r\n//        }\r\n//        System.out.println(\"----------\");\r\n//        System.out.println(\"后至前遍历\");\r\n//        while (lit.hasPrevious()){\r\n//            String s = lit.previous();\r\n//            System.out.println(s);\r\n//        }\r\n\r\n        System.out.println(\"----------\");\r\n        java.util.ListIterator<String> lit = list.listIterator();\r\n        while (lit.hasNext()){\r\n            String s = lit.next();\r\n            if(s.equals(\"impressive\")){\r\n                lit.add(\"java\");\r\n            }\r\n        }\r\n        System.out.println(list);\r\n    }\r\n}\r\n```\r\n\r\n## 6.6 增强for循环\r\n\r\n![image-20210715095944784](cloudDisk/markdown/Java笔记.assets\\image-20210715095944784.png)\r\n\r\n```java\r\npackage test11;\r\n\r\nimport java.util.ArrayList;\r\nimport java.util.Collection;\r\nimport java.util.List;\r\n\r\npublic class ForDemo {\r\n    public static void main(String[] args) {\r\n        // 遍历数组\r\n        int[] arr = {1,2,3,4,5,6};\r\n        for (int i :\r\n                arr) {\r\n            System.out.println(i);\r\n        }\r\n        String[] strArr = {\"hello\",\"world\",\"java\"};\r\n        for (String i :\r\n                strArr) {\r\n            System.out.println(i);\r\n        }\r\n\r\n        System.out.println(\"-----------------\");\r\n\r\n        // 遍历List\r\n        List<String> list = new ArrayList<String>();\r\n        list.add(\"hello\");\r\n        list.add(\"impressive\");\r\n        list.add(\"world\");\r\n        for (String s :\r\n                list) {\r\n            if(s.equals(\"world\")){\r\n                list.add(\"java\"); //ConcurrentModificationException\r\n                // 抛出异常，故内部为一迭代器 iterator()\r\n\r\n            }\r\n        }\r\n\r\n        System.out.println(\"-----------------\");\r\n\r\n    }\r\n}\r\n```\r\n\r\n## 6.7 案例\r\n\r\n![image-20210715101711999](cloudDisk/markdown/Java笔记.assets\\image-20210715101711999.png)\r\n\r\n![image-20210715101929669](cloudDisk/markdown/Java笔记.assets\\image-20210715101929669.png)\r\n\r\n## 6.8 数据结构\r\n\r\n### 栈\r\n\r\n![image-20210715102312169](cloudDisk/markdown/Java笔记.assets\\image-20210715102312169.png)\r\n\r\n### 队列\r\n\r\n![image-20210715102517316](cloudDisk/markdown/Java笔记.assets\\image-20210715102517316.png)\r\n\r\n## 6.9\r\n\r\n![image-20210715102657093](cloudDisk/markdown/Java笔记.assets\\image-20210715102657093.png)\r\n\r\n## 6.10 链表\r\n\r\n![image-20210715102753810](cloudDisk/markdown/Java笔记.assets\\image-20210715102753810.png)\r\n\r\n![image-20210715102913608](cloudDisk/markdown/Java笔记.assets\\image-20210715102913608.png)\r\n\r\n![image-20210715103114149](cloudDisk/markdown/Java笔记.assets\\image-20210715103114149.png)\r\n\r\n## 6.11 List集合子类特点\r\n\r\n![image-20210715103315017](cloudDisk/markdown/Java笔记.assets\\image-20210715103315017.png)\r\n\r\n![image-20210715103333955](cloudDisk/markdown/Java笔记.assets\\image-20210715103333955.png)\r\n\r\n```java\r\npackage test11;\r\n\r\nimport java.util.*;\r\n\r\npublic class ForDemo {\r\n    public static void main(String[] args) {\r\n        ArrayList<String> al = new ArrayList<String>();\r\n        al.add(\"hello\");\r\n        al.add(\"impressive\");\r\n        al.add(\"world\");\r\n        // 增强for\r\n        for (String s :\r\n                al) {\r\n            System.out.println(s);\r\n        }\r\n        // for\r\n        for (int i = 0; i < al.size(); i++) {\r\n            String s = al.get(i);\r\n            System.out.println(s);\r\n        }\r\n        // 迭代器\r\n        Iterator<String> it = al.iterator();\r\n        while (it.hasNext()){\r\n            String s = it.next();\r\n            System.out.println(s);\r\n        }\r\n        System.out.println(\"---------------\");\r\n        LinkedList<String> lkl = new LinkedList<String>();\r\n        lkl.add(\"hello\");\r\n        lkl.add(\"world\");\r\n        lkl.add(\"java\");\r\n        for (String s :\r\n                lkl) {\r\n            System.out.println(s);\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n## 6.12 LinkedList集合的特有功能\r\n\r\n![image-20210715104517039](cloudDisk/markdown/Java笔记.assets\\image-20210715104517039.png)\r\n\r\n# 七、set\r\n\r\n## 7.1 set集合概述和特点\r\n\r\n![image-20210715104911143](cloudDisk/markdown/Java笔记.assets\\image-20210715104911143.png)\r\n\r\n```java\r\npackage test12;\r\n\r\nimport java.util.HashSet;\r\nimport java.util.Set;\r\n\r\npublic class SetDemo {\r\n    public static void main(String[] args) {\r\n        // 创建集合对象\r\n        Set<String> set = new HashSet<>();\r\n\r\n        // 添加元素\r\n        set.add(\"hello\");\r\n        set.add(\"world\");\r\n        set.add(\"java\");\r\n        set.add(\"java\");\r\n\r\n        // 遍历\r\n        for (String s :\r\n                set) {\r\n            System.out.println(s);\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n\r\n\r\n## 7.2 哈希值\r\n\r\n![image-20210715105632394](cloudDisk/markdown/Java笔记.assets\\image-20210715105632394.png)\r\n\r\n![image-20210715110040415](cloudDisk/markdown/Java笔记.assets\\image-20210715110040415.png)\r\n\r\n![image-20210715110116139](cloudDisk/markdown/Java笔记.assets\\image-20210715110116139.png)\r\n\r\n## 7.3 HshSet集合概述和特点\r\n\r\n![image-20210715110252209](cloudDisk/markdown/Java笔记.assets\\image-20210715110252209.png)\r\n\r\n## 7.4 HashSet集合保证元素唯一性代码分析\r\n\r\n![image-20210715111754033](cloudDisk/markdown/Java笔记.assets\\image-20210715111754033.png)\r\n\r\n## 7.5 哈希表\r\n\r\n![image-20210715111836799](cloudDisk/markdown/Java笔记.assets\\image-20210715111836799.png)\r\n\r\n![image-20210715112131625](cloudDisk/markdown/Java笔记.assets\\image-20210715112131625.png)\r\n\r\n## 7.6 案例\r\n\r\n![image-20210715112942168](cloudDisk/markdown/Java笔记.assets\\image-20210715112942168.png)\r\n\r\nStudent.java\r\n\r\n```java\r\npackage test13;\r\n\r\npublic class Student {\r\n    private String name;\r\n    private int age;\r\n\r\n   ...\r\n\r\n    @Override\r\n    public String toString() {\r\n        return \"Student{\" +\r\n                \"name=\'\" + name + \'\\\'\' +\r\n                \", age=\" + age +\r\n                \'}\';\r\n    }\r\n\r\n    @Override\r\n    public boolean equals(Object o) {\r\n        if (this == o) return true;\r\n        if (o == null || getClass() != o.getClass()) return false;\r\n\r\n        Student student = (Student) o;\r\n\r\n        if (age != student.age) return false;\r\n        return name != null ? name.equals(student.name) : student.name == null;\r\n    }\r\n\r\n    @Override\r\n    public int hashCode() {\r\n        int result = name != null ? name.hashCode() : 0;\r\n        result = 31 * result + age;\r\n        return result;\r\n    }\r\n}\r\n```\r\n\r\nHashSetDemo.java\r\n\r\n```java\r\npackage test13;\r\n\r\nimport java.util.HashSet;\r\n\r\npublic class HashSetDemo {\r\n    public static void main(String[] args) {\r\n        HashSet<Student> hashSet = new HashSet<Student>();\r\n        Student s1 = new Student(\"tony\",16);\r\n        Student s2 = new Student(\"dsa\",16);\r\n        Student s3 = new Student(\"tofdsany\",16);\r\n        Student s4 = new Student(\"tofdsany\",16);\r\n        hashSet.add(s1);\r\n        hashSet.add(s2);\r\n        hashSet.add(s3);\r\n        hashSet.add(s4);\r\n\r\n        for (Student s :\r\n                hashSet) {\r\n            System.out.println(s);\r\n        }\r\n    }\r\n}\r\n```\r\n\r\nresult:![image-20210715113043483](cloudDisk/markdown/Java笔记.assets\\image-20210715113043483.png)\r\n\r\n## 7.7 LinkedHshSet集合概述和特点\r\n\r\n![image-20210715113243858](cloudDisk/markdown/Java笔记.assets\\image-20210715113243858.png)\r\n\r\n![image-20210715113409781](cloudDisk/markdown/Java笔记.assets\\image-20210715113409781.png)\r\n\r\n![image-20210715113421014](cloudDisk/markdown/Java笔记.assets\\image-20210715113421014.png)\r\n\r\n7.8 TreeSet集合概述和特点\r\n\r\n![image-20210715113705546](cloudDisk/markdown/Java笔记.assets\\image-20210715113705546.png)\r\n\r\n```java\r\npackage test14;\r\n\r\nimport java.util.TreeSet;\r\n\r\npublic class TreeSetDemo {\r\n    public static void main(String[] args) {\r\n        TreeSet<Integer> ts = new TreeSet<Integer>();\r\n        ts.add(20);\r\n        ts.add(40);\r\n        ts.add(55);\r\n        ts.add(78);\r\n        ts.add(78);\r\n        ts.add(30);\r\n\r\n        for (Integer i :\r\n                ts) {\r\n            System.out.println(i);\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n## 7.8 自然排序Comparable的使用\r\n\r\n![image-20210715115146123](cloudDisk/markdown/Java笔记.assets\\image-20210715115146123.png)\r\n\r\nStudent.java\r\n\r\n```java\r\npackage test15;\r\n\r\npublic class Student implements Comparable<Student>{\r\n    private String name;\r\n    private int age;\r\n\r\n...\r\n\r\n    @Override\r\n    public int compareTo(Student s) {\r\n//        System.out.println(s.name); // s 是treeSet里已有的元素，即被比较的对象\r\n//        System.out.println(this.name); // this 是要去比较的对象\r\n\r\n        // 按年龄从小到大排序\r\n//        return this.getAge() - s.getAge(); //当add(s2)时,this.age=20,s.age=30,30>20,放后面\r\n                                            //当add(s3)时,this.age=15,s.age=20,15<20,放前面\r\n\r\n        int num = this.getAge() - s.getAge();\r\n        if(num==0){\r\n            num = this.name.compareTo(s.name); //姓名相同，返回0\r\n        }\r\n        return num;\r\n\r\n\r\n\r\n//        return 0;  // 不添加到元素\r\n//        return 1;\r\n//        return -1;\r\n    }\r\n}\r\n```\r\n\r\nCompareableTest.java\r\n\r\n```java\r\npackage test15;\r\n\r\nimport java.util.TreeSet;\r\n\r\npublic class ComparableTest {\r\n    public static void main(String[] args) {\r\n        TreeSet<Student> ts = new TreeSet<>();\r\n        Student s1 = new Student(\"tony\",20);\r\n        Student s2 = new Student(\"pony\",30);\r\n        Student s3 = new Student(\"hash\",15);\r\n        Student s4 = new Student(\"hash\",15);\r\n        ts.add(s1);\r\n        ts.add(s2);\r\n        ts.add(s3);\r\n        ts.add(s4);\r\n\r\n        System.out.println(\"-------------\");\r\n        for (Student s :\r\n                ts) {\r\n            System.out.println(s);\r\n        }\r\n        System.out.println(\"-------------\");\r\n    }\r\n}\r\n```\r\n\r\nresult\r\n\r\n![image-20210715122544255](cloudDisk/markdown/Java笔记.assets\\image-20210715122544255.png)\r\n\r\n## 7.9 比较器排序Comparator的使用\r\n\r\n![image-20210715133604191](cloudDisk/markdown/Java笔记.assets\\image-20210715133604191.png)\r\n\r\n```java\r\npackage test15;\r\n\r\nimport java.util.Comparator;\r\nimport java.util.TreeSet;\r\n\r\npublic class ComparableTest {\r\n    public static void main(String[] args) {\r\n        TreeSet<Student> ts = new TreeSet<>(new Comparator<Student>() {\r\n            @Override\r\n            public int compare(Student s1, Student s2) {\r\n                int num = s1.getAge() - s2.getAge();\r\n                num = num==0?s1.getName().compareTo(s2.getName()):num;\r\n                return num;\r\n            }\r\n        });\r\n        Student s1 = new Student(\"tony\",20);\r\n        Student s2 = new Student(\"pony\",30);\r\n        Student s3 = new Student(\"hash\",15);\r\n        Student s4 = new Student(\"hash\",15);\r\n        ts.add(s1);\r\n        ts.add(s2);\r\n        ts.add(s3);\r\n        ts.add(s4);\r\n\r\n        System.out.println(\"-------------\");\r\n        for (Student s :\r\n                ts) {\r\n            System.out.println(s);\r\n        }\r\n        System.out.println(\"-------------\");\r\n    }\r\n}\r\n```\r\n\r\n## 案例 - 成绩排序\r\n\r\n![image-20210715133746677](cloudDisk/markdown/Java笔记.assets\\image-20210715133746677.png)\r\n\r\nStudent.java\r\n\r\n```java\r\npackage test16;\r\n\r\npublic class Student {\r\n    private String name;\r\n    private double chineseScore;\r\n    private double mathScore;\r\n\r\n...\r\n\r\n    }\r\n}\r\n```\r\n\r\nDemo.java\r\n\r\n```java\r\npackage test16;\r\n\r\nimport java.util.Comparator;\r\nimport java.util.TreeSet;\r\n\r\npublic class Demo {\r\n    public static void main(String[] args) {\r\n        TreeSet<Student> ts = new TreeSet<Student>(new Comparator<Student>() {\r\n            @Override\r\n            public int compare(Student o1, Student o2) {\r\n                double sumScore1 = o1.getChineseScore() + o1.getMathScore();\r\n                double sumScore2 = o2.getChineseScore() + o2.getMathScore();\r\n                int num = (int)(sumScore2 - sumScore1);  //从大到小\r\n//                return o1.getName().compareTo(o2.getName());\r\n                num = num==0?o1.getName().compareTo(o2.getName()):num;\r\n                return num;\r\n            }\r\n\r\n        });\r\n        Student s1 = new Student(\"Tony\", 20, 50);\r\n        Student s2 = new Student(\"hash\", 30, 60);\r\n        Student s3 = new Student(\"pony\", 20, 10);\r\n        Student s4 = new Student(\"hony\", 20, 10);\r\n        Student s5 = new Student(\"hony\", 30, 10);\r\n        ts.add(s1);\r\n        ts.add(s2);\r\n        ts.add(s3);\r\n        ts.add(s4);\r\n        ts.add(s5);\r\n\r\n        for (Student s :\r\n                ts) {\r\n            System.out.println(s);\r\n        }\r\n\r\n    }\r\n}\r\n```\r\n\r\n## 案例 - 不重复的随机数\r\n\r\n![image-20210716123741096](cloudDisk/markdown/Java笔记.assets\\image-20210716123741096.png)\r\n\r\n```java\r\npackage test17;\r\n\r\nimport com.sun.source.tree.Tree;\r\n\r\nimport java.util.PrimitiveIterator;\r\nimport java.util.Random;\r\nimport java.util.Set;\r\nimport java.util.TreeSet;\r\nimport java.util.stream.IntStream;\r\n\r\npublic class Demo {\r\n    public static void main(String[] args) {\r\n        TreeSet<Integer> ts = new TreeSet<Integer>();\r\n        Random random = new Random();\r\n//        IntStream ints = random.ints(1, 21);\r\n//        PrimitiveIterator.OfInt it = ints.iterator();\r\n        while (ts.size()<10){\r\n            ts.add(random.nextInt(20)+1);\r\n        }\r\n        for (int i :\r\n                ts) {\r\n            System.out.println(i);\r\n        }\r\n    }\r\n}\r\n```','2022-06-23 21:57:17','Java 是由 Sun Microsystems 公司于 1995 年 5 月推出的 Java 面向对象程序设计语言和 Java 平台的总称。由 James Gosling和同事们共同研发，并在 1995 年正式推出。\r\n\r\n后来 Sun 公司被 Oracle （甲骨文）公司收购，Java 也随之成为 Oracle 公司的产品。','cloudDisk/markdown/Java笔记.assets\\image-20210713142145140.png','原创','','','\0','Java 基础（六）','2022-06-23 21:57:17',1,100,NULL,0),(175,'','# 一、泛型\r\n\r\n## 1.1 概述\r\n\r\n![image-20210716125827165](cloudDisk/markdown/Java笔记.assets\\image-20210716125827165.png)\r\n\r\n![image-20210716125854330](cloudDisk/markdown/Java笔记.assets\\image-20210716125854330.png)\r\n\r\n![image-20210716130249078](cloudDisk/markdown/Java笔记.assets\\image-20210716130249078.png)\r\n\r\n## 1.2 泛型类\r\n\r\n![image-20210716130743001](cloudDisk/markdown/Java笔记.assets\\image-20210716130743001.png)\r\n\r\nStudent.java\r\n\r\n```java\r\npackage test02;\r\n\r\npublic class Student<T> {\r\n    private T t;\r\n\r\n    public T getT() {\r\n        return t;\r\n    }\r\n\r\n    public void setT(T t) {\r\n        this.t = t;\r\n    }\r\n}\r\n```\r\n\r\nDemo.java\r\n\r\n```java\r\npackage test02;\r\n\r\npublic class Demo {\r\n    public static void main(String[] args) {\r\n        Student<Integer> s1 = new Student<Integer>();\r\n        s1.setT(20);\r\n        System.out.println(s1.getT());\r\n\r\n        Student<String> s2 = new Student<String>();\r\n        s2.setT(\"Tony\");\r\n        System.out.println(s2.getT());\r\n    }\r\n}\r\n```\r\n\r\n## 1.3 泛型方法\r\n\r\n![image-20210716131733807](cloudDisk/markdown/Java笔记.assets\\image-20210716131733807.png)\r\n\r\n![image-20210716131742152](cloudDisk/markdown/Java笔记.assets\\image-20210716131742152.png)\r\n\r\n## 1.4 泛型接口\r\n\r\n![image-20210716131824543](cloudDisk/markdown/Java笔记.assets\\image-20210716131824543.png)\r\n\r\n##### 实现类，重写方法\r\n\r\nGeneric.java\r\n\r\n```java\r\npackage test03;\r\n\r\npublic interface Generic<T> {\r\n    void show(T t);\r\n}\r\n```\r\n\r\nGenericImpl.java\r\n\r\n```java\r\npackage test03;\r\n\r\npublic class GenericImpl<T> implements Generic<T>{\r\n    @Override\r\n    public void show(T t) {\r\n        System.out.println(t);\r\n    }\r\n}\r\n```\r\n\r\nGenericDemo.java\r\n\r\n```java\r\npackage test03;\r\n\r\npublic class GenericDemo {\r\n    public static void main(String[] args) {\r\n        GenericImpl<String> g1 = new GenericImpl<String>();\r\n        g1.show(\"Tony\");\r\n\r\n        GenericImpl<Integer> g2 = new GenericImpl<Integer>();\r\n        g2.show(20);\r\n    }\r\n}\r\n```\r\n\r\n## 1.5 类型通配符\r\n\r\n![image-20210716133221228](cloudDisk/markdown/Java笔记.assets\\image-20210716133221228.png)\r\n\r\n```java\r\npackage test04;\r\n\r\nimport java.util.ArrayList;\r\nimport java.util.List;\r\n\r\npublic class Demo {\r\n    public static void main(String[] args) {\r\n        // 通配符<?>,元素可以是任意类型\r\n        List<?> l1 = new ArrayList<Object>();\r\n        List<?> l2 = new ArrayList<Number>();\r\n        List<?> l3 = new ArrayList<Integer>();\r\n\r\n        // 通配符<? extends 某类型>, 某类型为上限，元素只能添加某类型即其子类型\r\n        // List<? extends Number> l4 = new ArrayList<Object>();\r\n        List<? extends Number> l5 = new ArrayList<Number>();\r\n        List<? extends Number> l6 = new ArrayList<Integer>();\r\n\r\n        // 通配符<? super 某类型>, 某类型为下限，元素只能添加某类型即其父类型\r\n         List<? super Number> l7 = new ArrayList<Object>();\r\n        List<? super Number> l8 = new ArrayList<Number>();\r\n        //List<? super Number> l9 = new ArrayList<Integer>();\r\n    }\r\n}\r\n```\r\n\r\n## 1.6 可变参数（python里的多参数，def a(*args)）\r\n\r\n![image-20210716134440373](cloudDisk/markdown/Java笔记.assets\\image-20210716134440373.png)\r\n\r\n```java\r\npackage test05;\r\n\r\npublic class ArgsDemo {\r\n    public static void main(String[] args) {\r\n        System.out.println(sum(10,20,30,40,50,60));\r\n        System.out.println(sum(10,20,50,60));\r\n    }\r\n    public static int sum(int... a){\r\n        int sum=0;\r\n        for (int i :\r\n                a) {\r\n            sum += i;\r\n        }\r\n        return sum;\r\n    }\r\n}\r\n```\r\n\r\n## 1.7 可变参数的使用\r\n\r\n![image-20210716140520232](cloudDisk/markdown/Java笔记.assets\\image-20210716140520232.png)\r\n\r\n\r\n\r\n![image-20210716140459433](cloudDisk/markdown/Java笔记.assets\\image-20210716140459433.png)\r\n\r\n## 二、Map集合概述和使用\r\n\r\n## 2.1 概述\r\n\r\n![image-20210716140659615](cloudDisk/markdown/Java笔记.assets\\image-20210716140659615.png)\r\n\r\n## 2.2 Map集合的基本功能\r\n\r\n\r\n\r\n![image-20210716141058840](cloudDisk/markdown/Java笔记.assets\\image-20210716141058840.png)\r\n\r\n```java\r\npackage test06;\r\n\r\nimport java.util.HashMap;\r\nimport java.util.Map;\r\n\r\npublic class MapDemo {\r\n    public static void main(String[] args) {\r\n        // 创建Map对象\r\n        Map<String,String> map = new HashMap<String, String>();\r\n\r\n        //添加元素\r\n        map.put(\"张无忌\",\"赵敏\");\r\n        map.put(\"郭靖\",\"黄蓉\");\r\n        map.put(\"杨过\",\"小龙女\");\r\n\r\n        // 取value,没有则返回null\r\n//        System.out.println(map.get(\"杨\"));\r\n        // 取不到。则返回第二个参数\r\n//        System.out.println(map.getOrDefault(\"杨过\",\"无\"));\r\n\r\n        // 根据key删除value,返回value,不存在key则返回null\r\n//        map.remove(\"张无忌\");\r\n\r\n        // 删除所有元素\r\n//        map.clear();\r\n\r\n        // 是否包含指定的key或value\r\n//        System.out.println(map.containsKey(\"杨过\"));\r\n//        System.out.println(map.containsValue(\"小龙女\"));\r\n\r\n        // 是否为空\r\n//        System.out.println(map.isEmpty());\r\n\r\n        // 长度，即键值对个数\r\n//        System.out.println(map.size());\r\n\r\n        System.out.println(map);\r\n    }\r\n}\r\n```\r\n\r\n## 2.3 Map集合的获取功能\r\n\r\n![image-20210716142504054](cloudDisk/markdown/Java笔记.assets\\image-20210716142504054.png)\r\n\r\n## 2.4 Map集合遍历（方式1）\r\n\r\n![image-20210716143159195](cloudDisk/markdown/Java笔记.assets\\image-20210716143159195.png)\r\n\r\n![image-20210716143315538](cloudDisk/markdown/Java笔记.assets\\image-20210716143315538.png)\r\n\r\n## 2.5 Map集合的遍历（方式2）\r\n\r\n![image-20210716143524564](cloudDisk/markdown/Java笔记.assets\\image-20210716143524564.png)\r\n\r\n```java\r\npackage test06;\r\n\r\nimport java.util.Collection;\r\nimport java.util.HashMap;\r\nimport java.util.Map;\r\nimport java.util.Set;\r\n\r\npublic class MapDemo {\r\n    public static void main(String[] args) {\r\n        // 创建Map对象\r\n        Map<String,String> map = new HashMap<String, String>();\r\n\r\n        //添加元素\r\n        map.put(\"张无忌\",\"赵敏\");\r\n        map.put(\"郭靖\",\"黄蓉\");\r\n        map.put(\"杨过\",\"小龙女\");\r\n\r\n        // 获取每一个键值对的对象集合\r\n        Set<Map.Entry<String, String>> entries = map.entrySet();\r\n        for (Map.Entry<String, String> m :\r\n                entries\r\n                ) {\r\n            System.out.println(m.getKey() + \",\" + m.getValue());\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n## 案例 - 1\r\n\r\n![image-20210716144511989](cloudDisk/markdown/Java笔记.assets\\image-20210716144511989.png)\r\n\r\nStudent.java\r\n\r\n```java\r\npackage test07;\r\n\r\npublic class Student {\r\n    private String name;\r\n    private int age;\r\n\r\n    @Override\r\n    public boolean equals(Object o) {\r\n        if (this == o) return true;\r\n        if (o == null || getClass() != o.getClass()) return false;\r\n\r\n        Student student = (Student) o;\r\n\r\n        if (age != student.age) return false;\r\n        return name != null ? name.equals(student.name) : student.name == null;\r\n    }\r\n\r\n    @Override\r\n    public int hashCode() {\r\n        int result = name != null ? name.hashCode() : 0;\r\n        result = 31 * result + age;\r\n        return result;\r\n    }\r\n\r\n...\r\n}\r\n```\r\n\r\nDemo.java\r\n\r\n```java\r\npackage test07;\r\n\r\nimport java.util.HashMap;\r\nimport java.util.HashSet;\r\nimport java.util.Map;\r\nimport java.util.Set;\r\n\r\npublic class Demo {\r\n    public static void main(String[] args) {\r\n        Map<Student,String> map = new HashMap<Student,String>();\r\n        Student s1 = new Student(\"Tony\",20);\r\n        Student s2 = new Student(\"Pony\",50);\r\n        Student s3 = new Student(\"hashc\",80);\r\n        Student s4 = new Student(\"hashc\",80);\r\n        map.put(s1,\"苏州\");\r\n        map.put(s2,\"深圳\");\r\n        map.put(s3,\"上海\");\r\n        map.put(s4,\"澳洲\");\r\n\r\n        Set<Student> set = map.keySet();\r\n        for (Student s :\r\n                set) {\r\n            String dizhi = map.get(s);\r\n            String name = s.getName();\r\n            int age = s.getAge();\r\n            System.out.println(\"姓名：\"+name+\"，年龄：\"+age+\"，住址：\"+dizhi);\r\n        }\r\n\r\n        System.out.println(map);\r\n    }\r\n}\r\n```\r\n\r\n## 案例 - 2\r\n\r\n![image-20210716151008188](cloudDisk/markdown/Java笔记.assets\\image-20210716151008188.png)\r\n\r\n```java\r\npackage test07;\r\n\r\nimport java.util.*;\r\n\r\npublic class Demo {\r\n    public static void main(String[] args) {\r\n        Map<String, ArrayList> map = new HashMap<String, ArrayList>();\r\n\r\n        ArrayList<String> al1 = new ArrayList<>();\r\n        al1.add(\"刘备\");\r\n        al1.add(\"诸葛亮\");\r\n        map.put(\"三国\",al1);\r\n\r\n        ArrayList<String> al2 = new ArrayList<>();\r\n        al2.add(\"开花\");\r\n        al2.add(\"孙猴子\");\r\n        map.put(\"西游记\",al2);\r\n\r\n        ArrayList<String> al3 = new ArrayList<>();\r\n        al3.add(\"李逵\");\r\n        al3.add(\"宋江\");\r\n        map.put(\"水浒传\",al3);\r\n\r\n        Set<String> set = map.keySet();\r\n        StringBuilder sb = new StringBuilder();\r\n        for (String s :\r\n                set) {\r\n            ArrayList<String> al = map.get(s);\r\n            sb.append(\"电视剧：\").append(s).append(\"，关键词：\");\r\n            for (String s1 :\r\n                    al) {\r\n                if(s1.equals(al.get(al.size()-1))){\r\n                    sb.append(s1);\r\n                    break;\r\n                }\r\n                sb.append(s1).append(\"、\");\r\n            }\r\n            sb.append(\"\\n\");\r\n        }\r\n        System.out.println(sb.toString());\r\n    }\r\n}\r\n```\r\n\r\nresult:![image-20210716153019131](cloudDisk/markdown/Java笔记.assets\\image-20210716153019131.png)\r\n\r\n## 案例 - 3\r\n\r\n![image-20210716153231559](cloudDisk/markdown/Java笔记.assets\\image-20210716153231559.png)\r\n\r\n```java\r\npackage test07;\r\n\r\nimport java.util.*;\r\n\r\npublic class Demo {\r\n    public static void main(String[] args) {\r\n        System.out.print(\"输入一串字符：\");\r\n        Scanner scanner = new Scanner(System.in);\r\n        String s = scanner.nextLine();\r\n\r\n//        HashMap<Character, Integer> map = new HashMap<Character, Integer>();\r\n\r\n        // key按照自然排序\r\n        TreeMap<Character, Integer> map = new TreeMap<Character, Integer>();\r\n\r\n        StringBuilder sb = new StringBuilder(s);\r\n        for (int i = 0; i < sb.length(); i++) {\r\n            char c = sb.charAt(i); //获取一个字符\r\n            if(map.containsKey(c)){ //判断字符是否存在map中\r\n                Integer num = map.get(c);\r\n                map.put(c,++num);\r\n            }\r\n            else {\r\n                map.put(c,1);\r\n            }\r\n        }\r\n        Set<Character> keySet = map.keySet();\r\n        for (Character key :\r\n                keySet\r\n             ) {\r\n            Integer value = map.get(key);\r\n            System.out.print(key+\"(\"+value+\")\");\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n# 三、Collections工具类的概述和使用\r\n\r\n## 3.1 概述\r\n\r\n![image-20210717084954382](cloudDisk/markdown/Java笔记.assets\\image-20210717084954382.png)\r\n\r\n![image-20210717085329349](cloudDisk/markdown/Java笔记.assets\\image-20210717085329349.png)\r\n\r\n![image-20210717085721650](cloudDisk/markdown/Java笔记.assets\\image-20210717085721650.png)\r\n\r\n## 3.2 案例\r\n\r\n![image-20210717090902471](cloudDisk/markdown/Java笔记.assets\\image-20210717090902471.png)\r\n\r\n```java\r\npackage test08;\r\n\r\nimport java.util.ArrayList;\r\nimport java.util.Collections;\r\nimport java.util.Comparator;\r\nimport java.util.List;\r\n\r\npublic class DiZhuDemo {\r\n    public static void main(String[] args) {\r\n        List<String> poker = new ArrayList<String>();\r\n        String[] arr1 = {\"♦\", \"♣\", \"♥\", \"♠\"};\r\n        String[] arr2 = {\"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\", \"10\", \"J\", \"Q\", \"K\", \"A\"};\r\n        for (String s :\r\n                arr1) {\r\n            for (String s2 :\r\n                    arr2) {\r\n                poker.add(s + s2);\r\n            }\r\n        }\r\n        poker.add(\"joker\");\r\n        poker.add(\"JOKER\");\r\n        Collections.shuffle(poker);\r\n\r\n        List<String> tonyPoker = new ArrayList<String>();\r\n        List<String> ponyPoker = new ArrayList<String>();\r\n        List<String> zxxPoker = new ArrayList<String>();\r\n        List<String> diZhuPoker = new ArrayList<String>();\r\n\r\n        for (int i = 0; i < poker.size(); i++) {\r\n            String p = poker.get(i);\r\n            if (i < 3) {\r\n                diZhuPoker.add(p);\r\n            } else {\r\n                if (i % 3 == 0) {\r\n                    tonyPoker.add(p);\r\n                } else if (i % 3 == 1) {\r\n                    ponyPoker.add(p);\r\n                } else if (i % 3 == 2) {\r\n                    zxxPoker.add(p);\r\n                }\r\n            }\r\n        }\r\n        displayPoker(\"tony\", tonyPoker);\r\n        displayPoker(\"pony\", ponyPoker);\r\n        displayPoker(\"zxx\", zxxPoker);\r\n        displayPoker(\"地主\", diZhuPoker);\r\n\r\n    }\r\n\r\n    public static void displayPoker(String name, List<String> l) {\r\n        Collections.sort(l, new Comparator<String>() {\r\n            @Override\r\n            public int compare(String o1, String o2) {\r\n                for (int i = 0; i < o1.length(); i++) {\r\n                    int num1 = pokerToInt(o1);\r\n                    int num2 = pokerToInt(o2);\r\n                    int num;\r\n                    num = num1 - num2;\r\n                    return num;\r\n                }\r\n                return 0;\r\n            }\r\n        });\r\n        System.out.print(name + \"的牌是：\");\r\n        for (String s :\r\n                l) {\r\n            System.out.print(s + \"\\t\");\r\n        }\r\n        System.out.println();\r\n    }\r\n\r\n    public static int pokerToInt(String o1){\r\n        int num;\r\n        o1 = o1.replace(\"♦\",\"\").replace(\"♣\",\"\").replace(\"♥\",\"\").replace(\"♠\",\"\");\r\n        if(o1.equals(\"K\")){\r\n            num = 13;\r\n        }\r\n        else if(o1.equals(\"Q\")){\r\n            num = 12;\r\n        }\r\n        else if(o1.equals(\"J\")){\r\n            num = 11;\r\n        }\r\n        else if(o1.equals(\"A\")){\r\n            num = 14;\r\n        }\r\n        else if(o1.equals(\"2\")){\r\n            num = 15;\r\n        }\r\n        else if(o1.equals(\"joker\")){\r\n            num = 16;\r\n        }\r\n        else if (o1.equals(\"JOKER\")){\r\n            num = 17;\r\n        }\r\n        else {\r\n            num = Integer.parseInt(o1);\r\n        }\r\n        return num;\r\n    }\r\n}\r\n```\r\n','2022-06-23 21:58:12','Java 是由 Sun Microsystems 公司于 1995 年 5 月推出的 Java 面向对象程序设计语言和 Java 平台的总称。由 James Gosling和同事们共同研发，并在 1995 年正式推出。\r\n\r\n后来 Sun 公司被 Oracle （甲骨文）公司收购，Java 也随之成为 Oracle 公司的产品。','cloudDisk/markdown/Java笔记.assets\\image-20210716125827165.png','原创','','','\0','Java 基础（七）','2022-06-23 21:58:12',1,100,NULL,0),(176,'','# 一、File\r\n\r\n## 1.1 File类描述和构造方法\r\n\r\n![image-20210717101233577](cloudDisk/markdown/Java笔记.assets\\image-20210717101233577.png)\r\n\r\n![image-20210717101512743](cloudDisk/markdown/Java笔记.assets\\image-20210717101512743.png)\r\n\r\n## 1.2 目录、文件创建方法\r\n\r\n![image-20210717102201252](cloudDisk/markdown/Java笔记.assets\\image-20210717102201252.png)\r\n\r\n## 1.3 File类的判断和获取功能\r\n\r\n![image-20210717102439690](cloudDisk/markdown/Java笔记.assets\\image-20210717102439690.png)\r\n\r\n## 1.4 File类的删除功能\r\n\r\n![image-20210717103743963](cloudDisk/markdown/Java笔记.assets\\image-20210717103743963.png)\r\n\r\n## 1.5 递归\r\n\r\n![image-20210717104359382](cloudDisk/markdown/Java笔记.assets\\image-20210717104359382.png)\r\n\r\n## 案例 - 1\r\n\r\n![image-20210717104431072](cloudDisk/markdown/Java笔记.assets\\image-20210717104431072.png)\r\n\r\n```java\r\npackage test02;\r\n\r\npublic class Demo {\r\n    public static void main(String[] args) {\r\n        System.out.println(jie(20L));\r\n    }\r\n    public static long jie(long n){\r\n        if(n==1){\r\n            return 1;\r\n        }\r\n        return n * jie(n-1);\r\n    }\r\n}\r\n```\r\n\r\n## 案例 - 2![image-20210717105514823](cloudDisk/markdown/Java笔记.assets\\image-20210717105514823.png)\r\n\r\n```java\r\npackage test03;\r\n\r\nimport java.io.File;\r\n\r\npublic class FileDihui {\r\n    public static void main(String[] args) {\r\n        File dir = new File(\"E:\\\\学习\");\r\n        d(dir);\r\n    }\r\n    public static void d(File f){\r\n        File[] files = f.listFiles();\r\n        for (File file :\r\n                files) {\r\n            if (file.isDirectory()){ //是目录。调用递归\r\n                System.out.println(file.getAbsolutePath());\r\n                d(file);\r\n            }\r\n            else { //不是目录。直接打印\r\n                System.out.println(\"\\t\"+file.getAbsolutePath());\r\n            }\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n# 二、字节流\r\n\r\n## 2.1 IO流概述和分类\r\n\r\n![image-20210717111535864](cloudDisk/markdown/Java笔记.assets\\image-20210717111535864.png)\r\n\r\n![image-20210717111649331](cloudDisk/markdown/Java笔记.assets\\image-20210717111649331.png)\r\n\r\n![image-20210717111832457](cloudDisk/markdown/Java笔记.assets\\image-20210717111832457.png)\r\n\r\n## 2.2 字节流写数据\r\n\r\n![image-20210717112640425](cloudDisk/markdown/Java笔记.assets\\image-20210717112640425.png)\r\n\r\n```java\r\npackage test04;\r\n\r\nimport java.io.FileNotFoundException;\r\nimport java.io.FileOutputStream;\r\nimport java.io.IOException;\r\nimport java.io.OutputStream;\r\n\r\npublic class Demo {\r\n    public static void main(String[] args) throws IOException {\r\n        FileOutputStream os = new FileOutputStream(\"a.txt\");\r\n        os.write(97);\r\n        os.write(57);\r\n        os.close();\r\n\r\n    }\r\n}\r\n```\r\n\r\n## 2.3 字节流写数据的3种方式\r\n\r\n![image-20210717113101081](cloudDisk/markdown/Java笔记.assets\\image-20210717113101081.png)\r\n\r\n```java\r\npackage test04;\r\n\r\nimport java.io.FileNotFoundException;\r\nimport java.io.FileOutputStream;\r\nimport java.io.IOException;\r\nimport java.io.OutputStream;\r\n\r\npublic class Demo {\r\n    public static void main(String[] args) throws IOException {\r\n        FileOutputStream os = new FileOutputStream(\"a.txt\");\r\n\r\n        // byte类型\r\n        os.write(97);\r\n        os.write(57);\r\n\r\n        // byte数组类型\r\n        byte[] b = {\'s\',\'a\',\'h\'};\r\n        os.write(b);\r\n\r\n        // 字符串方法转为byte数组类型\r\n        byte[] bytes = \"hello impressive world.\".getBytes();\r\n        os.write(bytes);\r\n        \r\n        byte[] bytes1 = \"i love you, complicated girl\".getBytes();\r\n        os.write(bytes1,0,10); //写入：i love you\r\n\r\n        os.close();\r\n    }\r\n}\r\n```\r\n\r\n## 2.4 字节流写数据的两小问题 - 换行和追加写入\r\n\r\n![image-20210718085945331](cloudDisk/markdown/Java笔记.assets\\image-20210718085945331.png)\r\n\r\n## 2.5 字节流写数据加异常处理\r\n\r\n![image-20210718090156041](cloudDisk/markdown/Java笔记.assets\\image-20210718090156041.png)\r\n\r\n```java\r\npackage test04;\r\n\r\nimport java.io.FileOutputStream;\r\nimport java.io.IOException;\r\n\r\npublic class FileOutputStreamDem01 {\r\n    public static void main(String[] args) {\r\n\r\n        FileOutputStream fos = nulll;\r\n        try{\r\n            fos = new FileOutputStream(\"a.txt\");\r\n            fos.write(\"hello\".getBytes());\r\n        }\r\n        catch (IOException e){\r\n            e.printStackTrace();\r\n        }\r\n        finally {\r\n            if (fos != null){\r\n                try {\r\n                    fos.close();\r\n                } catch (IOException e) {\r\n                    e.printStackTrace();\r\n                }\r\n            }\r\n\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n## 2.6 字节流读数据（一次读一个字节数据）\r\n\r\n![image-20210718091102481](cloudDisk/markdown/Java笔记.assets\\image-20210718091102481.png)\r\n\r\n```java\r\npackage test04;\r\n\r\nimport java.io.FileInputStream;\r\nimport java.io.IOException;\r\n\r\npublic class FileInputStreamDemo02 {\r\n    public static void main(String[] args) throws IOException {\r\n        FileInputStream fis = new FileInputStream(\"a.txt\");\r\n        int r;\r\n        while ((r=fis.read())!=-1){\r\n            System.out.print((char) r);\r\n        }\r\n        fis.close();\r\n    }\r\n}\r\n```\r\n\r\n## 案例\r\n\r\n![image-20210718092710998](cloudDisk/markdown/Java笔记.assets\\image-20210718092710998.png)\r\n\r\n![image-20210718093849397](cloudDisk/markdown/Java笔记.assets\\image-20210718093849397.png)\r\n\r\n## 2.7 读取字节数组\r\n\r\n```java\r\npackage test05;\r\n\r\nimport java.io.FileInputStream;\r\nimport java.io.IOException;\r\nimport java.io.InputStream;\r\nimport java.io.OutputStream;\r\n\r\npublic class Demo {\r\n    public static void main(String[] args) throws IOException {\r\n        FileInputStream fis = new FileInputStream(\"a.txt\");\r\n\r\n        int len;\r\n        byte[] bys = new byte[1024];\r\n        while ((len=fis.read(bys))!=-1){\r\n            System.out.print(new String(bys,0,len));\r\n        }\r\n        fis.close();\r\n    }\r\n}\r\n```\r\n\r\n## 案例 - 复制图片\r\n\r\n![image-20210718095147759](cloudDisk/markdown/Java笔记.assets\\image-20210718095147759.png)\r\n\r\n![image-20210718095349165](cloudDisk/markdown/Java笔记.assets\\image-20210718095349165.png)\r\n\r\n## 2.8 字节缓冲流\r\n\r\n![image-20210718095643609](cloudDisk/markdown/Java笔记.assets\\image-20210718095643609.png)\r\n\r\n```java\r\npackage test05;\r\n\r\nimport java.io.*;\r\n\r\npublic class Demo {\r\n    public static void main(String[] args) throws IOException {\r\n        // 写数据\r\n        BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(\"a.txt\"));\r\n        bos.write(\"hello\\r\\nimpressive\\r\\nworld\\r\\n\".getBytes());\r\n        bos.close();\r\n\r\n        // 读数据\r\n        BufferedInputStream bis = new BufferedInputStream(new FileInputStream((\"a.txt\")));\r\n        \r\n        // 一字节一读\r\n//        int r;\r\n//        while ((r=bis.read())!=-1){\r\n//            System.out.print((char)r);\r\n//        }\r\n        \r\n        // 1024字节一读\r\n        int len;\r\n        byte[] bytes = new byte[1024]; // 一次最多读1024个字节\r\n        while ((len=bis.read(bytes))!=-1){ // len为读到的字节个数\r\n            String s = new String(bytes,0,len); // 字节数组转字符串\r\n            System.out.println(s);\r\n        }\r\n        bis.close();\r\n\r\n    }\r\n}\r\n```\r\n\r\n## 案例 - 复制视频\r\n\r\n### 1. 基本字节流一次读写一个字节\r\n\r\n### 2. 基本字节流一次读写一个字节数组\r\n\r\n### 3. 字节缓冲流一次读写一个字节\r\n\r\n### 4. 字节缓冲流一次读写一个字节数组\r\n\r\n```java\r\npackage test05;\r\n\r\nimport java.io.*;\r\n\r\npublic class Demo {\r\n    static String inputPath = \"E:\\\\学习\\\\Java\\\\272\\\\old\\\\哪吒.mp4\";\r\n    static String outputPath = \"E:\\\\学习\\\\Java\\\\272\\\\new\\\\哪吒.mp4\";\r\n    public static void main(String[] args) throws IOException {\r\n\r\n\r\n        long start = System.currentTimeMillis();\r\n\r\n//        method1(); // >30min\r\n//        method2(); // 耗时：37797毫秒\r\n//        method3(); // 耗时：27769毫秒\r\n//        method4(); // 耗时：12749毫秒\r\n\r\n        long end = System.currentTimeMillis();\r\n        System.out.println(\"耗时：\"+(end-start)+\"毫秒\");\r\n    }\r\n    public static void method1() throws IOException {\r\n        FileInputStream fis = new FileInputStream(inputPath); //读\r\n        FileOutputStream fos = new FileOutputStream(outputPath);//写\r\n        int by;\r\n        while ((by=fis.read()) != -1){\r\n            fos.write(by);\r\n        }\r\n        fis.close();\r\n        fos.close();\r\n    }\r\n    public static void method2() throws IOException {\r\n        FileInputStream fis = new FileInputStream(inputPath); //读\r\n        FileOutputStream fos = new FileOutputStream(outputPath);//写\r\n        int len;\r\n        byte[] bytes = new byte[1024];\r\n        while ((len=fis.read(bytes)) != -1){\r\n            fos.write(bytes,0,len);\r\n        }\r\n        fis.close();\r\n        fos.close();\r\n    }\r\n    public static void method3() throws IOException {\r\n        BufferedInputStream bis = new BufferedInputStream(new FileInputStream(inputPath)); //读\r\n        BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(outputPath)); //写\r\n\r\n        int by;\r\n        while ((by=bis.read()) != -1){\r\n            bos.write(by);\r\n        }\r\n\r\n        bis.close();\r\n        bos.close();\r\n    }\r\n    public static void method4() throws IOException {\r\n        BufferedInputStream bis = new BufferedInputStream(new FileInputStream(inputPath)); //读\r\n        BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(outputPath)); //写\r\n\r\n        int len;\r\n        byte[] bytes = new byte[1024];\r\n        while ((len=bis.read(bytes)) != -1){\r\n            bos.write(bytes,0,len);\r\n        }\r\n\r\n        bis.close();\r\n        bos.close();\r\n    }\r\n}\r\n```\r\n\r\n# 三、字符流\r\n\r\n## 3.1 为什么会出现字符流\r\n\r\n<img src=\"cloudDisk/markdown/Java笔记.assets\\image-20210718105155103.png\" alt=\"image-20210718105155103\" style=\"zoom:150%;\" />\r\n\r\n## 3.2 编码表\r\n\r\n![image-20210718105459132](cloudDisk/markdown/Java笔记.assets\\image-20210718105459132.png)\r\n\r\n![image-20210718105606402](cloudDisk/markdown/Java笔记.assets\\image-20210718105606402.png)\r\n\r\n![image-20210718105730957](cloudDisk/markdown/Java笔记.assets\\image-20210718105730957.png)\r\n\r\n## ![image-20210718105839701](cloudDisk/markdown/Java笔记.assets\\image-20210718105839701.png)\r\n\r\n\r\n\r\n![image-20210718110225454](cloudDisk/markdown/Java笔记.assets\\image-20210718110225454.png)\r\n\r\n## 3.4 字符流中的编码、解码问题\r\n\r\n![image-20210718111805477](cloudDisk/markdown/Java笔记.assets\\image-20210718111805477.png)\r\n\r\n```java\r\npackage test06;\r\n\r\nimport java.io.*;\r\n\r\npublic class Demo {\r\n    public static void main(String[] args) throws IOException {\r\n        // 创建对象，默认编码\r\n//        OutputStreamWriter osw = new OutputStreamWriter(new FileOutputStream(\"a.txt\"));\r\n        // 创建对象，指定编码\r\n        OutputStreamWriter osw = new OutputStreamWriter(new FileOutputStream(\"a.txt\"),\"UTF-8\");\r\n        osw.write(\"hello impressive world!!!\");\r\n        osw.close();\r\n\r\n        // 创建对象,默认编码\r\n//        InputStreamReader isr = new InputStreamReader(new FileInputStream(\"a.txt\"));\r\n        // 创建对象，指定编码\r\n        InputStreamReader isr = new InputStreamReader(new FileInputStream(\"a.txt\"),\"UTF-8\");\r\n        // 一次读取一个字符数据\r\n        int ch;\r\n        while ((ch=isr.read())!=-1){\r\n            System.out.print((char)ch);\r\n        }\r\n        isr.close();\r\n    }\r\n}\r\n```\r\n\r\n## 3.5 字符流写数据的5种方式\r\n\r\n![image-20210718111844934](cloudDisk/markdown/Java笔记.assets\\image-20210718111844934.png)\r\n\r\n![image-20210718112613668](cloudDisk/markdown/Java笔记.assets\\image-20210718112613668.png)\r\n\r\n![image-20210718112625787](cloudDisk/markdown/Java笔记.assets\\image-20210718112625787.png)\r\n\r\n## 3.6 字符流读数据的2种方式\r\n\r\n![image-20210718112712312](cloudDisk/markdown/Java笔记.assets\\image-20210718112712312.png)\r\n\r\n```java\r\npackage test07;\r\n\r\nimport java.io.FileInputStream;\r\nimport java.io.IOException;\r\nimport java.io.InputStreamReader;\r\nimport java.io.InvalidObjectException;\r\n\r\npublic class Demo {\r\n    public static void main(String[] args) throws IOException {\r\n        InputStreamReader isr = new InputStreamReader(new FileInputStream(\"src\\\\test07\\\\Demo.java\"));\r\n        int len;\r\n        char[] chs = new char[1024]; // 最对读1024个字符\r\n        while ((len=isr.read(chs))!=-1){ // isr.read(chs)返回成功读了的字符个数，没读到返回-1\r\n            String s = new String(chs,0,len); // 构造方法，字符数组转字符串\r\n            System.out.print(s);\r\n        }\r\n\r\n    }\r\n}\r\n```\r\n\r\n### 案例\r\n\r\n![image-20210719092922813](cloudDisk/markdown/Java笔记.assets\\image-20210719092922813.png)\r\n\r\n```java\r\npackage test07;\r\n\r\nimport java.io.*;\r\n\r\npublic class Demo {\r\n    public static void main(String[] args) throws IOException {\r\n        InputStreamReader isr = new InputStreamReader(new FileInputStream(\"a.txt\"));\r\n        OutputStreamWriter osw = new OutputStreamWriter(new FileOutputStream(\"src\\\\test07\\\\a.txt\"));\r\n        int len;\r\n        char[] chars = new char[1024];\r\n        while ((len=isr.read(chars))!=-1){\r\n            osw.write(chars,0,len);\r\n        }\r\n        isr.close();\r\n        osw.close();\r\n    }\r\n}\r\n```\r\n\r\n### 案例 - 改进版 (FileReader 简化了创建InputStreamReader步骤)\r\n\r\n### （但是没法转码）\r\n\r\n![image-20210719094245231](cloudDisk/markdown/Java笔记.assets\\image-20210719094245231.png)\r\n\r\n![image-20210719094312608](cloudDisk/markdown/Java笔记.assets\\image-20210719094312608.png)\r\n\r\n```java\r\npackage test07;\r\n\r\nimport java.io.*;\r\n\r\npublic class Demo {\r\n    public static void main(String[] args) throws IOException {\r\n        FileReader isr = new FileReader(\"a.txt\");\r\n        FileWriter osw = new FileWriter(\"src\\\\test07\\\\a.txt\");\r\n        int len;\r\n        char[] chars = new char[1024];\r\n        while ((len=isr.read(chars))!=-1){\r\n            osw.write(chars,0,len);\r\n        }\r\n        isr.close();\r\n        osw.close();\r\n    }\r\n}\r\n```\r\n\r\n## 3.7 字符缓冲流\r\n\r\n![image-20210719094921675](cloudDisk/markdown/Java笔记.assets\\image-20210719094921675.png)\r\n\r\n![image-20210719095332250](cloudDisk/markdown/Java笔记.assets\\image-20210719095332250.png)\r\n\r\n### 案例\r\n\r\n![image-20210719095803755](cloudDisk/markdown/Java笔记.assets\\image-20210719095803755.png)\r\n\r\n```java\r\npackage test07;\r\n\r\nimport java.io.*;\r\n\r\npublic class Demo {\r\n    public static void main(String[] args) throws IOException {\r\n        BufferedReader br = new BufferedReader(new FileReader(\"a.txt\"));\r\n        BufferedWriter bw = new BufferedWriter(new FileWriter(\"src\\\\test07\\\\a.txt\"));\r\n        int len;\r\n        char[] chars = new char[1024];\r\n        while ((len=br.read(chars))!=-1){\r\n            bw.write(chars,0,len);\r\n        }\r\n        br.close();\r\n        bw.close();\r\n    }\r\n}\r\n```\r\n\r\n## 3.8 字符缓冲流的特有功能\r\n\r\n![image-20210719100344516](cloudDisk/markdown/Java笔记.assets\\image-20210719100344516.png)\r\n\r\n```java\r\npackage test07;\r\n\r\nimport java.io.*;\r\n\r\npublic class Demo {\r\n    public static void main(String[] args) throws IOException {\r\n\r\n        BufferedWriter bw = new BufferedWriter(new FileWriter(\"a.txt\"));\r\n\r\n        for (int i = 0; i < 10; i++) {\r\n            bw.write(\"hello world\" + i);\r\n            bw.newLine(); // 换行，由于Linux系统换行符为\\n，windows为\\r\\n，mac为\\r\r\n            bw.flush(); // 刷新\r\n        }\r\n        bw.close();\r\n\r\n        \r\n        // 读行标准格式\r\n        BufferedReader br = new BufferedReader(new FileReader(\"a.txt\"));\r\n        String line;\r\n        while ((line = br.readLine())!=null){\r\n            System.out.println(line);\r\n        }\r\n\r\n        br.close();\r\n\r\n    }\r\n}\r\n```\r\n\r\n## 3.9 IO流小结\r\n\r\n![image-20210719101409536](cloudDisk/markdown/Java笔记.assets\\image-20210719101409536.png)\r\n\r\n![image-20210719101602048](cloudDisk/markdown/Java笔记.assets\\image-20210719101602048.png)\r\n\r\n#### InputStreamReader/OutputStreamReader 太长写起来麻烦，所以用FileReader/FileWriter，但是需要指定编码，还得用InputStreamReader/OutputStreamReader；\r\n\r\n![Java](cloudDisk/markdown/Java笔记.assets\\Java.png)\r\n\r\n## 案例\r\n\r\n![image-20210719102652886](cloudDisk/markdown/Java笔记.assets\\image-20210719102652886.png)\r\n\r\n![image-20210719102940360](cloudDisk/markdown/Java笔记.assets\\image-20210719102940360.png)\r\n\r\n## 案例 \r\n\r\n![image-20210719103120755](cloudDisk/markdown/Java笔记.assets\\image-20210719103120755.png)\r\n\r\n```java\r\npackage test07;\r\n\r\nimport java.io.*;\r\nimport java.util.ArrayList;\r\n\r\npublic class Demo {\r\n    public static void main(String[] args) throws IOException {\r\n        ArrayList<Student> students = new ArrayList<Student>();\r\n        Student s1 = new Student(\"2017251001\", \"linjiang\", 20, \"suzhou\");\r\n        Student s2 = new Student(\"2017251002\", \"mazhiming\", 20, \"suzhou\");\r\n        Student s3 = new Student(\"2017251003\", \"zhudaizi\", 20, \"suzhou\");\r\n        students.add(s1);\r\n        students.add(s2);\r\n        students.add(s3);\r\n\r\n        BufferedWriter bw = new BufferedWriter(new FileWriter(\"src\\\\test07\\\\students.txt\"));\r\n        for (Student s :\r\n                students) {\r\n            bw.write(s.toString());\r\n            bw.newLine();\r\n        }\r\n        bw.close();\r\n\r\n    }\r\n}\r\n```\r\n\r\n## 案例 - 集合到文件（数据排序）\r\n\r\n![image-20210719114423616](cloudDisk/markdown/Java笔记.assets\\image-20210719114423616.png)\r\n\r\n```java\r\npackage test07;\r\n\r\nimport java.io.*;\r\nimport java.util.ArrayList;\r\nimport java.util.Comparator;\r\nimport java.util.Scanner;\r\nimport java.util.TreeSet;\r\n\r\npublic class Demo {\r\n    public static void main(String[] args) throws IOException {\r\n        TreeSet<Student> ts = new TreeSet<Student>(new Comparator<Student>() {\r\n            @Override\r\n            public int compare(Student o1, Student o2) {\r\n                int num = o2.getSumPoint() - o1.getSumPoint();\r\n                num = num == 0 ? o1.getName().compareTo(o2.getName()) : num;\r\n                return num;\r\n            }\r\n        });\r\n\r\n        for (int i = 0; i < 5; i++) {\r\n            Scanner scanner = new Scanner(System.in);\r\n            Student s = new Student();\r\n            System.out.print(\"第\" + (i + 1) + \"个学生的姓名：\");\r\n            String name = scanner.nextLine();\r\n            System.out.print(\"第\" + (i + 1) + \"个学生的语文成绩：\");\r\n            int chinesePoint = scanner.nextInt();\r\n            System.out.print(\"第\" + (i + 1) + \"个学生的数学成绩：\");\r\n            int mathPoint = scanner.nextInt();\r\n            System.out.print(\"第\" + (i + 1) + \"个学生的英语成绩：\");\r\n            int englishPoint = scanner.nextInt();\r\n            s.setName(name);\r\n            s.setChinesePoint(chinesePoint);\r\n            s.setMathPoint(mathPoint);\r\n            s.setEnglishPoint(englishPoint);\r\n            ts.add(s);\r\n        }\r\n\r\n        BufferedWriter bw = new BufferedWriter(new FileWriter(\"src\\\\test07\\\\students.txt\"));\r\n        bw.write(\"姓名\\t\\t语文\\t\\t数学\\t\\t英语\");\r\n        bw.newLine();\r\n        for (Student s :\r\n                ts) {\r\n            bw.write(s.getName() + \"\\t\\t\" + s.getChinesePoint() + \"\\t\\t\" + s.getMathPoint() + \"\\t\\t\" + s.getEnglishPoint());\r\n            bw.newLine();\r\n            bw.flush();\r\n        }\r\n        bw.close();\r\n\r\n    }\r\n}\r\n```\r\n\r\n```xml\r\n姓名		语文		数学		英语\r\nzxx		99		89		88\r\nTony	50		60		40\r\nposh	55     	2		5\r\npony	10    	20     	30\r\nlld		1		1		1\r\n```\r\n\r\n## 案例 - 单级文件夹\r\n\r\n![image-20210719125222447](cloudDisk/markdown/Java笔记.assets\\image-20210719125222447.png)\r\n\r\n```java\r\npackage test08;\r\n\r\nimport java.io.*;\r\n\r\npublic class CopyFolderDemo {\r\n    public static void main(String[] args) throws IOException {\r\n        //创建数据源目录File对象，路径 E:\\学习\\Java\\272itcast\r\n        File srcFolder = new File(\"E:\\\\学习\\\\Java\\\\272\\\\itcast\");\r\n\r\n        //获取数据源目录File对象名称（itcast）\r\n        String srcFolderName = srcFolder.getName();\r\n\r\n        //创建目的地File对象，路径名是src/test08\r\n        File destFolder = new File(\"src/test08\", srcFolderName);\r\n\r\n        // 判断目的地的File是否存在，不存在就创建\r\n        if (!destFolder.exists()) {\r\n            destFolder.mkdir();\r\n        }\r\n\r\n        // 获取数据源目录下所有文件的File数组\r\n        File[] listFiles = srcFolder.listFiles();\r\n        for (File srcFile :\r\n                listFiles) {\r\n            // 获取源文件的名称\r\n            String srcFileName = srcFile.getName();\r\n\r\n            // 拼接目的地文件File对象\r\n            File destFile = new File(destFolder, srcFileName);\r\n\r\n            copyFile(srcFile, destFile);\r\n        }\r\n    }\r\n\r\n    private static void copyFile(File srcFile, File destFile) throws IOException {\r\n        BufferedInputStream bis = new BufferedInputStream(new FileInputStream(srcFile));\r\n        BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(destFile));\r\n        int len;\r\n        byte[] bytes = new byte[1024];\r\n        while ((len = bis.read(bytes)) != -1) {\r\n            bos.write(bytes,0,len);\r\n        }\r\n        bis.close();\r\n        bos.close();\r\n    }\r\n}\r\n```\r\n\r\n## 案例 - 多级文件夹\r\n\r\n![image-20210719125347880](cloudDisk/markdown/Java笔记.assets\\image-20210719125347880.png)\r\n\r\n```java\r\npackage test08;\r\n\r\nimport java.io.*;\r\nimport java.lang.reflect.Field;\r\n\r\npublic class CopyFolderDemo {\r\n    static String srcFolderName = \"E:\\\\学习\\\\Java\\\\272\\\\itcast\";\r\n    static String destFolderName = \"E:\\\\学习\\\\Java\\\\272\\\\src\\\\test08\";\r\n    public static void main(String[] args) throws IOException {\r\n        //创建数据源目录File对象，路径 E:\\学习\\Java\\272\\itcast\r\n        File srcFolder = new File(srcFolderName);\r\n        File destFolder = new File(destFolderName);\r\n        copy(srcFolder,destFolder);\r\n\r\n    }\r\n                            // 传入源文件夹/文件，目标文件夹/文件\r\n    private static void copy(File srcFolder,File destFolder) throws IOException{\r\n        if(srcFolder.isDirectory()){ // 如果是目录则执行下面\r\n\r\n            //由源文件夹的最后一个名称，构建目标文件夹，存在就创建，不存在就跳过\r\n            String folderName = srcFolder.getName();\r\n            File destNewfolder = new File(destFolder,folderName);\r\n            if(!destNewfolder.exists()){\r\n                destNewfolder.mkdir();\r\n            }\r\n\r\n            // System.out.println(destNewfolder.getAbsolutePath());\r\n            File[] files = srcFolder.listFiles();\r\n\r\n            // 递归遍历所有的文件夹即文件\r\n            for (File file :\r\n                    files) {\r\n                copy(file,destNewfolder);\r\n            }\r\n        }\r\n        else { // 如果是文件执行下面\r\n            // 由源文件的的名称，构建目标文件\r\n            String fileName = srcFolder.getName();\r\n            File destFile = new File(destFolder, fileName);\r\n\r\n            // System.out.println(\"\\t\"+destFile.getAbsolutePath());\r\n            copyFile(srcFolder,destFile); // 复制文件\r\n        }\r\n\r\n    }\r\n\r\n    private static void copyFile(File srcFile,File destFile) throws IOException {\r\n        BufferedInputStream bis = new BufferedInputStream(new FileInputStream(srcFile));\r\n        BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(destFile));\r\n        int len;\r\n        byte[] bytes = new byte[1024];\r\n        while ((len = bis.read(bytes)) != -1) {\r\n            bos.write(bytes,0,len);\r\n        }\r\n        bis.close();\r\n        bos.close();\r\n    }\r\n}\r\n```\r\n\r\n## 3.10 复制文件的异常处理\r\n\r\n![image-20210720091936231](cloudDisk/markdown/Java笔记.assets\\image-20210720091936231.png)\r\n\r\n```java\r\n// throws ...\r\npublic static void method1() throws IOException {\r\n    FileReader fr = new FileReader(\"f.txt\");\r\n    FileWriter fw = new FileWriter(\"f.txt\");\r\n    char[] chs = new char[1024];\r\n    int len;\r\n    while ((len = fr.read()) != -1) {\r\n        fw.write(chs, 0, len);\r\n    }\r\n    fw.close();\r\n    fr.close();\r\n}\r\n\r\n// try...catch...finally\r\npublic static void method2() {\r\n    FileReader fr = null;\r\n    FileWriter fw = null;\r\n    try {\r\n        fr = new FileReader(\"f.txt\");\r\n        fw = new FileWriter(\"f.txt\");\r\n        char[] chs = new char[1024];\r\n        int len;\r\n        while ((len = fr.read()) != -1) {\r\n            fw.write(chs, 0, len);\r\n        }\r\n    } catch (IOException e) {\r\n        e.printStackTrace();\r\n    } finally {\r\n        try {\r\n            fw.close();\r\n            fr.close();\r\n        } catch (IOException e) {\r\n            e.printStackTrace();\r\n        }\r\n    }\r\n}\r\n\r\n// IDK7改进方案\r\npublic static void method3() {\r\n    try (FileReader fr = new FileReader(\"f.txt\");\r\n         FileWriter fw = new FileWriter(\"f.txt\");) {\r\n        char[] chs = new char[1024];\r\n        int len;\r\n        while ((len = fr.read()) != -1) {\r\n            fw.write(chs, 0, len);\r\n        }\r\n    } catch (IOException e) {\r\n        e.printStackTrace();\r\n    }\r\n}\r\n\r\n// IDK9改进方案\r\npublic static void method4() throws IOException {\r\n    FileReader fr = new FileReader(\"f.txt\");\r\n    FileWriter fw = new FileWriter(\"f.txt\");\r\n    try (fr;fw) {\r\n        char[] chs = new char[1024];\r\n        int len;\r\n        while ((len = fr.read()) != -1) {\r\n            fw.write(chs, 0, len);\r\n        }\r\n    } catch (IOException e) {\r\n        e.printStackTrace();\r\n    }\r\n}\r\n```\r\n\r\n# 四、特殊操作流\r\n\r\n## 4.1 标准输入输出流\r\n\r\n![image-20210720093409250](cloudDisk/markdown/Java笔记.assets\\image-20210720093409250.png)\r\n\r\n![image-20210720094122915](cloudDisk/markdown/Java笔记.assets\\image-20210720094122915.png)\r\n\r\n![image-20210720094207947](cloudDisk/markdown/Java笔记.assets\\image-20210720094207947.png)\r\n\r\n![image-20210720094625856](cloudDisk/markdown/Java笔记.assets\\image-20210720094625856.png)\r\n\r\n## 4.2 打印流\r\n\r\n![image-20210720095234259](cloudDisk/markdown/Java笔记.assets\\image-20210720095234259.png)\r\n\r\n```java\r\n    public static void main(String[] args) throws IOException {\r\n        PrintStream ps = new PrintStream(\"a.txt\");\r\n\r\n//        写数据\r\n//        字节输出流有的方法\r\n        ps.write(97);;\r\n\r\n//        使用特有方法写数据\r\n        ps.println(\"98\");\r\n        ps.print(99);\r\n\r\n    }\r\n```\r\n\r\n### 字符打印流\r\n\r\n![image-20210720095759457](cloudDisk/markdown/Java笔记.assets\\image-20210720095759457.png)\r\n\r\n```java\r\n    public static void main(String[] args) throws IOException {\r\n//        PrintWriter pw = new PrintWriter(\"a.txt\");\r\n        /*\r\n        pw.write(\"hello\");\r\n        pw.write(\"\\r\\n\");\r\n        pw.flush();\r\n        pw.write(\"world\");\r\n        pw.write(\"\\r\\n\");\r\n        pw.flush();\r\n         */\r\n\r\n//        pw.println(\"hello\");\r\n//        pw.println(\"world\");\r\n//        pw.flush();\r\n\r\n        // 自动刷新\r\n        PrintWriter pw = new PrintWriter(new FileWriter(\"a.txt\"), true);\r\n        pw.println(\"hello\");\r\n        pw.println(\"world\");\r\n\r\n        pw.close();\r\n    }\r\n```\r\n\r\n### 案例\r\n\r\n![image-20210720102014685](cloudDisk/markdown/Java笔记.assets\\image-20210720102014685.png)\r\n\r\n\r\n\r\n```java\r\npublic static void main(String[] args) throws IOException {\r\n    BufferedReader br = new BufferedReader(new FileReader(\"a.txt\"));\r\n    PrintWriter pw = new PrintWriter(new FileWriter(\"aa\\\\a.txt\"));\r\n    String line;\r\n    while ((line=br.readLine())!=null){\r\n        pw.println(line);\r\n    }\r\n    pw.close();\r\n    br.close();\r\n}\r\n```\r\n\r\n## 4.3 对象序列化流\r\n\r\n### 序列化\r\n\r\n![image-20210720102317079](cloudDisk/markdown/Java笔记.assets\\image-20210720102317079.png)\r\n\r\n![image-20210720102848346](cloudDisk/markdown/Java笔记.assets\\image-20210720102848346.png)\r\n\r\n```java\r\npublic static void main(String[] args) throws IOException {\r\n    ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(\"a.txt\"));\r\n    Student s = new Student(\"tony\", 20);\r\n    oos.writeObject(s);\r\n    oos.close();\r\n}\r\n```\r\n\r\n### 反序列化\r\n\r\n![image-20210720103242649](cloudDisk/markdown/Java笔记.assets\\image-20210720103242649.png)\r\n\r\n```java\r\npublic static void main(String[] args) throws IOException {\r\n    ObjectInputStream ois = new ObjectInputStream(new FileInputStream(\"a.txt\"));\r\n    Object obj = ois.readObject();\r\n    Student s = (Student) obj;\r\n    System.out.println(s.getName()+\",\"+s.getAge());\r\n    ois.close();\r\n}\r\n```\r\n\r\n### 序列化遇到的问题\r\n\r\n![image-20210720104629060](cloudDisk/markdown/Java笔记.assets\\image-20210720104629060.png)\r\n\r\n## 4.4 Properties\r\n\r\n![image-20210720105312169](cloudDisk/markdown/Java笔记.assets\\image-20210720105312169.png)\r\n\r\n```java\r\npublic static void main(String[] args) throws IOException {\r\n    // 创建集合对象\r\n    Properties prop = new Properties();\r\n\r\n    //存储元素\r\n    prop.put(\"1\",\"p\");\r\n    prop.put(\"2\",\"o\");\r\n    prop.put(\"3\",\"n\");\r\n\r\n    //遍历集合\r\n    Set<Object> keySet = prop.keySet();\r\n    for (Object key :\r\n            keySet) {\r\n        Object value = prop.get(key);\r\n        System.out.println(key+\"，\"+value);\r\n    }\r\n}\r\n```\r\n\r\n![image-20210720105342995](cloudDisk/markdown/Java笔记.assets\\image-20210720105342995.png)\r\n\r\n```java\r\n    public static void main(String[] args) throws IOException {\r\n        // 创建集合对象\r\n        Properties prop = new Properties();\r\n\r\n        prop.setProperty(\"1\",\"p\");\r\n        prop.setProperty(\"2\",\"d\");\r\n        prop.setProperty(\"3\",\"c\");\r\n        /*\r\n        Object setProperty(String key, String value) {\r\n            return put(key, value);\r\n        }\r\n        Object put(Object key, Object value) {\r\n            return map.put(key, value);\r\n        }\r\n         */\r\n        // 指定键搜索\r\n//        prop.getProperty(\"1\");\r\n\r\n        Set<String> names = prop.stringPropertyNames();\r\n        for (String key :\r\n                names) {\r\n            String value = prop.getProperty(key);\r\n            System.out.println(key+\"，\"+value);\r\n        }\r\n    }\r\n```\r\n\r\n### Properties和IO流结合的方法：\r\n\r\n![image-20210720110329284](cloudDisk/markdown/Java笔记.assets\\image-20210720110329284.png)\r\n\r\n```java\r\n    public static void main(String[] args) throws IOException {\r\n//        mystore();\r\n        myload();\r\n    }\r\n\r\n    private static void mystore() throws IOException{\r\n        Properties prop = new Properties();\r\n        prop.setProperty(\"1\",\"p\");\r\n        prop.setProperty(\"2\",\"d\");\r\n        prop.setProperty(\"3\",\"c\");\r\n        FileWriter fw = new FileWriter(\"a.txt\");\r\n        prop.store(fw,null);\r\n        fw.close();\r\n    }\r\n\r\n    private static void myload() throws IOException{\r\n        Properties prop = new Properties();\r\n        FileReader fr = new FileReader(\"a.txt\");\r\n        prop.load(fr);\r\n        Set<String> names = prop.stringPropertyNames();\r\n        for (String key:\r\n             names) {\r\n            String value = prop.getProperty(key);\r\n            System.out.println(key + \",\" + value);\r\n        }\r\n        fr.close();\r\n    }\r\n```','2022-06-23 21:59:42','Java 是由 Sun Microsystems 公司于 1995 年 5 月推出的 Java 面向对象程序设计语言和 Java 平台的总称。由 James Gosling和同事们共同研发，并在 1995 年正式推出。\r\n\r\n后来 Sun 公司被 Oracle （甲骨文）公司收购，Java 也随之成为 Oracle 公司的产品。','cloudDisk/markdown/Java笔记.assets\\image-20210717102439690.png','原创','','','\0','Java 基础（八）','2022-06-23 21:59:42',1,100,NULL,0),(177,'','# 一、实现多线程\r\n\r\n## 1.1 进程\r\n\r\n![image-20210721085413855](cloudDisk/markdown/Java笔记.assets\\image-20210721085413855.png)S\r\n\r\n## 1.2 线程\r\n\r\n![image-20210721085428442](cloudDisk/markdown/Java笔记.assets\\image-20210721085428442.png)\r\n\r\n## 1.3 多线程的实现方式\r\n\r\n![image-20210721085610555](cloudDisk/markdown/Java笔记.assets\\image-20210721085610555.png)\r\n\r\n![image-20210721090036593](cloudDisk/markdown/Java笔记.assets\\image-20210721090036593.png)\r\n\r\n## 1.4 设置和获取线程名称\r\n\r\n![image-20210721093514620](cloudDisk/markdown/Java笔记.assets\\image-20210721093514620.png)\r\n\r\n```java\r\npackage test01;\r\n\r\npublic class MyThread extends Thread{\r\n    public MyThread(){}\r\n    public MyThread(String name){\r\n        super(name);\r\n    }\r\n    @Override\r\n    public void run() {\r\n        for (int i = 0; i < 100; i++) {\r\n            System.out.println(getName() + i);\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n```java\r\npackage test01;\r\n\r\npublic class ThreadDemo {\r\n    public static void main(String[] args) {\r\n//        MyThread my1 = new MyThread();\r\n//        MyThread my2 = new MyThread();\r\n//\r\n//        // public final void setName(String name)\r\n//        my1.setName(\"高铁\");\r\n//        my2.setName(\"飞机\");\r\n\r\n        //Thread(String name)\r\n        MyThread my1 = new MyThread(\"高铁\");\r\n        MyThread my2 = new MyThread(\"飞机\");\r\n        my1.start();\r\n        my2.start();\r\n//        static Thread currentThread() 返回对当前正在执行的线程对象的引用。\r\n        System.out.println(Thread.currentThread().getName());\r\n\r\n    }\r\n}\r\n```\r\n\r\n## 1.5 线程调度\r\n\r\n![image-20210721093641950](cloudDisk/markdown/Java笔记.assets\\image-20210721093641950.png)\r\n\r\n![image-20210721094137036](cloudDisk/markdown/Java笔记.assets\\image-20210721094137036.png)\r\n\r\n## 1.6 线程控制\r\n\r\n![image-20210721094257654](cloudDisk/markdown/Java笔记.assets\\image-20210721094257654.png)\r\n\r\n守护线程：非守护线程结束时，守护线程一起结束\r\n\r\n```java\r\npackage test01;\r\n\r\npublic class ThreadDemo {\r\n    public static void main(String[] args) {\r\n        MyThread my1 = new MyThread(\"刘备\");\r\n        MyThread my2 = new MyThread(\"张飞\");\r\n        MyThread my3 = new MyThread(\"关羽\");\r\n\r\n        // 设置my1,my2,my3为守护线程。当执行至此刻的当前线程结束,守护线程强制结束\r\n        my1.setDaemon(true);\r\n        my2.setDaemon(true);\r\n        my3.setDaemon(true);\r\n\r\n        my1.start();\r\n//        try {\r\n//            my1.join(); //等待my1线程结束，才往下走\r\n//        } catch (InterruptedException e) {\r\n//            e.printStackTrace();\r\n//        }\r\n        my2.start();\r\n        my3.start();\r\n\r\n//        将当前的main线程取名为主线程\r\n        Thread.currentThread().setName(\"主线程\");\r\n        for (int i = 0; i < 5; i++) {\r\n            try {\r\n                MyThread.sleep(100); //暂停0.1秒\r\n            } catch (InterruptedException e) {\r\n                e.printStackTrace();\r\n            }\r\n            System.out.println(Thread.currentThread().getName() + i);\r\n        }\r\n\r\n    }\r\n}\r\n```\r\n\r\n## 1.7 线程的生命周期\r\n\r\n![image-20210721104457808](cloudDisk/markdown/Java笔记.assets\\image-20210721104457808.png)\r\n\r\n## 1.8 多线程实现方式\r\n\r\n![image-20210721104605065](cloudDisk/markdown/Java笔记.assets\\image-20210721104605065.png)\r\n\r\n![image-20210721104952417](cloudDisk/markdown/Java笔记.assets\\image-20210721104952417.png)\r\n\r\n![image-20210721104944883](cloudDisk/markdown/Java笔记.assets\\image-20210721104944883.png)\r\n\r\n![image-20210721105111762](cloudDisk/markdown/Java笔记.assets\\image-20210721105111762.png)\r\n\r\n## 案例 - 卖票\r\n\r\n![image-20210721105420738](cloudDisk/markdown/Java笔记.assets\\image-20210721105420738.png)\r\n\r\n\r\n\r\n```java\r\npackage test02;\r\n\r\npublic class SellTicket implements Runnable {\r\n    private int tickets = 100;\r\n\r\n    @Override\r\n    public void run() {\r\n        while (true) {\r\n            try {\r\n                Thread.sleep(100);\r\n            } catch (InterruptedException e) {\r\n                e.printStackTrace();\r\n            }\r\n            if (tickets > 0) {\r\n                System.out.println(Thread.currentThread().getName() + \"正在出售第\" + tickets +\r\n                        \"张票\");\r\n                tickets--;\r\n            }\r\n        }\r\n\r\n    }\r\n}\r\n```\r\n\r\n```java\r\npackage test02;\r\n\r\npublic class SellTicketDemo {\r\n    public static void main(String[] args) {\r\n        SellTicket st = new SellTicket();\r\n        Thread t1 = new Thread(st, \"窗口1\");\r\n        Thread t2 = new Thread(st, \"窗口2\");\r\n        Thread t3 = new Thread(st, \"窗口3\");\r\n        t1.start();\r\n        t2.start();\r\n        t3.start();\r\n    }\r\n}\r\n```\r\n\r\n# 二、线程同步\r\n\r\n## 2.1 卖票案例数据安全问题\r\n\r\n![image-20210721115957567](cloudDisk/markdown/Java笔记.assets\\image-20210721115957567.png)\r\n\r\n## 2.2 买票案例数据安全问题的解决\r\n\r\n![image-20210721121756991](cloudDisk/markdown/Java笔记.assets\\image-20210721121756991.png)\r\n\r\n## 2.3 同步代码块 - 锁上代码，每时每刻只有一个线程执行\r\n\r\n![image-20210721121831814](cloudDisk/markdown/Java笔记.assets\\image-20210721121831814.png)\r\n\r\n![image-20210721122442380](cloudDisk/markdown/Java笔记.assets\\image-20210721122442380.png)\r\n\r\n```java\r\npackage test02;\r\n\r\npublic class SellTicket implements Runnable {\r\n    private int tickets = 100;\r\n    private Object obj = new Object();\r\n    @Override\r\n    public void run() {\r\n        int t = 0;\r\n        while (true) {\r\n            // tickets = 100;\r\n            // t1,t2,t3\r\n            // 假设t1抢到CPU的执行权\r\n            synchronized (obj){\r\n                // t1进来后，就把这段代码锁起来\r\n                try {\r\n                    Thread.sleep(100);\r\n                    // t1休息100毫秒，在这期间t2抢到这块代码执行权，但t2只能在代码块前等待\r\n                } catch (InterruptedException e) {\r\n                    e.printStackTrace();\r\n                }\r\n                if (tickets > 0) {\r\n                    System.out.println(Thread.currentThread().getName() + \"正在出售第\" + tickets +\r\n                            \"张票\");\r\n                    tickets++;\r\n                }\r\n            }\r\n            //t1出来了，这段代码的锁释放\r\n        }\r\n\r\n    }\r\n}\r\n```\r\n\r\n## 2.4 同步方法\r\n\r\n![image-20210721123707775](cloudDisk/markdown/Java笔记.assets\\image-20210721123707775.png)\r\n\r\n```java\r\npackage test02;\r\n\r\npublic class SellTicket implements Runnable {\r\n    private int tickets = 100;\r\n    private Object obj = new Object();\r\n    private int x = 0;\r\n\r\n    @Override\r\n    public void run() {\r\n        int t = 0;\r\n        while (true) {\r\n            if (x % 2 == 0) {\r\n                // 下面代码的锁和 a()方法的锁是同步的\r\n                synchronized (this) {\r\n//                ...\r\n                }\r\n                // 下面代码的锁和 b()静态方法的锁是同步的\r\n                synchronized (SellTicket.class) {\r\n                    //                ...\r\n                }\r\n            }\r\n            else{\r\n                a();\r\n                b();\r\n            }\r\n        }\r\n    }\r\n\r\n    // 同步方法的锁对象是：this\r\n    public synchronized void a() {\r\n//        ...\r\n    }\r\n\r\n    // 同步静态方法的锁对象是：.class\r\n    public synchronized void b() {\r\n//        ...\r\n    }\r\n}\r\n```\r\n\r\n## 2.5 线程安全的类\r\n\r\n![image-20210722084015035](cloudDisk/markdown/Java笔记.assets\\image-20210722084015035.png)\r\n\r\n```java\r\npackage test02;\r\n\r\nimport java.util.*;\r\n\r\npublic class SellTicketDemo {\r\n    public static void main(String[] args) {\r\n        StringBuffer sb = new StringBuffer();\r\n        Vector<String> v = new Vector<String>();\r\n        Hashtable<String, String> ht = new Hashtable<String, String>;\r\n        \r\n        // 把ArrayList包装成线程安全类\r\n        List<String> l = Collections.synchronizedList(new ArrayList<String>());\r\n    }\r\n}\r\n```\r\n\r\n## 2.6 Lock锁\r\n\r\n![image-20210722084929622](cloudDisk/markdown/Java笔记.assets\\image-20210722084929622.png)\r\n\r\n```java\r\npackage test02;\r\n\r\nimport java.util.concurrent.locks.Lock;\r\nimport java.util.concurrent.locks.ReentrantLock;\r\n\r\npublic class SellTicket implements Runnable {\r\n    private int tickets = 100;\r\n    private Lock lock = new ReentrantLock();\r\n\r\n    @Override\r\n    public void run() {\r\n        while (true) {\r\n            try{\r\n                lock.lock();\r\n                try {\r\n                    Thread.sleep(100);\r\n                } catch (InterruptedException e) {\r\n                    e.printStackTrace();\r\n                }\r\n                if (tickets > 0) {\r\n                    System.out.println(Thread.currentThread().getName() + \"正在出售第\" + tickets +\r\n                            \"张票\");\r\n                    tickets--;\r\n                }\r\n            } finally {\r\n                lock.unlock();\r\n            }\r\n\r\n        }\r\n\r\n    }\r\n}\r\n```\r\n\r\n# 三、生产者消费者\r\n\r\n## 3.1 生产者消费者模式概述\r\n\r\n![image-20210722085748613](cloudDisk/markdown/Java笔记.assets\\image-20210722085748613.png)\r\n\r\n![image-20210722085933552](cloudDisk/markdown/Java笔记.assets\\image-20210722085933552.png)\r\n\r\n## 3.2 生产者消费者案例\r\n\r\n![image-20210722090105038](cloudDisk/markdown/Java笔记.assets\\image-20210722090105038.png)\r\n\r\nBox\r\n\r\n```java\r\npackage test03;\r\n\r\npublic class Box {\r\n    private int x;\r\n    private boolean empty = true;\r\n    public Box(int x) {\r\n        this.x = x;\r\n    }\r\n\r\n    public synchronized void getMilk(){\r\n        if(empty){\r\n            try {\r\n                wait();\r\n            } catch (InterruptedException e) {\r\n                e.printStackTrace();\r\n            }\r\n        }\r\n        System.out.println(\"取出第\"+x+\"瓶牛奶\");\r\n        empty = true;\r\n        notifyAll();\r\n    }\r\n\r\n    public synchronized void putMilk() {\r\n        if (!empty){\r\n            try {\r\n                wait();\r\n            } catch (InterruptedException e) {\r\n                e.printStackTrace();\r\n            }\r\n        }\r\n        x += 1;\r\n        System.out.println(\"送奶工放入\"+x+\"瓶牛奶\");\r\n        empty = false;\r\n        notifyAll();\r\n    }\r\n}\r\n```\r\n\r\nCustomer\r\n\r\n```java\r\npackage test03;\r\n\r\npublic class Customer implements Runnable{\r\n    private Box box;\r\n\r\n    public Customer(Box box) {\r\n        this.box = box;\r\n    }\r\n\r\n\r\n    @Override\r\n    public void run() {\r\n        while (true){\r\n            box.getMilk();\r\n        }\r\n    }\r\n}\r\n```\r\n\r\nProducer\r\n\r\n```java\r\npackage test03;\r\n\r\npublic class Producer implements Runnable {\r\n    private  Box box;\r\n\r\n    public Producer(Box box) {\r\n        this.box = box;\r\n    }\r\n\r\n    @Override\r\n    public void run() {\r\n        for (int i = 0; i < 30; i++) {\r\n            box.putMilk();\r\n        }\r\n    }\r\n}\r\n```\r\n\r\nBoxDemo\r\n\r\n```java\r\npackage test03;\r\n\r\npublic class Boxdemo {\r\n    public static void main(String[] args) {\r\n        Box box = new Box(0);\r\n        Customer customer = new Customer(box);\r\n        Producer producer = new Producer(box);\r\n        Thread t1 = new Thread(customer);\r\n        Thread t2 = new Thread(producer);\r\n        t1.start();\r\n        t2.start();\r\n    }\r\n}\r\n```','2022-06-23 22:01:01','Java 是由 Sun Microsystems 公司于 1995 年 5 月推出的 Java 面向对象程序设计语言和 Java 平台的总称。由 James Gosling和同事们共同研发，并在 1995 年正式推出。\r\n\r\n后来 Sun 公司被 Oracle （甲骨文）公司收购，Java 也随之成为 Oracle 公司的产品。','cloudDisk/markdown/Java笔记.assets\\image-20210721104457808.png','原创','','','\0','Java 基础（九）','2022-06-23 22:01:01',5,100,NULL,0),(178,'','# 一、网络编程入门\r\n\r\n## 1.1 概述\r\n\r\n![image-20210722094338809](cloudDisk/markdown/Java笔记.assets\\image-20210722094338809.png)\r\n\r\n## 1.2 网络编程的三要素\r\n\r\n![image-20210722094602577](cloudDisk/markdown/Java笔记.assets\\image-20210722094602577.png)\r\n\r\n## 1.3 IP地址\r\n\r\n![image-20210722094829218](cloudDisk/markdown/Java笔记.assets\\image-20210722094829218.png)\r\n\r\n![image-20210722095004982](cloudDisk/markdown/Java笔记.assets\\image-20210722095004982.png)\r\n\r\n## 1.4 InetAddress使用\r\n\r\n![image-20210722095500810](cloudDisk/markdown/Java笔记.assets\\image-20210722095500810.png)\r\n\r\n```java\r\nimport java.net.InetAddress;\r\nimport java.net.UnknownHostException;\r\n\r\npublic class test04 {\r\n    public static void main(String[] args) throws UnknownHostException {\r\n        InetAddress address = InetAddress.getByName(\"192.168.1.105\");\r\n        String hostName = address.getHostName();\r\n        String hostAddress = address.getHostAddress();\r\n        System.out.println(hostAddress);\r\n        System.out.println(hostName);\r\n    }\r\n}\r\n```\r\n\r\n## 1.5 端口\r\n\r\n![image-20210722095948576](cloudDisk/markdown/Java笔记.assets\\image-20210722095948576.png)\r\n\r\n## 1.6 协议\r\n\r\n![image-20210722100100783](cloudDisk/markdown/Java笔记.assets\\image-20210722100100783.png)\r\n\r\n![image-20210722100319778](cloudDisk/markdown/Java笔记.assets\\image-20210722100319778.png)\r\n\r\n# 二、UDP通信程序\r\n\r\n## 2.1 概述\r\n\r\n![image-20210722100451621](cloudDisk/markdown/Java笔记.assets\\image-20210722100451621.png)\r\n\r\n## 2.2 UDP发送数据\r\n\r\n![image-20210722101211566](cloudDisk/markdown/Java笔记.assets\\image-20210722101211566.png)\r\n\r\n```java\r\nimport java.io.IOException;\r\nimport java.net.*;\r\n\r\npublic class test04 {\r\n    public static void main(String[] args) throws IOException {\r\n        // 1\r\n        DatagramSocket ds = new DatagramSocket();\r\n        // 2\r\n        byte[] bytes = \"hello world\".getBytes();\r\n        DatagramPacket dp = new DatagramPacket(bytes, bytes.length, InetAddress.getByName(\"192.168.1.105\"), 10086);\r\n        // 3\r\n        ds.send(dp);\r\n        // 4\r\n        ds.close();\r\n    }\r\n}\r\n```\r\n\r\n## 2.3 UDP接收数据\r\n\r\n![image-20210722102238134](cloudDisk/markdown/Java笔记.assets\\image-20210722102238134.png)\r\n\r\n```java\r\npackage test04;\r\n\r\nimport java.io.IOException;\r\nimport java.net.DatagramPacket;\r\nimport java.net.DatagramSocket;\r\nimport java.net.SocketException;\r\n\r\npublic class ReceiveData {\r\n    public static void main(String[] args) throws IOException {\r\n        // 1\r\n        DatagramSocket ds = new DatagramSocket(10086);\r\n        // 2\r\n        byte[] bytes = new byte[1024];\r\n        DatagramPacket dp = new DatagramPacket(bytes,bytes.length);\r\n        // 3\r\n        ds.receive(dp);\r\n        // 4\r\n        System.out.println(\"接收到的数据是：\"+ new String(dp.getData(),0,dp.getLength()));\r\n        // 5\r\n        ds.close();\r\n    }\r\n}\r\n```\r\n\r\n# 三、TCP通信程序\r\n\r\n## 3.1 TCP通信原理\r\n\r\n![image-20210722104023748](cloudDisk/markdown/Java笔记.assets\\image-20210722104023748.png)\r\n\r\n## 3.2 TCP发送数据\r\n\r\n![image-20210722104503637](cloudDisk/markdown/Java笔记.assets\\image-20210722104503637.png)\r\n\r\n```java\r\npackage test05;\r\n\r\nimport java.io.IOException;\r\nimport java.io.OutputStream;\r\nimport java.net.Socket;\r\n\r\npublic class ClientDemo {\r\n    public static void main(String[] args) throws IOException {\r\n        // 1. 创建Socket对象\r\n        Socket socket = new Socket(\"192.168.1.105\", 12345);\r\n        // 2. 获取输出流\r\n        OutputStream os = socket.getOutputStream();\r\n        // 写数据\r\n        os.write(\"hello, nice to meet you\".getBytes());\r\n        // 3. 释放资源\r\n        socket.close();\r\n\r\n    }\r\n}\r\n```\r\n\r\n## 3.3 TCP接收数据\r\n\r\n![image-20210722105625582](cloudDisk/markdown/Java笔记.assets\\image-20210722105625582.png)\r\n\r\n```java\r\npackage test05;\r\n\r\nimport java.io.IOException;\r\nimport java.io.InputStream;\r\nimport java.net.ServerSocket;\r\nimport java.net.Socket;\r\n\r\npublic class ServeDemo {\r\n    public static void main(String[] args) throws IOException {\r\n        // 1\r\n        ServerSocket ss = new ServerSocket(12345);\r\n        // 2\r\n        Socket socket = ss.accept();\r\n        // 3\r\n        InputStream is = socket.getInputStream();\r\n        // 读数据\r\n        byte[] bytes = new byte[1024];\r\n        int len;\r\n        while ((len = is.read(bytes))!=-1) {\r\n            System.out.println(new String(bytes,0,len));\r\n        }\r\n        // 4\r\n        ss.close();\r\n    }\r\n}\r\n```\r\n\r\n## 3.4 TCP通信程序练习\r\n\r\n### 练习1\r\n\r\n![image-20210722110808833](cloudDisk/markdown/Java笔记.assets\\image-20210722110808833.png)\r\n\r\nClientDemo\r\n\r\n```java\r\npackage test06;\r\n\r\nimport java.io.IOException;\r\nimport java.io.InputStream;\r\nimport java.io.OutputStream;\r\nimport java.net.Socket;\r\n\r\npublic class ClientDemo {\r\n    public static void main(String[] args) throws IOException {\r\n        // 1. 创建Socket对象\r\n        Socket socket = new Socket(\"192.168.1.105\", 12346);\r\n        // 2. 获取输出流, 写数据\r\n        OutputStream os = socket.getOutputStream();\r\n        os.write(\"客户端：hello, nice to meet you, server.\".getBytes());\r\n\r\n        // 接收反馈\r\n        InputStream is = socket.getInputStream();\r\n        byte[] bytes = new byte[1024];\r\n        int len = is.read(bytes);\r\n        System.out.println(\"服务器：\"+new String(bytes, 0, len));\r\n        // 释放资源\r\n        socket.close();\r\n\r\n    }\r\n}\r\n```\r\n\r\nServeDemo.java\r\n\r\n```java\r\npackage test06;\r\n\r\nimport java.io.IOException;\r\nimport java.io.InputStream;\r\nimport java.io.OutputStream;\r\nimport java.net.ServerSocket;\r\nimport java.net.Socket;\r\n\r\npublic class ServeDemo {\r\n    public static void main(String[] args) throws IOException {\r\n        ServerSocket ss = new ServerSocket(12346);\r\n        // 接收数据\r\n        Socket socket = ss.accept();\r\n        InputStream is = socket.getInputStream();\r\n        byte[] bytes = new byte[1024];\r\n        int len = is.read(bytes);\r\n        System.out.println(new String(bytes,0,len));\r\n\r\n        // 给出反馈\r\n        OutputStream os = socket.getOutputStream();\r\n        os.write(\"Received, nice to meet you too\".getBytes());\r\n\r\n        ss.close();\r\n    }\r\n}\r\n```\r\n\r\n### 练习2\r\n\r\n![image-20210723095900313](cloudDisk/markdown/Java笔记.assets\\image-20210723095900313.png)\r\n\r\nClientDemo\r\n\r\n```java\r\npackage test06;\r\n\r\nimport java.io.*;\r\nimport java.net.Socket;\r\n\r\npublic class ClientDemo {\r\n    public static void main(String[] args) throws IOException {\r\n        // 1. 创建Socket对象\r\n        Socket socket = new Socket(\"192.168.1.105\", 12346);\r\n        // 2. 字节流转缓冲字符流\r\n        OutputStream os = socket.getOutputStream();\r\n        OutputStreamWriter osw = new OutputStreamWriter(os);\r\n        BufferedWriter bw = new BufferedWriter(osw);\r\n\r\n        // 等待输入数据\r\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\r\n\r\n        // 写数据\r\n        while (true){\r\n            String line = br.readLine();\r\n            if(line.equals(\"886\"))\r\n                break;\r\n            bw.write(line);\r\n            bw.newLine();\r\n            bw.flush();\r\n        }\r\n\r\n        socket.close();\r\n\r\n    }\r\n}\r\n```\r\n\r\nServeDemo\r\n\r\n```java\r\npackage test06;\r\n\r\nimport java.io.*;\r\nimport java.net.ServerSocket;\r\nimport java.net.Socket;\r\n\r\npublic class ServeDemo {\r\n    public static void main(String[] args) throws IOException {\r\n        ServerSocket ss = new ServerSocket(12346);\r\n        // 接收数据\r\n        Socket socket = ss.accept();\r\n        InputStream is = socket.getInputStream();\r\n        InputStreamReader isr = new InputStreamReader(is);\r\n        BufferedReader br = new BufferedReader(isr);\r\n        String line;\r\n        while (( line= br.readLine())!=null){\r\n            System.out.println(line);\r\n        }\r\n\r\n        ss.close();\r\n    }\r\n}\r\n```\r\n\r\n### 练习3\r\n\r\n![image-20210723102147981](cloudDisk/markdown/Java笔记.assets\\image-20210723102147981.png)\r\n\r\nClientDemo\r\n\r\n```java\r\npackage test06;\r\n\r\nimport java.io.*;\r\nimport java.net.Socket;\r\n\r\npublic class ClientDemo {\r\n    public static void main(String[] args) throws IOException {\r\n        // 1. 创建Socket对象\r\n        Socket socket = new Socket(\"192.168.1.105\", 12346);\r\n\r\n        // 读取数据\r\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\r\n\r\n        // 发送数据\r\n        BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(socket.getOutputStream()));\r\n        while (true){\r\n            String line = br.readLine();\r\n            if(line.equals(\"886\"))\r\n                break;\r\n            bw.write(line);\r\n            bw.newLine();\r\n            bw.flush();\r\n        }\r\n\r\n\r\n        socket.close();\r\n\r\n    }\r\n}\r\n```\r\n\r\nServeDemo\r\n\r\n```java\r\npackage test06;\r\n\r\nimport java.io.*;\r\nimport java.net.ServerSocket;\r\nimport java.net.Socket;\r\n\r\npublic class ServeDemo {\r\n    public static void main(String[] args) throws IOException {\r\n        ServerSocket ss = new ServerSocket(12346);\r\n        Socket socket = ss.accept();\r\n\r\n        // 创建文件对象\r\n        BufferedWriter bw = new BufferedWriter(new FileWriter(\"received.txt\"));\r\n\r\n        BufferedReader br = new BufferedReader(new InputStreamReader(socket.getInputStream()));\r\n\r\n        String line;\r\n        while ((line=br.readLine())!=null){\r\n            bw.write(line);\r\n            bw.newLine();\r\n            bw.flush();\r\n        }\r\n        ss.close();\r\n        bw.close();\r\n    }\r\n}\r\n```\r\n\r\n### 练习4\r\n\r\n![image-20210723104227515](cloudDisk/markdown/Java笔记.assets\\image-20210723104227515.png)\r\n\r\nClientDemo\r\n\r\n```java\r\npackage test06;\r\n\r\nimport java.io.*;\r\nimport java.net.Socket;\r\n\r\npublic class ClientDemo {\r\n    public static void main(String[] args) throws IOException {\r\n        // 1. 创建Socket对象\r\n        Socket socket = new Socket(\"192.168.1.105\", 12346);\r\n\r\n        // 创建读取文件对象\r\n        BufferedReader br = new BufferedReader(new FileReader(\"send.txt\"));\r\n\r\n        // 发送信息对象\r\n        BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(socket.getOutputStream()));\r\n\r\n        String line;\r\n        while ((line = br.readLine()) != null){\r\n            bw.write(line);\r\n            bw.newLine();\r\n            bw.flush();\r\n        }\r\n        bw.close();\r\n        socket.close();\r\n\r\n    }\r\n}\r\n```\r\n\r\nServeDemo\r\n\r\n```java\r\npackage test06;\r\n\r\nimport java.io.*;\r\nimport java.net.ServerSocket;\r\nimport java.net.Socket;\r\n\r\npublic class ServeDemo {\r\n    public static void main(String[] args) throws IOException {\r\n        ServerSocket ss = new ServerSocket(12346);\r\n        Socket socket = ss.accept();\r\n        // 写文件对象\r\n        BufferedWriter bw = new BufferedWriter(new FileWriter(\"received.txt\"));\r\n        // 接收信息对象\r\n        BufferedReader br = new BufferedReader(new InputStreamReader(socket.getInputStream()));\r\n        String line;\r\n        while ((line = br.readLine())!=null){\r\n            bw.write(line);\r\n            bw.newLine();\r\n            bw.flush();\r\n        }\r\n        bw.close();\r\n        socket.close();\r\n    }\r\n}\r\n```\r\n\r\n### 练习5\r\n\r\n![image-20210723110149278](cloudDisk/markdown/Java笔记.assets\\image-20210723110149278.png)\r\n\r\n\r\n\r\n![image-20210723112406440](cloudDisk/markdown/Java笔记.assets\\image-20210723112406440.png)\r\n\r\nClientDemo\r\n\r\n```java\r\npackage test06;\r\n\r\nimport java.io.*;\r\nimport java.net.Socket;\r\n\r\npublic class ClientDemo {\r\n    public static void main(String[] args) throws IOException {\r\n        // 1. 创建Socket对象\r\n        Socket socket = new Socket(\"192.168.1.105\", 12351);\r\n\r\n        // 创建读取文件对象\r\n        BufferedReader br = new BufferedReader(new FileReader(\"send.txt\"));\r\n\r\n        // 发送信息对象\r\n        BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(socket.getOutputStream()));\r\n\r\n        String line;\r\n        while ((line = br.readLine()) != null){\r\n            bw.write(line);\r\n            bw.newLine();\r\n            bw.flush();\r\n        }\r\n        socket.shutdownOutput(); // 输出结束标记\r\n\r\n        // 接收反馈\r\n        BufferedReader br2 = new BufferedReader(new InputStreamReader(socket.getInputStream()));\r\n        String s = br2.readLine();\r\n        System.out.println(\"服务器：\"+s);\r\n        br2.close();\r\n\r\n        bw.close();\r\n        socket.close();\r\n\r\n    }\r\n}\r\n```\r\n\r\nServeDemo\r\n\r\n```java\r\npackage test06;\r\n\r\nimport java.io.*;\r\nimport java.net.ServerSocket;\r\nimport java.net.Socket;\r\n\r\npublic class ServeDemo {\r\n    public static void main(String[] args) throws IOException {\r\n        ServerSocket ss = new ServerSocket(12351);\r\n        Socket socket = ss.accept();\r\n        // 写文件对象\r\n        BufferedWriter bw = new BufferedWriter(new FileWriter(\"received.txt\"));\r\n        // 接收信息对象\r\n        BufferedReader br = new BufferedReader(new InputStreamReader(socket.getInputStream()));\r\n        String line;\r\n        while ((line = br.readLine())!=null){\r\n            bw.write(line);\r\n            bw.newLine();\r\n            bw.flush();\r\n        }\r\n\r\n\r\n        // 给出反馈\r\n        BufferedWriter bw2 = new BufferedWriter(new OutputStreamWriter(socket.getOutputStream()));\r\n        bw2.write(\"上传成功！！！\");\r\n        bw2.close();\r\n\r\n        bw.close();\r\n        socket.close();\r\n\r\n    }\r\n}\r\n```\r\n\r\n### 练习6\r\n\r\n![image-20210723112553976](cloudDisk/markdown/Java笔记.assets\\image-20210723112553976.png)\r\n\r\nClientDemo\r\n\r\n```java\r\npackage test06;\r\n\r\nimport java.io.*;\r\nimport java.net.Socket;\r\n\r\npublic class ClientDemo {\r\n    public static void main(String[] args) throws IOException {\r\n        // 1. 创建Socket对象\r\n        Socket socket = new Socket(\"192.168.1.105\", 12354);\r\n\r\n        // 创建读取文件对象\r\n        BufferedReader br = new BufferedReader(new FileReader(\"send.txt\"));\r\n\r\n        // 发送信息对象\r\n        BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(socket.getOutputStream()));\r\n\r\n        String line;\r\n        while ((line = br.readLine()) != null){\r\n            bw.write(line);\r\n            bw.newLine();\r\n            bw.flush();\r\n        }\r\n        socket.shutdownOutput(); // 输出结束标记\r\n\r\n        // 接收反馈\r\n        BufferedReader br2 = new BufferedReader(new InputStreamReader(socket.getInputStream()));\r\n        String s = br2.readLine();\r\n        System.out.println(\"服务器：\"+s);\r\n        br2.close();\r\n\r\n        bw.close();\r\n        socket.close();\r\n\r\n    }\r\n}\r\n```\r\n\r\nServeThread\r\n\r\n```java\r\npackage test06;\r\n\r\nimport java.io.*;\r\nimport java.net.Socket;\r\n\r\npublic class ServeThread implements Runnable {\r\n    Socket s;\r\n    int count = 0;\r\n\r\n    public ServeThread(Socket s,int count) {\r\n        this.s = s;\r\n        this.count = count;\r\n    }\r\n    @Override\r\n    public void run() {\r\n        try {\r\n            System.out.println(count++);\r\n            BufferedReader br = new BufferedReader(new InputStreamReader(s.getInputStream()));\r\n            BufferedWriter bw = new BufferedWriter(new FileWriter(\"receive\\\\received[\"+count+\"].txt\"));\r\n            String line;\r\n            while ((line = br.readLine())!=null){\r\n                bw.write(line);\r\n                bw.newLine();\r\n                bw.flush();\r\n            }\r\n            // 给出反馈\r\n            BufferedWriter bufferedWriter = new BufferedWriter(new OutputStreamWriter(s.getOutputStream()));\r\n            bufferedWriter.write(\"文件上传成功！！！\");\r\n            bufferedWriter.close();\r\n            bw.close();\r\n            br.close();\r\n        } catch (IOException e) {\r\n            e.printStackTrace();\r\n        }\r\n    }\r\n}\r\n```\r\n\r\nServeDemo\r\n\r\n```java\r\npackage test06;\r\n\r\nimport javax.swing.plaf.TableHeaderUI;\r\nimport java.io.*;\r\nimport java.net.ServerSocket;\r\nimport java.net.Socket;\r\n\r\npublic class ServeDemo {\r\n    public static void main(String[] args) throws IOException {\r\n        ServerSocket ss = new ServerSocket(12354);\r\n        int count = 0;\r\n        while (true){\r\n            Socket s = ss.accept();\r\n            Thread t = new Thread(new ServeThread(s,count));\r\n            t.start();\r\n            count++;\r\n        }\r\n\r\n    }\r\n}\r\n```','2022-06-23 22:02:09','Java 是由 Sun Microsystems 公司于 1995 年 5 月推出的 Java 面向对象程序设计语言和 Java 平台的总称。由 James Gosling和同事们共同研发，并在 1995 年正式推出。\r\n\r\n后来 Sun 公司被 Oracle （甲骨文）公司收购，Java 也随之成为 Oracle 公司的产品。','cloudDisk/markdown/Java笔记.assets\\image-20210722094338809.png','原创','','','\0','Java 基础（十）','2022-06-23 22:02:09',0,100,NULL,0),(179,'','# 一、Lambda表达式\r\n\r\n## 1.1 函数式编程思想概述\r\n\r\n![image-20210723120437218](cloudDisk/markdown/Java笔记.assets\\image-20210723120437218.png)\r\n\r\n## 1.2 体验Lambda表达式\r\n\r\n![image-20210723120940915](cloudDisk/markdown/Java笔记.assets\\image-20210723120940915.png)\r\n\r\n```java\r\npackage test07;\r\n\r\nimport test01.MyThread;\r\n\r\npublic class Demo {\r\n    public static void main(String[] args) {\r\n        // 1. 实现类的方法\r\n//        MyThread my = new MyThread();\r\n//        new Thread(my).start();\r\n\r\n        // 2. 内部类方式\r\n//        new Thread(new Runnable() {\r\n//            @Override\r\n//            public void run() {\r\n//                System.out.println(\"多线程启动了\");\r\n//            }\r\n//        }).start();\r\n\r\n        // 3. Lambda表达式\r\n        new Thread( () -> {\r\n            System.out.println(\"多线程启动了\");\r\n        } ).start();\r\n\r\n    }\r\n}\r\n```\r\n\r\n## 1.3 Lambda表达式的标准格式\r\n\r\n![image-20210723121930549](cloudDisk/markdown/Java笔记.assets\\image-20210723121930549.png)\r\n\r\n![image-20210723122023780](cloudDisk/markdown/Java笔记.assets\\image-20210723122023780.png)\r\n\r\n## 1.4 Lambda表达式的练习\r\n\r\n### 练习1\r\n\r\n![image-20210723122128386](cloudDisk/markdown/Java笔记.assets\\image-20210723122128386.png)\r\n\r\n```java\r\npackage test07;\r\n\r\npublic interface Eatable {\r\n    void eat();\r\n}\r\n```\r\n\r\n```java\r\npackage test07;\r\n\r\nimport test01.MyThread;\r\n\r\npublic class Demo {\r\n    public static void main(String[] args) {\r\n        useEatable( () -> {\r\n            System.out.println(\"吃西瓜\");\r\n        });\r\n    }\r\n    public static void useEatable(Eatable e){\r\n        e.eat();\r\n    }\r\n}\r\n```\r\n\r\n### 练习2\r\n\r\n![image-20210723122954684](cloudDisk/markdown/Java笔记.assets\\image-20210723122954684.png)\r\n\r\n```java\r\npackage test08;\r\n\r\npublic interface Flyable {\r\n    void fly(String s);\r\n}\r\n```\r\n\r\n```java\r\npackage test08;\r\n\r\npublic class FlyableDemo {\r\n    public static void main(String[] args) {\r\n        useFlyable(new Flyable() {\r\n            @Override\r\n            public void fly(String s) {\r\n                System.out.println(s);\r\n                System.out.println(\"突然暴风雨\");\r\n            }\r\n        });\r\n        System.out.println(\"-----------\");\r\n        useFlyable((String s)->{\r\n            System.out.println(s);\r\n            System.out.println(\"突然暴风雨\");\r\n        });\r\n    }\r\n    public static void useFlyable(Flyable f){\r\n        f.fly(\"晴空万里\");\r\n    }\r\n\r\n}\r\n```\r\n\r\n## 1.5 Lambda表达式的省略模式\r\n\r\n![image-20210724090520006](cloudDisk/markdown/Java笔记.assets\\image-20210724090520006.png)\r\n\r\n## 1.6 Lambda表达式注意事项\r\n\r\n![image-20210724091017349](cloudDisk/markdown/Java笔记.assets\\image-20210724091017349.png)\r\n\r\n```java\r\npublic static void main(String[] args) {\r\n    Runnable r = () -> System.out.println(\"Lambda表达式\");\r\n    new Thread(r);\r\n}\r\n```\r\n\r\n## 1.7 Lambda表达式和匿名内部类区别\r\n\r\n![image-20210724091925791](cloudDisk/markdown/Java笔记.assets\\image-20210724091925791.png)\r\n\r\n# 一、接口组成更新\r\n\r\n## 1.1 接口组成更新描述\r\n\r\n![image-20210724092142749](cloudDisk/markdown/Java笔记.assets\\image-20210724092142749.png)\r\n\r\n## 1.2 接口中默认方法\r\n\r\n![image-20210724092847708](cloudDisk/markdown/Java笔记.assets\\image-20210724092847708.png)\r\n\r\nFlyable\r\n\r\n```java\r\npackage test08;\r\n\r\npublic interface Flyable {\r\n    void fly1();\r\n    default void fly2(){\r\n        System.out.println(\"fly2\");\r\n    }\r\n}\r\n```\r\n\r\nFlyableImpl\r\n\r\n```java\r\npackage test08;\r\n\r\npublic class FlyableImpl implements Flyable {\r\n    @Override\r\n    public void fly1() {\r\n        System.out.println(\"重写 fly1\");\r\n    }\r\n\r\n}\r\n```\r\n\r\nFlyableDemo\r\n\r\n```java\r\npackage test08;\r\n\r\npublic class FlyableDemo {\r\n    public static void main(String[] args) {\r\n        Flyable f = new FlyableImpl();\r\n        f.fly1();\r\n        f.fly2();\r\n    }\r\n}\r\n```\r\n\r\n## 1.3 接口中的静态方法\r\n\r\n![image-20210724093741110](cloudDisk/markdown/Java笔记.assets\\image-20210724093741110.png)\r\n\r\n## 1.4 接口中私有方法\r\n\r\n![image-20210724094408617](cloudDisk/markdown/Java笔记.assets\\image-20210724094408617.png)\r\n\r\n# 一、方法引用\r\n\r\n## 1.1 体验方法引用\r\n\r\n![image-20210724095044892](cloudDisk/markdown/Java笔记.assets\\image-20210724095044892.png)\r\n\r\n```java\r\npackage test08;\r\n\r\npublic interface Printable {\r\n    void prinSting(String s);\r\n}\r\n```\r\n\r\n```java\r\npackage test08;\r\n\r\npublic class PrintableDemo {\r\n    public static void main(String[] args) {\r\n        usePrintable(s -> System.out.println(s));\r\n        usePrintable(System.out::println);\r\n        //方法引用符号：::\r\n        // 可推导的就是可省略的\r\n    }\r\n    public static void usePrintable(Printable p){\r\n        p.prinSting(\"爱\");\r\n    }\r\n}\r\n```\r\n\r\n## 1.2 方法引用符\r\n\r\n![image-20210724095800168](cloudDisk/markdown/Java笔记.assets\\image-20210724095800168.png)\r\n\r\n## 1.3 引用类方法\r\n\r\n![image-20210724100431024](cloudDisk/markdown/Java笔记.assets\\image-20210724100431024.png)\r\n\r\n## 1.4 引用对象的实例方法\r\n\r\n![image-20210724100531432](cloudDisk/markdown/Java笔记.assets\\image-20210724100531432.png)\r\n\r\nPrintString\r\n\r\n```java\r\npackage test09;\r\n\r\npublic class PrintString {\r\n    public String printUpper(String s){\r\n        return s.toUpperCase();\r\n    }\r\n}\r\n```\r\n\r\nPrinter\r\n\r\n```java\r\npackage test09;\r\n\r\npublic interface Printer {\r\n    String printUpperCase(String s);\r\n}\r\n```\r\n\r\nPrinterDemo\r\n\r\n```java\r\npackage test09;\r\n\r\npublic class PrinterDemo {\r\n    public static void main(String[] args) {\r\n//        String s =usePrinter(ps -> {\r\n//            return ps.toUpperCase();\r\n//        });\r\n\r\n        // 引用对象的方法\r\n        PrintString ps = new PrintString();\r\n        String s = usePrinter(ps::printUpper);\r\n        System.out.println(s);\r\n    }\r\n    public static String usePrinter(Printer p){\r\n        return p.printUpperCase(\"Hello world\");\r\n    }\r\n}\r\n```\r\n\r\n## 1.5 引用类的实例方法\r\n\r\n![image-20210724104029702](cloudDisk/markdown/Java笔记.assets\\image-20210724104029702.png)\r\n\r\nMyString\r\n\r\n```java\r\npackage test10;\r\n\r\npublic interface MyString {\r\n    String mySubSting(String s,int x,int y);\r\n}\r\n```\r\n\r\nMyStringDemo\r\n\r\n```java\r\npackage test10;\r\n\r\n\r\npublic class MyStringDemo {\r\n    public static void main(String[] args) {\r\n//        useMyString((x,y,z) -> x.substring(y,z));\r\n        useMyString(String::substring);\r\n    }\r\n    public static void useMyString(MyString my){\r\n        String s = my.mySubSting(\"I LOVE YOU ZXXXXXX\", 11, 13);\r\n        System.out.println(s);\r\n    }\r\n}\r\n```\r\n\r\n## 1.6 引用构造器\r\n\r\n![image-20210724105537309](cloudDisk/markdown/Java笔记.assets\\image-20210724105537309.png)\r\n\r\nStudent\r\n\r\n```java\r\npackage test11;\r\n\r\npublic class Student {\r\n    private String name;\r\n    private int age;\r\n\r\n    public String getName() {\r\n        return name;\r\n    }\r\n\r\n}\r\n```\r\n\r\nStudentBuilder\r\n\r\n```java\r\npackage test11;\r\n\r\npublic interface StudentBuilder {\r\n    Student build(String name,int age);\r\n}\r\n```\r\n\r\nStudentDemo\r\n\r\n```java\r\npackage test11;\r\n\r\npublic class StudentDemo {\r\n    public static void main(String[] args) {\r\n//        useStudentBuilder(((name, age) -> new Student(name,age)));\r\n        useStudentBuilder(Student::new);\r\n    }\r\n    public static void useStudentBuilder(StudentBuilder s){\r\n        Student s1 = s.build(\"Tony\", 20);\r\n        System.out.println(s1.getName());\r\n\r\n    }\r\n}\r\n```\r\n\r\n# 一、函数式接口\r\n\r\n# 1.1 概述\r\n\r\n![image-20210724111100111](cloudDisk/markdown/Java笔记.assets\\image-20210724111100111.png)\r\n\r\n```java\r\npackage test11;\r\n@FunctionalInterface\r\npublic interface StudentBuilder {\r\n    Student build(String name,int age);\r\n}\r\n```\r\n\r\n## 1.2 函数式接口作为方法的参数\r\n\r\n![image-20210724112125953](cloudDisk/markdown/Java笔记.assets\\image-20210724112125953.png)\r\n\r\n```java\r\npackage test12;\r\n\r\npublic class Demo {\r\n    public static void main(String[] args) {\r\n        startThread(new Runnable() {\r\n            @Override\r\n            public void run() {\r\n                System.out.println(Thread.currentThread().getName()+\"线程启动了\");\r\n            }\r\n        });\r\n        startThread(() -> System.out.println(Thread.currentThread().getName()+\"线程启动了\"));\r\n    }\r\n    public static void startThread(Runnable r){\r\n        new Thread(r).start();\r\n    }\r\n}\r\n```\r\n\r\n## 1.3 函数式接口作为方法的返回值\r\n\r\n![image-20210724112756796](cloudDisk/markdown/Java笔记.assets\\image-20210724112756796.png)\r\n\r\n## 1.4 常用的函数式接口\r\n\r\n\r\n\r\n![image-20210724113252707](cloudDisk/markdown/Java笔记.assets\\image-20210724113252707.png)\r\n\r\n## 1.5 Supplier接口\r\n\r\n![image-20210724113328203](cloudDisk/markdown/Java笔记.assets\\image-20210724113328203.png)\r\n\r\n![image-20210724113507204](cloudDisk/markdown/Java笔记.assets\\image-20210724113507204.png)\r\n\r\n![image-20210724113810735](cloudDisk/markdown/Java笔记.assets\\image-20210724113810735.png)\r\n\r\n```java\r\npackage test12;\r\n\r\nimport java.util.ArrayList;\r\nimport java.util.function.Supplier;\r\n\r\npublic class Demo {\r\n    public static void main(String[] args) {\r\n        int[] arr = {4,3,2,11,1,5,3,45};\r\n        int maxValue = getMax(() -> {\r\n           int max = arr[0];\r\n            for (int i = 0; i < arr.length; i++) {\r\n                if(arr[i] > max){\r\n                    max = arr[i];\r\n                }\r\n            }\r\n            return  max;\r\n        });\r\n        System.out.println(maxValue);\r\n    }\r\n    public static int getMax(Supplier<Integer> sup){\r\n        return sup.get();\r\n    }\r\n}\r\n```\r\n\r\n## 1.6 Consumer接口\r\n\r\n![image-20210725094916413](cloudDisk/markdown/Java笔记.assets\\image-20210725094916413.png)\r\n\r\n```java\r\npackage test12;\r\n\r\nimport java.util.ArrayList;\r\nimport java.util.function.Consumer;\r\nimport java.util.function.Supplier;\r\n\r\npublic class Demo {\r\n    public static void main(String[] args) {\r\n        operateString(\"tony\", s -> {\r\n            System.out.println(new StringBuilder(s).reverse().toString());\r\n        });\r\n        System.out.println(\"-----------\");\r\n        operateString(\"zxx\",s -> {\r\n            System.out.println(s);\r\n        }, s -> {\r\n            System.out.println(new StringBuilder(s).reverse().toString());\r\n        });\r\n    }\r\n\r\n    // 定义一个方法，用不同的方式消费同一字符串数据两次\r\n    public static void operateString(String name, Consumer<String> con1,Consumer<String> con2){\r\n//        con1.accept(name);\r\n//        con2.accept(name);\r\n        // 等同于下面\r\n        con1.andThen(con2).accept(name);\r\n    }\r\n\r\n    // 定义一个方法，消费一个字符串数据\r\n    public static void operateString(String name, Consumer<String> con){\r\n        con.accept(name);\r\n    }\r\n\r\n}\r\n```\r\n\r\n### 练习\r\n\r\n![image-20210725100746096](cloudDisk/markdown/Java笔记.assets\\image-20210725100746096.png)\r\n\r\n```java\r\npackage test12;\r\n\r\nimport java.util.ArrayList;\r\nimport java.util.function.Consumer;\r\nimport java.util.function.Supplier;\r\n\r\npublic class Demo {\r\n    public static void main(String[] args) {\r\n        String[] strArray = {\"tony,20\",\"zxx,21\",\"hash,10\"};\r\n        for (String s :\r\n                strArray) {\r\n            operateString(s, s1 -> {\r\n                String name = s1.split(\",\")[0];\r\n                System.out.print(\"姓名：\"+name+\",年龄：\");\r\n            }, s1 -> {\r\n                String age = s1.split(\",\")[1];\r\n                System.out.println(age);\r\n            });\r\n        }\r\n    }\r\n    public static void operateString(String s,Consumer<String> con1,Consumer<String> con2){\r\n        con1.andThen(con2).accept(s);\r\n    }\r\n\r\n}\r\n```\r\n\r\n## 1.7 Predicate接口\r\n\r\n![image-20210725102530514](cloudDisk/markdown/Java笔记.assets\\image-20210725102530514.png)\r\n\r\n```java\r\npackage test12;\r\n\r\nimport java.util.ArrayList;\r\nimport java.util.function.Consumer;\r\nimport java.util.function.Predicate;\r\nimport java.util.function.Supplier;\r\n\r\npublic class Demo {\r\n    public static void main(String[] args) {\r\n        boolean b1 = checkString(\"hello\", s -> s.length() > 2);\r\n        System.out.println(b1);\r\n        boolean b2 = checkString(\"hello\", s -> s.length() <2);\r\n        System.out.println(b2);\r\n    }\r\n    private static boolean checkString(String s, Predicate<String> pre){\r\n//        return pre.test(s);\r\n        // pre.test(s) = pre.negate.test(s);\r\n        return pre.test(s);\r\n    }\r\n}\r\n```\r\n\r\n### 练习\r\n\r\n![image-20210725103844645](cloudDisk/markdown/Java笔记.assets\\image-20210725103844645.png)\r\n\r\n```java\r\npackage test12;\r\n\r\nimport java.util.ArrayList;\r\nimport java.util.function.Consumer;\r\nimport java.util.function.Predicate;\r\nimport java.util.function.Supplier;\r\n\r\npublic class Demo {\r\n    public static void main(String[] args) {\r\n        String[] strArray = {\"林青霞,30\",\"柳岩,34\",\"张曼玉,35\",\"貂蝉,31\",\"王祖贤,33\"};\r\n        ArrayList<String> arrayList = checkStringList(strArray, s -> {\r\n            String name = s.split(\",\")[0];\r\n            return name.length() > 2;\r\n        }, s -> {\r\n            int age = Integer.parseInt(s.split(\",\")[1]);\r\n            return age > 33;\r\n        });\r\n        System.out.println(arrayList.toString());\r\n    }\r\n    private static ArrayList<String> checkStringList(String[] s, Predicate<String> pre1, Predicate<String> pre2){\r\n        ArrayList<String> al = new ArrayList<>();\r\n        for (String string:\r\n                s\r\n             ) {\r\n//            boolean b1 = pre1.test(string);\r\n//            boolean b2 = pre2.test(string);\r\n            boolean b = pre1.and(pre2).test(string);\r\n            if (b){\r\n                al.add(string);\r\n            }\r\n        }\r\n        return al;\r\n    }\r\n}\r\n```\r\n\r\n## 1.8 Function接口\r\n\r\n![image-20210725110136613](cloudDisk/markdown/Java笔记.assets\\image-20210725110136613.png)\r\n\r\n```java\r\npackage test12;\r\n\r\nimport java.util.ArrayList;\r\nimport java.util.function.Consumer;\r\nimport java.util.function.Function;\r\nimport java.util.function.Predicate;\r\nimport java.util.function.Supplier;\r\n\r\nimport static java.lang.Integer.valueOf;\r\n\r\npublic class Demo {\r\n    public static void main(String[] args) {\r\n        convert(\"100\", s -> {\r\n           return Integer.parseInt(s);\r\n        });\r\n        \r\n        convert(15,i -> {\r\n            String s = String.valueOf(i + 5);\r\n            return s;\r\n        });\r\n\r\n        convert(\"32\", ss -> {\r\n            return Integer.parseInt(ss) + 5;\r\n        }, ss -> {\r\n            return String.valueOf(ss);\r\n        });\r\n\r\n    }\r\n\r\n    // 定义一个方法，把一个字符串转换成int类型，在控制台输出\r\n    private static void convert(String s, Function<String,Integer> fun) {\r\n        int i = fun.apply(s);\r\n        System.out.println(s);\r\n    }\r\n\r\n    // 定义一个方法，把一个int类型的数据加上一个整数之后，转化为字符串在控制台输出\r\n    private static void convert(int i, Function<Integer,String> fun) {\r\n        String s = fun.apply(i);\r\n        System.out.println(s);\r\n    }\r\n\r\n    // 定义一个方法，一个字符串转换为int类型，把int类型的数据加上一个整数之后，转化为字符串在控制台输出\r\n    private static void convert(String s, Function<String,Integer> fun1,Function<Integer,String> fun2) {\r\n//        Integer integer = fun1.apply(s);\r\n//        String string = fun2.apply(integer);\r\n//        System.out.println(string);\r\n        String string = fun1.andThen(fun2).apply(s);\r\n        System.out.println(string);\r\n    }\r\n\r\n}\r\n```\r\n\r\n### 练习\r\n\r\n![image-20210725113117136](cloudDisk/markdown/Java笔记.assets\\image-20210725113117136.png)\r\n\r\n```java\r\npackage test12;\r\n\r\nimport java.util.ArrayList;\r\nimport java.util.function.Consumer;\r\nimport java.util.function.Function;\r\nimport java.util.function.Predicate;\r\nimport java.util.function.Supplier;\r\n\r\nimport static java.lang.Integer.valueOf;\r\n\r\npublic class Demo {\r\n    public static void main(String[] args) {\r\n        String s = \"林青霞,30\";\r\n        joinStr(s,string -> {\r\n           int age = Integer.parseInt(string.split(\",\")[1]);\r\n           return age + 70;\r\n        });\r\n    }\r\n\r\n    private static void joinStr(String s, Function<String,Integer> fun) {\r\n        Integer ss = fun.apply(s);\r\n        System.out.println(ss);\r\n    }\r\n\r\n}\r\n```','2022-06-23 22:04:10','Java 是由 Sun Microsystems 公司于 1995 年 5 月推出的 Java 面向对象程序设计语言和 Java 平台的总称。由 James Gosling和同事们共同研发，并在 1995 年正式推出。\r\n\r\n后来 Sun 公司被 Oracle （甲骨文）公司收购，Java 也随之成为 Oracle 公司的产品。','cloudDisk/markdown/Java笔记.assets\\image-20210723120940915.png','原创','','','\0','Java 基础（十一）','2022-06-23 22:04:10',0,100,NULL,0),(180,'','# 一、Stream流\r\n\r\n## 1.1 体验Stream流\r\n\r\n![image-20210725114617689](cloudDisk/markdown/Java笔记.assets\\image-20210725114617689.png)\r\n\r\n![image-20210725115454136](cloudDisk/markdown/Java笔记.assets\\image-20210725115454136.png)\r\n\r\n## 1.2 Stream流的生成方式\r\n\r\n![image-20210725115621444](cloudDisk/markdown/Java笔记.assets\\image-20210725115621444.png)\r\n\r\n![image-20210725115722042](cloudDisk/markdown/Java笔记.assets\\image-20210725115722042.png)\r\n\r\n![image-20210725115802304](cloudDisk/markdown/Java笔记.assets\\image-20210725115802304.png)\r\n\r\n![image-20210725120143273](cloudDisk/markdown/Java笔记.assets\\image-20210725120143273.png)\r\n\r\n## 1.3 Stream流的常见中间操作方法\r\n\r\n### Stream\\<T> filiter(Predicate predicate):\r\n\r\n![image-20210725120616358](cloudDisk/markdown/Java笔记.assets\\image-20210725120616358.png)\r\n\r\n```java\r\npackage test12;\r\n\r\nimport java.util.ArrayList;\r\n\r\npublic class Demo {\r\n    public static void main(String[] args) {\r\n        ArrayList<String> list = new ArrayList<String>();\r\n        list.add(\"zxx\");\r\n        list.add(\"zlb\");\r\n        list.add(\"zyz\");\r\n        list.add(\"mzm\");\r\n        list.add(\"tony\");\r\n        list.add(\"zj\");\r\n        list.add(\"pony\");\r\n\r\n        // 以z开头的输出在控制台\r\n        list.stream().filter(s -> s.startsWith(\"z\")).forEach(System.out::println);\r\n\r\n        System.out.println(\"-----------\");\r\n\r\n        // 长度为3的输出\r\n        list.stream().filter(s -> s.length() == 3).forEach(System.out::println);\r\n\r\n        System.out.println(\"-----------\");\r\n\r\n        // 长度为3，以z开头\r\n        list.stream().filter(s -> s.startsWith(\"z\")).filter(s -> s.length() == 3).forEach(System.out::println);\r\n    }\r\n\r\n}\r\n```\r\n\r\n### Stream\\<T> limit(long maxSize):\r\n\r\n### Stream\\<T> skip(long n):\r\n\r\n![image-20210725121456824](cloudDisk/markdown/Java笔记.assets\\image-20210725121456824.png)\r\n\r\n```java\r\npackage test12;\r\n\r\nimport java.util.ArrayList;\r\n\r\npublic class Demo {\r\n    public static void main(String[] args) {\r\n        ArrayList<String> list = new ArrayList<String>();\r\n        list.add(\"zxx\");\r\n        list.add(\"zlb\");\r\n        list.add(\"zyz\");\r\n        list.add(\"mzm\");\r\n        list.add(\"tony\");\r\n        list.add(\"zj\");\r\n        list.add(\"pony\");\r\n\r\n        // 输出前3数据\r\n        list.stream().limit(3).forEach(System.out::println);\r\n\r\n        System.out.println(\"----------\");\r\n\r\n        //跳过前3个数据\r\n        list.stream().skip(3).forEach(System.out::println);\r\n\r\n        System.out.println(\"----------\");\r\n\r\n        // 跳过两个，输出剩下的前两个：zyz 和 mzm\r\n        list.stream().skip(2).limit(2).forEach(System.out::println);\r\n    }\r\n\r\n}\r\n```\r\n\r\n### static \\<T> Stream\\<T> concat(Stream a, Stream b):\r\n\r\n### Stream\\<T> distinct():\r\n\r\n![image-20210725122309265](cloudDisk/markdown/Java笔记.assets\\image-20210725122309265.png)\r\n\r\n```java\r\npackage test12;\r\n\r\nimport java.util.ArrayList;\r\nimport java.util.stream.Stream;\r\n\r\npublic class Demo {\r\n    public static void main(String[] args) {\r\n        ArrayList<String> list = new ArrayList<String>();\r\n        list.add(\"zxx\");\r\n        list.add(\"zlb\");\r\n        list.add(\"zyz\");\r\n        list.add(\"mzm\");\r\n        list.add(\"tony\");\r\n        list.add(\"zj\");\r\n        list.add(\"pony\");\r\n\r\n        // 1. 取前4数据组成一个流\r\n        Stream<String> s1 = list.stream().limit(4);\r\n\r\n        // 2. 跳过2个数据组成一个流\r\n        Stream<String> s2 = list.stream().skip(2);\r\n\r\n        // 3. 合并1和2得到的流，并输出\r\n//        Stream.concat(s1,s2).forEach(System.out::println);\r\n\r\n        // 4. 合并1和2得到的流，去重复\r\n        Stream.concat(s1,s2).distinct().forEach(System.out::println);\r\n    }\r\n\r\n}\r\n```\r\n\r\n### Stream\\<T> sorted():\r\n\r\n### Stream\\<T> sorted(Comparator comparator):\r\n\r\n![image-20210725123114277](cloudDisk/markdown/Java笔记.assets\\image-20210725123114277.png)\r\n\r\n```java\r\npackage test12;\r\n\r\nimport java.util.ArrayList;\r\nimport java.util.stream.Stream;\r\n\r\npublic class Demo {\r\n    public static void main(String[] args) {\r\n        ArrayList<String> list = new ArrayList<String>();\r\n        list.add(\"zxx\");\r\n        list.add(\"zlb\");\r\n        list.add(\"zyz\");\r\n        list.add(\"mzm\");\r\n        list.add(\"tony\");\r\n        list.add(\"zj\");\r\n        list.add(\"pony\");\r\n\r\n        // 1. 按字母顺序排序输出\r\n        list.stream().sorted().forEach(System.out::println);\r\n\r\n        System.out.println(\"----------\");\r\n\r\n        // 2. 按字符长度排序输出\r\n        list.stream().sorted((s1,s2) -> {\r\n            int len = s1.length()-s2.length();\r\n            len = len == 0? s1.compareTo(s2): len;\r\n            return len;\r\n        }).forEach(System.out::println);\r\n    }\r\n\r\n}\r\n```\r\n\r\n### \\<R> Stream\\<R> map(Function mapper):\r\n\r\n### IntStream mapToInt(ToIntFunction mapper):\r\n\r\n![image-20210725124004276](cloudDisk/markdown/Java笔记.assets\\image-20210725124004276.png)\r\n\r\n```java\r\npackage test12;\r\n\r\nimport java.util.ArrayList;\r\nimport java.util.stream.IntStream;\r\nimport java.util.stream.Stream;\r\n\r\npublic class Demo {\r\n    public static void main(String[] args) {\r\n        ArrayList<String> list = new ArrayList<String>();\r\n        list.add(\"10\");\r\n        list.add(\"20\");\r\n        list.add(\"30\");\r\n        list.add(\"40\");\r\n        list.add(\"50\");\r\n        list.add(\"60\");\r\n        list.add(\"70\");\r\n\r\n        // 1. 字符串转换为整形后输出\r\n        // list.stream().map( s -> Integer.parseInt(s)).forEach(System.out::println);\r\n        //list.stream().mapToInt(s -> Integer.parseInt(s)).forEach(System.out::println);\r\n\r\n        // 2. 求和\r\n        int result = list.stream().mapToInt(s -> Integer.parseInt(s)).sum();\r\n        System.out.println(result);\r\n    }\r\n\r\n}\r\n```\r\n\r\n## 1.4 Stream流常见的终结操作方法\r\n\r\n![image-20210725125621081](cloudDisk/markdown/Java笔记.assets\\image-20210725125621081.png)\r\n\r\n```java\r\npackage test12;\r\n\r\nimport java.util.ArrayList;\r\nimport java.util.stream.IntStream;\r\nimport java.util.stream.Stream;\r\n\r\npublic class Demo {\r\n    public static void main(String[] args) {\r\n        ArrayList<String> list = new ArrayList<String>();\r\n        list.add(\"10\");\r\n        list.add(\"20\");\r\n        list.add(\"20\");\r\n        list.add(\"40\");\r\n        list.add(\"20\");\r\n        list.add(\"60\");\r\n        list.add(\"70\");\r\n        long count = list.stream().filter(s -> s.startsWith(\"2\")).count();\r\n        System.out.println(count);\r\n    }\r\n\r\n}\r\n```\r\n\r\n## 1.5 Stream流练习\r\n\r\n![image-20210726091116955](cloudDisk/markdown/Java笔记.assets\\image-20210726091116955.png)\r\n\r\n```java\r\npackage test12;\r\n\r\nimport java.io.BufferedReader;\r\nimport java.io.InputStreamReader;\r\nimport java.util.ArrayList;\r\nimport java.util.stream.IntStream;\r\nimport java.util.stream.Stream;\r\n\r\npublic class Demo {\r\n    public static void main(String[] args) {\r\n        ArrayList<String> actorArrayList = new ArrayList<String>();\r\n        ArrayList<String> actressArrayList = new ArrayList<String>();\r\n        ArrayList<Actor> arrayList = new ArrayList<Actor>();\r\n        actorArrayList.add(\"托尼\");\r\n        actorArrayList.add(\"林俊杰\");\r\n        actorArrayList.add(\"胡歌\");\r\n        actorArrayList.add(\"周杰伦\");\r\n        actorArrayList.add(\"李永乐\");\r\n        actorArrayList.add(\"钟南山\");\r\n        actressArrayList.add(\"林丹\");\r\n        actressArrayList.add(\"林凌\");\r\n        actressArrayList.add(\"杨幂\");\r\n        actressArrayList.add(\"刘亦菲\");\r\n        actressArrayList.add(\"林品如\");\r\n        actressArrayList.add(\"安以轩\");\r\n\r\n        // 男演员为3字前三人\r\n        Stream<String> s1 = actorArrayList.stream().filter(s -> s.length() == 3).limit(3);\r\n        // 女演员只要姓林的，并且不要第一个\r\n        Stream<String> s2 = actressArrayList.stream().filter(s -> s.startsWith(\"林\")).skip(1);\r\n        // 过滤后的男女演员混在一起\r\n        Stream<String> s3 = Stream.concat(s1, s2);\r\n\r\n        s3.map(s -> new Actor(s)).forEach( s -> System.out.println(s.getName()));\r\n\r\n    }\r\n\r\n}\r\n```\r\n\r\n## 1.6 Stream流的收集操作\r\n\r\n![image-20210726095932784](cloudDisk/markdown/Java笔记.assets\\image-20210726095932784-1627264773396-1627264774396.png)\r\n\r\n```java\r\npackage test12;\r\n\r\nimport java.io.BufferedReader;\r\nimport java.io.InputStreamReader;\r\nimport java.util.*;\r\nimport java.util.stream.Collectors;\r\nimport java.util.stream.IntStream;\r\nimport java.util.stream.Stream;\r\n\r\npublic class Demo {\r\n    public static void main(String[] args) {\r\n        ArrayList<String> actorArrayList = new ArrayList<String>();\r\n        actorArrayList.add(\"托尼\");\r\n        actorArrayList.add(\"林俊杰\");\r\n        actorArrayList.add(\"胡歌\");\r\n        actorArrayList.add(\"周杰伦\");\r\n        actorArrayList.add(\"李永乐\");\r\n        actorArrayList.add(\"钟南山\");\r\n\r\n        // 转list\r\n        List<String> l = actorArrayList.stream().filter(s -> s.startsWith(\"钟\")).collect(Collectors.toList());\r\n        System.out.println(l.toString());\r\n\r\n        // 转set\r\n        Set<String> c = actorArrayList.stream().filter(s -> s.length() == 2).collect(Collectors.toSet());\r\n        System.out.println(c.toString());\r\n\r\n        String[] s = {\"tony,20\",\"zxx,20\",\"pony,40\"};\r\n        // 转map\r\n        Map<String, Integer> map = Arrays.stream(s).filter(ss -> Integer.parseInt(ss.split(\",\")[1]) == 20).collect(Collectors.toMap(ss -> ss.split(\",\")[0], ss -> Integer.parseInt(ss.split(\",\")[1])));\r\n        System.out.println(map.toString());\r\n    }\r\n\r\n}\r\n```\r\n\r\n# 一、类加载器\r\n\r\n## 1.1 类加载\r\n\r\n![image-20210726101422675](cloudDisk/markdown/Java笔记.assets\\image-20210726101422675.png)\r\n\r\n![image-20210726101710127](cloudDisk/markdown/Java笔记.assets\\image-20210726101710127.png)\r\n\r\n## 1.2 类加载器\r\n\r\n![image-20210726103043986](cloudDisk/markdown/Java笔记.assets\\image-20210726103043986.png)\r\n\r\n![image-20210726103108602](cloudDisk/markdown/Java笔记.assets\\image-20210726103108602.png)\r\n\r\n# 二、反射\r\n\r\n# 2.1 概述\r\n\r\n![image-20210726103516985](cloudDisk/markdown/Java笔记.assets\\image-20210726103516985.png)\r\n\r\n![image-20210726103527111](cloudDisk/markdown/Java笔记.assets\\image-20210726103527111.png)\r\n\r\n## 2.2 获取Class类的对象\r\n\r\n![image-20210726103650701](cloudDisk/markdown/Java笔记.assets\\image-20210726103650701.png)\r\n\r\n\r\n\r\n## 2.3 反射获取构造方法并使用\r\n\r\n![image-20210726120915805](cloudDisk/markdown/Java笔记.assets\\image-20210726120915805.png)\r\n\r\n```java\r\npackage test01;\r\n\r\npublic class Student {\r\n    private String name;\r\n    private int age;\r\n    private String grade;\r\n...\r\n\r\n    public Student(String name, int age, String grade) {\r\n        this.name = name;\r\n        this.age = age;\r\n        this.grade = grade;\r\n    }\r\n\r\n    public Student() {\r\n    }\r\n    private Student(String name){\r\n        this.name = name;\r\n    }\r\n\r\n    @Override\r\n    public String toString() {\r\n        return \"Student{\" +\r\n                \"name=\'\" + name + \'\\\'\' +\r\n                \", age=\" + age +\r\n                \", grade=\'\" + grade + \'\\\'\' +\r\n                \'}\';\r\n    }\r\n}\r\n```\r\n\r\n```java\r\npackage test02;\r\n\r\nimport java.lang.reflect.Constructor;\r\nimport java.lang.reflect.InvocationTargetException;\r\n\r\npublic class ReflectDemo01 {\r\n    public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException {\r\n        Class<?> c = Class.forName(\"test01.Student\");\r\n        // 返回所有公共构造方法对象的数组\r\n        // Constructor<?>[] cons = c.getConstructors();\r\n\r\n        // 返回所有构造方法对象的数组\r\n        Constructor<?>[] cons = c.getDeclaredConstructors();\r\n\r\n        for (Constructor con :\r\n                cons) {\r\n            System.out.println(con);\r\n        }\r\n        System.out.println(\"--------\");\r\n\r\n        // 返回单个公共构造方法对象\r\n        Constructor<?> con = c.getConstructor();\r\n        // System.out.println(con);\r\n        // 创建对象\r\n        Object obj = con.newInstance();\r\n        System.out.println(obj);\r\n\r\n    }\r\n}\r\n```\r\n\r\n## 2.4 反射获取构造方法并使用练习\r\n\r\n### 练习1：通过反射实现以下操作\r\n\r\n![image-20210726123254991](cloudDisk/markdown/Java笔记.assets\\image-20210726123254991.png)\r\n\r\n![image-20210726123610622](cloudDisk/markdown/Java笔记.assets\\image-20210726123610622.png)\r\n\r\n```java\r\npackage test01;\r\n\r\npublic class Student {\r\n    private String name;\r\n    private int age;\r\n    private String address;\r\n\r\n    public Student(String name, int age, String address) {\r\n        this.name = name;\r\n        this.age = age;\r\n        this.address = address;\r\n    }\r\n\r\n    @Override\r\n    public String toString() {\r\n        return \"Student{\" +\r\n                \"name=\'\" + name + \'\\\'\' +\r\n                \", age=\" + age +\r\n                \", address=\'\" + address + \'\\\'\' +\r\n                \'}\';\r\n    }\r\n}\r\n```\r\n\r\n```java\r\npackage test02;\r\nimport java.lang.reflect.Constructor;\r\nimport java.lang.reflect.InvocationTargetException;\r\n\r\npublic class ReflectDemo01 {\r\n    public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException {\r\n        Class<?> c = Class.forName(\"test01.Student\");\r\n        Constructor<?> con = c.getConstructor(String.class, int.class, String.class);\r\n        Object o = con.newInstance(\"Tony\", 20, \"苏州\");\r\n        System.out.println(o);\r\n    }\r\n}\r\n```\r\n\r\n### 练习2\r\n\r\n![image-20210726124836442](cloudDisk/markdown/Java笔记.assets\\image-20210726124836442.png)\r\n\r\n```java\r\npackage test01;\r\n\r\npublic class Student {\r\n    private String name;\r\n\r\n\r\n    private Student(String name) {\r\n        this.name = name;\r\n    }\r\n\r\n    @Override\r\n    public String toString() {\r\n        return \"Student{\" +\r\n                \"name=\'\" + name + \'\\\'\' +\r\n                \'}\';\r\n    }\r\n}\r\n```\r\n\r\n```java\r\npackage test02;\r\nimport java.lang.reflect.Constructor;\r\nimport java.lang.reflect.InvocationTargetException;\r\n\r\npublic class ReflectDemo01 {\r\n    public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException {\r\n        Class<?> c = Class.forName(\"test01.Student\");\r\n\r\n        Constructor<?> con = c.getDeclaredConstructor(String.class);\r\n        // 由于此构造方法设置了private,所有无权限访问,但可以通过暴力反射使用构造方法\r\n        // public void setAccessible(boolean flag): 值为true取消访问检查\r\n        con.setAccessible(true);\r\n\r\n        Object obj = con.newInstance(\"Tony\");\r\n        System.out.println(obj);\r\n    }\r\n}\r\n```\r\n\r\n## 2.5 反射获取成员变量并使用\r\n\r\n![image-20210726130332286](cloudDisk/markdown/Java笔记.assets\\image-20210726130332286.png)\r\n\r\n```java\r\npackage test01;\r\n\r\npublic class Student {\r\n    public String name;\r\n    private int age;\r\n\r\n    public Student() {\r\n    }\r\n\r\n    @Override\r\n    public String toString() {\r\n        return \"Student{\" +\r\n                \"name=\'\" + name + \'\\\'\' +\r\n                \", age=\" + age +\r\n                \'}\';\r\n    }\r\n}\r\n```\r\n\r\n```java\r\npackage test02;\r\nimport java.lang.reflect.Constructor;\r\nimport java.lang.reflect.Field;\r\nimport java.lang.reflect.InvocationTargetException;\r\n\r\npublic class ReflectDemo01 {\r\n    public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException, NoSuchFieldException {\r\n        Class<?> c = Class.forName(\"test01.Student\");\r\n        // 返回所有成员变量对象的数组\r\n        Field[] declaredFields = c.getDeclaredFields();\r\n        for (Field f :\r\n                declaredFields) {\r\n            System.out.println(f);\r\n        }\r\n        System.out.println(\"--------\");\r\n\r\n        // 返回单个成员变量对象(name)\r\n        Field df = c.getDeclaredField(\"name\");\r\n\r\n        // 返回无参构造方法\r\n        Constructor<?> con = c.getConstructor();\r\n        // 创建对象\r\n        Object obj = con.newInstance();\r\n        System.out.println(obj);\r\n\r\n        // 给obj的成员变量name赋值\r\n        df.set(obj,\"Tony\");\r\n\r\n        System.out.println(obj);\r\n    }\r\n}\r\n```\r\n\r\n## 2.5 反射获取成员变量并使用练习\r\n\r\n### 练习\r\n\r\n![image-20210726131027099](cloudDisk/markdown/Java笔记.assets\\image-20210726131027099.png)\r\n\r\n```java\r\npackage test01;\r\n\r\npublic class Student {\r\n    public String name;\r\n    private int age;\r\n    private String address;\r\n    public Student() {\r\n    }\r\n\r\n    @Override\r\n    public String toString() {\r\n        return \"Student{\" +\r\n                \"name=\'\" + name + \'\\\'\' +\r\n                \", age=\" + age +\r\n                \", address=\'\" + address + \'\\\'\' +\r\n                \'}\';\r\n    }\r\n}\r\n```\r\n\r\n\r\n\r\n```java\r\npackage test02;\r\nimport java.lang.reflect.Constructor;\r\nimport java.lang.reflect.Field;\r\nimport java.lang.reflect.InvocationTargetException;\r\n\r\npublic class ReflectDemo01 {\r\n    public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException, NoSuchFieldException {\r\n        Class<?> c = Class.forName(\"test01.Student\");\r\n\r\n        // 返回无参构造方法\r\n        Constructor<?> con = c.getDeclaredConstructor();\r\n        // 创建对象\r\n        Object obj = con.newInstance();\r\n\r\n        // 修改name\r\n        Field fieldName = c.getDeclaredField(\"name\");\r\n        fieldName.setAccessible(true);\r\n        fieldName.set(obj,\"Tony\");\r\n\r\n        // 修改age\r\n        Field fieldAge = c.getDeclaredField(\"age\");\r\n        fieldAge.setAccessible(true);\r\n        fieldAge.set(obj,20);\r\n\r\n        // 修改地址\r\n        Field fieldAddress = c.getDeclaredField(\"address\");\r\n        fieldAddress.setAccessible(true);\r\n        fieldAddress.set(obj,\"苏州\");\r\n\r\n\r\n        System.out.println(obj);\r\n    }\r\n}\r\n```\r\n\r\n## 2.7 反射获取成员方法并使用\r\n\r\n![image-20210727085925246](cloudDisk/markdown/Java笔记.assets\\image-20210727085925246.png)\r\n\r\n```java\r\npackage test02;\r\nimport java.lang.reflect.Constructor;\r\nimport java.lang.reflect.Field;\r\nimport java.lang.reflect.InvocationTargetException;\r\nimport java.lang.reflect.Method;\r\n\r\npublic class ReflectDemo01 {\r\n    public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException, NoSuchFieldException {\r\n        Class<?> c = Class.forName(\"test01.Student\");\r\n\r\n        // 返回无参构造方法\r\n        Constructor<?> con = c.getDeclaredConstructor();\r\n        // 创建对象\r\n        Object obj = con.newInstance();\r\n\r\n        // 返回所有公共方法以及继承的方法\r\n        // Method[] methods = c.getMethods();\r\n        // 返回所有方法，不包括继承的\r\n        Method[] methods = c.getDeclaredMethods();\r\n        for (Method m :\r\n                methods) {\r\n            System.out.println(m);\r\n        }\r\n        System.out.println(\"------------\");\r\n        \r\n        Method method = c.getDeclaredMethod(\"playGame\");\r\n        method.setAccessible(true);\r\n        method.invoke(obj);\r\n\r\n\r\n    }\r\n}\r\n```\r\n\r\n## 2.8 反射获取成员方法并使用练习\r\n\r\n### 练习\r\n\r\n![image-20210727090609740](cloudDisk/markdown/Java笔记.assets\\image-20210727090609740.png)\r\n\r\n\r\n\r\n```java\r\npackage test01;\r\n\r\npublic class Student {\r\n    public String name;\r\n    private int age;\r\n    public Student() {\r\n    }\r\n\r\n    public void method1(){\r\n        System.out.println(\"method1\");\r\n    }\r\n    public void method2(String name){\r\n        System.out.println(\"method2\");\r\n    }\r\n    public void method3(String name,int age){\r\n        System.out.println(\"method3\");\r\n    }\r\n    private int function(String name,int age){\r\n        System.out.println(\"function\");\r\n        return 3;\r\n    }\r\n\r\n    @Override\r\n    public String toString() {\r\n        return \"Student{\" +\r\n                \"name=\'\" + name + \'\\\'\' +\r\n                \", age=\" + age +\r\n                \'}\';\r\n    }\r\n}\r\n```\r\n\r\n\r\n\r\n```java\r\npackage test02;\r\nimport java.lang.reflect.Constructor;\r\nimport java.lang.reflect.Field;\r\nimport java.lang.reflect.InvocationTargetException;\r\nimport java.lang.reflect.Method;\r\n\r\npublic class ReflectDemo01 {\r\n    public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException, NoSuchFieldException {\r\n        Class<?> c = Class.forName(\"test01.Student\");\r\n\r\n        // 返回无参构造方法\r\n        Constructor<?> con = c.getDeclaredConstructor();\r\n        // 创建对象\r\n        Object obj = con.newInstance();\r\n\r\n        // 返回所有公共方法以及继承的方法\r\n        // Method[] methods = c.getMethods();\r\n        // 返回所有方法，不包括继承的\r\n\r\n        Method method = c.getDeclaredMethod(\"method1\");\r\n        method.setAccessible(true);\r\n        method.invoke(obj);\r\n        System.out.println(\"----------\");\r\n\r\n        Method method2 = c.getDeclaredMethod(\"method2\", String.class);\r\n        method2.setAccessible(true);\r\n        method2.invoke(obj,\"Tony\");\r\n        System.out.println(\"----------\");\r\n\r\n        Method method3 = c.getDeclaredMethod(\"method3\", String.class, int.class);\r\n        method3.setAccessible(true);\r\n        method3.invoke(obj,\"Tony\",20);\r\n        System.out.println(\"----------\");\r\n\r\n        Method function = c.getDeclaredMethod(\"function\", String.class, int.class);\r\n        function.setAccessible(true);\r\n        Object o = function.invoke(obj, \"Tony\", 21);\r\n        System.out.println(o);\r\n\r\n    }\r\n}\r\n```\r\n\r\n\r\n\r\n## 2.9 反射练习\r\n\r\n### 练习1\r\n\r\n![image-20210727091853487](cloudDisk/markdown/Java笔记.assets\\image-20210727091853487.png)\r\n\r\n```java\r\npackage test02;\r\nimport java.lang.reflect.InvocationTargetException;\r\nimport java.lang.reflect.Method;\r\nimport java.util.ArrayList;\r\n\r\npublic class ReflectDemo01 {\r\n    public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException, NoSuchFieldException {\r\n        ArrayList<Integer> al = new ArrayList<Integer>();\r\n        al.add(1);\r\n        al.add(2);\r\n        al.add(3);\r\n\r\n        // 由于反射得到的是最原始的 add(Object o) 方法，所有能添加任意的对象\r\n        Class<? extends ArrayList> c = al.getClass();\r\n        Method m = c.getDeclaredMethod(\"add\", Object.class);\r\n        m.invoke(al,\"hello\");\r\n\r\n        System.out.println(al.toString());\r\n    }\r\n}\r\n```\r\n\r\n### 练习2\r\n\r\n![image-20210727092640159](cloudDisk/markdown/Java笔记.assets\\image-20210727092640159.png)\r\n\r\n```java\r\npublic class Student {\r\n    public String name;\r\n    private int age;\r\n    public Student() {\r\n    }\r\n\r\n    public void method1(){\r\n        System.out.println(\"method1\");\r\n    }\r\n    public void method2(){\r\n        System.out.println(\"method2\");\r\n    }\r\n}\r\n```\r\n\r\n```txt\r\n{\r\n    class = test01.Student\r\n    method = method2\r\n}\r\n```\r\n\r\n```java\r\npackage test02;\r\nimport java.io.FileNotFoundException;\r\nimport java.io.FileReader;\r\nimport java.io.IOException;\r\nimport java.lang.reflect.Constructor;\r\nimport java.lang.reflect.InvocationTargetException;\r\nimport java.lang.reflect.Method;\r\nimport java.util.Properties;\r\n\r\npublic class ReflectDemo01 {\r\n    public static void main(String[] args) throws IllegalAccessException, InvocationTargetException, InstantiationException, NoSuchFieldException, IOException, ClassNotFoundException, NoSuchMethodException {\r\n        Properties prop = new Properties();\r\n        prop.load(new FileReader(\"class.txt\"));\r\n        String className = prop.getProperty(\"class\");\r\n        String methodName = prop.getProperty(\"method\");\r\n\r\n        Class<?> c = Class.forName(className);\r\n        Constructor<?> con = c.getConstructor();\r\n        Object obj = con.newInstance();\r\n        Method m = c.getDeclaredMethod(methodName);\r\n        m.invoke(obj);\r\n\r\n    }\r\n}\r\n```\r\n\r\n# 一、模块化\r\n\r\n## 1.1 概述\r\n\r\n![image-20210727095020959](cloudDisk/markdown/Java笔记.assets\\image-20210727095020959.png)\r\n\r\n![image-20210727095154575](cloudDisk/markdown/Java笔记.assets\\image-20210727095154575.png)\r\n\r\n## 1.2 模块的基本使用\r\n\r\n![image-20210727101057543](cloudDisk/markdown/Java笔记.assets\\image-20210727101057543.png)\r\n\r\n![image-20210727101258918](cloudDisk/markdown/Java笔记.assets\\image-20210727101258918.png)\r\n\r\nmyOne/src/module-info.java\r\n\r\n```java\r\nmodule myOne {\r\n    exports com.test01;\r\n    exports com.test02;\r\n}\r\n```\r\n\r\nmyTwo/src/module-info.java\r\n\r\n```java\r\nmodule myTwo {\r\n    requires myOne;\r\n}\r\n```\r\n\r\n\r\n\r\nStudent.java\r\n\r\n```java\r\npackage com.test01;\r\n\r\npublic class Student {\r\n    public void learn(){\r\n        System.out.println(\"good good study, day day up\");\r\n    }\r\n}\r\n```\r\n\r\nTeacher.java\r\n\r\n```java\r\npackage com.test02;\r\n\r\npublic class Teacher {\r\n    public void teach(){\r\n        System.out.println(\"teach\");\r\n    }\r\n}\r\n```\r\n\r\nTest01.java\r\n\r\n```java\r\npackage cn.test01;\r\n\r\nimport com.test01.Student;\r\nimport com.test02.Teacher;\r\npublic class Test01 {\r\n    public static void main(String[] args) {\r\n        Student s = new Student();\r\n        s.learn();\r\n\r\n        Teacher teacher = new Teacher();\r\n        teacher.teach();\r\n    }\r\n}\r\n```\r\n\r\n\r\n\r\n## 1.3 模块服务的使用\r\n\r\n![image-20210727101226092](cloudDisk/markdown/Java笔记.assets\\image-20210727101226092.png)\r\n\r\n### 使用步骤\r\n\r\n![image-20210727102659069](cloudDisk/markdown/Java笔记.assets\\image-20210727102659069.png)\r\n\r\n![image-20210727104007869](cloudDisk/markdown/Java笔记.assets\\image-20210727104007869.png)\r\n\r\nmyOne/src/module-info.java\r\n\r\n```java\r\nimport com.itheima_03.MyService;\r\nimport com.itheima_03.impl.Czxy;\r\nimport com.itheima_03.impl.Itheima;\r\n\r\nmodule myOne {\r\n    exports com.itheima_03;\r\n    provides MyService with Itheima, Czxy;\r\n}\r\n```\r\n\r\nmyTwo/src/module-info.java\r\n\r\n```java\r\nimport com.itheima_03.MyService;\r\n\r\nmodule myTwo {\r\n    requires myOne;\r\n\r\n    uses MyService;\r\n}\r\n```\r\n\r\n\r\n\r\nCzxy.java\r\n\r\n```java\r\npackage com.itheima_03.impl;\r\n\r\nimport com.itheima_03.MyService;\r\n\r\npublic class Czxy implements MyService {\r\n    @Override\r\n    public void service() {\r\n        System.out.println(\"传智商学院\");\r\n    }\r\n}\r\n```\r\n\r\nItheima.java\r\n\r\n```java\r\npackage com.itheima_03.impl;\r\n\r\nimport com.itheima_03.MyService;\r\n\r\npublic class Itheima implements MyService {\r\n    @Override\r\n    public void service() {\r\n        System.out.println(\"学IT\");\r\n    }\r\n}\r\n```\r\n\r\nTest01.java\r\n\r\n```java\r\npackage com.itheima_03;\r\n\r\npublic interface MyService {\r\n    void service();\r\n}\r\n```','2022-06-23 22:05:06','Java 是由 Sun Microsystems 公司于 1995 年 5 月推出的 Java 面向对象程序设计语言和 Java 平台的总称。由 James Gosling和同事们共同研发，并在 1995 年正式推出。\r\n\r\n后来 Sun 公司被 Oracle （甲骨文）公司收购，Java 也随之成为 Oracle 公司的产品。','cloudDisk/markdown/Java笔记.assets\\image-20210725115621444.png','原创','','','\0','Java 基础（十二）','2022-06-23 22:05:06',3,100,NULL,0),(181,'','# 一、Junit单元测试\r\n\r\n## 1.1 测试分类：\r\n\r\n1. 黑盒测试：不需要写代码，给输入值，看程序是否能输出期望的值。\r\n\r\n2. 白盒测试：需要写代码。关注程序的执行流程。\r\n\r\n## 1.2 Junit使用：白盒测试\r\n\r\n步骤：\r\n\r\n1. 定义一个测试类（测试用例）\r\n\r\n   建议：\r\n\r\n   ​	测试类名：被测试的类名Test		名：xxx.xxx.xx.test\r\n\r\n2. 定义测试：可以独立运行\r\n\r\n   建议：\r\n\r\n   ​	方法名：test测试的方法名\r\n\r\n   ​	返回值：void\r\n\r\n   ​	参数：空参\r\n\r\n3. 给方法加@Test\r\n\r\n4. 导入junit依赖环境\r\n\r\n判定结果：\r\n\r\n​	红色：失败\r\n\r\n​	绿色：成功\r\n\r\n​	一般使用断言来操作结果\r\n\r\n​		Assert.assertEquals(期望结果, 运算结果);\r\n\r\n![image-20210727120819998](cloudDisk/markdown/JavaWeb笔记.assets\\image-20210727120819998.png)\r\n\r\n```java\r\npackage com.tony01.junit;\r\n\r\npublic class Calculator {\r\n    public int add(int a, int b) {\r\n        return a + b;\r\n    }\r\n}\r\n```\r\n\r\n```java\r\npackage com.tony01.test;\r\n\r\nimport com.tony01.junit.Calculator;\r\nimport org.junit.Assert;\r\nimport org.junit.Test;\r\n\r\npublic class CalculatorTest {\r\n    @Test\r\n    public void testAdd(){\r\n        Calculator calc = new Calculator();\r\n        int result = calc.add(1, 2);\r\n        Assert.assertEquals(3,result);\r\n    }\r\n}\r\n```\r\n\r\n补充：\r\n\r\n​	@Before：修饰的方法会在测试方法之前被自动执行\r\n\r\n​	@After：修饰的方法会在测试方法执行之后自动被执行\r\n\r\n```java\r\n@Before\r\npublic void init(){\r\n    System.out.println(\"init...\");\r\n}\r\n\r\n@After\r\npublic void close(){\r\n    System.out.println(\"close\");\r\n}\r\n```\r\n\r\n# 二、反射\r\n\r\n# 三、注解\r\n\r\n## 3.1 概念描述\r\n\r\n1. JDK1.5之后的特性\r\n2. 说明程序的\r\n3. 使用注解：@注解名称\r\n\r\n作用分类\r\n\r\n1. 编译文档：通过代码里标识的注解生成文档【生成文档doc文档】\r\n2. 代码分析：通过代码里标识的注解对代码进行分析【使用反射】\r\n3. 编译检查：通过代码里的标识的注解让编译器能够实现基本的编译检查【Override】\r\n\r\nJDK中预定义的一些注解\r\n\r\n 1. @Override ：检测该注解标注的方法是否继承自父类\r\n\r\n 2. @Deprecated ：该注解标注的内容，表示已过时\r\n\r\n 3. @SuppressWarnings ：压制警告\r\n\r\n    一般传递参数all  @SuppressWarning(\"all\")\r\n\r\n```java\r\n@SuppressWarnings(\"all\")\r\npublic class Calculator {\r\n    @Deprecated\r\n    public int add(int a, int b) {\r\n        return a + b;\r\n    }\r\n    public int add2(int a, int b) {\r\n        return a + b;\r\n    }\r\n}\r\n```\r\n\r\n## 3.2 自定义注解\r\n\r\n##### 格式：\r\n\r\n​	元注解\r\n\r\n​	public @interface 注解名称{\r\n\r\n​			属性列表;\r\n\r\n​		}\r\n\r\n##### 本质：\r\n\r\n​	就是一个接口，默认继承Annotation接口\r\n\r\n​	public interface MyAnno extends java.lang.annotation.Annotation {}\r\n\r\n##### 属性：\r\n\r\n​	接口中的成员方法\r\n\r\n* 要求：\r\n  * 属性的返回值类型有以下取值\r\n    * 基本数据类型\r\n    * String\r\n    * 枚举\r\n    * 注解\r\n    * 以上类型的数组\r\n  * 定义了以上，在使用时需要给属性赋值\r\n    * 如果定义了属性时，使用default关键字给属性默认初始化值，则使用注解时，可以不进行属性的赋值\r\n    * 如果只有一个属性需要赋值，并且属性的名称是value，则value可以忽略，直接定义值即可\r\n    * 数组赋值时，使用{}包裹。如果数组中只有一个值，则{}省略\r\n\r\n```java\r\npackage com.tony01.junit;\r\n\r\npublic @interface MyAnno {\r\n    int value();\r\n    String name() default \"Tony\";\r\n    int[] arr();\r\n}\r\n```\r\n\r\n```java\r\npackage com.tony01.junit;\r\n\r\n@MyAnno(value = 12,arr={1,2})\r\npublic class Calculator {\r\n}\r\n```\r\n\r\n##### 元注解：用于表述注解的注解\r\n\r\n* @Target：用于描述注解能够作用的位置\r\n  * ElementType取值：\r\n    * TYPE：可以作用于类上\r\n    * METHOD：可以作用于方法上\r\n    * FIELD：可以作用于成员变量上\r\n* @Retention：描述注解被保留的阶级\r\n  * @Retention(RetentionPolicy.RUNTIME)：当前被描述的注解，会保留到class字节码文件中，并被JVM读取到\r\n* @Documented：描述注解是否被抽取到api文档中\r\n* Inherited：描述注解是否被子类继承\r\n\r\n```java\r\npackage com.tony01.junit;\r\n\r\nimport java.lang.annotation.*;\r\n\r\n@Target(value = {ElementType.TYPE})\r\n@Retention(value = RetentionPolicy.RUNTIME)\r\n@Documented\r\npublic @interface MyAnno {\r\n    int value();\r\n    String name() default \"Tony\";\r\n}\r\n```\r\n\r\n##### 在程序使用（解析）注解：获取注解中定义的属性值\r\n\r\n 1. 获取注释定义的位置的对象（class,Method,Field）\r\n\r\n 2. 获取指定的注解\r\n\r\n    ```java\r\n    // c.getAnnotation(MyAnno.class);\r\n    // 其实就是在内存中生成了一个该注释接口的子类实现对象\r\n    public class MyAnnoImpl implements MyAnnoImpl{\r\n        public String className(){\r\n            return \"com.tony01.junit.MyAnno\";\r\n        }\r\n        public String name(){\r\n            return \"aa\";\r\n        }\r\n    }\r\n    \r\n    ```\r\n\r\n##### 事例\r\n\r\n```java\r\npackage com.tony01.junit;\r\n\r\nimport java.lang.annotation.*;\r\n\r\n@Target(value = {ElementType.TYPE})\r\n@Retention(value = RetentionPolicy.RUNTIME)\r\npublic @interface MyAnno {\r\n    String className();\r\n    String name();\r\n}\r\n```\r\n\r\n```java\r\npackage com.tony01.junit;\r\n\r\n@MyAnno(className = \"com.tony01.junit.MyAnno\",name = \"aa\")\r\npublic class MyAnnoTest {\r\n    public static void main(String[] args) {\r\n        // 1. 获取当前类的字节码文件对象\r\n        Class<MyAnnoTest> c = MyAnnoTest.class;\r\n\r\n        // 2. 获取上面的注释对象\r\n        // c.getAnnotation(MyAnno.class);\r\n        // 其实就是在内存中生成了一个该注释接口的子类实现对象\r\n        /*\r\n        public class MyAnnoImpl implements MyAnnoImpl{\r\n            public String className(){\r\n                return \"com.tony01.junit.MyAnno\";\r\n            }\r\n            public String name(){\r\n                return \"aa\";\r\n            }\r\n        }\r\n         */\r\n\r\n        MyAnno at = c.getAnnotation(MyAnno.class);\r\n        // 3. 调用注释对象中的抽象方法，获取返回值\r\n        String className = at.className();\r\n        String name = at.name();\r\n        System.out.println(className+\"，\"+name);\r\n\r\n    }\r\n}\r\n```\r\n\r\n##### 练习：【简单的测试框架】计算器类检错，输出到 bug.txt\r\n\r\nCheck\r\n\r\n```java\r\npackage com.tony01.test;\r\n\r\nimport java.lang.annotation.ElementType;\r\nimport java.lang.annotation.Retention;\r\nimport java.lang.annotation.RetentionPolicy;\r\nimport java.lang.annotation.Target;\r\n\r\n@Retention(RetentionPolicy.RUNTIME)\r\n@Target(ElementType.METHOD)\r\npublic @interface Check {\r\n\r\n}\r\n```\r\n\r\nCalculator\r\n\r\n```java\r\npackage com.tony01.test;\r\n/*\r\n* 小明定义的计算器类\r\n* */\r\npublic class Calculator {\r\n    //加法\r\n    @Check\r\n    public void add(){\r\n        int a = 4;\r\n        int[] arr = {1,2,3};\r\n        System.out.println(arr[a]);\r\n        System.out.println(\"1 + 1 =\" + (1+0));\r\n    }\r\n    //减法\r\n    @Check\r\n    public void sub(){\r\n        System.out.println(\"1 - 0 =\" + (1-0));\r\n    }\r\n    //乘法\r\n    @Check\r\n    public void mul(){\r\n        System.out.println(\"1 * 0 =\" + (1*0));\r\n    }\r\n    //除法\r\n    @Check\r\n    public void div(){\r\n        System.out.println(\"1 / 0 =\" + (1/0));\r\n    }\r\n\r\n    public void show(){\r\n        System.out.println(\"永无bug。。。\");\r\n    }\r\n\r\n}\r\n```\r\n\r\nCheckDemo\r\n\r\n```java\r\npackage com.tony01.test;\r\n\r\nimport java.io.BufferedWriter;\r\nimport java.io.FileWriter;\r\nimport java.io.IOException;\r\nimport java.lang.annotation.Annotation;\r\nimport java.lang.reflect.InvocationTargetException;\r\nimport java.lang.reflect.Method;\r\n\r\n/*\r\n* 简单的测试框架\r\n*\r\n* 当主方法执行后，会自动运行被检测的所有方法（加了check注解的方法）\r\n* ，判断方法是否异常，并记录到文件中\r\n* */\r\npublic class CheckDemo {\r\n    public static void main(String[] args) throws IOException {\r\n        //1. 创建计算器对象\r\n        Calculator calculator = new Calculator();\r\n        //2. 获取字节码文件对象\r\n        Class<? extends Calculator> calculatorClass = calculator.getClass();\r\n        //3. 获取所有方法\r\n        Method[] methods = calculatorClass.getDeclaredMethods();\r\n        BufferedWriter bw = new BufferedWriter(new FileWriter(\"bug.txt\"));\r\n        int number=0;\r\n        for (Method med :\r\n                methods) {\r\n            //4. 判断方法上是否有Check注解\r\n            if(med.isAnnotationPresent(Check.class)){\r\n                try {\r\n                    //5. 有就执行\r\n                    med.invoke(calculator);\r\n                } catch (Exception e) {\r\n                    // 捕获异常记录到文件中\r\n                    number++;\r\n                    bw.write(med.getName() + \"方法出异常了！！！\");\r\n                    bw.newLine();\r\n                    bw.write(\"异常名称：\"+e.getCause().getClass().getSimpleName());\r\n                    bw.newLine();\r\n                    bw.write(\"异常原因：\"+e.getCause().getMessage());\r\n                    bw.newLine();\r\n                    bw.write(\"------------------------\");\r\n                    bw.newLine();\r\n                }\r\n            }\r\n        }\r\n        bw.write(\"本次共出现\"+number+\"次异常\");\r\n        bw.flush();\r\n        bw.close();\r\n\r\n\r\n\r\n\r\n    }\r\n}\r\n```\r\n\r\n##### 小结：\r\n\r\n* 以后大多数时候，我们会使用注解，而不是自定义注解\r\n* 注解给谁用？\r\n  * 编译器\r\n  * 给解析程序用\r\n* 注解不是程序的一部分，可以理解为注解就是一个标签\r\n\r\n\r\n\r\n# 四、数据库\r\n\r\n## 4.1 基本概念\r\n\r\n![image-20210729111203346](cloudDisk/markdown/JavaWeb笔记.assets\\image-20210729111203346.png)\r\n\r\n## 4.2 环境配置\r\n\r\n1. 安装\r\n   * 参考网上资料\r\n2. 卸载\r\n   * 去mysql的安装目录找到my.ini文件\r\n     * 复制 datadir=\".../MySQL/MySQL Server 5.5/Data/\"\r\n     * 卸载MySQL\r\n     * 删除C：/ProgramData目录下的MySQL文件夹\r\n3. 配置\r\n   * MySQL服务启动\r\n     * 手动。\r\n     * cmd--> services.msc 打开服务窗口\r\n     * 使用管理员打开cmd\r\n       * net start mysql : 启动mysql的服务\r\n       * net stop mysql : 关闭mysql服务\r\n   * MySQL登录\r\n     * mysql -uroot -p密码\r\n     * mysql - h[ip地址] -uroot -p连接目标密码\r\n     * mysql --host=ip --user=root --password=连接目标密码\r\n   * MySQL退出\r\n     * exit\r\n     * quit\r\n   * MySQL目录结构\r\n     * 安装目录\r\n       * 配置文件 my.ini\r\n     * MySQL数据目录\r\n       * 几个概念\r\n         * 数据库：文件夹\r\n         * 表：文件\r\n         * 数据：数据\r\n\r\n## 4.3 SQL\r\n\r\n1. 什么是SQL？\r\n\r\n   Structured Query Language : 结构化查询语言\r\n\r\n   其实就是定义了操作所有关系型数据库的规则。每一种数据库操作方式存在不一样的地方，称为”方言“\r\n\r\n2. SQL通用语法\r\n\r\n   ![image-20210729123447505](cloudDisk/markdown/JavaWeb笔记.assets\\image-20210729123447505.png)\r\n\r\n3. SQL分类\r\n\r\n   ![image-20210729123820341](cloudDisk/markdown/JavaWeb笔记.assets\\image-20210729123820341.png)\r\n\r\n   ![image-20210729123838193](cloudDisk/markdown/JavaWeb笔记.assets\\image-20210729123838193.png)\r\n\r\n## 4.4 DDL：操作数据库、表\r\n\r\n1. 操作数据库：CRUD\r\n\r\n   1. C（Create）：创建\r\n\r\n      * 创建数据库：\r\n\r\n        * create database 数据库名称\r\n\r\n      * 创建数据库，判断不存在，再创建：\r\n\r\n        * create database if not exists 数据库名称;\r\n\r\n      * 创建数据库，并指定字符集\r\n\r\n        * create database 数据库名称 character set 字符集名;\r\n\r\n      * 练习：创建db4数据库。判断是否存在，并指定字符集为gbk\r\n\r\n        * ```sql\r\n          create database if not exists db4 character set gbk;\r\n          ```\r\n\r\n   2. R(Retrieve) ：查询\r\n\r\n      * 查询所有数据库名称\r\n\r\n        * ```sql\r\n          show databases;\r\n          ```\r\n\r\n      * 查询某个数据库字符集：查询某个数据库的创建语句\r\n\r\n        * show create database 数据库名;\r\n\r\n   3. U(Update)：修改\r\n\r\n      * 修改数据库的字符集\r\n        * alter database 数据库名称 character set 字符集名称;\r\n\r\n   4. D(Delete)：删除\r\n\r\n      * 删除数据库\r\n        * drop database 数据库名称;\r\n      * 判断数据库是否存在，再删除\r\n        * drop database if exists 数据库名称;\r\n\r\n   5. 使用数据库\r\n\r\n      * 查询当前正在使用的数据库名称\r\n\r\n        * ```sql\r\n          select database();\r\n          ```\r\n\r\n      * 使用数据库\r\n\r\n        * use 数据库名称;\r\n\r\n2. 操作表\r\n\r\n   1. C（Create)：创建\r\n\r\n      * 语法\r\n\r\n        create table 表明 (\r\n\r\n        ​	列名1 数据类型1,	\r\n\r\n        ​	列名2 数据类型3,\r\n\r\n        ​	.....\r\n\r\n        ​	列名n 数据类型n\r\n\r\n        );\r\n\r\n        例：\r\n\r\n        ```sql\r\n        	CREATE TABLE student(id INT, \r\n        	NAME VARCHAR(32),\r\n        	age INT,\r\n        	sex VARCHAR(10),\r\n        	address VARCHAR(10),\r\n        	Math INT,\r\n        	English INT\r\n        	);\r\n        ```\r\n\r\n        \r\n\r\n      * 注意：最后一列，不需要加逗号（,）\r\n\r\n      * 数据库类型：\r\n\r\n        * int：整数类型\r\n          * age int,\r\n        * double : 小数类型\r\n          * score double(5,2)\r\n        * date：日期，只包含年月日，yyyy-MM-dd\r\n        * datetime : 日期，包含年月日时分秒  yyyy-MM-dd HH:mm:ss\r\n        * timestamp : 时间戳类型  包含年月日时分秒   yyyy-MM-dd HH:mm:ss\r\n          * 如果将来不给这个字段赋值，或赋值为null，则默认使用当前的系统时间，来自动赋值\r\n        * varchar : 字符串\r\n          * name varchar(20) : 名字最大20个字符\r\n          * zhangsan 8 个字符       张三 2个字符\r\n\r\n      * 创建表\r\n\r\n        ![image-20210729133303831](cloudDisk/markdown/JavaWeb笔记.assets\\image-20210729133303831.png)\r\n\r\n        ```sql\r\n        create table if not exists Student(\r\n        \r\n        number int,\r\n        \r\n         name varchar(32),\r\n        \r\n         age int,\r\n        \r\n         score double(5,2), \r\n        \r\n        birthday date, \r\n        \r\n        insertTime timestamp\r\n        \r\n        );\r\n        ```\r\n\r\n        \r\n\r\n      * 复制表\r\n\r\n        * ```sql\r\n          create table stu like Student ;\r\n          ```\r\n\r\n          \r\n\r\n   2. R(Retrieve) ：查询\r\n\r\n      * 查询某个数据库中所有表的名称\r\n        * show tables;\r\n      * 查询表结构\r\n        * desc 表名;\r\n\r\n   3. U(Update)：修改\r\n\r\n      1. 修改表名\r\n         * alter table 表名 rename to 新表名;\r\n      2. 修改表的字符集\r\n         * alter table 表名 character set 字符集名称;\r\n      3. 添加一列\r\n         * alter table 表名 add 列 数据类型;\r\n      4. 修改列名称 类型\r\n         * alter table 表名 change 列名 新列名 新数据类型;\r\n         * alter table 表名 modify 列名 新数据类型;\r\n      5. 删除列\r\n         * alter table 表名 drop 列名;\r\n\r\n   4. D(Delete)：删除\r\n\r\n      * drop table 表名;\r\n\r\n      * drop table if exists 表名;\r\n\r\n## 4.5 客户端图形化工具：SQLYog\r\n\r\n## 4.6 DML ：增删改表中的数据\r\n\r\n1. 添加数据：\r\n\r\n   * 语法：\r\n\r\n     * insert into 表名（列名1, 列名2, ... , 列名n） values(值1, 值2, ..., 值n);\r\n\r\n   * 注意：\r\n\r\n     1. 列名和值要一一对应\r\n\r\n     2. 如果表名后，不定义列名，则默认给所有列添加值\r\n\r\n        insert into 表名 values(值1,值2, ..., 值n);\r\n\r\n        例：\r\n\r\n        ```sql\r\n        INSERT INTO stu VALUES(2017251002,\"Tony\",20,80,\"2000-08-13\",NULL,\"男\");\r\n        ```\r\n\r\n        ![image-20210730085953993](cloudDisk/markdown/JavaWeb笔记.assets\\image-20210730085953993.png)\r\n\r\n     3. 除了数字类型，其他类型需要使用引号\r\n\r\n   * 例：\r\n\r\n     ```sql\r\n     INSERT INTO student VALUES(\r\n     	1,\"林江\",20,\"男\",\"常州\",80,82),(\r\n     	2,\"Tony\",20,\"男\",\"苏州\",70,79),(\r\n     	3,\"朱薛\",21,\"女\",\"苏州\",85,80),(\r\n     	4,\"柳岩\",20,\"女\",\"淮安\",85,90),(\r\n     	5,\"马云\",50,\"男\",\"杭州\",5,NULL),(\r\n     	6,\"马化腾\",43,\"男\",\"深圳\",80,90),(\r\n     	7,\"刘亦菲\",21,\"女\",\"北京\",90,80)\r\n     	;\r\n     ```\r\n\r\n     \r\n\r\n2. 删除数据：\r\n\r\n   * 语法：\r\n\r\n     * delete from 表名 [where 条件];\r\n\r\n     * 例：\r\n\r\n       * ![image-20210730090849678](cloudDisk/markdown/JavaWeb笔记.assets\\image-20210730090849678.png)\r\n\r\n       * ```sql\r\n         DELETE FROM stu WHERE number=2017251002;\r\n         ```\r\n\r\n         \r\n\r\n       * ![image-20210730090913104](cloudDisk/markdown/JavaWeb笔记.assets\\image-20210730090913104.png)\r\n\r\n   * 注意：\r\n\r\n     1. 如果不加条件，则删除表中所有记录。\r\n     2. 如果要删除所有记录\r\n        1. delete from 表名;  --  不推荐使用。有多少条数据就会执行多少条语句；\r\n        2. truncate table 表名;  --  推荐使用，效率高。先删除表，再新建张一样的表。\r\n\r\n3. 修改数据：\r\n\r\n   * 语法：\r\n\r\n     * update 表名 set 列名1 = 值1, 列名2 = 值2, ... [where 条件];\r\n\r\n     * 例：\r\n\r\n       * ![image-20210730091623126](cloudDisk/markdown/JavaWeb笔记.assets\\image-20210730091623126.png)\r\n\r\n       * ```sql\r\n         UPDATE stu SET age = 21, score = 82 WHERE number = 2017251002;\r\n         ```\r\n\r\n         \r\n\r\n       * ![image-20210730091730877](cloudDisk/markdown/JavaWeb笔记.assets\\image-20210730091730877.png)\r\n\r\n     \r\n\r\n   * 注意：\r\n\r\n     * 如果不加任何条件，则会将表中所有记录全部修改。\r\n\r\n# 五、DQL : 查询表中的记录\r\n\r\n## 5.1 语法\r\n\r\n1. ##### 语法：\r\n\r\n   * select\r\n     * 字段列表\r\n   * from\r\n     * 表名列表\r\n   * where\r\n     * 条件列表\r\n   * group by\r\n     * 分组列表\r\n   * having \r\n     * 分组后的条件列表\r\n   * order by\r\n     * 排序\r\n   * limit\r\n     * 分页限定\r\n\r\n## 5.2 DQL - 基础查询\r\n\r\n1. ##### 基础查询\r\n\r\n   1. 多个字段的查询\r\n\r\n      select 字段名, 字段名2 ... from 表名;\r\n\r\n      * 注意\r\n\r\n        * 如果查询所有字段，则可以用 * 来代替字段列表。\r\n\r\n      * 例：\r\n\r\n        * ![image-20210730095031082](cloudDisk/markdown/JavaWeb笔记.assets\\image-20210730095031082.png)\r\n\r\n        * ```sql\r\n          SELECT NAME,address FROM student;\r\n          ```\r\n\r\n          \r\n\r\n        * ![image-20210730095150156](cloudDisk/markdown/JavaWeb笔记.assets\\image-20210730095150156.png)\r\n\r\n   2. 取出重复：\r\n\r\n      * distinct\r\n\r\n      * 例：\r\n\r\n        * ```sql\r\n          SELECT address FROM student;\r\n          ```\r\n\r\n          \r\n\r\n        * ![image-20210730095226803](cloudDisk/markdown/JavaWeb笔记.assets\\image-20210730095226803.png)\r\n\r\n        * ```sql\r\n          SELECT DISTINCT address FROM student;\r\n          ```\r\n\r\n          \r\n\r\n        * ![image-20210730095247711](cloudDisk/markdown/JavaWeb笔记.assets\\image-20210730095247711.png)\r\n\r\n   3. 计算列\r\n\r\n      * 一般可以使用四则计算一些列的值。（一般只会进行数值型的计算）\r\n\r\n      * ifnull(表达式1, 表达式2) : null参与的计算，计算出来的结果为null\r\n\r\n        * 表达式1： 那个字段需要判断是否为null\r\n\r\n        * 表达式2：如果该字段为null后的替换值\r\n\r\n        * if(表达式1 == null){\r\n\r\n          ​	return 表达式2;\r\n\r\n          }\r\n\r\n      * 例：\r\n\r\n        * ![image-20210730095527255](cloudDisk/markdown/JavaWeb笔记.assets\\image-20210730095527255.png)\r\n\r\n        * ```sql\r\n          SELECT NAME,Math,English,Math+English FROM student;\r\n          ```\r\n\r\n          \r\n\r\n        * null参与的计算，计算出来的结果为null\r\n\r\n        * ![image-20210730095549118](cloudDisk/markdown/JavaWeb笔记.assets\\image-20210730095549118.png)\r\n\r\n        * 解决方法：\r\n\r\n          ```sql\r\n          SELECT NAME,Math,English,IFNULL(Math+English,0) FROM student;\r\n          ```\r\n\r\n          \r\n\r\n        * ![image-20210730095656750](cloudDisk/markdown/JavaWeb笔记.assets\\image-20210730095656750.png)\r\n\r\n   4. 起别名\r\n\r\n      * as : as也可以省略\r\n\r\n      * 例：\r\n\r\n        * ```sql\r\n          SELECT NAME,Math AS \"数学\",English \"英语\",IFNULL(Math+English,0)AS \"总分\" FROM student;\r\n          ```\r\n\r\n          \r\n\r\n        * ![image-20210730095821949](cloudDisk/markdown/JavaWeb笔记.assets\\image-20210730095821949.png)\r\n\r\n## 5.3 DQL - 条件查询\r\n\r\n1. 条件查询\r\n\r\n   1. where子句后跟条件\r\n\r\n   2. 运算符\r\n\r\n      ![image-20210730101550670](cloudDisk/markdown/JavaWeb笔记.assets\\image-20210730101550670.png)\r\n\r\n      \r\n\r\n      * \\> 、 < 、 <= 、 \\>= 、 < \\>\r\n\r\n        * ```sql\r\n          SELECT * FROM student WHERE age=20;\r\n          ```\r\n\r\n          \r\n\r\n        * ![image-20210730101807252](cloudDisk/markdown/JavaWeb笔记.assets\\image-20210730101807252.png)\r\n\r\n      * BETWEEN ... AND\r\n\r\n        * ```sql\r\n          SELECT * FROM student WHERE age BETWEEN 20 AND 21;\r\n          ```\r\n\r\n          \r\n\r\n        * ![image-20210730101946516](cloudDisk/markdown/JavaWeb笔记.assets\\image-20210730101946516.png)\r\n\r\n      * IN(集合)\r\n\r\n        * ```sql\r\n          SELECT * FROM student WHERE age IN (20,50);\r\n          ```\r\n\r\n          \r\n\r\n        * ![image-20210730102735032](cloudDisk/markdown/JavaWeb笔记.assets\\image-20210730102735032.png)\r\n\r\n      * LIKE\r\n\r\n        * _  :  任意单个字符\r\n\r\n        * %  :  任意多个字符\r\n\r\n        * ```sql\r\n          SELECT * FROM student WHERE NAME LIKE \"马%\";\r\n          ```\r\n\r\n          \r\n\r\n        * ![image-20210730102522642](cloudDisk/markdown/JavaWeb笔记.assets\\image-20210730102522642.png)\r\n\r\n        * ```sql\r\n          SELECT * FROM student WHERE address LIKE \"%州\";\r\n          ```\r\n\r\n          \r\n\r\n        * ![image-20210730102605440](cloudDisk/markdown/JavaWeb笔记.assets\\image-20210730102605440.png)\r\n\r\n      * IS NULL\r\n\r\n        * ```sql\r\n          SELECT * FROM student WHERE English IS NULL;\r\n          ```\r\n\r\n          \r\n\r\n        * ![image-20210730102330969](cloudDisk/markdown/JavaWeb笔记.assets\\image-20210730102330969.png)\r\n\r\n      * and  或  &&\r\n\r\n        * ![image-20210730102126474](cloudDisk/markdown/JavaWeb笔记.assets\\image-20210730102126474.png)\r\n\r\n      * or  或  ||\r\n\r\n        * ```sql\r\n          SELECT * FROM student WHERE age<=20 OR age>25;\r\n          ```\r\n\r\n          \r\n\r\n        * ![image-20210730102228881](cloudDisk/markdown/JavaWeb笔记.assets\\image-20210730102228881.png)\r\n\r\n      * not  或  !\r\n\r\n        * ```sql\r\n          SELECT * FROM student WHERE  age != 20;\r\n          ```\r\n\r\n          \r\n\r\n        * ![image-20210730102911297](cloudDisk/markdown/JavaWeb笔记.assets\\image-20210730102911297.png)\r\n\r\n## 5.4 DQL - 排序查询\r\n\r\n* 语法：order by 子句\r\n\r\n  * order by 排序字段1 排序方式1, 排序字段2 排序方式2 ...\r\n\r\n* 排序方式：\r\n\r\n  * ASC ：升序，默认的；\r\n  * DESC ：降序。\r\n\r\n* 注意：\r\n\r\n  * 如果有多个排序条件，则前边的条件值一样时，才会判断第二条件。\r\n\r\n* 例：\r\n\r\n  * ![image-20210730105129047](cloudDisk/markdown/JavaWeb笔记.assets\\image-20210730105129047.png)\r\n\r\n  * ```sql\r\n    SELECT * FROM student ORDER BY Math ASC,English ASC;\r\n    ```\r\n\r\n    \r\n\r\n  * ![image-20210730105102792](cloudDisk/markdown/JavaWeb笔记.assets\\image-20210730105102792.png)\r\n\r\n    \r\n\r\n## 5.5 DQL - 集合函数 : 将一列数据作为整体，进行纵向的计算\r\n\r\n![image-20210730110024041](cloudDisk/markdown/JavaWeb笔记.assets\\image-20210730110024041.png)\r\n\r\n1. ##### count : 计算个数\r\n\r\n   * ```sql\r\n     SELECT COUNT(id) FROM student;\r\n     ```\r\n\r\n     \r\n\r\n   * ![image-20210730105930092](cloudDisk/markdown/JavaWeb笔记.assets\\image-20210730105930092.png)\r\n\r\n2. ##### max : 计算最大值\r\n\r\n   * ```sql\r\n     SELECT MAX(Math) FROM student;\r\n     ```\r\n\r\n     \r\n\r\n   * ![image-20210730105955154](cloudDisk/markdown/JavaWeb笔记.assets\\image-20210730105955154-1627613995743.png)\r\n\r\n3. ##### min : 计算最小值\r\n\r\n   * ```sql\r\n     SELECT MIN(Math) FROM student;\r\n     ```\r\n\r\n     \r\n\r\n   * ![image-20210730110045963](cloudDisk/markdown/JavaWeb笔记.assets\\image-20210730110045963.png)\r\n\r\n4. ##### sum : 计算总和\r\n\r\n   * ```sql\r\n     SELECT SUM(Math) FROM student;\r\n     ```\r\n\r\n     \r\n\r\n   * ![image-20210730110127959](cloudDisk/markdown/JavaWeb笔记.assets\\image-20210730110127959.png)\r\n\r\n5. ##### avg : 计算平均值\r\n\r\n   * ```sql\r\n     SELECT AVG(Math) FROM student;\r\n     ```\r\n\r\n     \r\n\r\n   * ![image-20210730110148903](cloudDisk/markdown/JavaWeb笔记.assets\\image-20210730110148903.png)\r\n\r\n* ##### 注意：聚合函数的计算，排除null值\r\n\r\n  * 解决方案：\r\n    * 选择不包含非空的列：主键\r\n    * IFNULL函数\r\n\r\n​	\r\n\r\n## 5.6 DQL - 分组查询\r\n\r\n![image-20210730105129047](cloudDisk/markdown/JavaWeb笔记.assets\\image-20210730105129047.png)\r\n\r\n1. 语法：group by 分组字段；\r\n\r\n2. 注意：\r\n\r\n   1. 分组之后查询的字段：分组字段、聚合函数\r\n   2. where 和 having 的区别？\r\n      1. where 在分组之前进行限定，如果不满足条件，则不参与分组。having在分组之后进行限定，如果不满足结果，则不会被查询出来；\r\n      2. where 后不可以跟聚合函数，having可以进行聚合函数的判断。\r\n\r\n3. 例题：\r\n\r\n   1. 按照性别分组。分别查询男、女同学的平均分\r\n\r\n      * ```sql\r\n        SELECT sex,AVG(Math) FROM student GROUP BY sex;\r\n        ```\r\n\r\n        \r\n\r\n      * ![image-20210730112208457](cloudDisk/markdown/JavaWeb笔记.assets\\image-20210730112208457.png)\r\n\r\n   2. 按照性别分组。分别查询男、女同学的平均分，人数\r\n\r\n      * ```sql\r\n        SELECT sex,AVG(Math),COUNT(id) FROM student GROUP BY sex;\r\n        ```\r\n\r\n        \r\n\r\n      * ![image-20210730112307347](cloudDisk/markdown/JavaWeb笔记.assets\\image-20210730112307347.png)\r\n\r\n   3. 按照性别分组。分别查询男、女同学的平均分，人数，要求：分数低于70的人，不参与分组\r\n\r\n      * ```sql\r\n        SELECT sex,AVG(Math),COUNT(id) FROM student WHERE Math > 70 GROUP BY sex;\r\n        ```\r\n\r\n        \r\n\r\n      * ![image-20210730112440711](cloudDisk/markdown/JavaWeb笔记.assets\\image-20210730112440711.png)\r\n\r\n   4. 按照性别分组。分别查询男、女同学的平均分，人数，要求：分数低于70的人，不参与分组，分组之后人数要大于两个人\r\n\r\n      * ```sql\r\n        SELECT sex,AVG(Math),COUNT(id) FROM student WHERE Math > 70 GROUP BY sex HAVING COUNT(id)>2;\r\n        ```\r\n\r\n        \r\n\r\n      * 简写：\r\n\r\n        ```sql\r\n        SELECT sex,AVG(Math),COUNT(id) 人数 FROM student WHERE Math > 70 GROUP BY sex HAVING 人数 >2;\r\n        ```\r\n\r\n        \r\n\r\n      * ![image-20210730112651086](cloudDisk/markdown/JavaWeb笔记.assets\\image-20210730112651086.png)\r\n\r\n## 5.7 DQL - 分页查询\r\n\r\n![image-20210730105129047](cloudDisk/markdown/JavaWeb笔记.assets\\image-20210730105129047.png)\r\n\r\n1. 语法：limit 开始的索引, 每页查询的条数;\r\n\r\n2. 公式：开始的索引 = （当前的页码 - 1）* 每页显示的条数\r\n\r\n   * 例：每页显示3条数据\r\n\r\n     * ```sql\r\n       SELECT * FROM student LIMIT 0,3;	-- 第一页数据\r\n       ```\r\n\r\n       \r\n\r\n     * ![image-20210730113840523](cloudDisk/markdown/JavaWeb笔记.assets\\image-20210730113840523.png)\r\n\r\n     * ```sql\r\n       SELECT * FROM student LIMIT 3,3;	-- 第二页数据\r\n       ```\r\n\r\n       \r\n\r\n     * ![](cloudDisk/markdown/JavaWeb笔记.assets\\image-20210730113919320.png)\r\n\r\n     * ```sql\r\n       SELECT * FROM student LIMIT 6,3;	-- 第三页数据\r\n       ```\r\n\r\n       \r\n\r\n     * ![image-20210730113931177](cloudDisk/markdown/JavaWeb笔记.assets\\image-20210730113931177.png)\r\n\r\n3. limit 是一个MySQL“方言”\r\n\r\n# 六、约束\r\n\r\n## 6.1 概念\r\n\r\n对表中的数据进行限定，保证数据的正确性、有效性和完整性。\r\n\r\n分类：\r\n\r\n 	1. 主键约束：primary key\r\n 	2. 非空约束：not null\r\n 	3. 唯一约束：unique\r\n 	4. 外键约束：foreign key\r\n\r\n## 6.2 非空约束\r\n\r\n非空约束 ： 某一列的值不能为null\r\n\r\n1. ##### 创建表时添加约束\r\n\r\n   ```sql\r\n   CREATE TABLE stu(\r\n   	id INT,\r\n   	NAME VARCHAR(20) NOT NULL\r\n   );\r\n   ```\r\n\r\n   \r\n\r\n2. ##### 创建表完后，添加非空约束\r\n\r\n   ```sql\r\n   ALTER TABLE stu MODIFY NAME VARCHAR(20) NOT NULL\r\n   ```\r\n\r\n   \r\n\r\n3. ##### 删除name的非空约束\r\n\r\n   ```sql\r\n   ALTER TABLE stu MODIFY NAME VARCHAR(20);\r\n   ```\r\n\r\n   \r\n\r\n\r\n\r\n## 6.3 唯一约束\r\n\r\n唯一约束 ： 某一列的值不能重复\r\n\r\n1. 注意：\r\n\r\n   * 唯一约束可以有Null值，但是只能有一条记录为Null\r\n\r\n2. 在创建表时，条件唯一约束\r\n\r\n   ```sql\r\n   CREATE TABLE stu1(\r\n   	id INT,\r\n   	phoneNumber VARCHAR(20) UNIQUE\r\n   );\r\n   ```\r\n\r\n   \r\n\r\n3. 删除唯一约束\r\n\r\n   ```sql\r\n   ALTER TABLE stu1 DROP INDEX phoneNumber;\r\n   ```\r\n\r\n   \r\n\r\n4. 在表创建啊完后，添加唯一约束\r\n\r\n   ```sql\r\n   ALTER TABLE stu1 MODIFY phoneNumber VARCHAR(20) UNIQUE;\r\n   ```\r\n\r\n   \r\n\r\n## 6.4 主键约束\r\n\r\n1. ##### 注意：\r\n\r\n   1. 含义：非空且唯一\r\n   2. 一张表只能有一个字段为主键\r\n   3. 主键就是表中记录的唯一标识\r\n\r\n2. ##### 在创建表时，添加主键约束\r\n\r\n   ```sql\r\n   create table stu(\r\n   \r\n   	id int primary key,\r\n   \r\n   	name varchar(20)\r\n   \r\n   );\r\n   ```\r\n\r\n3. ##### 删除主键\r\n\r\n   ```sql\r\n   -- 错误 alter table student modify id int;\r\n   \r\n   ALTER TABLE student DROP PRIMARY KEY;\r\n   ```\r\n\r\n   \r\n\r\n4. ##### 创建完表后，添加主键\r\n\r\n   ```sql\r\n   ALTER TABLE student MODIFY id INT PRIMARY KEY;\r\n   ```\r\n\r\n5. ##### 自动增长：\r\n\r\n   1. 概念：如果某一列是数值类型的，使用 auto_increment 可以来完成值的自动增长\r\n\r\n   2. 在创建表时，添加主键约束，并完成自动增长\r\n\r\n      ```sql\r\n      create table stu(\r\n      \r\n      	id int primary key auto_increment,  --  给id添加主键约束\r\n      \r\n      	name varchar(20)\r\n      \r\n      );\r\n      ```\r\n\r\n      \r\n\r\n   3. 删除自动增长\r\n\r\n      ```sql\r\n      alter table stu modify id int;\r\n      ```\r\n\r\n      \r\n\r\n   4. 添加自动增长\r\n\r\n      ```sql\r\n      alter table stu modify id int auto_increment;\r\n      ```\r\n\r\n## 6.5 外键约束\r\n\r\n1. ##### 在创建表时，可以添加外键\r\n\r\n   * 语法：\r\n\r\n     create table 表名(\r\n\r\n     ​	...\r\n\r\n     外键列\r\n\r\n     constraint 外键名称 foreign key (外键列名称) references 主表名称(主表列名称)\r\n\r\n     )\r\n\r\n2. ##### 删除外键\r\n\r\n   alter table 表名 drop foreign key 外键名称;\r\n\r\n3. ##### 创建表之后，添加外键\r\n\r\n   alter table 表名 add constraint 外键名称 foreign key (外键字段名称) references 主表名称(主表列名称);\r\n\r\n4. ##### 例\r\n\r\n   * 创建部门表\r\n\r\n     * ```sql\r\n       CREATE TABLE dep(\r\n       	dep_id INT PRIMARY KEY,\r\n       	dep_name VARCHAR(20)\r\n       );\r\n       ```\r\n\r\n   * 部门表插入数据\r\n\r\n     * ```sql\r\n       INSERT INTO dep VALUES(\r\n       	1,\"机械电子工程\"),(\r\n       	2,\"计算机与科学\"\r\n       	);\r\n       ```\r\n\r\n     * ![image-20210731112754284](cloudDisk/markdown/JavaWeb笔记.assets\\image-20210731112754284.png)\r\n\r\n   * 创建学生表，使 departmentID 和 部门表的id 产生联系（即添加外键）\r\n\r\n     * ```sql\r\n       CREATE TABLE stu(\r\n       	id INT PRIMARY KEY AUTO_INCREMENT, \r\n       	NAME VARCHAR(32) NOT NULL,\r\n       	age INT,\r\n       	sex VARCHAR(10),\r\n       	address VARCHAR(10),\r\n       	departmentID INT,\r\n       	CONSTRAINT stu_dep_fk FOREIGN KEY (departmentID) REFERENCES dep(dep_id) -- 添加外键\r\n       );\r\n       ```\r\n\r\n   * 学生表插入数据\r\n\r\n     * ```sql\r\n       INSERT INTO stu VALUES(\r\n       	1,\"林江\",20,\"男\",\"常州\",1),(\r\n       	2,\"Tony\",20,\"男\",\"苏州\",2),(\r\n       	3,\"朱薛\",21,\"女\",\"苏州\",1),(\r\n       	4,\"柳岩\",20,\"女\",\"淮安\",2),(\r\n       	5,\"马云\",50,\"男\",\"杭州\",1),(\r\n       	6,\"马化腾\",43,\"男\",\"深圳\",2),(\r\n       	7,\"刘亦菲\",21,\"女\",\"北京\",2)	\r\n       ;\r\n       ```\r\n\r\n     * ![image-20210731113017866](cloudDisk/markdown/JavaWeb笔记.assets\\image-20210731113017866.png)\r\n\r\n   * 此时无法删除部门表里的数据\r\n\r\n     * ![image-20210731113305820](cloudDisk/markdown/JavaWeb笔记.assets\\image-20210731113305820.png)\r\n\r\n   * 删除外键\r\n\r\n     * ```sql\r\n       ALTER TABLE stu DROP FOREIGN KEY stu_dep_fk;\r\n       ```\r\n\r\n     * 删除之后可以删除部门数据了\r\n\r\n       * ![image-20210731113450240](cloudDisk/markdown/JavaWeb笔记.assets\\image-20210731113450240.png)\r\n\r\n   * 添加外键\r\n\r\n     ```sql\r\n     ALTER TABLE stu ADD CONSTRAINT stu_dep_fk FOREIGN KEY (departmentID) REFERENCES dep(dep_id);\r\n     ```\r\n\r\n5. ##### 级联操作 - 类似于多米诺骨牌，当主表的被关联列的值被修改时，其他表的值也随之改变\r\n\r\n   1. ##### 添加级联操作\r\n\r\n   语法：\r\n\r\n   ```sql\r\n   alter table 表名 add constraint 外键名称 foreign key (外键字段名称) references 主表名称 on update cascade on delete cascade;\r\n   ```\r\n\r\n   \r\n\r\n   2. \r\n\r\n   3. ##### 分类：\r\n\r\n      1. 级联更新：on update cascade\r\n      2. 级联删除：on delete cascade\r\n\r\n# 七、数据库的设计\r\n\r\n## 7.1 多表之间的关系\r\n\r\n1. ##### 一对一：\r\n\r\n   * 如：人和身份证\r\n   * 分析：一个人只有一个身份证，一个身份证只能对应一个人\r\n\r\n2. ##### 一对多（多对一）\r\n\r\n   * 如：部门和员工\r\n   * 分析：一个部门有多个员工，一个员工只能对应一个部门\r\n\r\n3. ##### 多对多\r\n\r\n   * 如：学生和课程\r\n   * 分析：一个学生可以选择多门课程，一个课程也可以被多个学生选择\r\n\r\n## 7.2 实现关系：\r\n\r\n1. ##### 一对多（多对一）：\r\n\r\n   * 如：部门和员工\r\n   * ![image-20210731121043270](cloudDisk/markdown/JavaWeb笔记.assets\\image-20210731121043270.png)\r\n   * 实现方式：在多的一方建立外键，指向一的一方的主键\r\n\r\n2. ##### 多对多\r\n\r\n   * 如：学生和课程\r\n   * ![image-20210731121110582](cloudDisk/markdown/JavaWeb笔记.assets\\image-20210731121110582.png)\r\n   * 实现方式：多对多实现关系需要借助第三张中间表。中间表至少包含两个字段，这两个字段作为第三张表的外键分别指向表的主键\r\n\r\n3. ##### 一对一\r\n\r\n   * 如：人和身份证\r\n   * ![image-20210731121641331](cloudDisk/markdown/JavaWeb笔记.assets\\image-20210731121641331.png)\r\n   * 实现方式：一对一关系实现，可以在任意一方添加唯一外键指向另一方的主键。\r\n\r\n## 7.3 案例 - 多表练习\r\n\r\n![image-20210731122824584](cloudDisk/markdown/JavaWeb笔记.assets\\image-20210731122824584.png)\r\n\r\n```sql\r\n# 创建旅游路线分类表\r\n\r\nCREATE TABLE tab_category(\r\n	cid INT PRIMARY KEY AUTO_INCREMENT, -- 主键，自动增长\r\n	cname VARCHAR(100) NOT NULL UNIQUE -- 非空，唯一\r\n);\r\n\r\n# 创建旅游线表\r\n\r\nCREATE TABLE tab_route(\r\n	rid INT PRIMARY KEY AUTO_INCREMENT,\r\n	rname VARCHAR(20) NOT NULL UNIQUE,\r\n	rprice DOUBLE,\r\n	rcid INT,\r\n	rdate DATE,\r\n	FOREIGN KEY (rcid) REFERENCES tab_category(cid)\r\n);\r\n\r\n#创建用户表\r\nCREATE TABLE tab_user(\r\n	uid INT PRIMARY KEY AUTO_INCREMENT,\r\n	username VARCHAR(30) NOT NULL UNIQUE,\r\n	PASSWORD VARCHAR(30) NOT NULL,\r\n	NAME VARCHAR(30),\r\n	birthday DATE,\r\n	sex CHAR(1) DEFAULT \'男\',\r\n	telephone VARCHAR(11),\r\n	email VARCHAR(100)\r\n);\r\n\r\n# 创建中间表\r\nCREATE TABLE tab_favorite(\r\n	rid INT,\r\n	uid INT,\r\n	DATE DATETIME, -- 插入时间\r\n	PRIMARY KEY(rid,uid), -- 联合主键，两个列是不能重复的\r\n	FOREIGN KEY (rid) REFERENCES tab_route(rid),\r\n	FOREIGN KEY (uid) REFERENCES tab_user(uid)\r\n);\r\n\r\n```\r\n\r\n![image-20210731130829981](cloudDisk/markdown/JavaWeb笔记.assets\\image-20210731130829981.png)\r\n\r\n\r\n\r\n## 7.4 数据库设计范式\r\n\r\n* ### 概念：\r\n\r\n  设计数据库时，需要遵循的一些规范。要遵循后面的规范要求，必须先遵循前边的所有规范要求。\r\n\r\n  设计关系数据库时，遵从不同的规范要求，设计出合理的关系型数据库，这些不同的规范要求被称为不同的范式，各种范式呈递次规范，越高的范式数据库冗余越小。目前关系数据库有六种范式：第一范式（1NF）、第二范式（2NF）、第三范式（3NF）、巴斯-科德范式（BCNF）、第四范式(4NF）和第五范式（5NF，又称完美范式）。\r\n\r\n* ### 分类：\r\n\r\n  ![image-20210801112813754](cloudDisk/markdown/JavaWeb笔记.assets\\image-20210801112813754.png)\r\n\r\n  1. #### 第一范式（1NF）：\r\n\r\n     每一列都是不可分割的原子数据项\r\n\r\n     ![image-20210801111402289](cloudDisk/markdown/JavaWeb笔记.assets\\image-20210801111402289.png)\r\n\r\n  2. #### 第二范式（2NF）：\r\n\r\n     在1NF的基础上，非码属性必须完全依赖于候选码（在1NF基础上消除非主属性对主码的部分函数依赖）\r\n\r\n     * #### 几个概念：\r\n\r\n       1. **函数依赖：**A --> B，如果通过A属性（属性组）的值，可以确定唯一B属性的值。则称B依赖于A\r\n          * 例如：学号 --> 姓名；	（学号,课程名称） --> 分数\r\n       2. **完全函数依赖：**A --> B, 如果A是一个属性组，则B属性值得确定需要依赖于A属性组中所有的属性值\r\n          * 例如：（学号, 课程名称）--> 分数\r\n          * 分数完全依赖于学号和课程名称\r\n       3. **部分函数依赖：**A --> B, 如果A是一个属性组，则B属性值得确定只需要依赖于A属性组中某一些值即可\r\n          * 例如：（学号, 课程名称）--> 姓名\r\n          * 姓名部分依赖于学号和课程名称\r\n       4. **传递函数依赖：**A --> B, B --> C，如果通过A属性（属性组）的值，可以确定唯一B属性的值，通过B属性（属性组）的值可以唯一确定C属性的值，则C传递函数依赖于A\r\n          * 如学号 -->系名，系名 --> 系主任\r\n       5. **码：**如果在一张表中，一个属性或属性组，被其他所有属性所完全依赖，则称这个属性（属性组）为该表的码\r\n          * 例如：该表中码为：（学号, 课程名称）\r\n          * 主属性：码属性组中所有的属性\r\n          * 非主属性：除码属性组的属性\r\n\r\n     ![image-20210801112752033](cloudDisk/markdown/JavaWeb笔记.assets\\image-20210801112752033.png)\r\n\r\n  3. #### 第三范式（3NF）：\r\n\r\n     在2NF基础上，任何非主[属性](https://baike.baidu.com/item/属性)不依赖于其它非主属性（在2NF基础上消除传递依赖）\r\n\r\n     ![image-20210801112851626](cloudDisk/markdown/JavaWeb笔记.assets\\image-20210801112851626.png)\r\n\r\n# 八、数据库的备份和还原\r\n\r\n1. 命令行：\r\n\r\n   * 语法：\r\n     * 备份：mysqldump -u用户名 -p密码 数据库名称 > 保存的路径\r\n       * ![image-20210801113833553](cloudDisk/markdown/JavaWeb笔记.assets\\image-20210801113833553.png)\r\n     * 还原：\r\n       1. 登录数据库\r\n          * ![image-20210801113907029](cloudDisk/markdown/JavaWeb笔记.assets\\image-20210801113907029.png)\r\n       2. 创建数据库\r\n          * ![image-20210801113946258](cloudDisk/markdown/JavaWeb笔记.assets\\image-20210801113946258.png)\r\n       3. 使用数据库\r\n          * ![image-20210801113957580](cloudDisk/markdown/JavaWeb笔记.assets\\image-20210801113957580.png)\r\n       4. 执行文件。 source 文件路径\r\n          * ![image-20210801114014227](cloudDisk/markdown/JavaWeb笔记.assets\\image-20210801114014227.png)\r\n\r\n2. 图形化工具\r\n\r\n   * 备份\r\n\r\n     ![image-20210801114115452](cloudDisk/markdown/JavaWeb笔记.assets\\image-20210801114115452.png)\r\n\r\n     ![image-20210801114126476](cloudDisk/markdown/JavaWeb笔记.assets\\image-20210801114126476.png)\r\n\r\n   * 还原\r\n\r\n     ![image-20210801114327048](cloudDisk/markdown/JavaWeb笔记.assets\\image-20210801114327048.png)\r\n\r\n# 九、多表查询\r\n\r\n* ### 查询语法：\r\n\r\n  select\r\n\r\n  ​		列名列表\r\n\r\n  from\r\n\r\n  ​		表名列表\r\n\r\n  where ...\r\n\r\n* ### 准备sql\r\n\r\n  ```sql\r\n  CREATE TABLE dep(\r\n  	dep_id INT PRIMARY KEY,\r\n  	dep_name VARCHAR(20)\r\n  );\r\n  INSERT INTO dep VALUES(\r\n  	1,\"机械电子工程\"),(\r\n  	2,\"计算机与科学\"\r\n  	);\r\n  CREATE TABLE stu(\r\n  	id INT PRIMARY KEY AUTO_INCREMENT, \r\n  	NAME VARCHAR(32) NOT NULL,\r\n  	age INT,\r\n  	sex VARCHAR(10),\r\n  	address VARCHAR(10),\r\n  	departmentID INT,\r\n  	CONSTRAINT stu_dep_fk FOREIGN KEY (departmentID) REFERENCES dep(dep_id) -- 添加外键\r\n  );\r\n  INSERT INTO stu VALUES(\r\n  	1,\"林江\",20,\"男\",\"常州\",1),(\r\n  	2,\"Tony\",20,\"男\",\"苏州\",2),(\r\n  	3,\"朱薛\",21,\"女\",\"苏州\",1),(\r\n  	4,\"柳岩\",20,\"女\",\"淮安\",2),(\r\n  	5,\"马云\",50,\"男\",\"杭州\",1),(\r\n  	6,\"马化腾\",43,\"男\",\"深圳\",2),(\r\n  	7,\"刘亦菲\",21,\"女\",\"北京\",2)	\r\n  ;\r\n  ```\r\n\r\n* ### 笛卡尔积：\r\n\r\n  * 有两个集合A，B。取这两个集合的所有组成情况。\r\n  * 要完成多表查询，需要消除无用的数据\r\n  * 例：\r\n    * 笛卡尔积生成的行数 = A集合行数 * B集合行数\r\n    * ![image-20210801120602791](cloudDisk/markdown/JavaWeb笔记.assets\\image-20210801120602791.png)\r\n\r\n* ### 多表查询分类：\r\n\r\n  1. #### 内连接查询：\r\n\r\n     1. ##### 隐式内连接：\r\n\r\n        * ```sql\r\n          -- 查询所有学生信息对应的系信息\r\n          SELECT * FROM stu,dep WHERE stu.`departmentID` = dep.`dep_id`;\r\n          ```\r\n\r\n          ![image-20210801121924281](cloudDisk/markdown/JavaWeb笔记.assets\\image-20210801121924281.png)\r\n\r\n        * ```sql\r\n          -- 查询学生表的名称，性别。系表名称\r\n          SELECT stu.`NAME`,stu.`sex`,dep.`dep_name` FROM stu,dep WHERE stu.`departmentID` = dep.`dep_id`;\r\n          ```\r\n\r\n          ![image-20210801121936896](cloudDisk/markdown/JavaWeb笔记.assets\\image-20210801121936896.png)\r\n\r\n        * ```sql\r\n          -- 企业开发，标准写法\r\n          SELECT\r\n          	t1.`NAME`, -- 学生表姓名\r\n          	t1.`sex`, -- 学生表性别\r\n          	t2.`dep_name` -- 系表名称\r\n          FROM\r\n          	stu t1,\r\n          	dep t2\r\n          WHERE\r\n          	t1.`departmentID` = t2.`dep_id`\r\n          ```\r\n\r\n     2. ##### 显式内连接：\r\n\r\n        * 语法：select 字段列表 from 表名1 [inner] join 表名2 on 条件;\r\n\r\n        * 例：\r\n\r\n          * ```sql\r\n            SELECT * FROM stu INNER JOIN dep ON stu.`departmentID` = dep.`dep_id`;\r\n            SELECT * FROM stu JOIN dep ON stu.`departmentID` = dep.`dep_id`;\r\n            ```\r\n\r\n          * ![image-20210801122458625](cloudDisk/markdown/JavaWeb笔记.assets\\image-20210801122458625.png)\r\n\r\n     3. ##### 内连接查询注意事项\r\n\r\n        1. 从哪些表中查询数据\r\n        2. 条件是什么\r\n        3. 查询哪些字段\r\n\r\n  2. #### 外连接查询\r\n\r\n     1. ##### 左外连接：\r\n\r\n        * 语法：select 字段列表 from 表1 left [outer] join 表2 on 条件;\r\n\r\n        * 查询的是左表所有数据及其交集部分 (交集部分指：内连接查询到的数据)\r\n\r\n        * 例：\r\n\r\n          * ![image-20210801123755913](cloudDisk/markdown/JavaWeb笔记.assets\\image-20210801123755913.png)\r\n\r\n            ![image-20210801123901627](cloudDisk/markdown/JavaWeb笔记.assets\\image-20210801123901627.png)\r\n\r\n          * ```sql\r\n            SELECT * FROM stu LEFT JOIN dep ON stu.`departmentID` = dep.`dep_id`;\r\n            ```\r\n\r\n          * ![image-20210801123829008](cloudDisk/markdown/JavaWeb笔记.assets\\image-20210801123829008.png)\r\n\r\n     2. ##### 右外连接：\r\n\r\n        * 语法：select 字段列表 from 表1 right[outer] join 表2 on 条件;\r\n        * 查询的是右表所有数据及其交集部分\r\n\r\n  3. #### 子查询：\r\n\r\n     * ##### 概念：查询中嵌套查询，称嵌套查询为子查询。\r\n\r\n     * 例：\r\n\r\n       ```sql\r\n       -- 查询年龄最小的学生\r\n       -- 1. 查询最小的年龄是多少 20\r\n       SELECT MIN(age) FROM stu;\r\n       -- 2. 查询学生信息，并且年龄最小20的\r\n       SELECT * FROM stu WHERE stu.`age`=20;\r\n       \r\n       -- 一条sql就能完成这个操作 - 子查询\r\n       SELECT * FROM stu WHERE stu.`age`=(SELECT MIN(age) FROM stu);\r\n       ```\r\n\r\n       ![image-20210801125002392](cloudDisk/markdown/JavaWeb笔记.assets\\image-20210801125002392-1627793535133.png)\r\n\r\n     * ##### 子查询不同情况\r\n\r\n       1. 子查询的结果是单行单列的：\r\n\r\n          ```sql\r\n          -- 子查询作为条件，使用运算符取判断。运算符：> >= < <= =\r\n          -- 子查询查询高于平均年龄的人\r\n          SELECT * FROM stu WHERE stu.`age` > (SELECT AVG(age) FROM stu);\r\n          ```\r\n\r\n       2. 子查询的结果是多行单列的：\r\n\r\n          ```sql\r\n          -- 子查询可以作为条件，使用in来判断\r\n          -- 查询”机械电子工程“和”计算机与科学“系的学生信息\r\n          SELECT dep_id FROM dep WHERE dep_name = \"机械电子工程\" OR dep_name = \"计算机与科学\";\r\n          SELECT * FROM stu WHERE departmentID = 1 OR departmentID = 2;\r\n          SELECT * FROM stu WHERE departmentID IN (1,2);\r\n          \r\n          -- 子查询\r\n          SELECT \r\n          	* \r\n          FROM \r\n             stu \r\n          WHERE \r\n             departmentID \r\n          IN (SELECT dep_id FROM dep WHERE dep_name = \"机械电子工程\" OR dep_name = \"计算机与科学\");\r\n          ```\r\n\r\n       3. 子查询的结果是多行多列的：\r\n\r\n          * 子查询可以作为一张虚拟的表参与查询\r\n\r\n          * 例：查询学生性别为女的员工信息和系信息\r\n\r\n            1. 子查询\r\n\r\n               ```sql\r\n               SELECT * FROM dep t1, (SELECT * FROM stu WHERE stu.`sex` = \"女\") t2\r\n               WHERE t1.`dep_id` = t2.departmentID;\r\n               ```\r\n\r\n               ![image-20210801132140024](cloudDisk/markdown/JavaWeb笔记.assets\\image-20210801132140024.png)\r\n\r\n            2. 普通内连接\r\n\r\n               ```sql\r\n               SELECT * FROM stu,dep WHERE stu.`departmentID`=dep.`dep_id` AND stu.`sex`=\"女\";\r\n               ```\r\n\r\n               ![image-20210801132343230](cloudDisk/markdown/JavaWeb笔记.assets\\image-20210801132343230.png)\r\n\r\n* ## 练习\r\n\r\n  * 已给出四表\r\n\r\n    ```sql\r\n    CREATE TABLE dept(\r\n    	id INT PRIMARY KEY PRIMARY KEY,\r\n    	dname VARCHAR(50),\r\n    	loc VARCHAR(50)\r\n    	);\r\n    INSERT INTO dept (id,dname,loc) VALUES\r\n    (10,\"教研部\",\"北京\"),\r\n    (20,\"学工部\",\"上海\"),\r\n    (30,\"销售部\",\"广州\"),\r\n    (40,\"财务部\",\"深圳\");\r\n    \r\n    CREATE TABLE job(\r\n    	id INT PRIMARY KEY,\r\n    	jname VARCHAR(20),\r\n    	description VARCHAR(50)\r\n    );\r\n    INSERT INTO job(id,jname,description) VALUES\r\n    (1,\"董事长\",\"管理整个公司，接单\"),\r\n    (2,\"经理\",\"管理部门员工\"),\r\n    (3,\"销售员\",\"向客人推销产品\"),\r\n    (4,\"文员\",\"使用办公软件\");\r\n    \r\n    CREATE TABLE emp(\r\n    	id INT PRIMARY KEY, \r\n    	ename VARCHAR(50),\r\n    	job_id INT,\r\n    	mgr INT,\r\n    	joindate DATE,\r\n    	salary DECIMAL(7,2),\r\n    	bonus DECIMAL(7,2),\r\n    	dept_id INT,\r\n    	CONSTRAINT emp_jobid_ref_job_id_fk FOREIGN KEY (job_id) REFERENCES job (id),\r\n    	CONSTRAINT emp_jobid_ref_job_dept_fk FOREIGN KEY (dept_id) REFERENCES dept (id)\r\n    );\r\n    INSERT INTO emp VALUES\r\n    (1001,\"孙悟空\",4,1004,\"2000-12-17\",\"8000.00\",NULL,20),\r\n    (1002,\"卢俊义\",3,1006,\"2001-02-20\",\"16000.00\",\"3000.00\",30),\r\n    (1003,\"林冲\",3,1006,\"2001-02-22\",\"12500.00\",\"5000.00\",30),\r\n    (1004,\"唐僧\",2,1009,\"2001-04-02\",\"29750.00\",NULL,20),\r\n    (1005,\"李逵\",4,1006,\"2001-09-28\",\"12500.00\",\"14000.00\",30),\r\n    (1006,\"宋江\",2,1009,\"2001-05-01\",\"28500.00\",NULL,30),\r\n    (1007,\"刘备\",2,1009,\"2001-09-01\",\"24500.00\",NULL,10),\r\n    (1008,\"猪八戒\",4,1004,\"2007-04-19\",\"30000.00\",NULL,20),\r\n    (1009,\"罗贯中\",1,NULL,\"2001-11-17\",\"50000.00\",NULL,10),\r\n    (1010,\"吴用\",3,1006,\"2001-09-08\",\"15000.00\",\"0.00\",30),\r\n    (1011,\"沙僧\",4,1004,\"2007-05-23\",\"11000.00\",NULL,20),\r\n    (1012,\"李逵\",4,1006,\"2001-12-03\",\"9500.00\",NULL,30),\r\n    (1013,\"小白龙\",4,1004,\"2001-12-03\",\"30000.00\",NULL,20),\r\n    (1014,\"关羽\",4,1007,\"2002-01-23\",\"13000.00\",NULL,10);\r\n    \r\n    CREATE TABLE salarygrade(\r\n    	grade INT PRIMARY KEY,\r\n    	losalary INT,\r\n    	hisalary INT\r\n    );\r\n    \r\n    INSERT INTO salarygrade(grade,losalary,hisalary) VALUES\r\n    (1,7000,12000),\r\n    (2,12010,14000),\r\n    (3,14010,20000),\r\n    (4,20010,30000),\r\n    (5,30010,99990);\r\n    ```\r\n\r\n    dept:\r\n\r\n    ​	![image-20210802105900103](cloudDisk/markdown/JavaWeb笔记.assets/image-20210802105900103.png)\r\n\r\n    emp:\r\n\r\n    ​	![image-20210802105923545](cloudDisk/markdown/JavaWeb笔记.assets/image-20210802105923545.png)\r\n\r\n    job:\r\n\r\n    ![image-20210802105941035](C:/Users/Tony/Desktop/image-20210802105941035.png)\r\n\r\n    salarygrade:\r\n\r\n    ![image-20210802110021407](cloudDisk/markdown/JavaWeb笔记.assets/image-20210802110021407.png)\r\n\r\n    ![image-20210802110035652](cloudDisk/markdown/JavaWeb笔记.assets/image-20210802110035652.png)\r\n\r\n  * 查询需求\r\n\r\n    1. 查询所有员工信息。查询员工编号，员工姓名，工资，职务名称，职务描述\r\n\r\n       ```sql\r\n       * * 1. SELECT \r\n              	t1.id,t1.ename,t1.salary,t2.jname,t2.description\r\n              FROM \r\n              	emp t1,job t2 \r\n              WHERE \r\n              	t1.job_id = t2.id\r\n       \r\n       \r\n       ```\r\n\r\n       ![image-20210802110721816](cloudDisk/markdown/JavaWeb笔记.assets/image-20210802110721816.png)\r\n\r\n    2. 查询员工编号，员工姓名，工资，职务名称，职务描述，部门名称，部门位置\r\n\r\n       ```sql\r\n       * * 1. SELECT \r\n              	t1.id,t1.ename,t1.salary,t2.jname,t2.description,t3.dname,t3.loc\r\n              FROM \r\n              	emp t1,job t2,dept t3\r\n              WHERE \r\n              	t1.job_id = t2.id AND t1.dept_id = t3.id\r\n       \r\n       \r\n       ```\r\n\r\n       ![image-20210802111021925](cloudDisk/markdown/JavaWeb笔记.assets/image-20210802111021925.png)\r\n\r\n    3. 查询员工姓名，工资，工资等级\r\n\r\n       ```sql\r\n       SELECT \r\n       	t1.ename,t1.salary,t2.grade\r\n       FROM \r\n       	emp t1,salarygrade t2\r\n       WHERE \r\n       	t1.salary >= t2.losalary AND t1.salary <= t2.hisalary\r\n       ```\r\n\r\n       ![image-20210802111744182](cloudDisk/markdown/JavaWeb笔记.assets/image-20210802111744182.png)\r\n\r\n    4. 查询员工姓名，工资，职务名称，职务描述，部门描述，部门位置，工资等级\r\n\r\n       ```sql\r\n       SELECT \r\n       	t1.ename,t1.salary,t2.grade,t3.jname,t3.description,t4.dname,t4.loc\r\n       FROM \r\n       	emp t1,salarygrade t2,job t3,dept t4\r\n       WHERE \r\n       	t1.salary >= t2.losalary AND \r\n       	t1.salary <= t2.hisalary AND \r\n       	t1.job_id = t3.id AND \r\n       	t1.dept_id = t4.id\r\n       ```\r\n\r\n       ![image-20210802112309154](cloudDisk/markdown/JavaWeb笔记.assets/image-20210802112309154.png)\r\n\r\n    5. **查询出部门编号，部门名称，部门位置，部门人数**\r\n\r\n       ```sql\r\n       方法一（我自己写的）：\r\n       SELECT \r\n       	t1.id,t1.dname,t1.loc,COUNT(t2.id)\r\n       FROM \r\n       	dept t1, emp t2\r\n       WHERE \r\n       	t1.id = t2.dept_id\r\n       GROUP BY t1.dname;\r\n       \r\n       方法二：\r\n       SELECT \r\n       	t1.`id`,t1.`dname`,t1.`loc`,t2.total\r\n       FROM \r\n       	dept t1,\r\n       	(\r\n       	SELECT \r\n       		dept_id,COUNT(id) total\r\n       	FROM\r\n       		emp\r\n       	GROUP BY dept_id\r\n       	) t2\r\n       WHERE t1.`id` = t2.dept_id;\r\n       ```\r\n\r\n       ![image-20210802114728370](cloudDisk/markdown/JavaWeb笔记.assets/image-20210802114728370.png)\r\n\r\n    6. 查询所有员工的姓名及其直接上级的姓名，没有领导的员工也需要查询\r\n\r\n       ```sql\r\n       SELECT \r\n       	t1.`ename` 员工姓名,\r\n       	t2.`ename` 上级姓名\r\n       FROM \r\n       	emp t1\r\n       LEFT JOIN \r\n       	emp t2\r\n       ON\r\n       	t1.`mgr` = t2.id\r\n       ```\r\n\r\n       ![image-20210802115535968](cloudDisk/markdown/JavaWeb笔记.assets/image-20210802115535968.png)\r\n\r\n​	\r\n\r\n# 十、事务\r\n\r\n1. ## 事务的基本介绍\r\n\r\n   1. 概念：\r\n\r\n      * 如果一个包含多个步骤的业务操作，被事务管理，那么这些操作要么同时成功，要么同时失败。\r\n\r\n   2. 操作：\r\n\r\n      1. 开始事务：start transaction;\r\n      2. 回滚：rollback;\r\n      3. 提交：commit;\r\n\r\n   3. 例子：\r\n\r\n      ```sql\r\n      CREATE TABLE account(\r\n      	id INT PRIMARY KEY AUTO_INCREMENT,\r\n      	NAME VARCHAR(10),\r\n      	balance DOUBLE\r\n      );\r\n      -- 添加数据\r\n      INSERT INTO account (NAME,balance) VALUES (\"zhangsan\",1000),(\"lisi\",1000);\r\n      \r\n      SELECT * FROM account;\r\n      UPDATE account SET balance = 1000;\r\n      \r\n      -- 张三给李四转账 500 元\r\n      -- 0. 开启事务\r\n      START  TRANSACTION;\r\n      -- 1. 张三账户 -500\r\n      UPDATE account SET balance = balance -500 WHERE NAME = \"zhangsan\";\r\n      -- 2. 李四账户 +500\r\n      出错了\r\n      UPDATE account SET balance = balance +500 WHERE NAME = \"lisi\";\r\n      \r\n      \r\n      -- 发现执行没问题，提交事务\r\n      -- commit;\r\n      \r\n      -- 发现出现问题了，回滚事务\r\n      ROLLBACK;\r\n      ```\r\n\r\n   4. MySQL 数据库中默认自动提交\r\n\r\n      * 事务提交的两种方式\r\n        1. 自动提交\r\n           * mysql就是自动提交的\r\n           * 一条DML（增删改）语句会自动提交一次事务。\r\n        2. 手动提交：\r\n           * 需要开启事务，再提交\r\n           * Oracle 数据库默认是手动提交事务\r\n      * 修改默认的提交方式：\r\n        * 查看事务的默认提交方式：select @@autocommit; -- 1代表自动提交   0 代表手动提交\r\n        * 修改默认提交方式：set @@autocommit = 0;\r\n\r\n2. ## 事物的四大特征\r\n\r\n   * 原子性：是不可分割的最小操作单位，要么同时成功，要么同时失败；\r\n   * 持久性：当事务提交或回滚后，数据库会持久化的保存数据；\r\n   * 隔离性：多个事务之间，相互独立；\r\n   * 一致性：事务操作前后没数据总量不变\r\n\r\n3. ## 事物的隔离级别（了解）\r\n\r\n   * 概念：多个事务之间隔离的，相互独立的、但是多个事务操作同一批数据，则会引发一些问题，设置不同的隔离级别就可以解决这些问题\r\n\r\n   * 存在的问题：\r\n\r\n     1. 脏读：一个事务，读到另一个事务中没有提交的数据\r\n     2. 不可重复读（虚读）：在同一个事务中，两次读到的数据不一样\r\n     3. 幻读：一个事务操作（DML）数据表中的所有记录，另一个事务添加了一条数据，则第一个事务查询不到自己的修改\r\n\r\n   * 隔离级别：\r\n\r\n     1. read uncommitted: 读未提交\r\n        * 产生的问题：脏读、不可重复读、幻读\r\n     2. read committed: 读已提交（Oracle）\r\n        * 产生的问题：不可重复读、幻读\r\n     3. repeatable read: 可重复读（MySQL默认）\r\n        * 产生的问题：幻读\r\n     4. serializable: 串行化（类似线程并发加锁）\r\n        * 可以解决所有问题\r\n\r\n     * 注意：隔离级别从小到大安全性越来越高，但是效率越低\r\n     * 数据库查询隔离级别：\r\n       * select @@tx_isolation;\r\n     * 数据库设置隔离级别：\r\n       * set global transaction isolation level 级别字符串;\r\n\r\n# 十一、DCL\r\n\r\n* SQL分类\r\n\r\n  1. DDL：操作数据库和表\r\n  2. DML：增删改表中数据\r\n  3. DQL：查询表中数据\r\n  4. DCL：管理用户，授权\r\n\r\n* DBA：数据库管理员\r\n\r\n* DCL：管理用户，授权\r\n\r\n  1. #### 管理用户\r\n\r\n     1. ##### 添加用户：\r\n\r\n        ```sql\r\n        -- 创建用户 - 语法\r\n        CREATE USER \"用户名\"@\"主机名\" IDENTIFIED BY \"密码\";\r\n        -- 例\r\n        CREATE USER \"zhangsan\"@\"localhost\" IDENTIFIED BY \"123\";\r\n        CREATE USER \"lisi\"@\"%\" IDENTIFIED BY \"123\";\r\n        ```\r\n\r\n        * 通配符：% 标识可以在任意主机使用用户登录数据库\r\n\r\n     2. ##### 删除用户：\r\n\r\n        ```sql\r\n        -- 删除用户 - 语法\r\n        DROP USER \"用户名\"@\"主机名\";\r\n        \r\n        -- 例\r\n        DROP USER \"zhangsan\"@\"localhost\";\r\n        ```\r\n\r\n     3. ##### 修改用户密码：\r\n\r\n        ```sql\r\n        -- 修改lisi用户密码为 abc\r\n        UPDATE USER SET authentication_string = PASSWORD(\"abc\") WHERE USER = \"lisi\";\r\n        -- 修改root用户密码为 123\r\n        SET PASSWORD FOR \"root\"@\"localhost\" = PASSWORD(\"123\");\r\n        ```\r\n\r\n        **mysql中忘了root密码怎么办？**\r\n\r\n         1. cmd -- > net stop mysql 停止mysql服务（如果不行，试着把mysql改成mysql+\"版本号\"）\r\n\r\n         2. 使用无验证方式启动mysql服务：mysqld --skip-grant-tables\r\n\r\n         3. 打开新的cmd窗口，直接输入mysql命令，敲回车。就可以登录成功\r\n\r\n         4. use mysql;\r\n\r\n         5. SET PASSWORD FOR \"root\"@\"localhost\" = PASSWORD(\"新密码\");\r\n\r\n            * 如果出现了修改密码报错：\r\n\r\n              ERROR 1290 (HY000): The MySQL server is running with the --skip-grant-tables option so it cannot execute this statement\r\n\r\n            * 先执行：flush privileges;\r\n\r\n         6. 关闭两个窗口\r\n\r\n         7. 打开任务管理器，手动结束mysqld.exe 的进程\r\n\r\n         8. 启动mysql服务\r\n\r\n         9. 使用新密码登录。\r\n\r\n     4. ##### 查询用户：\r\n\r\n        ```sql\r\n        -- 1.切换到mysql数据库\r\n        USE mysql;\r\n        -- 2. 查询user表\r\n        SELECT * FROM USER;\r\n        ```\r\n\r\n  2. #### 授权管理：\r\n\r\n     1. ##### 查询权限：\r\n\r\n        ```sql\r\n        -- 查询权限 - 格式\r\n        SHOW GRANTS FOR \"用户名\"@\"主机名\";\r\n        \r\n        -- 例\r\n        SHOW GRANTS FOR \"lisi\"@\"%\";\r\n        SHOW GRANTS FOR \"root\"@\"localhost\";\r\n        ```\r\n\r\n     2. ##### 授予权限：\r\n\r\n        ```sql\r\n        -- 授予权限 - 格式\r\n        GRANT 权限列表 ON 数据库名.表名 TO \"用户名\"@\"主机名\";\r\n        \r\n        -- 例（给李四授予db3数据库中account表的查询、删除和修改权限）\r\n        \r\n        \r\n        -- 给张三用户授予所有权限，在任意数据库任意表上\r\n        GRANT ALL ON *.* TO \"zhangsan\"@\"localhost\";\r\n        ```\r\n\r\n     3. ##### 撤销权限：\r\n\r\n        ```sql\r\n        1. 1. -- 撤销权限：\r\n              REVOKE 权限列表 ON 数据库名.表名 FROM \"用户名\"@\"主机名\";\r\n        \r\n              -- 例（撤销李四对于db3数据库中account表的修改权限）\r\n              REVOKE UPDATE ON db3.`account` FROM \"lisi\"@\"%\";\r\n        ```\r\n\r\n     4. 刷新权限：FLUSH PRIVILEGES;\r\n\r\n# 十二、JDBC\r\n\r\n## 12.1 **概念：**\r\n\r\n**Java DataBase connectivity Java 数据库连接，Java语言操作数据库**\r\n\r\n* **JDBC本质**：其实是官方（sun公司）定义的一套操作所有关系型数据库的规则，即接口。各个数据库厂商去实现这套接口，提供数据库驱动的jar包。我们可以使用这套接口（JDBC）编程，真正执行的代码时驱动jar包中的实现类\r\n\r\n* **快速入门**\r\n\r\n  * 步骤：\r\n\r\n    1. 导入驱动jar包 mysql-connector-java-8.0.26.jar\r\n       1. 复制  mysql-connector-java-8.0.26.jar 到项目的lib目录下\r\n       2. 右击 --> Add as library\r\n    2. 注册驱动\r\n    3. 获取数据库连接对象 Connection\r\n    4. 定义sql语句\r\n    5. 获取执行sql语句的对象 Statement\r\n    6. 执行sql，接收返回结果\r\n    7. 处理结果\r\n    8. 释放资源\r\n\r\n  * 代码实现：\r\n\r\n    ```java\r\n    public class Test01 {\r\n        public static void main(String[] args) throws ClassNotFoundException, SQLException {\r\n    //        1. 导入驱动jar包\r\n    //        2. 注册驱动\r\n            Class.forName(\"com.mysql.jdbc.Driver\");\r\n    //        3. 获取数据库连接对象 Connection\r\n            Connection connection = DriverManager.getConnection(\"jdbc:mysql://localhost:3306/db3\", \"root\", \"123\");\r\n    //        4. 定义sql语句\r\n            String sql = \"update account set balance = 500 where id = 1\";\r\n    //        5. 获取执行sql语句的对象 Statement\r\n            Statement statement = connection.createStatement();\r\n    //        6. 执行sql，接收返回结果\r\n            int count = statement.executeUpdate(sql);\r\n    //        7. 处理结果\r\n            System.out.println(count);\r\n    //        8. 释放资源\r\n            statement.close();\r\n            connection.close();\r\n        }\r\n    }\r\n    ```\r\n\r\n\r\n## 12.2 详解各个对象：\r\n\r\n### 12.21 DriverManager ：驱动管理对象\r\n\r\n* 功能：\r\n\r\n  1. 注册驱动：告诉程序该使用哪一个数据库驱动jar\r\n\r\n     static void registerDriver(Driver driver): 注册与给定的驱动程序 DriverManager\r\n\r\n     写代码使用：Class.forName(\"com.mysql.jdbc.Driver\")；\r\n\r\n     通过\"com.mysql.jdbc.Driver\"中源码发现，类中有个静态代码块（类被加载时调用）\r\n\r\n     ![image-20210803142750608](cloudDisk/markdown/JavaWeb笔记.assets/image-20210803142750608.png)\r\n\r\n     注意：mysql5之后的驱动jar包可以省略注册驱动的步骤。\r\n\r\n  2. 获取数据库连接：\r\n\r\n     * 方法：\r\n\r\n       ```java\r\n       static Connection getConnection(String url,\r\n           String user, String password)\r\n       ```\r\n\r\n     * 参数：\r\n\r\n       * url ：指定连接的路径\r\n         * 语法：”jabc:mysql://ip地址(域名):端口号/数据库名称\"\r\n         * 例子：\"jdbc:mysql://localhost:3306/db3\"\r\n         * 细节：如果连接的时本机的mysql服务器，并且mysql服务器默认端口是3306,则url可以简写为：”jabc:mysql:///数据库名称\"\r\n       * user ：用户名\r\n       * password ：密码\r\n\r\n### 12.22 connection ：数据库连接对象\r\n\r\n1. 功能：\r\n   1. 获取执行sql 的对象\r\n      * Statement createStatement()\r\n      * PreparedStatement prepareStatemrnt(String sql)\r\n   2. 管理事务：\r\n      * 开启事务：void setAutoCommit(boolean autoCommit) : 调用该方法设置参数为false，即开启事务\r\n      * 提交事务：commit()\r\n      * 回滚事务：rollback()\r\n\r\n### 12.23 statement ：执行sql的对象\r\n\r\n1. 执行sql\r\n\r\n   1. boolean execute(String sql) : 可以执行任意的sql (了解)\r\n   2. int executeUpdate(String sql) : 执行DML（insert,update）语句、DDL(create,alter,drop)语句\r\n      * 返回值：影响的行数，可以通过这个影响的行数判断DML语句是否执行成功，返回值>0的则执行成功，反之，则失败。\r\n   3. ResultSet executeQuery(String sql) : 执行DQL(select)语句\r\n\r\n2. 练习：\r\n\r\n   1. account表 添加一条记录\r\n\r\n      ```java\r\n      public static void main(String[] args) {\r\n          Connection connection = null;\r\n          Statement statement = null;\r\n          try {\r\n              // 1. 注册驱动\r\n              Class.forName(\"com.mysql.jdbc.Driver\");\r\n              // 2. 定义sql\r\n              String sql = \"insert into account values(null,\'李华\',3000)\";\r\n              // 3. 获取Connection对象\r\n              connection = DriverManager.getConnection(\"jdbc:mysql:///db3\",\"root\",\"123\");\r\n              // 4. 获取执行sql的对象 Statement\r\n              statement = connection.createStatement();\r\n              // 5. 执行sql\r\n              int count = statement.executeUpdate(sql);\r\n              // 6. 处理结果\r\n              System.out.println(count);\r\n              if(count > 0){\r\n                  System.out.println(\"添加成功!!!\");\r\n              }else {\r\n                  System.out.println(\"添加失败!!!\");\r\n              }\r\n          } catch (ClassNotFoundException e) {\r\n              e.printStackTrace();\r\n          } catch (SQLException throwables) {\r\n              throwables.printStackTrace();\r\n          }finally {\r\n              // 7. 释放资源\r\n              if(connection != null){\r\n                  try {\r\n                      connection.close();\r\n                  } catch (SQLException throwables) {\r\n                      throwables.printStackTrace();\r\n                  }\r\n              }\r\n              if(statement != null){\r\n                  try {\r\n                      statement.close();\r\n                  } catch (SQLException throwables) {\r\n                      throwables.printStackTrace();\r\n                  }\r\n              }\r\n          }\r\n      }\r\n      ```\r\n\r\n      ![image-20210804112807128](cloudDisk/markdown/JavaWeb笔记.assets/image-20210804112807128.png)\r\n\r\n   2. account表 修改一条记录\r\n\r\n      ```java\r\n      package com.tony.test02;\r\n      \r\n      import java.sql.Connection;\r\n      import java.sql.DriverManager;\r\n      import java.sql.SQLException;\r\n      import java.sql.Statement;\r\n      \r\n      public class JDBCDemo {\r\n          public static void main(String[] args) {\r\n              Connection connection = null;\r\n              Statement statement = null;\r\n              try {\r\n                  // 1. 注册驱动\r\n                  Class.forName(\"com.mysql.jdbc.Driver\");\r\n                  // 2. 定义sql\r\n                  String sql = \"update account set balance = 3500 where name = \'李华\'\";\r\n                  // 3. 获取Connection对象\r\n                  connection = DriverManager.getConnection(\"jdbc:mysql:///db3\",\"root\",\"123\");\r\n                  // 4. 获取执行sql的对象 Statement\r\n                  statement = connection.createStatement();\r\n                  // 5. 执行sql\r\n                  int count = statement.executeUpdate(sql);\r\n                  // 6. 处理结果\r\n                  System.out.println(count);\r\n                  if(count > 0){\r\n                      System.out.println(\"修改成功!!!\");\r\n                  }else {\r\n                      System.out.println(\"修改失败!!!\");\r\n                  }\r\n              } catch (ClassNotFoundException e) {\r\n                  e.printStackTrace();\r\n              } catch (SQLException throwables) {\r\n                  throwables.printStackTrace();\r\n              }finally {\r\n                  // 7. 释放资源\r\n                  if(connection != null){\r\n                      try {\r\n                          connection.close();\r\n                      } catch (SQLException throwables) {\r\n                          throwables.printStackTrace();\r\n                      }\r\n                  }\r\n                  if(statement != null){\r\n                      try {\r\n                          statement.close();\r\n                      } catch (SQLException throwables) {\r\n                          throwables.printStackTrace();\r\n                      }\r\n                  }\r\n              }\r\n          }\r\n      }\r\n      ```\r\n\r\n      ![image-20210804112918519](cloudDisk/markdown/JavaWeb笔记.assets/image-20210804112918519.png)\r\n\r\n   3. account表 删除一条记录\r\n\r\n      ```java\r\n      package com.tony.test02;\r\n      \r\n      import java.sql.Connection;\r\n      import java.sql.DriverManager;\r\n      import java.sql.SQLException;\r\n      import java.sql.Statement;\r\n      \r\n      public class JDBCDemo {\r\n          public static void main(String[] args) {\r\n              Connection connection = null;\r\n              Statement statement = null;\r\n              try {\r\n                  // 1. 注册驱动\r\n                  Class.forName(\"com.mysql.jdbc.Driver\");\r\n                  // 2. 定义sql\r\n                  String sql = \"delete from account where name = \'李华\'\";\r\n                  // 3. 获取Connection对象\r\n                  connection = DriverManager.getConnection(\"jdbc:mysql:///db3\",\"root\",\"123\");\r\n                  // 4. 获取执行sql的对象 Statement\r\n                  statement = connection.createStatement();\r\n                  // 5. 执行sql\r\n                  int count = statement.executeUpdate(sql);\r\n                  // 6. 处理结果\r\n                  System.out.println(count);\r\n                  if(count > 0){\r\n                      System.out.println(\"删除成功!!!\");\r\n                  }else {\r\n                      System.out.println(\"删除失败!!!\");\r\n                  }\r\n              } catch (ClassNotFoundException e) {\r\n                  e.printStackTrace();\r\n              } catch (SQLException throwables) {\r\n                  throwables.printStackTrace();\r\n              }finally {\r\n                  // 7. 释放资源\r\n                  if(connection != null){\r\n                      try {\r\n                          connection.close();\r\n                      } catch (SQLException throwables) {\r\n                          throwables.printStackTrace();\r\n                      }\r\n                  }\r\n                  if(statement != null){\r\n                      try {\r\n                          statement.close();\r\n                      } catch (SQLException throwables) {\r\n                          throwables.printStackTrace();\r\n                      }\r\n                  }\r\n              }\r\n          }\r\n      }\r\n      ```\r\n\r\n      ![image-20210804113904905](cloudDisk/markdown/JavaWeb笔记.assets/image-20210804113904905.png)\r\n\r\n### 12.24 ResultSet ：结果集对象，封装查询结果\r\n\r\n* next() : 游标向下移动一行\r\n\r\n* getXxx(参数) : 获取数据\r\n\r\n  * Xxx : 代表数据类型	如：int getInt(), String getString(1)\r\n  * String : 代表列名称     如：getDouble(\"balance\")\r\n  * 参数：\r\n    1. int : 代表列的编号，从1开始	如：getString(1)\r\n    2. String : 代表列的名称，如：getDouble(\"balance\")\r\n\r\n* 获取zhangsan信息\r\n\r\n  ![image-20210804120002332](cloudDisk/markdown/JavaWeb笔记.assets/image-20210804120002332.png)\r\n\r\n  ```java\r\n  package com.tony.test02;\r\n  \r\n  import java.sql.*;\r\n  \r\n  public class JDBCDemo {\r\n      public static void main(String[] args) {\r\n          Connection connection = null;\r\n          Statement statement = null;\r\n          ResultSet resultSet = null;\r\n          try {\r\n              // 1. 注册驱动\r\n              Class.forName(\"com.mysql.jdbc.Driver\");\r\n              // 2. 定义sql\r\n              String sql = \"select * from account\";\r\n              // 3. 获取Connection对象\r\n              connection = DriverManager.getConnection(\"jdbc:mysql:///db3\",\"root\",\"123\");\r\n              // 4. 获取执行sql的对象 Statement\r\n              statement = connection.createStatement();\r\n              // 5. 执行sql\r\n              resultSet = statement.executeQuery(sql);\r\n              // 6. 处理结果\r\n              // 6.1 让游标向下游动一行\r\n              resultSet.next();\r\n              int id = resultSet.getInt(1);\r\n              String name = resultSet.getString(\"name\");\r\n              String balance = resultSet.getString(\"balance\");\r\n              System.out.println(id+\",\"+name+\",\"+balance);\r\n  \r\n  \r\n          } catch (ClassNotFoundException e) {\r\n              e.printStackTrace();\r\n          } catch (SQLException throwables) {\r\n              throwables.printStackTrace();\r\n          }finally {\r\n              // 7. 释放资源\r\n              if(connection != null){\r\n                  try {\r\n                      connection.close();\r\n                  } catch (SQLException throwables) {\r\n                      throwables.printStackTrace();\r\n                  }\r\n              }\r\n              if(statement != null){\r\n                  try {\r\n                      statement.close();\r\n                  } catch (SQLException throwables) {\r\n                      throwables.printStackTrace();\r\n                  }\r\n              }\r\n              if(statement != null){\r\n                  try {\r\n                      resultSet.close();\r\n                  } catch (SQLException throwables) {\r\n                      throwables.printStackTrace();\r\n                  }\r\n              }\r\n          }\r\n      }\r\n  }\r\n  ```\r\n\r\n  result: ![image-20210804115953708](cloudDisk/markdown/JavaWeb笔记.assets/image-20210804115953708.png)\r\n\r\n* 注意\r\n\r\n  * 使用步骤\r\n    1. 游标向下移动一行\r\n    2. 判断是否有数据\r\n    3. 获取数据\r\n\r\n  ```java\r\n  // 6.1 让游标向下游动一行\r\n  while (resultSet.next()){\r\n      int id = resultSet.getInt(1);\r\n      String name = resultSet.getString(\"name\");\r\n      String balance = resultSet.getString(\"balance\");\r\n      System.out.println(id+\",\"+name+\",\"+balance);\r\n  }\r\n  ```\r\n\r\n  result:![image-20210804120940654](cloudDisk/markdown/JavaWeb笔记.assets/image-20210804120940654.png)\r\n\r\n### 12.25 PreparedStatement ：执行sql的对象\r\n\r\n1. SQL注入问题：在拼接sql时，有一些sql的特殊关键字参与字符串的拼接。会造成安全性问题\r\n\r\n   1. 输入用户名，输入密码：a\' or \'a\' = \'a\r\n   2. sql : select * from user where username = \'fhdsikf\' and password = \'a\' or \'a\' = \'a\'\r\n\r\n2. 解决sql注入问题：使用PreparedStatement对象来解决\r\n\r\n3. 预编译的sql：参数使用 ? 作为占位符\r\n\r\n4. 步骤：\r\n\r\n   1. 导入驱动jar包 mysql-connector-java-5.1.37-bin.jar\r\n\r\n   2. 注册驱动\r\n\r\n   3. 获取数据库连接对象 Connection\r\n\r\n   4. 定义sql\r\n\r\n      * 注意：sql的参数使用 ? 作为占位符。 如：select * from user where username = ? and password = ?;\r\n\r\n   5. 获取执行sql语句的对象 PreparedStatement    Connection 对象的方法 prepareStatement(String sql)\r\n\r\n   6. 给 ? 赋值：\r\n\r\n      * 方法：setXxx(参数1, 参数2)\r\n\r\n        参数1 - ? 的位置编号 从1 开始\r\n\r\n        参数2 - ? 的值\r\n\r\n   7. 执行sql, 接收返回的结果，不需要传递sql参数\r\n\r\n   8. 处理结果\r\n\r\n   9. 释放资源\r\n\r\n5. 注意：后期都会使用PreparedStatement来完成增删改查的所有操作\r\n\r\n   1. 可以防止SQL注入\r\n   2. 效率更高\r\n\r\n## 12.3 抽取JDBC工具类 ：JDBCUtitls\r\n\r\n* 目的：简化书写\r\n\r\n* 分析\r\n\r\n  1. 注册驱动也抽取\r\n\r\n  2. 抽取一个方法获取连接对象\r\n\r\n     * 需求：不想传递参数（麻烦），还得保证工具类的通用性。\r\n\r\n     * 解决：配置文件\r\n\r\n       jdbc.properties\r\n\r\n       ​	url=\r\n\r\n       ​	user=\r\n\r\n       ​	password=\r\n\r\n  3. 抽取一个方法释放资源\r\n\r\n* 代码实现\r\n\r\n  jdbc.properties:\r\n\r\n  ```txt\r\n  url=jdbc:mysql:///db3\r\n  user=root\r\n  password=123\r\n  driver=com.mysql.jdbc.Driver\r\n  ```\r\n\r\n  JDBCUtitls 工具类：\r\n\r\n  ```java\r\n  package com.tony.util;\r\n  import java.io.FileReader;\r\n  import java.io.IOException;\r\n  import java.net.URL;\r\n  import java.nio.channels.ClosedSelectorException;\r\n  import java.sql.*;\r\n  import java.util.Properties;\r\n  \r\n  public class JDBCUtils {\r\n      private static String url;\r\n      private static String user;\r\n      private static String password;\r\n      private static String driver;\r\n      static {\r\n          //读取资源文件，获取值\r\n          try {\r\n              // 1. 创建Properties集合类\r\n              Properties pro = new Properties();\r\n  \r\n              // 获取src路径下文件的方式 ---> Classloader 类加载器\r\n              ClassLoader classLoader = JDBCUtils.class.getClassLoader();\r\n              URL res = classLoader.getResource(\"jdbc.properties\");\r\n              String path = res.getPath();\r\n  \r\n              // 2. 加载文件\r\n              // pro.load(new FileReader(\"E:\\\\学习\\\\JavaWeb\\\\Peoject\\\\src\\\\jdbc.properties\"));\r\n              pro.load(new FileReader(path));\r\n  \r\n              // 3. 获取数据，赋值\r\n              JDBCUtils.url = pro.getProperty(\"url\");\r\n              user = pro.getProperty(\"user\");\r\n              password = pro.getProperty(\"password\");\r\n              driver = pro.getProperty(\"driver\");\r\n              //4. 注册驱动\r\n              Class.forName(driver);\r\n          } catch (IOException e) {\r\n              e.printStackTrace();\r\n          } catch (ClassNotFoundException e) {\r\n              e.printStackTrace();\r\n          }\r\n      }\r\n  \r\n      /*\r\n       * 获取连接对象\r\n       * */\r\n      public static Connection getConnection() throws SQLException {\r\n          return DriverManager.getConnection(url,user,password);\r\n      }\r\n  \r\n      public static void close(ResultSet rs,Statement stmt, Connection conn){\r\n          if(rs != null){\r\n              try {\r\n                  rs.close();\r\n              } catch (SQLException throwables) {\r\n                  throwables.printStackTrace();\r\n              }\r\n          }\r\n          if(stmt != null){\r\n              try {\r\n                  stmt.close();\r\n              } catch (SQLException throwables) {\r\n                  throwables.printStackTrace();\r\n              }\r\n          }\r\n          if(conn != null){\r\n              try {\r\n                  conn.close();\r\n              } catch (SQLException throwables) {\r\n                  throwables.printStackTrace();\r\n              }\r\n          }\r\n      }\r\n  }\r\n  ```\r\n\r\n  测试类：\r\n\r\n  ```java\r\n  package com.tony.test02;\r\n  \r\n  import com.tony.util.JDBCUtils;\r\n  \r\n  import javax.swing.text.Utilities;\r\n  import java.sql.*;\r\n  \r\n  public class JDBCDemo {\r\n      public static void main(String[] args) {\r\n          Connection connection = null;\r\n          Statement statement = null;\r\n          ResultSet resultSet = null;\r\n          try {\r\n              connection = JDBCUtils.getConnection();\r\n              // 2. 定义sql\r\n              String sql = \"select * from account\";\r\n              // 4. 获取执行sql的对象 Statement\r\n              statement = connection.createStatement();\r\n              // 5. 执行sql\r\n              resultSet = statement.executeQuery(sql);\r\n              // 6. 处理结果\r\n              // 6.1 让游标向下游动一行\r\n              while (resultSet.next()){\r\n                  int id = resultSet.getInt(1);\r\n                  String name = resultSet.getString(\"name\");\r\n                  String balance = resultSet.getString(\"balance\");\r\n                  System.out.println(id+\",\"+name+\",\"+balance);\r\n              }\r\n          } catch (SQLException throwables) {\r\n              throwables.printStackTrace();\r\n          } finally {\r\n              // 7. 释放资源\r\n              JDBCUtils.close(resultSet,statement,connection);\r\n          }\r\n      }\r\n  }\r\n  ```\r\n\r\n### 12.31 练习：\r\n\r\n* 需求：\r\n\r\n  1. 通过键盘录入用户名和密码\r\n  2. 判断用户是否输入成功\r\n\r\n* 步骤：\r\n\r\n  1. 创建数据库表 user\r\n\r\n     ```sql\r\n     CREATE TABLE USER(\r\n         id INT PRIMARY KEY AUTO_INCREMENT,\r\n         username VARCHAR(32),\r\n         PASSWORD VARCHAR(32)\r\n     );\r\n     INSERT INTO USER VALUES(NULL,\"zhangsan\",\"123\"),(NULL,\"lisi\",\"234\");\r\n     ```\r\n\r\n  2. 抽取JDBC工具类 ：JDBCUtitls\r\n\r\n  3. 测试类（主方法和login方法）\r\n\r\n     ```java\r\n     package com.tony.test03;\r\n     \r\n     import com.tony.util.JDBCUtils;\r\n     \r\n     import java.sql.*;\r\n     import java.util.Scanner;\r\n     \r\n     public class JDBCDemo {\r\n         public static void main(String[] args) {\r\n             Scanner scanner = new Scanner(System.in);\r\n             System.out.print(\"输入用户名：\");\r\n             String username = scanner.nextLine();\r\n             System.out.print(\"输入密码：\");\r\n             String password = scanner.nextLine();\r\n             if(login(username,password)){\r\n                 System.out.println(\"登录成功！\");\r\n             } else{\r\n                 System.out.println(\"账号密码错误！\");\r\n             }\r\n         }\r\n     \r\n         public static boolean login(String username, String password){\r\n             if(username == null || password == null){\r\n                 return false;\r\n             }\r\n             // 判断数据库是否登录成功\r\n             Connection connection = null;\r\n             PreparedStatement pstmt = null;\r\n             ResultSet resultSet = null;\r\n             // 1. 获取连接\r\n             try{\r\n                 connection = JDBCUtils.getConnection();\r\n                 // 2. 定义sql\r\n                 String sql = \"select * from user where username = ? and password =?\";\r\n                 // 3. 获取执行sql的对象\r\n                 pstmt = connection.prepareStatement(sql);\r\n                 // 4. 给 ? 赋值\r\n                 pstmt.setString(1,username);\r\n                 pstmt.setString(2,password);\r\n                 // 5. 执行查询不需要传递sql\r\n                 resultSet = pstmt.executeQuery();\r\n                 return resultSet.next();\r\n             } catch (SQLException throwables) {\r\n                 throwables.printStackTrace();\r\n             }finally {\r\n                 JDBCUtils.close(resultSet,pstmt,connection);\r\n             }\r\n     \r\n             return  false;\r\n         }\r\n     }\r\n     ```\r\n\r\n\r\n## 12.4 JDBC控制事务\r\n\r\n1. 事务：一个包含多个步骤的业务操作。如果这个事务操作被事务管理，则这多个步骤要么同时成功，要么同时失败。\r\n\r\n2. 操作：\r\n\r\n   1. 开启事务\r\n   2. 提交事务\r\n   3. 回滚事务\r\n\r\n3. 使用Connection对来来管理事务\r\n\r\n   * 开始事务：setAutoCommit(boolean autoCommit); 调用该方法参数为false，即开启事务。\r\n     * 在执行sql之前开启事务\r\n\r\n   * 回滚事务：rollback();\r\n     * 当所有sql都执行完提交事务\r\n\r\n   * 提交事务：commit();\r\n     * 在catch中回滚事务\r\n\r\n4. 练习 - 李四向张三转账500\r\n\r\n   ```java\r\n   package com.tony.test04;\r\n   \r\n   import com.tony.util.JDBCUtils;\r\n   \r\n   import java.sql.Connection;\r\n   import java.sql.PreparedStatement;\r\n   import java.sql.ResultSet;\r\n   import java.sql.SQLException;\r\n   \r\n   public class zhuanzhangDemo {\r\n       public static void main(String[] args) {\r\n           Connection connection = null;\r\n           PreparedStatement preparedStatement = null;\r\n           try {\r\n               connection = JDBCUtils.getConnection();\r\n               // 开启事务\r\n               connection.setAutoCommit(false);\r\n   \r\n               String sql = \"UPDATE account SET balance = balance+? where name = ?\";\r\n               preparedStatement = connection.prepareStatement(sql);\r\n               preparedStatement.setInt(1,500);\r\n               preparedStatement.setString(2,\"zhangsan\");\r\n               int i = preparedStatement.executeUpdate();\r\n               sql = \"UPDATE account SET balance = balance-? where name = ?\";\r\n               preparedStatement = connection.prepareStatement(sql);\r\n               preparedStatement.setInt(1,500);\r\n               \r\n               //手动制造异常\r\n               int ccds = 1/0;\r\n               \r\n               preparedStatement.setString(2,\"lisi\");\r\n               int j = preparedStatement.executeUpdate();\r\n               if (i == j && i == 1){\r\n                   System.out.println(\"转账成功\");\r\n                   connection.commit();\r\n               } else{\r\n                   System.out.println(\"转账失败\");\r\n               }\r\n           } catch (Exception throwables) {\r\n               if(connection != null){\r\n                   try {\r\n                       connection.rollback();\r\n                   } catch (SQLException e) {\r\n                       e.printStackTrace();\r\n                   }\r\n               }\r\n               throwables.printStackTrace();\r\n           } finally {\r\n               JDBCUtils.close(null,preparedStatement,connection);\r\n           }\r\n       }\r\n   }\r\n   ```\r\n\r\n# 十三、数据库连接池\r\n\r\n## 13.1 数据库连接池\r\n\r\n![image-20210805115219675](cloudDisk/markdown/JavaWeb笔记.assets/image-20210805115219675.png)\r\n\r\n**概念：其实就是一个容器（集合），存放数据库连接的容器。**\r\n\r\n* 在系统初始化好后，容器被创建，容器中会申请一些连接对象，当用户来访问数据库时，从容器中获取连接对象，用户访问完后，会将连接对象归还给容器。\r\n\r\n**好处：**\r\n\r\n1. 节约资源\r\n2. 用户访问高效\r\n\r\n**实现：**标准接口：DataSource    javax.sql包下的\r\n\r\n1. 方法：\r\n   * 获取连接：getConnection()\r\n   * 归还连接：如果连接对象Connection是从连接池中获取的，那么调用Connection.close()方法，则不会再关闭连接了。而是归还连接\r\n2. 一般我们不去实现它，有数据库厂商来实现\r\n   1. C3P0 : 数据库连接池技术\r\n   2. Druid : 数据库连接池实现技术，由阿里巴巴提供的\r\n\r\n### 13.11 C3P0 ：数据库连接池技术\r\n\r\n* 步骤：\r\n\r\n  1. 导入jar包（两个）c3p0-0.9.5.0.jar 、 mchange-commons-java-0.2.12.jar\r\n\r\n     * 不要忘记导入数据库驱动jar包\r\n     * ![image-20210805124104484](cloudDisk/markdown/JavaWeb笔记.assets/image-20210805124104484.png)\r\n\r\n  2. 定义配置文件：\r\n\r\n     * 名称：c3p0.properties  或者  c3p0-config.xml\r\n\r\n     * 路径：直接将文件方法src目录下即可\r\n\r\n     * ```xml\r\n       <c3p0-config>\r\n           <!--    使用默认的配置读取连接池对象-->\r\n           <default-config>\r\n               <!--        连接参数-->\r\n               <property name=\"driverClass\">com.mysql.jdbc.Driver</property>\r\n               <property name=\"jdbcUrl\">jdbc:mysql://localhost:3306/db3</property>\r\n               <property name=\"user\">root</property>\r\n               <property name=\"password\">123</property>\r\n       \r\n               <!--        连接池参数-->\r\n               <property name=\"initialPoolSize\">5</property>\r\n               <property name=\"checkoutTimeout\">3000</property>\r\n               <!--        <property name=\"maxIdleTime\">30</property>-->\r\n               <property name=\"maxPoolSize\">10</property>\r\n               <!--        <property name=\"minPoolSize\">2</property>-->\r\n           </default-config>\r\n       \r\n           <named-config name=\"mySource\">\r\n               <property name=\"driverClass\">com.mysql.jdbc.Driver</property>\r\n               <property name=\"jdbcUrl\">jdbc:mysql://localhost:3306/bookstore</property>\r\n               <property name=\"user\">root</property>\r\n               <property name=\"password\">xxxx</property>\r\n       \r\n               <property name=\"initialPoolSize\">10</property>\r\n               <property name=\"maxIdleTime\">30</property>\r\n               <property name=\"maxPoolSize\">100</property>\r\n               <property name=\"minPoolSize\">10</property>\r\n           </named-config>\r\n       </c3p0-config>\r\n       ```\r\n\r\n  3. 创建核心对象  数据库连接池对象  ComboPooledDataSource\r\n\r\n  4. 获取连接：getConnection\r\n\r\n     * ```java\r\n       public class C3P0Demo {\r\n           public static void main(String[] args) throws SQLException {\r\n               // 1. 创建数据库连接池对象\r\n               ComboPooledDataSource cbds = new ComboPooledDataSource();\r\n               // 2. 获取连接对象\r\n               Connection connection = cbds.getConnection();\r\n               // 3. 打印\r\n               System.out.println(connection);\r\n           }\r\n       }\r\n       ```\r\n\r\n       ```java\r\n       public class C3P0Demo {\r\n           public static void main(String[] args) throws SQLException {\r\n               // 1. 创建数据库连接池对象 (使用默认配置)\r\n               ComboPooledDataSource cbds = new ComboPooledDataSource();\r\n               // 使用自定义的配置\r\n               // ComboPooledDataSource cbds = new ComboPooledDataSource(\"mySource\");\r\n       \r\n               for (int i = 1; i <= 11; i++) {\r\n                   // 2. 获取连接对象\r\n                   Connection connection = cbds.getConnection();\r\n                   // 3. 打印\r\n                   System.out.println(i + \" : \" + connection);\r\n               }\r\n           }\r\n       }\r\n       ```\r\n\r\n       ![image-20210805125749385](cloudDisk/markdown/JavaWeb笔记.assets/image-20210805125749385.png)\r\n\r\n### 13.12 Druid : 数据库连接池技术，由阿里巴巴提供的\r\n\r\n* 步骤\r\n\r\n  1. 导入jar包 druid-1.1.18.jar\r\n\r\n     ![image-20210805135849346](cloudDisk/markdown/JavaWeb笔记.assets/image-20210805135849346.png)\r\n\r\n     * 下载链接：https://repo1.maven.org/maven2/com/alibaba/druid/1.1.18/\r\n\r\n  2. 定义配置文件\r\n\r\n     * 是properties形式的\r\n     * 可以叫任意名称，可以放在任意目录下\r\n\r\n  3. 加载配置文件。Properties\r\n\r\n     ```properties\r\n     # druid.properties文件的配置\r\n     driverClassName=com.mysql.jdbc.Driver\r\n     url=jdbc:mysql://localhost:3306/db3\r\n     username=root\r\n     password=123\r\n     # 初始化连接数量\r\n     initialSize=5\r\n     # 最大连接数\r\n     maxActive=10\r\n     # 最大超时时间\r\n     maxWait=3000\r\n     ```\r\n\r\n  4. 获取数据库连接池对象：通过工厂来获取    DruidDataSourceFactory\r\n\r\n  5. 获取连接：getConnection\r\n\r\n     ```java\r\n     public class DruidDemo {\r\n         public static void main(String[] args) throws Exception {\r\n             // 1. 导入jar包\r\n             // 2. 定义配置文件\r\n             // 3. 加载配置文件\r\n             Properties pro = new Properties();\r\n             InputStream is = DruidDemo.class.getClassLoader().getResourceAsStream(\"druid.properties\");\r\n             pro.load(is);\r\n             // 4. 获取连接池对象\r\n             DataSource ds = DruidDataSourceFactory.createDataSource(pro);\r\n             Connection connection = ds.getConnection();\r\n             System.out.println(connection);\r\n         }\r\n     }\r\n     ```\r\n\r\n     ![image-20210805135942164](cloudDisk/markdown/JavaWeb笔记.assets/image-20210805135942164.png)\r\n\r\n* 定义工具类\r\n\r\n  1. 定义一个类：JDBCUtils\r\n\r\n  2. 提供静态代码块加载配置文件，初始化连接池对象\r\n\r\n  3. 提供方法\r\n\r\n     1. 获取连接\r\n     2. 释放资源\r\n     3. 获取连接池\r\n\r\n  4. ```java\r\n     package com.tony.util;\r\n     \r\n     import com.alibaba.druid.pool.DruidDataSourceFactory;\r\n     \r\n     import javax.sql.DataSource;\r\n     import java.io.IOException;\r\n     import java.io.InputStream;\r\n     import java.sql.Connection;\r\n     import java.sql.ResultSet;\r\n     import java.sql.SQLException;\r\n     import java.sql.Statement;\r\n     import java.util.Properties;\r\n     \r\n     public final class DruidUtils {\r\n         private static DataSource ds;\r\n         static {\r\n             try {\r\n                 // 1. 加载配置文件\r\n                 Properties prop = new Properties();\r\n                 InputStream is = DruidUtils.class.getClassLoader().getResourceAsStream(\"druid.properties\");\r\n                 prop.load(is);\r\n                 // 2. 获取DataSource\r\n                 ds = DruidDataSourceFactory.createDataSource(prop);\r\n             } catch (IOException e) {\r\n                 e.printStackTrace();\r\n             } catch (Exception e) {\r\n                 e.printStackTrace();\r\n             }\r\n         }\r\n     \r\n         // 获取连接\r\n         public static Connection getConnection() throws SQLException {\r\n             return ds.getConnection();\r\n         }\r\n     \r\n     \r\n         // 释放资源\r\n         public static void close(Statement stmt, Connection connection, ResultSet rs){\r\n             if (stmt != null){\r\n                 try {\r\n                     stmt.close();\r\n                 } catch (SQLException throwables) {\r\n                     throwables.printStackTrace();\r\n                 }\r\n             }\r\n             if (connection != null){\r\n                 try {\r\n                     connection.close(); // 归还连接\r\n                 } catch (SQLException throwables) {\r\n                     throwables.printStackTrace();\r\n                 }\r\n             }\r\n             if (rs != null){\r\n                 try {\r\n                     rs.close();\r\n                 } catch (SQLException throwables) {\r\n                     throwables.printStackTrace();\r\n                 }\r\n             }\r\n         }\r\n     \r\n         // 获取连接池方法\r\n         public static DataSource getDataSource(){\r\n             return ds;\r\n         }\r\n     }\r\n     ```\r\n\r\n  5. 测试类：\r\n\r\n     ```java\r\n     package com.tony.test07;\r\n     \r\n     import com.tony.util.DruidUtils;\r\n     \r\n     import java.sql.Connection;\r\n     import java.sql.PreparedStatement;\r\n     import java.sql.SQLException;\r\n     import java.sql.Statement;\r\n     \r\n     public class DruidUtilsDemo {\r\n         public static void main(String[] args) {\r\n             Connection connection = null;\r\n             PreparedStatement preparedStatement = null;\r\n             try {\r\n                 // 1. 获取连接\r\n                 connection = DruidUtils.getConnection();\r\n                 // 2. 定义sql\r\n                 String sql = \"insert into account values(null,?,?)\";\r\n                 // 3. 获取pstmt对象\r\n                 preparedStatement = connection.prepareStatement(sql);\r\n                 // 4. 执行sql\r\n                 preparedStatement.setString(1,\"xiaoming\");\r\n                 preparedStatement.setInt(2,2000);\r\n                 preparedStatement.executeUpdate();\r\n             } catch (SQLException throwables) {\r\n                 throwables.printStackTrace();\r\n             } finally {\r\n                 DruidUtils.close(preparedStatement,connection,null);\r\n             }\r\n         }\r\n     }\r\n     ```\r\n\r\n\r\n\r\n## 13.2 Spring JDBC \r\n\r\n* Spring框架对JDBC的简单封装。提供了一个JDBCTemolate对象简化JDBC的开发\r\n\r\n### 步骤\r\n\r\n1. 导入jar包\r\n\r\n   下载链接：https://repo.spring.io/ui/native/libs-release-local/org/springframework/spring/5.0.19.RELEASE\r\n\r\n2. 创建JdbcTemplate对象。依赖于数据源DataSource\r\n\r\n   * JdbcTemplate template = new JdbcTemplate(ds);\r\n\r\n3. 调用JdbcTemplate的方法来完成CRUD的操作\r\n\r\n   * **update()** : 执行DML语句。增、删、改语句\r\n\r\n   * **queryForMap() **: 查询结果将结果集封装为map集合，将列名作为key，将值作为value 将这条记录封装为一个map集合\r\n\r\n     * 注意：这个方法查询的结果长度只能是1\r\n\r\n   * **queryForList()** : 查询结果将结果集封装为list集合\r\n\r\n     * 注意：将每一条记录封装为一个Map集合，再将Map集合装载到List集合中\r\n\r\n   * **query()** : 查询结果，将结果封装为JavaBean对象\r\n\r\n     * query的参数：RowMapper\r\n\r\n       * 一般我们使用BeanPropertyRowMapper实现类。可以完成数据到JavaBean的自动封装\r\n\r\n       * ```java\r\n         template.query(sql, new BeanPropertyRowMapper<类型>(类型.class));\r\n         //他会先提取表的列名，再去类里面找列名对应的 setXxx 方法，setXxx方法的参数是表的值\r\n         ```\r\n\r\n   * **queryForObject() **: 查询结果，将结果封装为对象\r\n\r\n     * 一般用于聚合函数的查询\r\n     * template.queryForObject(sql, long.class);\r\n\r\n4. 简单事例：\r\n\r\n   ```java\r\n   package com.tony.jdbcTemplate;\r\n   \r\n   import com.tony.util.DruidUtils;\r\n   import com.tony.util.JDBCUtils;\r\n   import org.springframework.jdbc.core.JdbcTemplate;\r\n   \r\n   public class JdbcTemplateDemo01 {\r\n       public static void main(String[] args) {\r\n           // 1. 导入jar包\r\n           // 2. 创建JDBCTemplate对象\r\n           JdbcTemplate template = new JdbcTemplate(DruidUtils.getDataSource());\r\n           // 3. 调用方法\r\n           String sql = \"update account set balance = 5000 where id = ?\";\r\n           int i = template.update(sql, 1); // ? = 1\r\n           System.out.println(i);\r\n       }\r\n   }\r\n   ```\r\n\r\n### 练习：\r\n\r\n### 1. update()练习：\r\n\r\n![image-20210806115336514](cloudDisk/markdown/JavaWeb笔记.assets/image-20210806115336514.png)\r\n\r\n#### 练1.1 修改1号数据的 salary 为 10000\r\n\r\n```java\r\n/*\r\n修改1001号数据的 salary 为 10000\r\n* */\r\n@Test\r\npublic void test01(){\r\n    JdbcTemplate template = new JdbcTemplate(DruidUtils.getDataSource());\r\n    String sql = \"update emp set salary = 10000 where id = 1001\";\r\n    int i = template.update(sql);\r\n    System.out.println(i);\r\n}\r\n```\r\n\r\n![image-20210806115405906](cloudDisk/markdown/JavaWeb笔记.assets/image-20210806115405906.png)\r\n\r\n#### 练1.2 添加一条记录\r\n\r\n```java\r\n/*\r\n添加一条记录\r\n* */\r\n@Test\r\npublic void test02(){\r\n    JdbcTemplate template = new JdbcTemplate(DruidUtils.getDataSource());\r\n    String sql = \"insert into emp values (1015,\'李逍遥\',4,1004,\'2021-08-06\',15000.00,null,40)\";\r\n    int i = template.update(sql);\r\n    System.out.println(i);\r\n}\r\n```\r\n\r\n![image-20210806115427756](cloudDisk/markdown/JavaWeb笔记.assets/image-20210806115427756-1628222069152.png)\r\n\r\n#### 练1.3 删除刚才添加的记录\r\n\r\n```java\r\n/*\r\n删除刚才添加的记录\r\n* */\r\n    @Test\r\n    public void test03(){\r\n        JdbcTemplate template = new JdbcTemplate(DruidUtils.getDataSource());\r\n        String sql = \"delete from emp where id = 1015\";\r\n        int i = template.update(sql);\r\n        System.out.println(i);\r\n    }\r\n}\r\n```\r\n\r\n![image-20210806115728089](cloudDisk/markdown/JavaWeb笔记.assets/image-20210806115728089.png)\r\n\r\n### 2. queryForMap()练习：\r\n\r\n#### 练1：查询id为1001的记录，将其封装为Map集合\r\n\r\n```java\r\n/*\r\n查询id为1001的记录，将其封装为Map集合\r\n* */\r\nprivate JdbcTemplate template = new JdbcTemplate(DruidUtils.getDataSource());\r\n@Test\r\npublic void test04(){\r\n    String sql = \"select * from emp where id = ?\";\r\n    Map<String, Object> map = template.queryForMap(sql, 1001);\r\n    System.out.println(map);\r\n    // 结果：{id=1001, ename=孙悟空, job_id=4, mgr=1004, joindate=2000-12-17, salary=10000.00, bonus=null, dept_id=20}\r\n}\r\n```\r\n\r\n### 3. queryForList()练习：\r\n\r\n#### 练：查询所有记录，将其封装为List\r\n\r\n```java\r\n/*\r\n查询所有记录，将其封装为List\r\n* */\r\n@Test\r\npublic void test05(){\r\n    String sql = \"select * from emp\";\r\n    List<Map<String, Object>> mapList = template.queryForList(sql);\r\n    mapList.stream().forEach((map) -> System.out.println(map));\r\n}\r\n```\r\n\r\n![image-20210806121244434](cloudDisk/markdown/JavaWeb笔记.assets/image-20210806121244434.png)\r\n\r\n### 4. query()练习：\r\n\r\n#### 练1：查询所有记录，将其封装为Emp对象的List集合\r\n\r\n* 方法一：\r\n\r\n```java\r\npublic class Emp {\r\n    private int id;\r\n    private String ename;\r\n    private int job_id;\r\n    private int mgr;\r\n    private java.sql.Date joindate;\r\n    private java.math.BigDecimal salary;\r\n    private java.math.BigDecimal bonus;\r\n    private int dept_id;\r\n    ...\r\n```\r\n\r\n```java\r\n/*\r\n方法一：查询所有记录，将其封装为Emp对象的List集合\r\n* */\r\n@Test\r\npublic void test06(){\r\n    String sql = \"select * from emp\";\r\n    List<Map<String, Object>> mapList = template.queryForList(sql);\r\n    ArrayList<Emp> emps = new ArrayList<>();\r\n    mapList.stream().forEach((map) -> {\r\n        Emp emp = new Emp();\r\n\r\n        Object id = map.get(\"id\");\r\n        if (id != null)\r\n            emp.setId((int)id);\r\n        \r\n        Object ename = map.get(\"ename\");\r\n        if(ename != null)\r\n            emp.setEname((String)ename);\r\n\r\n        Object job_id = map.get(\"job_id\");\r\n        if(job_id != null)\r\n            emp.setJob_id((int)job_id);\r\n\r\n        Object mgr = map.get(\"mgr\");\r\n        if(mgr != null)\r\n            emp.setMgr((int)mgr);\r\n\r\n        Object joindate = map.get(\"joindate\");\r\n        if(joindate != null)\r\n            emp.setJoindate((java.sql.Date)joindate);\r\n\r\n        Object salary = map.get(\"salary\");\r\n        if(salary != null)\r\n            emp.setSalary((java.math.BigDecimal)salary);\r\n\r\n        Object bonus = map.get(\"bonus\");\r\n        if(bonus != null)\r\n            emp.setBonus((java.math.BigDecimal)bonus);\r\n\r\n        Object dept_id = map.get(\"dept_id\");\r\n        if(dept_id != null)\r\n            emp.setDept_id((int)dept_id);\r\n\r\n        emps.add(emp);\r\n    });\r\n    emps.stream().forEach((emp) -> System.out.println(emp.toString()));\r\n}\r\n```\r\n\r\n![image-20210806125314813](cloudDisk/markdown/JavaWeb笔记.assets/image-20210806125314813.png)\r\n\r\n* 方法二：\r\n\r\n  ```java\r\n  /*\r\n  方法二：查询所有记录，将其封装为Emp对象的List集合\r\n  * */\r\n  @Test\r\n  public void test06() {\r\n      String sql = \"select * from emp\";\r\n      List<Emp> empList = template.query(sql, new RowMapper<Emp>() {\r\n          @Override\r\n          public Emp mapRow(ResultSet rs, int rowNum) throws SQLException {\r\n              Emp emp = new Emp();\r\n              int id = rs.getInt(\"id\");\r\n              emp.setId(id);\r\n  \r\n              String ename = rs.getString(\"ename\");\r\n              emp.setEname(ename);\r\n  \r\n              int job_id = rs.getInt(\"job_id\");\r\n              emp.setJob_id(job_id);\r\n  \r\n              int mgr = rs.getInt(\"mgr\");\r\n              emp.setMgr(mgr);\r\n  \r\n              Date joindate = rs.getDate(\"joindate\");\r\n              emp.setJoindate(joindate);\r\n  \r\n              BigDecimal salary = rs.getBigDecimal(\"salary\");\r\n              emp.setSalary(salary);\r\n  \r\n              BigDecimal bonus = rs.getBigDecimal(\"bonus\");\r\n              emp.setBonus(bonus);\r\n  \r\n              int dept_id = rs.getInt(\"dept_id\");\r\n              emp.setDept_id(dept_id);\r\n              return emp;\r\n          }\r\n      });\r\n  \r\n      empList.stream().forEach((emp) -> System.out.println(emp.toString()));\r\n  }\r\n  ```\r\n\r\n  ![image-20210806131022453](cloudDisk/markdown/JavaWeb笔记.assets/image-20210806131022453.png)\r\n\r\n##### 采用：BeanPropertyRowMapper实现类\r\n\r\n* **方法三 ( 很重要！！！！！！！！！！) ：**\r\n\r\n  ```java\r\n  public class Emp {\r\n      private Integer id;\r\n      private String ename;\r\n      private Integer job_id;\r\n      private Integer mgr;\r\n      private Date joindate;\r\n      private java.math.BigDecimal salary;\r\n      private java.math.BigDecimal bonus;\r\n      private Integer dept_id;\r\n      ...\r\n  ```\r\n\r\n  ```java\r\n  /*\r\n  方法三：查询所有记录，将其封装为Emp对象的List集合\r\n  * */\r\n  @Test\r\n  public void test06() {\r\n      String sql = \"select * from emp\";\r\n      List<Emp> empList = template.query(sql, new BeanPropertyRowMapper<Emp>(Emp.class));\r\n      empList.stream().forEach((emp) -> System.out.println(emp.toString()));\r\n  }\r\n  ```\r\n\r\n  ![image-20210806132252905](cloudDisk/markdown/JavaWeb笔记.assets/image-20210806132252905.png)\r\n\r\n### 5. queryForObject()练习（适用于聚合函数查询）\r\n\r\n#### 练1：查询总记录数\r\n\r\n```java\r\n    /*\r\n查询总记录数\r\n* */\r\n    @Test\r\n    public void test07() {\r\n        String sql = \"select count(id) from emp\";\r\n        Long total = template.queryForObject(sql, long.class);\r\n        System.out.println(total);\r\n    }\r\n```\r\n\r\nresult : 14\r\n\r\n# 十四、JavaWeb\r\n\r\n## 14.1 基本概念\r\n\r\n* JavaWeb概念 : 使用java语言开发基于互联网的项目\r\n* 软件架构：\r\n  1. C/S: Client/Server   客户端/服务器端，在远程有一个服务器端程序\r\n     * 如：QQ、迅雷。。。\r\n     * 优点：\r\n       1. 用户体验好\r\n     * 缺点：\r\n       1. 开发、安装、部署、维护麻烦\r\n  2. B/S: Broser/Server   浏览器/服务器端\r\n     * 只需要一个浏览器，用户通过不同的网址（URL），客户访问不同的服务器端程序\r\n     * 优点：\r\n       1. 开发、安装、部署、维护简单\r\n     * 缺点：\r\n       1. 如果应用过大，用户的体验会收到影响\r\n       2. 对硬件要求过高\r\n* B/S架构详解\r\n  * 资源分类\r\n    1. 静态资源：\r\n       * 使用静态网页开发技术发布的资源\r\n       * 特点：\r\n         1. 所有用户访问，得到的结果是一样的\r\n         2. 如：文本，图片，音频，视频，HTML，CSS，JS\r\n         3. 如果用户请求的是静态资源，那么服务器会直接将静态资源的解析引擎，可以展示静态资源\r\n    2. 动态资源：\r\n       * 使用动态网页及时发布的资源\r\n       * 特点：\r\n         1. 所有用户访问，得到的结果可能不一样\r\n         2. 如：jsp/servlet, php, asp...\r\n         3. 如果用户请求的是动态资源，那么服务器会执行动态资源，转化为静态资源，再发送给浏览器\r\n* 我们要学习动态资源，必须学习静态资源！\r\n* 静态资源：\r\n  * HTML : 用于搭建基础网页，展示页面的内容\r\n  * CSS : 用于美化页面，布局页面\r\n  * JavaScript : 控制页面元素，使其具有动态效果\r\n\r\n## 14.2 HTML\r\n\r\n### 概念：是最基础的网页开发语言\r\n\r\n![image-20210807104935182](cloudDisk/markdown/JavaWeb笔记.assets/image-20210807104935182.png)\r\n\r\n### 快速入门：\r\n\r\n* 语法：\r\n\r\n  ![image-20210807105610820](cloudDisk/markdown/JavaWeb笔记.assets/image-20210807105610820.png)\r\n\r\n  ![image-20210807105653360](cloudDisk/markdown/JavaWeb笔记.assets/image-20210807105653360.png)\r\n\r\n### 标签\r\n\r\n#### 1. 文件标签：构成Html最基础的标签\r\n\r\n![image-20210807110430146](cloudDisk/markdown/JavaWeb笔记.assets/image-20210807110430146.png)\r\n\r\n#### 2. 文本标签：和文本有关的标签\r\n\r\n![image-20210807113624205](cloudDisk/markdown/JavaWeb笔记.assets/image-20210807113624205.png)\r\n\r\n![image-20210807114333004](cloudDisk/markdown/JavaWeb笔记.assets/image-20210807114333004.png)\r\n\r\n```html\r\n<body>\r\n    <!-- 注释 -->\r\n    <!-- br换行 -->\r\n    白日依山近<br>\r\n    黄河入海流<br>\r\n\r\n    <!-- 标题标签 h1 - h6 -->\r\n    苏大强<br>\r\n    <h1>苏大强</h1>\r\n    <h2>苏大强</h2>\r\n    <h3>苏大强</h3>\r\n    <h4>苏大强</h4>\r\n    <h5>苏大强</h5>\r\n    <h6>苏大强</h6>\r\n\r\n    <!-- 段落标签 -->\r\n    <p>\r\n        《复仇者联盟》（Marvel\'s The Avengers）是漫威影业出品的一部科幻动作电影，取材自漫威漫画，是漫威电影宇宙的第六部电影，同时也是第一阶段的收官作品。\r\n    </p>\r\n    <p>\r\n        由乔斯·韦登执导，小罗伯特·唐尼、克里斯·埃文斯、马克·鲁法洛、克里斯·海姆斯沃斯、斯嘉丽·约翰逊、杰瑞米·雷纳、汤姆·希德勒斯顿、塞缪尔·杰克逊、克拉克·格雷格、寇碧·史莫德斯、联袂出演。\r\n    </p>\r\n    <p>\r\n        影片于2012年5月5日在中国内地正式上映。\r\n    </p>\r\n    \r\n    <!-- hr 显示一条水平线 -->\r\n    <hr>\r\n\r\n    <!-- b 加粗 -->\r\n    <b>Avengers</b>\r\n\r\n    <!-- i 斜体 -->\r\n    <i>Assemble</i>\r\n\r\n</body>\r\n```\r\n\r\n![image-20210807120235652](cloudDisk/markdown/JavaWeb笔记.assets/image-20210807120235652.png)\r\n\r\n#### 3. 图片标签：\r\n\r\n```html\r\n<body>\r\n    <!-- 展示一张图片 -->\r\n    <img src=\"C:\\Users\\Tony\\Pictures\\Saved Pictures\\timg (1).jpg\" alt=\"古镇\" width=\"500\" height=\"500\">\r\n\r\n    <!-- 相对路径\r\n        * 以.开头的路径\r\n            * ./ ：代表当前目录\r\n            * ../ : 代表上级目录\r\n     -->\r\n\r\n</body>\r\n```\r\n\r\n![image-20210807120212739](cloudDisk/markdown/JavaWeb笔记.assets/image-20210807120212739.png)\r\n\r\n#### 4. 列表标签：\r\n\r\n```html\r\n<body>\r\n    <!-- 有序列表 -->\r\n    TODO\r\n    <ol type=\"A\" start=\"2\">\r\n        <li>睁眼</li>\r\n        <li>看手机</li>\r\n        <li>穿衣服</li>\r\n        <Li>洗漱</Li>\r\n    </ol>\r\n\r\n    <!-- 无序列表 -->\r\n    TODO\r\n    <ul type=\"disc\">\r\n        <li>睁眼</li>\r\n        <li>看手机</li>\r\n        <li>穿衣服</li>\r\n        <Li>洗漱</Li>\r\n    </ul>\r\n    <ul type=\"square\">\r\n        <li>睁眼</li>\r\n        <li>看手机</li>\r\n        <li>穿衣服</li>\r\n        <Li>洗漱</Li>\r\n    </ul>\r\n    <ul type=\"circle\">\r\n        <li>睁眼</li>\r\n        <li>看手机</li>\r\n        <li>穿衣服</li>\r\n        <Li>洗漱</Li>\r\n    </ul>\r\n</body>\r\n```\r\n\r\n![image-20210807120821768](cloudDisk/markdown/JavaWeb笔记.assets/image-20210807120821768.png)\r\n\r\n#### 5. 链接标签：\r\n\r\n```html\r\n<body>\r\n    <!-- 超链接 -->\r\n    <a href=\"https://www.bilibili.com\">B站</a>\r\n    <br>\r\n    <!-- 本页面跳转 -->\r\n    <a href=\"https://www.bilibili.com\" target=\"_self\">B站</a>\r\n    <br>\r\n    <!-- 打开新的选项卡 -->\r\n    <a href=\"https://www.bilibili.com\" target=\"_blank\">B站</a>\r\n    <br>\r\n    <a href=\"mailto:1605337475@qq.com\" target=\"_blank\">联系我们</a>\r\n    <br>\r\n    <!-- 点击图片跳转 -->\r\n    <a href=\"https://baike.baidu.com/item/%E6%B4%9B%E6%9D%89%E7%9F%B6/214107?fr=aladdin\"><img src=\"C:\\Users\\Tony\\Pictures\\Saved Pictures\\timg (4).jpg\"></a>\r\n</body>\r\n```\r\n\r\n\r\n\r\n![image-20210807121954473](cloudDisk/markdown/JavaWeb笔记.assets/image-20210807121954473.png)\r\n\r\n#### 6. div 和 span : \r\n\r\n```html\r\n<body>\r\n    <!-- div : 每一个div占满一整行。块级标签\r\n    span : 文本信息在一行展示。行内标签、内联标签\r\n     -->\r\n    <span>Avengers</span>\r\n    <span>Assemble</span>\r\n\r\n    <hr>\r\n    <div>Avengers</div>\r\n    <div>Assemble</div>\r\n</body>\r\n```\r\n\r\n![image-20210807122449455](cloudDisk/markdown/JavaWeb笔记.assets/image-20210807122449455.png)\r\n\r\n#### 7. 语义化标签：html5中为了提高程序的可读性，提高了一些标签。\r\n\r\n![image-20210807122856660](cloudDisk/markdown/JavaWeb笔记.assets/image-20210807122856660.png)\r\n\r\n#### 8. 表格标签：\r\n\r\n* table : 定义表格\r\n  * width : 宽度\r\n  * border : 边框\r\n  * cellpadding : 定义内容和单元格的距离\r\n  * cellspacing : 定义单元格之间的距离。如果指定0，则单元格的线会合为一条\r\n  * bgcolor : 背景色\r\n  * align : 对齐方式\r\n* tr : 定义行\r\n* td : 定义单元格\r\n  * colspan : 合并行\r\n  * rowspan : 合并列\r\n* th : 定义表头单元格\r\n* \\<caption> : 表格标题\r\n* \\<thead> : 表示表格的头部分\r\n* \\<tbody> : 表示表格的体部分\r\n* \\<tfoot> : 表示表格的脚部分\r\n\r\n```html\r\n<body>\r\n    <table width=\"50%\" border=\"1\" cellpadding=\"0\" cellspacing=\"0\" align=\"center\" >\r\n        <tr>\r\n            <th>id</th>\r\n            <th>name</th>\r\n            <th>major</th>\r\n        </tr>\r\n        <tr>\r\n            <td>01</td>\r\n            <td>Strange</td>\r\n            <td>magic</td>\r\n        </tr>\r\n        <tr>\r\n            <td>02</td>\r\n            <td>Tony</td>\r\n            <td>slaver</td>\r\n        </tr>\r\n        <tr>\r\n            <td>03</td>\r\n            <td>Steve</td>\r\n            <td>PLC</td>\r\n        </tr>\r\n    </table>\r\n    <hr>\r\n    <table width=\"50%\" border=\"1\" cellpadding=\"0\" cellspacing=\"0\" align=\"center\" >\r\n        <tr>\r\n            <th>id</th>\r\n            <th>name</th>\r\n            <th>major</th>\r\n        </tr>\r\n        <tr>\r\n            <td rowspan=\"2\">01</td>\r\n            <td>Strange</td>\r\n            <td>magic</td>\r\n        </tr>\r\n        <tr>\r\n            <td>Tony</td>\r\n            <td>slaver</td>\r\n        </tr>\r\n        <tr>\r\n            <td>03</td>\r\n            <td colspan=\"2\">Steve</td>\r\n        </tr>\r\n    </table>\r\n</body>\r\n```\r\n\r\n![image-20210807125530996](cloudDisk/markdown/JavaWeb笔记.assets/image-20210807125530996.png)\r\n\r\n#### 9. 表单标签\r\n\r\n**概念：**用于采集用户输入的数据的。用于和服务器进行交互。\r\n\r\n**form：**用于定义表单的。可以定义一个范围，范围代表采集用户数据的范围\r\n\r\n* 属性\r\n  * action：指定提交数据的URL\r\n  * method:指定提交方式\r\n    * 分类：一共7种，2种比较常用\r\n      * get：\r\n        1. 请求参数会在地址栏中显示。会封装到请求行中(HTTP协议后讲解)。\r\n        2. 请求参数大小是有限制的。\r\n        3. 不太安全。\r\n      * post：\r\n        1. 请求参数不会再地址栏中显示。会封装在请求体中(HTTP协议后讲解)\r\n        2. 请求参数的大小没有限制。\r\n        3. 较为安全。\r\n* 表单项中的数据要想被提交：必须指定其name属性\r\n\r\n#### 10. 表单项标签：\r\n\r\n##### input：可以通过type属性值，改变元素展示的样式\r\n\r\n* type属性\r\n  * text：文本输入框，默认值\r\n    * 指定输入框的提示信息，当输入框的内容发生变化，会自动清空提示信息\r\n  * password：密码输入框\r\n  * radio: 单选框\r\n    * 注意：\r\n      1. 要想让多个单选框实现单选的效果，则多个单选框的name属性值必须一样。\r\n      2. 一般会给每一个单选框提供value属性，指定其被选中后提交的值\r\n      3. checked属性，可以指定默认值\r\n  * checkbox：复选框\r\n    * 注意：\r\n      1. 一般会给每一个单选框提供value属性，指定其被选中后提交的值\r\n      2. checked属性，可以指定默认值\r\n  * file：文件选择框\r\n  * hidden：隐藏域，用于提交一些信息。\r\n  * 按钮：\r\n    1. submit：提交按钮。可以提交表单\r\n    2. button：普通按钮\r\n    3. image：图片提交按钮\r\n       * src属性指定图片的路径\r\n\r\n##### label：指定输入项的文字描述信息\r\n\r\n* 注意：\r\n  * label的for属性一般会和 input 的 id属性值 对应。如果对应了，则点击label区域，会让input输入框获取焦点。\r\n\r\n##### select: 下拉列表\r\n\r\n* 子元素：option，指定列表项\r\n\r\n##### textarea：文本域\r\n\r\n* cols：指定列数，每一行有多少个字符\r\n* rows：默认多少行。\r\n\r\n##### 例：\r\n\r\n```html\r\n<!DOCTYPE html>\r\n<html lang=\"en\">\r\n<head>\r\n    <meta charset=\"UTF-8\">\r\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\r\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\r\n    <title>Demo</title>\r\n</head>\r\n<body>\r\n    <form action=\"#\" method=\"GET\">\r\n        <label for=\"username\">用户名：</label> <input type=\"text\" name=\"username\" placeholder=\"请输入用户名\" id=\"username\"><br>\r\n        密码：<input type=\"password\" name=\"password\" placeholder=\"请输入密码\"><br>\r\n        性别：<input type=\"radio\" name=\"gender\" value=\"male\" id=\"\" checked=\"checked\">男\r\n             <input type=\"radio\" name=\"gender\" value=\"frmale\" id=\"\">女<br>\r\n        爱好：<input type=\"checkbox\" name=\"hobby\" value=\"shopping\" id=\"\">逛街\r\n            <input type=\"checkbox\" name=\"hobby\" value=\"Java\" id=\"\">Java\r\n            <input type=\"checkbox\" name=\"hobby\" value=\"game\" id=\"\">游戏<br>\r\n        图片：<input type=\"file\" name=\"file\" id=\"\"><br>\r\n        隐藏域：<input type=\"hidden\" value=\"aaa\" name=\"hidden\" id=\"\"><br>\r\n        取色器：<input type=\"color\" name=\"color\" id=\"\"><br>\r\n        生日：<input type=\"date\" name=\"birthday\" id=\"\"> <br>\r\n        生日：<input type=\"datetime-local\" name=\"birthday\" id=\"\"><br>\r\n        邮箱：<input type=\"email\" name=\"email\" id=\"\"><br>\r\n        年龄：<input type=\"number\" name=\"age\" id=\"\"><br>\r\n        省份：<select name=\"province\" id=\"\">\r\n                <option value=\"\">---请选择---</option>\r\n                <option value=\"北京\">北京</option>\r\n                <option value=\"上海\">上海</option>\r\n                <option value=\"苏州\">苏州</option>\r\n            </select><br>\r\n        自我描述：\r\n            <textarea name=\"description\" id=\"\" cols=\"30\" rows=\"10\"></textarea>\r\n\r\n\r\n\r\n        <br>\r\n        <input type=\"submit\" value=\"登录\">\r\n        <input type=\"button\" value=\"一个按钮\">\r\n        <input type=\"image\" src=\"C:\\Users\\Tony\\Pictures\\Saved Pictures\\屏幕截图 2021-08-08 132602.png\" value=\"图片提交按钮\" alt=\"\">\r\n    </form>\r\n</body>\r\n</html>\r\n```\r\n\r\n![image-20210808134503439](cloudDisk/markdown/JavaWeb笔记.assets/image-20210808134503439.png)\r\n\r\n输入内容：\r\n\r\n![image-20210808134644759](cloudDisk/markdown/JavaWeb笔记.assets/image-20210808134644759.png)\r\n\r\n提交后的URL：\r\n\r\n* ```\r\n  file:///E:/%E5%AD%A6%E4%B9%A0/JavaWeb/html/%E8%A1%A8%E5%8D%95%E6%A0%87%E7%AD%BE.html?username=Tony\r\n  &password=123\r\n  &gender=male\r\n  &hobby=shopping\r\n  &hobby=Java\r\n  &file=5944dfe9d89bd.jpg\r\n  &hidden=aaa\r\n  &color=%23ffffff\r\n  &birthday=2021-08-07\r\n  &birthday=2021-08-08T13%3A45\r\n  &email=1605337475%40qq.com\r\n  &age=21\r\n  &province=%E8%8B%8F%E5%B7%9E\r\n  &description=Java+yyds%21%21%21#\r\n  ```\r\n\r\n#### 11. 案例\r\n\r\n![image-20210808135615760](cloudDisk/markdown/JavaWeb笔记.assets/image-20210808135615760.png)\r\n\r\n```html\r\n<!DOCTYPE html>\r\n<html lang=\"en\">\r\n<head>\r\n    <meta charset=\"UTF-8\">\r\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\r\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\r\n    <title>Demo</title>\r\n</head>\r\n<body>\r\n    <form action=\"#\" method=\"POST\">\r\n        <table border=\"1\">\r\n            <tr>\r\n               <td><label for=\"username\">用户名</label></td> \r\n               <td><input type=\"text\" placeholder=\"请输入账号\" name=\"username\" id=\"username\"></td>\r\n            </tr>\r\n            <tr>\r\n                <td><label for=\"password\">密码</label></td> \r\n                <td><input type=\"password\" placeholder=\"请输入密码\" name=\"password\" id=\"password\"></td>\r\n             </tr>\r\n             <tr>\r\n                <td><label for=\"email\">Email</label></td> \r\n                <td><input type=\"email\" placeholder=\"请输入Email\" name=\"email\" id=\"email\"></td>\r\n             </tr>\r\n             <tr>\r\n                <td><label for=\"name\">姓名</label></td> \r\n                <td><input type=\"text\" placeholder=\"请输入真实姓名\" name=\"name\" id=\"name\"></td>\r\n             </tr>\r\n             <tr>\r\n                <td><label for=\"phonenumber\">手机号</label></td> \r\n                <td><input type=\"text\" name=\"phonenumber\" placeholder=\"请输入您的手机号\" id=\"phonenumber\"></td>\r\n             </tr>\r\n             <tr>\r\n                <td><label>性别</label></td> \r\n                <td>\r\n                    <input type=\"radio\" name=\"gender\" value=\"male\" checked>男\r\n                    <input type=\"radio\" name=\"gender\" value=\"female\">女\r\n                </td>\r\n             </tr>\r\n             <tr>\r\n                <td><label>出生日期</label></td> \r\n                <td><input type=\"date\" name=\"birthday\"></td>\r\n             </tr>\r\n             <tr>\r\n                <td><label for=\"key\">验证码</label></td> \r\n                <td>\r\n                    <input type=\"text\" name=\"key\" id=\"key\">\r\n                    <img src=\"C:\\Users\\Tony\\Pictures\\Saved Pictures\\3.png\" alt=\"\" width=\"150\">\r\n                </td>\r\n             </tr>\r\n             <tr>\r\n                <td colspan=\"2\" align=\"center\"><input type=\"submit\" value=\"注册\"></td>\r\n                \r\n             </tr>\r\n        </table>\r\n    </form>\r\n</body>\r\n</html>\r\n```\r\n\r\n![image-20210808141235081](cloudDisk/markdown/JavaWeb笔记.assets/image-20210808141235081.png)\r\n\r\n提交后：\r\n\r\n![image-20210808141250700](cloudDisk/markdown/JavaWeb笔记.assets/image-20210808141250700.png)\r\n\r\n\r\n\r\n## 14.2 CSS\r\n\r\n### 1. 概念 : \r\n\r\n* Cascading style sheets 层叠样式表\r\n\r\n* 层叠：多个样式可以作用在同一个html的元素上，同时生效\r\n\r\n### 2. 好处：\r\n\r\n1. 功能强大\r\n2. 将内容展示和样式分离\r\n   * 降低耦合度。解耦\r\n   * 让分工协作更容易\r\n   * 提高开发效率\r\n\r\n### 3. CSS使用：CSS与html结合方式\r\n\r\n1. 内联样式\r\n\r\n   * 在标签内使用style属性指定css代码\r\n   * 如：\\<div style=\"color:red;\">hello css\\</div>\r\n\r\n2. 内部样式\r\n\r\n   * 在head标签内，定义style标签，style标签的标签体内容就是css代码\r\n\r\n   * ```html\r\n     如：\r\n     			<style>\r\n     		        div{\r\n     		            color:blue;\r\n     		        }\r\n     		\r\n     		    </style>\r\n     			<div>hello css</div>\r\n     ```\r\n\r\n     \r\n\r\n3. 外部样式\r\n\r\n   1. 定义css资源文件。\r\n   2. 在head标签内，定义link标签，引入外部的资源文件\r\n\r\n   a.css文件：\r\n\r\n   ```css\r\n   div{\r\n       color:green;\r\n   }\r\n   ```\r\n\r\n   ```html\r\n   <link rel=\"stylesheet\" href=\"css/a.css\">\r\n   <div>hello css</div>\r\n   <div>hello css</div>\r\n   ```\r\n\r\n   \r\n\r\n* 注意：\r\n\r\n  * 1,2,3种方式 css作用范围越来越大\r\n\r\n  * 1方式不常用，后期常用2,3\r\n\r\n  * 1方式不常用，后期常用2,3\r\n\r\n  * 3种格式可以写为：\r\n\r\n    ```html\r\n    <style>\r\n    	@import \"css/a.css\";\r\n    </style>\r\n    ```\r\n\r\n4. css语法：\r\n\r\n   * 格式：\r\n\r\n     选择器 {\r\n\r\n     ​		属性名1:属性值1;\r\n     ​		属性名2:属性值2;\r\n     ​		...\r\n\r\n     }\r\n\r\n   * 选择器:筛选具有相似特征的元素\r\n\r\n   * 注意：\r\n\r\n     * 每一对属性需要使用；隔开，最后一对属性可以不加；\r\n\r\n5. 选择器：筛选具有相似特征的元素\r\n\r\n   * 分类：\r\n\r\n     1. 基础选择器\r\n\r\n        1. id选择器：选择具体的id属性值的元素.建议在一个html页面中id值唯一\r\n           * 语法：#id属性值{}\r\n        2. 元素选择器：选择具有相同标签名称的元素\r\n           * 语法： 标签名称{}\r\n           * id选择器优先级高于元素选择器\r\n        3. 类选择器：选择具有相同的class属性值的元素。\r\n           * 语法：.class属性值{}\r\n           * 注意：类选择器选择器优先级高于元素选择器\r\n\r\n     2. 扩展选择器\r\n\r\n        1. 选择所有元素：\r\n\r\n           * 语法： *{}\r\n\r\n        2. 并集选择器：\r\n\r\n           * 选择器1,选择器2{}\r\n\r\n        3. 子选择器：筛选选择器1元素下的选择器2元素\r\n\r\n           * 语法：  选择器1 选择器2{}\r\n\r\n        4. 父选择器：筛选选择器2的父元素选择器1\r\n\r\n           * 语法：  选择器1 > 选择器2{}\r\n\r\n        5. 属性选择器：选择元素名称，属性名=属性值的元素\r\n\r\n           * 语法：  元素名称[属性名=\"属性值\"]{}\r\n\r\n        6. 伪类选择器：选择一些元素具有的状态\r\n\r\n           * 语法： 元素:状态{}\r\n\r\n           * 如： \\<a>\r\n\r\n             * 状态：\r\n               * link：初始化的状态\r\n               * visited：被访问过的状态\r\n               * active：正在访问状态\r\n               * hover：鼠标悬浮状态\r\n\r\n           * 例：\r\n\r\n             ```html\r\n             <style>\r\n                   div a:link{\r\n                      color:red;\r\n                   }\r\n                   div a:visited{\r\n                      color:blue;\r\n                   }\r\n                   div a:active{\r\n                      color:green;\r\n                   }\r\n                   div a:hover{\r\n                      color:pink;\r\n                   }\r\n             </style>\r\n             \r\n             <div><a href=\"\">bilibili</a></div><br>\r\n             <a href=\"\">bilibili</a>\r\n             ```\r\n\r\n             ![image-20210809112009392](cloudDisk/markdown/JavaWeb笔记.assets/image-20210809112009392.png)\r\n\r\n   ​	\r\n\r\n6. 属性\r\n\r\n   1. 字体、文本\r\n      * font-size：字体大小\r\n      * color：文本颜色\r\n      * text-align：对其方式\r\n      * line-height：行高 \r\n   2. 背景\r\n      * background：\r\n   3. 边框\r\n      * border：设置边框，复合属性\r\n   4. 尺寸\r\n      * width：宽度\r\n      * height：高度\r\n   5. 盒子模型：控制布局\r\n      * margin：外边距\r\n      * padding：内边距\r\n        * 默认情况下内边距会影响整个盒子的大小\r\n        * box-sizing: border-box;  设置盒子的属性，让width和height就是最终盒子的大小\r\n\r\n      * float：浮动\r\n        * left\r\n        * right\r\n\r\n### 4. 案例 - 登录界面\r\n\r\n![image-20210809141743928](cloudDisk/markdown/JavaWeb笔记.assets/image-20210809141743928.png)\r\n\r\n```html\r\n<!DOCTYPE html>\r\n<html lang=\"en\">\r\n<head>\r\n    <meta charset=\"UTF-8\">\r\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\r\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\r\n    <title>Demo</title>\r\n    <style>\r\n       body{\r\n         background: #FFFFFF url(\'C:/Users/Tony/Pictures/Saved Pictures/q.jpg\') no-repeat center;\r\n         padding: 50px;\r\n       }\r\n       .div-page{\r\n         background-color: #FFFFFF;\r\n         height: 700px;\r\n         width: 1200px;\r\n         margin: auto;\r\n         margin-top: 50px;\r\n         border:5px solid rgb(226, 226, 226);\r\n       }\r\n       .div-left{\r\n          width: 300px;\r\n         float: left;\r\n     \r\n       }\r\n       .div-center{\r\n          width: 500px;\r\n          padding: 50px;\r\n         float:left;\r\n         /* border: green solid 3px; */\r\n       }\r\n       .div-right{\r\n         float: right;\r\n \r\n       }\r\n       .text_1{\r\n          color: rgb(235, 216, 52);\r\n          font-size: 22px;\r\n          margin-left: 20px;\r\n\r\n          margin-bottom: 0px;\r\n       }\r\n       .text_2{\r\n          color: rgb(121, 120, 118);\r\n          font-size: 22px;\r\n          margin-left: 20px;\r\n          margin-top: 0px;\r\n\r\n       }\r\n       .div-right p{\r\n          font-size: 15px;\r\n          margin: 20px;\r\n       }\r\n       .div-right p a{\r\n          color: palevioletred;\r\n       }\r\n\r\n       .div-center table tr label{\r\n          color: rgb(121, 120, 118);\r\n          /* border: springgreen solid 2px; */\r\n           /* height: 25px;  */\r\n        width: 80px; \r\n\r\n       }\r\n       .div-center table tr input{\r\n          border: rgb(121, 120, 118) solid 1px;\r\n          border-radius: 8px;\r\n           height: 30px;\r\n           margin-left: 30px;\r\n           /* margin: auto; */\r\n           /* text-align: left; */\r\n          /* width: 200px;  */\r\n          /* border: springgreen solid 2px; */\r\n       }\r\n       .div-center table .label{\r\n          text-align: right;\r\n\r\n       }\r\n       .div-center td{\r\n         /* border: springgreen solid 2px; */\r\n         height: 50px;\r\n         /* width: 200px; */\r\n         /* text-align:right; */\r\n       }\r\n       .div-center tr{\r\n          height: 50px;\r\n          /* text-align:right; */\r\n          /* border: springgreen solid 2px; */\r\n       }\r\n       .div-center .input{\r\n          width: 300px;\r\n       }\r\n       .sexlabel{\r\n          padding: 10px;\r\n          box-sizing: border-box;  \r\n       }\r\n\r\n       .div-center table tr input[class=\"submit\"]{\r\n         background-color: palevioletred;\r\n         border-radius: 0em;\r\n         width: 150px;\r\n         height: 45px;\r\n         color: #e7e7e7;\r\n         font-size: 16px;\r\n         border-width: 0;\r\n       }\r\n    </style>\r\n</head>\r\n<body>\r\n      <div class=\"div-page\">\r\n         <div class=\"div-left\">\r\n            <p class=\"text_1\">新用户注册</p>\r\n            <p class=\"text_2\">USER REGISTER</p>\r\n         </div>\r\n         <div class=\"div-center\">\r\n            <form action=\"#\" method=\"POST\">\r\n               <table>\r\n                  <tr>\r\n                     <td class=\"label\"><label for=\"username\">用户名</label></td> \r\n                     <td colspan=\"2\"><input type=\"text\" class=\"input\" placeholder=\"请输入账号\" name=\"username\" id=\"username\"></td>\r\n                  </tr>\r\n                  <tr>\r\n                      <td class=\"label\"><label for=\"password\">密码</label></td> \r\n                      <td colspan=\"2\"><input type=\"password\" class=\"input\" placeholder=\"请输入密码\" name=\"password\" id=\"password\"></td>\r\n                   </tr>\r\n                   <tr>\r\n                      <td class=\"label\"><label for=\"email\">Email</label></td> \r\n                      <td colspan=\"2\"><input type=\"email\" class=\"input\" placeholder=\"请输入Email\" name=\"email\" id=\"email\"></td>\r\n                   </tr>\r\n                   <tr>\r\n                      <td class=\"label\"><label for=\"name\">姓名</label></td> \r\n                      <td colspan=\"2\"><input type=\"text\" class=\"input\" placeholder=\"请输入真实姓名\" name=\"name\" id=\"name\"></td>\r\n                   </tr>\r\n                   <tr>\r\n                      <td class=\"label\"><label for=\"phonenumber\">手机号</label></td> \r\n                      <td colspan=\"2\"><input type=\"text\" class=\"input\"  name=\"phonenumber\" placeholder=\"请输入您的手机号\" id=\"phonenumber\"></td>\r\n                   </tr>\r\n                   <tr>\r\n                      <td class=\"label\"><label>性别</label></td> \r\n                      <td>\r\n                           <table>\r\n                              <td>\r\n                                 <input type=\"radio\" name=\"gender\" value=\"male\" checked id=\"male\">\r\n                              </td>\r\n                              <td>\r\n                                 <label for=\"male\" >男</label> \r\n                              </td>\r\n                              <td>\r\n                                 <input type=\"radio\" name=\"gender\" value=\"female\" id=\"female\">\r\n                              </td>\r\n                              <td>\r\n                                 <label for=\"female\" >女</label>\r\n                              </td>\r\n                              </td>\r\n                           </table>\r\n                      </td>\r\n                   </tr>\r\n                   <tr>\r\n                      <td class=\"label\"><label>出生日期</label></td> \r\n                      <td colspan=\"2\"><input type=\"date\"class=\"input\" name=\"birthday\"></td>\r\n                   </tr>\r\n                   <tr>\r\n                      <td class=\"label\"><label for=\"key\">验证码</label></td> \r\n                      <td >\r\n                          <input type=\"text\" name=\"key\" id=\"key\">\r\n                          \r\n                      </td>\r\n                      <td>\r\n                        <img src=\"C:\\Users\\Tony\\Pictures\\Saved Pictures\\3.png\" alt=\"\" width=\"150\">\r\n                      </td>\r\n                   </tr>\r\n                   <tr>\r\n                      <td colspan=\"3\" align=\"center\"><input type=\"submit\" value=\"注册\" class=\"submit\"></td>\r\n                      \r\n                   </tr>\r\n              </table>\r\n            </form>\r\n         </div>\r\n         <div class=\"div-right\">\r\n            <p>已有账号？<a href=\"\">立即登录</a></p> \r\n            \r\n         </div>\r\n      </div>\r\n</body>\r\n</html>\r\n```\r\n','2022-06-23 22:08:34','Java Web，是用Java技术来解决相关web互联网领域的技术栈。web包括：web服务端和web客户端两部分。Java在客户端的应用有Java Applet，不过使用得很少，Java在服务器端的应用非常的丰富，比如Servlet，JSP、第三方框架等等。Java技术对Web领域的发展注入了强大的动力。','cloudDisk\\markdown\\JavaWeb笔记.assets\\v2-a3e62eaf0fc00ea128596a53ce32563a_720w.jpg','原创','','','\0','Java Web笔记（上）','2022-06-23 22:08:34',2,101,NULL,0),(182,'','\r\n# 十五、JavaScript\r\n\r\n* 参考手册：https://www.w3school.com.cn/jsref/index.asp\r\n\r\n* 概念：一门客户端脚本语言\r\n  * 运行在客户端浏览器中的，每一个浏览器都有JavaScript的解析引擎\r\n  * 脚本语言：不需要编译，直接就可以被浏览器解析执行了\r\n\r\n* 功能：\r\n  * 可以来增强用户和html页面的交互过程，可以来控制html元素，让页面有一些动态的效果，增强用户的体验。\r\n\r\n* JavaScript发展史：\r\n  1. 1992年，Nombase公司，开发出第一门客户端脚本语言，专门用于表单的校验。命名为 ： C--	，后来更名为：ScriptEase\r\n  2. 1995年，Netscape(网景)公司，开发了一门客户端脚本语言：LiveScript。后来，请来SUN公司的专家，修改LiveScript，命名为JavaScript\r\n  3. 1996年，微软抄袭JavaScript开发出JScript语言\r\n  4. 1997年，ECMA(欧洲计算机制造商协会)，制定出客户端脚本语言的标准：ECMAScript，就是统一了所有客户端脚本语言的编码方式。\r\n\r\n## 15.1 ECMAScript：客户端脚本语言的标准\r\n\r\n### 基本语法：\r\n\r\n#### 1. 与html结合方式\r\n\r\n1. 内部JS：\r\n   * 定义\\<script>，标签体内容就是js代码\r\n2. 外部JS：\r\n   * 定义\\<script>，通过src属性引入外部的js文件\r\n\r\n* 注意：\r\n  1. \\<script>可以定义在html页面的任何地方。但是定义的位置会影响执行顺序。\r\n  2. \\<script>可以定义多个。\r\n\r\n#### 2. 注释\r\n\r\n1. 单行注释：//注释内容\r\n2. 多行注释：/*注释内容*/\r\n\r\n#### 3. 数据类型：\r\n\r\n1. 原始数据类型(基本数据类型)：\r\n   1. number：数字。 整数/小数/NaN(not a number 一个不是数字的数字类型)\r\n   2. string：字符串。 字符串  \"abc\" \"a\" \'abc\'\r\n   3. boolean: true和false\r\n   4. null：一个对象为空的占位符\r\n   5. undefined：未定义。如果一个变量没有给初始化值，则会被默认赋值为undefined\r\n\r\n2. 引用数据类型：对象\r\n\r\n#### 4. 变量\r\n\r\n* 变量：一小块存储数据的内存空间\r\n* Java语言是强类型语言，而JavaScript是弱类型语言。\r\n  * 强类型：在开辟变量存储空间时，定义了空间将来存储的数据的数据类型。只能存储固定类型的数据\r\n  * 弱类型：在开辟变量存储空间时，不定义空间将来的存储数据类型，可以存放任意类型的数据。\r\n* 语法：\r\n  * var 变量名 = 初始化值;\r\n\r\n* typeof运算符：获取变量的类型。\r\n  * 注：null运算后得到的是object\r\n\r\n#### 5. 运算符\r\n\r\n##### 5.1 一元运算符：只有一个运算数的运算符\r\n\r\n​		++，-- ， +(正号)  \r\n\r\n		* ++ --: 自增(自减)\r\n			* ++(--) 在前，先自增(自减)，再运算\r\n			* ++(--) 在后，先运算，再自增(自减)\r\n		* +(-)：正负号\r\n	    * 注意：在JS中，如果运算数不是运算符所要求的类型，那么js引擎会**自动的将运算数进行类型转换**\r\n	      * **例如：var a = +\"12\"；  // a为number 类型 12**\r\n	       * 其他类型转number：\r\n	           * string转number：按照字面值转换。如果字面值不是数字，则转为NaN（不是数字的数字）\r\n	           * boolean转number：true转为1，false转为0\r\n\r\n##### 5.2 算数运算符\r\n\r\n\\+ - \\* / % ...\r\n\r\n##### 5.3 赋值运算符\r\n\r\n​	= += -+....\r\n\r\n##### 5.4 比较运算符\r\n\r\n> < >= <= == ===(全等于)\r\n\r\n* 比较方式\r\n  1. 类型相同：直接比较\r\n     * 字符串：按照字典顺序比较。按位逐一比较，直到得出大小为止。\r\n  2. 类型不同：先进行类型转换，再比较\r\n     * ===：全等于。在比较之前，先判断类型，如果类型不一样，则直接返回false\r\n\r\n##### 5.5 逻辑运算符\r\n\r\n​	&& || !\r\n\r\n##### 5.6 其他类型转boolean：\r\n\r\n1. number：0或NaN为假，其他为真\r\n2. string：除了空字符串(\"\")，其他都是true\r\n3. null&undefined:都是false\r\n4. 对象：所有对象都为true\r\n   		\r\n\r\n##### 5.7 三元运算符\r\n\r\n​	? : 表达式\r\n​	var a = 3;\r\n   var b = 4;\r\n\r\n   var c = a > b ? 1:0;\r\n	* 语法：\r\n		* 表达式? 值1:值2;\r\n		* 判断表达式的值，如果是true则取值1，如果是false则取值2；\r\n\r\n##### 5.8 流程控制语句：\r\n\r\n  1. if...else...\r\n 2. switch:\r\n\r\n  * 在java中，switch语句可以接受的数据类型： byte int shor char,枚举(1.5) ,String(1.7)\r\n   * switch(变量):\r\n\r\n  		case 值:\r\n\r\n  * 在JS中,switch语句可以接受任意的原始数据类型\r\n\r\n3. while\r\n4. do...while\r\n5. for\r\n\r\n##### 5.9 JS特殊语法：\r\n\r\n1. 语句以 ; 结尾，如果一行只有一条语句则 ;可以省略 (不建议)\r\n2. 变量的定义使用var关键字，也可以不使用\r\n   * 用： 定义的变量是局部变量\r\n   * 不用：定义的变量是全局变量(不建议)\r\n\r\n### 基本对象：\r\n\r\n#### 1. Function：函数(方法)对象\r\n\r\n    1. 创建：\r\n        1. var fun = new Function(形式参数列表,方法体);  //忘掉吧\r\n        2. function 方法名称(形式参数列表){\r\n                方法体\r\n            }\r\n    \r\n    3. var 方法名 = function(形式参数列表){\r\n            方法体\r\n       }\r\n\r\n3. 属性：\r\n   length:代表形参的个数\r\n4. 特点：\r\n   1. 方法定义是，形参的类型不用写,返回值类型也不写。\r\n   2. 方法是一个对象，如果定义名称相同的方法，会覆盖\r\n   3. 在JS中，方法的调用只与方法的名称有关，和参数列表无关\r\n   4. 在方法声明中有一个隐藏的内置对象（数组），arguments,封装所有的实际参数\r\n5. 调用：\r\n   方法名称(实际参数列表);\r\n\r\n#### 2. Array:数组对象\r\n\r\n1. 创建：\r\n   1. var arr = new Array(元素列表);\r\n   2. var arr = new Array(默认长度);\r\n   3. var arr = [元素列表];\r\n2. 方法\r\n   join(参数): 将数组中的元素按照指定的分隔符拼接为字符串\r\n   push()	向数组的末尾添加一个或更多元素，并返回新的长度。\r\n3. 属性\r\n   length:数组的长度\r\n4. 特点：\r\n   1. JS中，数组元素的类型可变的。\r\n   2. JS中，数组长度可变的。\r\n\r\n#### 3. Date：日期对象\r\n\r\n1. 创建：\r\n   var date = new Date();\r\n2. 方法：\r\n   toLocaleString()：返回当前date对象对应的时间本地字符串格式\r\n   getTime():获取毫秒值。返回当前如期对象描述的时间到1970年1月1日零点的毫秒值差\r\n\r\n#### 4. Math：数学对象\r\n\r\n1. 创建：\r\n   * 特点：Math对象不用创建，直接使用。  Math.方法名();\r\n2. 方法：\r\n   random():返回 0 ~ 1 之间的随机数。 含0不含1\r\n   ceil(x)：对数进行上舍入。\r\n   floor(x)：对数进行下舍入。\r\n   round(x)：把数四舍五入为最接近的整数。\r\n3. 属性：\r\n   PI\r\n\r\n#### 5. RegExp：正则表达式对象\r\n\r\n1. 正则表达式：定义字符串的组成规则。\r\n\r\n  ```\r\nre 测试：http://tool.chinaz.com/regex/\r\n1. 字符组： [字符组]\r\n    在同一个位置可能出现的各种字符组成了一个字符组，在正则表达式中用[]表示\r\n    字符分为很多类，比如数字、字母、标点等等。\r\n    假如你现在要求一个位置\"只能出现一个数字\",那么这个位置上的字符只能是0、1、2...9这10个数之一。\r\n\r\n    正则          待匹配字符    匹配结果   说明\r\n    [0123456789]    8           True       任意一个字符和\"待匹配字符\"相同都视为可以匹配\r\n    [0123456789]    a           False\r\n    [0-9]           7           True        [0-9] = [0123456789]\r\n    [a-z]           s           True        匹配所有小写字母\r\n    [A-Z]           B           True        匹配所有大写字母\r\n    [0-9a-fA-F]     e           True        匹配数字，大小写的a-f\r\n2. 字符：\r\n    元字符     匹配内容\r\n    .           匹配除换行符以外的任意字符\r\n    \\w          匹配字母或数字或下划线,word的缩写  word/0-9/_\r\n    \\W          匹配非字母或数字或下划线\r\n    \\s          匹配任意的空白符,space的缩写    tab/space/回车\r\n    \\d          匹配数字,digit的缩写\r\n    \\D          匹配非数字\r\n\r\n    \\n          匹配回车\r\n    \\t          匹配tab\r\n\r\n    \\b          匹配单词尾字母\r\n\r\n    ^           不匹配字符串的开始字符\r\n    $	        不匹配字符串的结束字符\r\n\r\n    a|b         匹配a或者b\r\n    [^ab]	    匹配除了字符组中a,b的所有字符\r\n3. 练习\r\n    正则    待匹配字符       匹配结果        说明\r\n    海.     海燕海娇海东      海燕海娇海东   匹配所有\"海.\"的字符\r\n    ^海.    海燕海娇海东      海燕           匹配所有\"海.\"的字符\r\n    海.$    海燕海娇海东      海东           只匹配结尾的\"海.$\"\r\n\r\n    练习1：匹配所有茶\r\n        绿茶白茶黑茶龙井茶恒河阿三黄茶红茶紫茶奶茶\r\n        正则表达式：[^茶]+茶   \r\n        结果：绿茶白 茶黑茶 龙井茶 恒河阿三黄茶 红茶 紫茶 奶茶\r\n        解释：\r\n            [^茶]：匹配不含茶的字符\r\n            [^茶]+：匹配一个或多个不含茶开头的连续字符\r\n            [^茶]+茶：一个或多个不含茶开头的连续字符，并且要以茶结尾\r\n\r\n    练习2：验证身份证\r\n        条件：15位或者18位的身份证，开头不能为0，结束可以为x\r\n        方法1：\r\n        正则表达式：^[1-9]\\d{14}(\\d{2}[0-9x])?$\r\n        解释：\r\n            ^[1-9]：开头能为一个非0的任意数字\r\n            \\d{14}：任意14个数字\r\n\r\n            \\d{2}：任意2个数字\r\n            [0-9x]：0到9任意一个数字或者x\r\n            (\\d{2}[0-9x])? ：它们两分成一组，受后面量词的限制，这个组只能出现0次或1次\r\n        方法2：\r\n            正则表达式：^([1-9]\\d{16}[0-9x]|[1-9]\\d{14})$\r\n            解释：\r\n                [1-9]：任意一个非0的数字\r\n                \\d{16}：任意16个数字\r\n                [0-9x]：任意一个数字或者x\r\n\r\n                [1-9]：任意一个非0的数字\r\n                \\d{14}：任意14个数字\r\n\r\n                ([1-9]\\d{16}[0-9x]|[1-9]\\d{14})：或关系\r\n\r\n   练习3：匹配：<script>     <script>\r\n        <script>...<script>\r\n        正则表达式：<.*?>  \r\n\r\n\r\n4. 几个贪婪匹配：\r\n    *? 重复任意次，但尽可能少重复\r\n    +? 重复1次或更多次，但尽可能少重复\r\n    ?? 重复0次或1次，但尽可能少重复\r\n    {n,m}? 重复n到m次，但尽可能少重复\r\n    {n,}? 重复n次以上，但尽可能少重复\r\n\r\n    .*?的用法：\r\n    . 是任意字符\r\n    * 是取 0 至 无限长度\r\n    ? 是非贪婪模式。\r\n    何在一起就是 取尽量少的任意字符，一般不会这么单独写，他大多用在：\r\n    .*?x\r\n    就是取前面任意长度的字符，直到一个x出现\r\n  ```\r\n\r\n  \r\n\r\n2. 正则对象：\r\n   1. 创建\r\n      1. var reg = new RegExp(\"正则表达式\");\r\n      2. var reg = /正则表达式/;\r\n   2. 方法	\r\n      1. test(参数): 验证指定的字符串是否符合正则定义的规范	\r\n\r\n#### 6. Global\r\n\r\n1. 特点：全局对象，这个Global中封装的方法不需要对象就可以直接调用。  方法名();\r\n\r\n2. 方法：\r\n   encodeURI():url编码\r\n   decodeURI():url解码\r\n\r\n   encodeURIComponent():url编码,编码的字符更多\r\n   decodeURIComponent():url解码\r\n\r\n   parseInt():将字符串转为数字\r\n       * 逐一判断每一个字符是否是数字，直到不是数字为止，将前边数字部分转为number\r\n       isNaN():判断一个值是否是NaN\r\n           * NaN六亲不认，连自己都不认。NaN参与的==比较全部问false\r\n\r\n   eval():讲 JavaScript 字符串，并把它作为脚本代码来执行。\r\n\r\n3. URL编码\r\n   传智播客 =  %E4%BC%A0%E6%99%BA%E6%92%AD%E5%AE%A2\r\n\r\n## 15.2 BOM\r\n\r\n1. 概念：Browser Object Model 浏览器对象模型\r\n\r\n   * 将浏览器的各个组成部分封装成对象。\r\n\r\n2. 组成：\r\n\r\n   * Window：窗口对象\r\n   * Navigator：浏览器对象\r\n   * Screen：显示器屏幕对象\r\n   * History：历史记录对象\r\n   * Location：地址栏对象\r\n\r\n3. Window：窗口对象\r\n\r\n   1. 创建\r\n\r\n   2. 方法\r\n\r\n      1. 与弹出框有关的方法：\r\n         alert()	显示带有一段消息和一个确认按钮的警告框。\r\n         confirm()	显示带有一段消息以及确认按钮和取消按钮的对话框。\r\n\r\n         * 如果用户点击确定按钮，则方法返回true\r\n\r\n         * 如果用户点击取消按钮，则方法返回false\r\n           prompt()	显示可提示用户输入的对话框。\r\n\r\n         * 返回值：获取用户输入的值 \r\n\r\n      2. 与打开关闭有关的方法：\r\n         close()	关闭浏览器窗口。\r\n\r\n         * 谁调用我 ，我关谁\r\n           open()	打开一个新的浏览器窗口\r\n         * 返回新的Window对象 \r\n\r\n      3. 与定时器有关的方式\r\n         setTimeout()	在指定的毫秒数后调用函数或计算表达式。\r\n\r\n         * 参数：\r\n               1. js代码或者方法对象\r\n               2. 毫秒值\r\n         * 返回值：唯一标识，用于取消定时器\r\n\r\n         clearTimeout()	取消由 setTimeout() 方法设置的 timeout。\r\n\r\n         setInterval()	按照指定的周期（以毫秒计）来调用函数或计算表达式。\r\n         clearInterval()	取消由 setInterval() 设置的 timeout。\r\n\r\n         * 轮播图案例\r\n\r\n           ```html\r\n           <!DOCTYPE html>\r\n           <html lang=\"en\">\r\n           <head>\r\n               <meta charset=\"UTF-8\">\r\n               <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\r\n               <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\r\n               <title>Demo</title>\r\n           </head>\r\n           <body>\r\n                 <img src=\"C:\\Users\\Tony\\Pictures\\Saved Pictures\\4.jpg\" width=\"100%\" name=\"1\" id=\"lunbotu\" alt=\"\">\r\n           \r\n           \r\n               <script>\r\n                   function fun(){\r\n                       if(lunbotu.name == \"1\"){\r\n                           lunbotu.src = \"C:/Users/Tony/Pictures/Saved Pictures/4.jpg\";\r\n                           lunbotu.name = \"2\";\r\n                       }\r\n                       else if(lunbotu.name == \"2\"){\r\n                           lunbotu.src = \"C:/Users/Tony/Pictures/Saved Pictures/5.jpg\";\r\n                           lunbotu.name = \"3\";\r\n                       }\r\n                       else if(lunbotu.name == \"3\"){\r\n                           lunbotu.src = \"C:/Users/Tony/Pictures/Saved Pictures/6.jpg\";\r\n                           lunbotu.name = \"1\";\r\n                       }\r\n                       \r\n                   }\r\n                   var lunbotu = document.getElementById(\"lunbotu\");\r\n                   window.setInterval(fun,2000); // 每 2s 调用一次fun\r\n               </script>\r\n           </body>\r\n           </html>\r\n           ```\r\n\r\n   3. 属性：\r\n\r\n      1. 获取其他BOM对象：\r\n         history\r\n         location\r\n         Navigator\r\n         Screen:\r\n      2. 获取DOM对象\r\n         document\r\n\r\n   4. 特点\r\n\r\n      * Window对象不需要创建可以直接使用 window使用。 window.方法名();\r\n      * window引用可以省略。  方法名();\r\n\r\n4. Location：地址栏对象\r\n\r\n   1. 创建(获取)：\r\n      1. window.location\r\n      2. location\r\n   2. 方法：\r\n      * reload()	重新加载当前文档。刷新\r\n   3. 属性\r\n      * href	设置或返回完整的 URL。\r\n\r\n   * 案例：5秒后自动跳往首页\r\n\r\n     * ```html\r\n       <!DOCTYPE html>\r\n       <html lang=\"en\">\r\n       <head>\r\n           <meta charset=\"UTF-8\">\r\n           <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\r\n           <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\r\n           <title>Demo</title>\r\n           <style>\r\n               p {\r\n                   text-align: center;\r\n                   font-size: 25px;\r\n               }\r\n               p span {\r\n                   color: red;\r\n               }\r\n           </style>\r\n       </head>\r\n       <body>\r\n           <p>\r\n               <span id=\"time\">5</span>\r\n               秒后，自动跳转到首页。。。\r\n           </p>\r\n       \r\n       \r\n           <script>\r\n               function countTime() {\r\n                   timer.innerHTML -= 1;\r\n                   if(timer.innerHTML==0){\r\n                       window.clearInterval(countTimer);\r\n                       location.href = \"https://www.baidu.com\";\r\n                   }\r\n               }\r\n               var timer = document.getElementById(\"time\");\r\n               var countTimer = window.setInterval(countTime,1000);\r\n       \r\n           </script>\r\n       </body>\r\n       </html>\r\n       ```\r\n\r\n       ![image-20210811161011311](cloudDisk/markdown/JavaWeb笔记.assets/image-20210811161011311.png)\r\n\r\n5. History：历史记录对象\r\n\r\n   1. 创建(获取)：\r\n      1. window.history\r\n      2. history\r\n\r\n   2. 方法：\r\n      * back()	加载 history 列表中的前一个 URL。\r\n      * forward()	加载 history 列表中的下一个 URL。\r\n      * go(参数)	加载 history 列表中的某个具体页面。\r\n        * 参数：\r\n          * 正数：前进几个历史记录\r\n          * 负数：后退几个历史记录\r\n   3. 属性：\r\n      * length	返回当前窗口历史列表中的 URL 数量。\r\n\r\n## 15.3 DOM\r\n\r\n功能：控制html文档的内容\r\n\r\n获取页面标签(元素)对象：Element\r\n\r\n* document.getElementById(\"id值\"):通过元素的id获取元素对象\r\n\r\n概念： Document Object Model 文档对象模型\r\n\r\n* 将标记语言文档的各个组成部分，封装为对象。可以使用这些对象，对标记语言文档进行CRUD的动态操作\r\n\r\n* W3C DOM 标准被分为 3 个不同的部分：\r\n\r\n  * 核心 DOM - 针对任何结构化文档的标准模型\r\n    * Document：文档对象\r\n    * Element：元素对象\r\n    * Attribute：属性对象\r\n    * Text：文本对象\r\n    * Comment:注释对象\r\n\r\n    * Node：节点对象，其他5个的父对象\r\n  * XML DOM - 针对 XML 文档的标准模型\r\n  * HTML DOM - 针对 HTML 文档的标准模型\r\n\r\n### 核心DOM模型：\r\n\r\n#### Document：文档对象\r\n\r\n1. 创建(获取)：在html dom模型中可以使用window对象来获取\r\n   1. window.document\r\n   2. document\r\n2. 方法：\r\n   1. 获取Element对象：\r\n      1. getElementById()	： 根据id属性值获取元素对象。id属性值一般唯一\r\n      2. getElementsByTagName()：根据元素名称获取元素对象们。返回值是一个数组\r\n      3. getElementsByClassName():根据Class属性值获取元素对象们。返回值是一个数组\r\n      4. getElementsByName(): 根据name属性值获取元素对象们。返回值是一个数组\r\n   2. 创建其他DOM对象：\r\n      createAttribute(name)\r\n      createComment()\r\n      createElement()\r\n      createTextNode()\r\n3. 属性\r\n\r\n#### Element：元素对象\r\n\r\n1. 获取/创建：通过document来获取和创建\r\n2. 方法：\r\n   1. removeAttribute()：删除属性\r\n   2. setAttribute()：设置属性\r\n\r\n#### Node：节点对象，其他5个的父对象\r\n\r\n* 特点：所有dom对象都可以被认为是一个节点\r\n\r\n* 方法：\r\n\r\n  * CRUD dom树：\r\n\r\n    * appendChild()：向节点的子节点列表的结尾添加新的子节点。\r\n\r\n    * removeChild()	：删除（并返回）当前节点的指定子节点。\r\n\r\n    * replaceChild()：用新节点替换一个子节点。\r\n\r\n    * 例：\r\n\r\n      ![image-20210812134926591](cloudDisk/markdown/JavaWeb笔记.assets/image-20210812134926591.png)\r\n\r\n      ![image-20210812134935989](cloudDisk/markdown/JavaWeb笔记.assets/image-20210812134935989.png)\r\n\r\n      ![image-20210812134945134](cloudDisk/markdown/JavaWeb笔记.assets/image-20210812134945134.png)\r\n\r\n      ```html\r\n      <!DOCTYPE html>\r\n      <html lang=\"en\">\r\n      <head>\r\n          <meta charset=\"UTF-8\">\r\n          <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\r\n          <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\r\n          <title>Demo</title>\r\n          <style>\r\n              div{\r\n                  border: crimson solid 1px;\r\n              }\r\n              #div1{\r\n                  height: 200px;\r\n                  width: 200px;\r\n              }\r\n              #div2{\r\n                  height: 100px;\r\n                  width: 100px;\r\n              }\r\n              #div3{\r\n                  height: 100px;\r\n                  width: 100px;\r\n              }\r\n          </style>\r\n      </head>\r\n      <body>\r\n          <div id=\"div1\">div1\r\n              <div id=\"div2\">\r\n                  div2\r\n              </div>\r\n          </div>\r\n          <a href=\"javascript:void(0)\" id=\"del\">删除div2</a>\r\n          <a href=\"#\" id=\"add\">添加div3</a>\r\n          <!-- 对于超链接标签他有两个功能\r\n          1. 可以被点击：样式\r\n          2. 点击后跳转到href指定的url\r\n          需求：保留1功能，去掉2功能\r\n          实现：href=\"javascript:void(0)\" -->\r\n          <script>\r\n              var ele_div1 = document.getElementById(\"div1\");\r\n              var ele_div2 = document.getElementById(\"div2\");\r\n              var ele_del = document.getElementById(\"del\");\r\n              var ele_add = document.getElementById(\"add\");\r\n              ele_del.onclick = function name() {\r\n                  ele_div1.removeChild(ele_div2);\r\n              }\r\n              ele_add.onclick = function name() {\r\n                  // 给div1添加子节点\r\n                  //创建子节点\r\n                  var div3 = document.createElement(\"div\");\r\n                  div3.innerHTML = \"div3\";\r\n                  div3.setAttribute(\"id\",\"div3\");\r\n                  // 给div添加子节点\r\n                  ele_div1.appendChild(div3);\r\n              }\r\n          </script>\r\n      </body>\r\n      </html>\r\n      ```\r\n\r\n#### 属性：\r\n\r\n* parentNode 返回节点的父节点。\r\n\r\n#### 案例：动态表格，能添加能删除\r\n\r\n![image-20210812135246199](cloudDisk/markdown/JavaWeb笔记.assets/image-20210812135246199.png)\r\n\r\n```html\r\n<!DOCTYPE html>\r\n<html lang=\"en\">\r\n<head>\r\n    <meta charset=\"UTF-8\">\r\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\r\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\r\n    <title>Demo</title>\r\n    <style>\r\n        div{\r\n            text-align: center;\r\n            margin-top: 60px;\r\n            \r\n        }\r\n        input[type=\"text\"]{\r\n            height: 30px;\r\n            width: 240px;\r\n        }\r\n        input[type=\"button\"]{\r\n            margin-left: 40px;\r\n            height: 34px;\r\n            width: 70px;\r\n        }\r\n        table{\r\n            margin: auto;\r\n            margin-top: 10px;\r\n            width: 680px;\r\n            border: black solid 1px;\r\n        }\r\n        .title{\r\n            font-weight: bold;\r\n        }\r\n        div td, div th{\r\n            border: black solid 1px;\r\n        }\r\n    </style>\r\n</head>\r\n<body>\r\n    <div>\r\n        <input type=\"text\" placeholder=\"请输入编号\" name=\"stu_id\" id=\"stu_id\">\r\n        <input type=\"text\" placeholder=\"请输入姓名\" name=\"stu_name\" id=\"stu_name\">\r\n        <input type=\"text\" placeholder=\"请输入性别\" name=\"stu_gender\" id=\"stu_gender\">\r\n        <input type=\"button\" name=\"\" id=\"add\" value=\"添加\">\r\n    </div>\r\n    <div>\r\n        <label for=\"\" class=\"title\">学生信息表</label>\r\n        <table>\r\n            <tr>\r\n                <th>\r\n                    <label for=\"\">编号</label>\r\n                </th>\r\n                <th>\r\n                    <label for=\"\">姓名</label>\r\n                </th>\r\n                <th>\r\n                    <label for=\"\">性别</label>\r\n                </th>\r\n                <th>\r\n                    <label for=\"\">操作</label>\r\n                </th>\r\n            </tr>\r\n            <!-- <tr>\r\n                <td>\r\n                    <label for=\"\">1</label>\r\n                </td>\r\n                <td>\r\n                    <label for=\"\">TONY</label>\r\n                </td>\r\n                <td>\r\n                    <label for=\"\">男</label>\r\n                </td>\r\n                <td>\r\n                    <a href=\"javascript:void(0);\">删除</a>\r\n                </td>\r\n            </tr> -->\r\n        </table>\r\n    </div>\r\n\r\n    <script>\r\n        function addToTable(studentId,studentName,studentGender) {\r\n            // 创建tr子节点\r\n            var ele_tr = document.createElement(\"tr\")\r\n            ele_table.appendChild(ele_tr);\r\n            // 创建td子节点\r\n            var ele_label_id = document.createElement(\"label\");\r\n            // ele_label_id.innerHTML = studentId;\r\n            // 添加文本节点\r\n            var ele_text_id = document.createTextNode(studentId)\r\n            ele_label_id.appendChild(ele_text_id)\r\n            // 添加 <label>ele_label_id</label> 到 td中， 并将 td 添加到tr中\r\n            ele_tr.appendChild(document.createElement(\"td\")).appendChild(ele_label_id);\r\n\r\n            var ele_label_name = document.createElement(\"label\");\r\n            // ele_label_name.innerHTML = studentName;\r\n            var ele_text_name = document.createTextNode(studentName)\r\n            ele_label_name.appendChild(ele_text_name)\r\n            // 添加 <label>ele_label_name</label> 到 td中， 并将 td 添加到tr中\r\n            ele_tr.appendChild(document.createElement(\"td\")).appendChild(ele_label_name);\r\n\r\n            var ele_label_gender = document.createElement(\"label\");\r\n            // ele_label_gender.innerHTML = studentGender;\r\n            var ele_text_gender = document.createTextNode(studentGender)\r\n            ele_label_gender.appendChild(ele_text_gender)\r\n            // 添加 <label>ele_label_gender</label> 到 td中， 并将 td 添加到tr中\r\n            ele_tr.appendChild(document.createElement(\"td\")).appendChild(ele_label_gender);\r\n\r\n            var ele_a_del = document.createElement(\"a\");\r\n            // ele_a_del.innerHTML = \"删除\";\r\n            var ele_text_del = document.createTextNode(\"删除\")\r\n            ele_a_del.appendChild(ele_text_del)\r\n            ele_a_del.href = \"javascript:void(0);\";\r\n            // 点击删除，删除对应的 tr\r\n            ele_a_del.onclick = function name() {\r\n                ele_table.removeChild(ele_tr);\r\n            }\r\n            // 添加 <a href=\"javascript:void(0);\">删除</a> 到 td中， 并将 td 添加到tr中\r\n            ele_tr.appendChild(document.createElement(\"td\")).appendChild(ele_a_del);\r\n        }\r\n\r\n        // 1. 按添加按钮后，获取添加的信息\r\n        var ele_add = document.getElementById(\"add\");\r\n        var ele_table = document.getElementsByTagName(\"table\")[0];\r\n        ele_add.onclick = function name() {\r\n            var ele_id = document.getElementById(\"stu_id\");\r\n            var ele_name = document.getElementById(\"stu_name\");\r\n            var ele_gender = document.getElementById(\"stu_gender\");\r\n            // var studentId = ele_id.value;\r\n            // var studentName = ele_name.value;\r\n            // var studentGender = ele_gender.value;\r\n            // 2. 将信息添加到table\r\n            addToTable(ele_id.value,ele_name.value,ele_gender.value)\r\n            \r\n        }\r\n    </script>\r\n</body>\r\n</html>\r\n```\r\n\r\n![image-20210812150126366](cloudDisk/markdown/JavaWeb笔记.assets/image-20210812150126366.png)\r\n\r\n##### 案例简化（使用innerHTML属性）\r\n\r\n```html\r\n<!DOCTYPE html>\r\n<html lang=\"en\">\r\n<head>\r\n    <meta charset=\"UTF-8\">\r\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\r\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\r\n    <title>Demo</title>\r\n    <style>\r\n        div{\r\n            text-align: center;\r\n            margin-top: 60px;\r\n            \r\n        }\r\n        input[type=\"text\"]{\r\n            height: 30px;\r\n            width: 240px;\r\n        }\r\n        input[type=\"button\"]{\r\n            margin-left: 40px;\r\n            height: 34px;\r\n            width: 70px;\r\n        }\r\n        table{\r\n            margin: auto;\r\n            margin-top: 10px;\r\n            width: 680px;\r\n            border: black solid 1px;\r\n        }\r\n        .title{\r\n            font-weight: bold;\r\n        }\r\n        div td, div th{\r\n            border: black solid 1px;\r\n        }\r\n    </style>\r\n</head>\r\n<body>\r\n    <div>\r\n        <input type=\"text\" placeholder=\"请输入编号\" name=\"stu_id\" id=\"stu_id\">\r\n        <input type=\"text\" placeholder=\"请输入姓名\" name=\"stu_name\" id=\"stu_name\">\r\n        <input type=\"text\" placeholder=\"请输入性别\" name=\"stu_gender\" id=\"stu_gender\">\r\n        <input type=\"button\" name=\"\" id=\"add\" value=\"添加\">\r\n    </div>\r\n    <div>\r\n        <label for=\"\" class=\"title\">学生信息表</label>\r\n        <table>\r\n            <tr>\r\n                <th>\r\n                    <label for=\"\">编号</label>\r\n                </th>\r\n                <th>\r\n                    <label for=\"\">姓名</label>\r\n                </th>\r\n                <th>\r\n                    <label for=\"\">性别</label>\r\n                </th>\r\n                <th>\r\n                    <label for=\"\">操作</label>\r\n                </th>\r\n            </tr>\r\n            <!-- <tr>\r\n                <td>\r\n                    <label for=\"\">1</label>\r\n                </td>\r\n                <td>\r\n                    <label for=\"\">TONY</label>\r\n                </td>\r\n                <td>\r\n                    <label for=\"\">男</label>\r\n                </td>\r\n                <td>\r\n                    <a href=\"javascript:void(0);\" onclick=\"del_tr(this);\">删除</a>\r\n                </td>\r\n            </tr> -->\r\n        </table>\r\n    </div>\r\n\r\n    <script>\r\n        function del_tr(obj) {\r\n            // 获取 obj 的上三级标签，也就是a标签的上面三级标签（table）\r\n            var obj_table = obj.parentNode.parentNode.parentNode;\r\n            var obj_tr = obj.parentNode.parentNode;\r\n            obj_table.removeChild(obj_tr);\r\n        }\r\n        function addToTable(studentId,studentName,studentGender) {\r\n            // 创建tr子节点\r\n            var ele_tr = document.createElement(\"tr\")\r\n            ele_table.appendChild(ele_tr);\r\n\r\n            // // 创建td子节点\r\n            // var ele_label_id = document.createElement(\"label\");\r\n            // var ele_text_id = document.createTextNode(studentId)\r\n            // ele_label_id.appendChild(ele_text_id)\r\n            // // 添加 <label>ele_label_id</label> 到 td中， 并将 td 添加到tr中\r\n            // ele_tr.appendChild(document.createElement(\"td\")).appendChild(ele_label_id);\r\n            // 简化后：\r\n            ele_tr.innerHTML += \"<td><label>\"+studentId+\"</label></td>\";\r\n\r\n            // var ele_label_name = document.createElement(\"label\");\r\n            // var ele_text_name = document.createTextNode(studentName)\r\n            // ele_label_name.appendChild(ele_text_name)\r\n            // // 添加 <label>ele_label_name</label> 到 td中， 并将 td 添加到tr中\r\n            // ele_tr.appendChild(document.createElement(\"td\")).appendChild(ele_label_name);\r\n            // 简化后：\r\n            ele_tr.innerHTML += \"<td><label>\"+studentName+\"</label></td>\";\r\n\r\n            // var ele_label_gender = document.createElement(\"label\");\r\n            // var ele_text_gender = document.createTextNode(studentGender)\r\n            // ele_label_gender.appendChild(ele_text_gender)\r\n            // // 添加 <label>ele_label_gender</label> 到 td中， 并将 td 添加到tr中\r\n            // ele_tr.appendChild(document.createElement(\"td\")).appendChild(ele_label_gender);\r\n            // 简化后：\r\n            ele_tr.innerHTML += \"<td><label>\"+studentGender+\"</label></td>\";\r\n\r\n            // var ele_a_del = document.createElement(\"a\");\r\n            // var ele_text_del = document.createTextNode(\"删除\")\r\n            // ele_a_del.appendChild(ele_text_del)\r\n            // ele_a_del.href = \"javascript:void(0);\";\r\n            // // 点击删除，删除对应的 tr\r\n            // ele_a_del.onclick = function name() {\r\n            //     ele_table.removeChild(ele_tr);\r\n            // }\r\n            // // 添加 <a href=\"javascript:void(0);\">删除</a> 到 td中， 并将 td 添加到tr中\r\n            // ele_tr.appendChild(document.createElement(\"td\")).appendChild(ele_a_del);\r\n            // 简化后：\r\n            ele_tr.innerHTML += \"<td><a href=\'javascript:void(0);\' onclick=\'del_tr(this)\'>删除</a></td>\";// onclick=\'del_tr(this) 中的 this 是所在标签的元素对象\r\n        }\r\n\r\n        // 1. 按添加按钮后，获取添加的信息\r\n        var ele_add = document.getElementById(\"add\");\r\n        var ele_table = document.getElementsByTagName(\"table\")[0];\r\n        ele_add.onclick = function name() {\r\n            var ele_id = document.getElementById(\"stu_id\");\r\n            var ele_name = document.getElementById(\"stu_name\");\r\n            var ele_gender = document.getElementById(\"stu_gender\");\r\n            // 2. 将信息添加到table\r\n            addToTable(ele_id.value,ele_name.value,ele_gender.value)\r\n        }\r\n\r\n    </script>\r\n</body>\r\n</html>\r\n```\r\n\r\n#### HTML DOM\r\n\r\n1. 标签体的设置和获取：innerHTML\r\n2. 使用html元素对象的属性\r\n3. 控制元素样式\r\n   1. 使用元素的style属性来设置\r\n      如：\r\n      	 //修改样式方式1\r\n           div1.style.border = \"1px solid red\";\r\n           div1.style.width = \"200px\";\r\n           //font-size--> fontSize\r\n           div1.style.fontSize = \"20px\";\r\n   2. 提前定义好类选择器的样式，通过元素的className属性来设置其class属性值。\r\n\r\n## 15.4 事件\r\n\r\n### 事件简单学习\r\n\r\n* 功能： 某些组件被执行了某些操作后，触发某些代码的执行。\r\n\r\n  * 造句：  xxx被xxx,我就xxx\r\n    * 我方水晶被摧毁后，我就责备对友。\r\n    * 敌方水晶被摧毁后，我就夸奖自己。\r\n\r\n* 如何绑定事件\r\n\r\n  1. 直接在html标签上，指定事件的属性(操作)，属性值就是js代码\r\n\r\n     1. 事件：onclick--- 单击事件\r\n\r\n  2. 通过js获取元素对象，指定事件属性，设置一个函数\r\n\r\n     * 案例1：电灯开关\r\n\r\n     * ![image-20210811133214931](cloudDisk/markdown/JavaWeb笔记.assets/image-20210811133214931.png)\r\n\r\n     * ```html\r\n       <!DOCTYPE html>\r\n       <html lang=\"en\">\r\n       <head>\r\n           <meta charset=\"UTF-8\">\r\n           <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\r\n           <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\r\n           <title>Demo</title>\r\n       \r\n       </head>\r\n       <body>\r\n             <img src=\"C:\\Users\\Tony\\Pictures\\Saved Pictures\\lightOff.jpg\" id=\"light\">\r\n       \r\n       \r\n           <script>\r\n               function ligthOn(){\r\n                   light.src = \"C:\\\\Users\\\\Tony\\\\Pictures\\\\Saved Pictures\\\\lightOn.jpg\";\r\n                   light.onclick = lightOff;\r\n               }\r\n               function lightOff(){\r\n                   light.src = \"C:\\\\Users\\\\Tony\\\\Pictures\\\\Saved Pictures\\\\lightOff.jpg\";\r\n                   light.onclick = ligthOn;\r\n               }\r\n               var light = document.getElementById(\"light\");\r\n               light.onclick = ligthOn;\r\n       \r\n           </script>\r\n       </body>\r\n       </html>\r\n       ```\r\n\r\n       \r\n\r\n# 十六、Bootstrap\r\n\r\n文档地址：https://v3.bootcss.com/css/\r\n\r\n## 概念：\r\n\r\n 一个前端开发的框架，Bootstrap，来自 Twitter，是目前很受欢迎的前端框架。Bootstrap 是基于 HTML、CSS、JavaScript 的，它简洁灵活，使得 Web 开发更加快捷。\r\n\r\n* 框架:一个半成品软件，开发人员可以在框架基础上，在进行开发，简化编码。\r\n* 好处：\r\n  1. 定义了很多的css样式和js插件。我们开发人员直接可以使用这些样式和插件得到丰富的页面效果。\r\n  2. 响应式布局。\r\n     * 同一套页面可以兼容不同分辨率的设备。\r\n\r\n## 快速入门\r\n\r\n1. 下载Bootstrap\r\n\r\n2. 在项目中将这三个文件夹复制\r\n\r\n3. 创建html页面，引入必要的资源文件\r\n\r\n4. 基本模板：\r\n\r\n   ```html\r\n   <!DOCTYPE html>\r\n   <html lang=\"zh-CN\">\r\n   <head>\r\n       <meta charset=\"utf-8\">\r\n       <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\r\n       <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\r\n       <!-- 上述3个meta标签*必须*放在最前面，任何其他内容都*必须*跟随其后！ -->\r\n       <title>Bootstrap HelloWorld</title>\r\n   \r\n       <!-- Bootstrap -->\r\n       <link href=\"bootstrap-3.4.1-dist/css/bootstrap.min.css\" rel=\"stylesheet\">\r\n           <!-- jQuery (Bootstrap 的所有 JavaScript 插件都依赖 jQuery，所以必须放在前边) -->\r\n       <script src=\"bootstrap-3.4.1-dist/js/jquery-3.2.1.min.js\"></script>\r\n       <!-- 加载 Bootstrap 的所有 JavaScript 插件。你也可以根据需要只加载单个插件。 -->\r\n       <script src=\"bootstrap-3.4.1-dist/js/bootstrap.min.js\"></script>\r\n   </head>\r\n   <body>\r\n   \r\n   \r\n   </body>\r\n   </html>\r\n   ```\r\n\r\n## 响应式布局\r\n\r\n* 同一套页面可以兼容不同分辨率的设备。\r\n\r\n* 实现：依赖于栅格系统：将一行平均分成12个格子，可以指定元素占几个格子\r\n\r\n* 步骤：\r\n\r\n  1. 定义容器。相当于之前的table、\r\n     * 容器分类：\r\n       1. container：两边留白\r\n       2. container-fluid：每一种设备都是100%宽度\r\n  2. 定义行。相当于之前的tr   样式：row\r\n  3. 定义元素。指定该元素在不同的设备上，所占的格子数目。样式：col-设备代号-格子数目\r\n     * 设备代号：\r\n       1. xs：超小屏幕 手机 (<768px)：col-xs-12\r\n       2. sm：小屏幕 平板 (≥768px)\r\n       3. md：中等屏幕 桌面显示器 (≥992px)\r\n       4. lg：大屏幕 大桌面显示器 (≥1200px)\r\n\r\n  * 注意：\r\n    1. 一行中如果格子数目超过12，则超出部分自动换行。\r\n    2. 栅格类属性可以向上兼容。栅格类适用于与屏幕宽度大于或等于分界点大小的设备。\r\n    3. 如果真实设备宽度小于了设置栅格类属性的设备代码的最小值，会一个元素沾满一整行。\r\n\r\n## CSS样式和JS插件\r\n\r\n1. 全局CSS样式：\r\n   * 按钮：class=\"btn btn-default\"\r\n   * 图片：\r\n     *  class=\"img-responsive\"：图片在任意尺寸都占100%\r\n     *  图片形状\r\n        *  <img src=\"...\" alt=\"...\" class=\"img-rounded\">：方形\r\n        *  <img src=\"...\" alt=\"...\" class=\"img-circle\"> ： 圆形\r\n        *  <img src=\"...\" alt=\"...\" class=\"img-thumbnail\"> ：相框\r\n   * 表格\r\n     * table\r\n     * table-bordered\r\n     * table-hover\r\n   * 表单\r\n     * 给表单项添加：class=\"form-control\" \r\n2. 组件：\r\n   * 导航条\r\n   * 分页条\r\n3. 插件：\r\n   * 轮播图\r\n\r\n## 案例：\r\n\r\n![image-20210814145540154](cloudDisk/markdown/JavaWeb笔记.assets/image-20210814145540154.png)\r\n\r\n![image-20210814145600530](cloudDisk/markdown/JavaWeb笔记.assets/image-20210814145600530.png)\r\n\r\n![image-20210814145613517](cloudDisk/markdown/JavaWeb笔记.assets/image-20210814145613517.png)\r\n\r\n```html\r\n<!DOCTYPE html>\r\n<html lang=\"zh-CN\">\r\n<head>\r\n    <meta charset=\"utf-8\">\r\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\r\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\r\n    <!-- 上述3个meta标签*必须*放在最前面，任何其他内容都*必须*跟随其后！ -->\r\n    <title>Bootstrap HelloWorld</title>\r\n\r\n    <!-- Bootstrap -->\r\n    <link href=\"bootstrap-3.4.1-dist/css/bootstrap.min.css\" rel=\"stylesheet\">\r\n        <!-- jQuery (Bootstrap 的所有 JavaScript 插件都依赖 jQuery，所以必须放在前边) -->\r\n    <script src=\"bootstrap-3.4.1-dist/js/jquery.min.js\"></script>\r\n    <!-- 加载 Bootstrap 的所有 JavaScript 插件。你也可以根据需要只加载单个插件。 -->\r\n    <script src=\"bootstrap-3.4.1-dist/js/bootstrap.min.js\"></script>\r\n    <style>\r\n        .top-search{\r\n            padding: 15px;\r\n        }\r\n        .top-search-margin{\r\n            margin-top: 15px;\r\n        }\r\n        .top-search-logo{\r\n            margin: auto;\r\n        }\r\n\r\n        .wangshi-bottomline{\r\n            border-bottom: rgb(45, 67, 116) solid 1px;\r\n            margin-bottom: 20px;\r\n        }\r\n        p{\r\n            margin: 12px;\r\n        }\r\n\r\n        .img-jianjie{\r\n            margin: auto;\r\n        }\r\n\r\n        .jianjie-logo-left{\r\n            margin: auto;\r\n        }\r\n        .jianjie-logo-center{\r\n            margin: auto;\r\n        }\r\n        .jianjie-logo-right{\r\n            margin: auto;\r\n        }\r\n\r\n        .text-jianjie-p{\r\n            margin-top: 50px;\r\n            font-size: 18px;\r\n        }\r\n\r\n        footer{\r\n            margin-top: 50px;\r\n            margin-bottom: 50px;\r\n        }\r\n        .img-wearetongshi{\r\n            margin: auto;\r\n        }\r\n\r\n    </style>\r\n</head>\r\n<body>\r\n    <header class=\"container-fluid\" >\r\n        <div class=\"row\">\r\n            <img src=\"./img/三体页面案例图片/threeBodyTitle.png\" class=\"img-responsive\"></img>\r\n        </div>\r\n        <div class=\"row top-search\">\r\n            <div class=\"col-md-3\">\r\n                <img src=\"./img/三体页面案例图片/threeBodyLogo.png\" class=\"img-responsive top-search-logo\"></img>\r\n            </div>\r\n            <div class=\"col-md-6\">\r\n                <div class=\"input-group top-search-margin\">\r\n                <input type=\"text\" class=\"form-control\" placeholder=\"Search for...\">\r\n                <span class=\"input-group-btn\">\r\n                    <button class=\"btn btn-default\" type=\"button\">搜索</button>\r\n                </span>\r\n                </div><!-- /input-group -->\r\n             </div>\r\n        </div>\r\n        <div class=\"row\">\r\n            <nav class=\"navbar navbar-default\">\r\n                <div class=\"container-fluid\">\r\n                  <!-- Brand and toggle get grouped for better mobile display -->\r\n                  <div class=\"navbar-header\">\r\n                    <button type=\"button\" class=\"navbar-toggle collapsed\" data-toggle=\"collapse\" data-target=\"#bs-example-navbar-collapse-1\" aria-expanded=\"false\">\r\n                      <span class=\"sr-only\">Toggle navigation</span>\r\n                      <span class=\"icon-bar\"></span>\r\n                      <span class=\"icon-bar\"></span>\r\n                      <span class=\"icon-bar\"></span>\r\n                    </button>\r\n                    <a class=\"navbar-brand\" href=\"#\">首页</a>\r\n                  </div>\r\n              \r\n                  <!-- Collect the nav links, forms, and other content for toggling -->\r\n                  <div class=\"collapse navbar-collapse\" id=\"bs-example-navbar-collapse-1\">\r\n                    <ul class=\"nav navbar-nav\">\r\n                      <li ><a href=\"#\">Link <span class=\"sr-only\">(current)</span></a></li>\r\n                      <li><a href=\"#\">Link</a></li>\r\n                      <li ><a href=\"#\">Link</a></li>\r\n                    </ul>\r\n                  </div><!-- /.navbar-collapse -->\r\n                </div><!-- /.container-fluid -->\r\n              </nav>\r\n        </div>\r\n        <div class=\"row\">\r\n                <div id=\"carousel-example-generic\" class=\"carousel slide\" data-ride=\"carousel\">\r\n                    <!-- Indicators -->\r\n                    <ol class=\"carousel-indicators\">\r\n                      <li data-target=\"#carousel-example-generic\" data-slide-to=\"0\" class=\"active\"></li>\r\n                      <li data-target=\"#carousel-example-generic\" data-slide-to=\"1\"></li>\r\n                      <li data-target=\"#carousel-example-generic\" data-slide-to=\"2\"></li>\r\n                      <li data-target=\"#carousel-example-generic\" data-slide-to=\"3\"></li>\r\n                    </ol>\r\n                  \r\n                    <!-- Wrapper for slides -->\r\n                    <div class=\"carousel-inner\" role=\"listbox\">\r\n                      <div class=\"item active\">\r\n                        <img src=\"./img/三体页面案例图片/threeBodyLunbotu1.jpg\" alt=\"...\">\r\n                      </div>\r\n                      <div class=\"item\">\r\n                        <img src=\"./img/三体页面案例图片/threeBodyLunbotu2.jpg\" alt=\"...\">\r\n                      </div>\r\n                      <div class=\"item\">\r\n                        <img src=\"./img/三体页面案例图片/threeBodyLunbotu3.jpg\" alt=\"...\">\r\n                      </div>\r\n                      <div class=\"item\">\r\n                        <img src=\"./img/三体页面案例图片/threeBodyLunbotu4.jpg\" alt=\"...\">\r\n                      </div>\r\n                    </div>\r\n                  \r\n                    <!-- Controls -->\r\n                    <a class=\"left carousel-control\" href=\"#carousel-example-generic\" role=\"button\" data-slide=\"prev\">\r\n                        <span class=\"glyphicon glyphicon-chevron-left\" aria-hidden=\"true\"></span>\r\n                        <span class=\"sr-only\">Previous</span>\r\n                    </a>\r\n                    <a class=\"right carousel-control\" href=\"#carousel-example-generic\" role=\"button\" data-slide=\"next\">\r\n                        <span class=\"glyphicon glyphicon-chevron-right\" aria-hidden=\"true\"></span>\r\n                        <span class=\"sr-only\">Next</span>\r\n                    </a>\r\n                </div>\r\n        </div>\r\n    </header>\r\n    <div class=\"container\" >\r\n        <div class=\"row wangshi-bottomline\">\r\n            <div class=\"col-md-3\"><img src=\"./img/三体页面案例图片/threeBodydiqiuwangshi.png\" alt=\"\"></div>\r\n        </div>\r\n        <div class=\"row\">\r\n            <div class=\"col-md-3 col-xs-6\">\r\n                <div class=\"thumbnail\">\r\n                    <img src=\"./img/三体页面案例图片/threeBodydiwang1.png\" alt=\"...\" >\r\n                    <p>【文曰小强】84分钟速读《三体》大合集</p>\r\n                </div>\r\n            </div>\r\n            <div class=\"col-md-3 col-xs-6\">\r\n                <div class=\"thumbnail\">\r\n                    <img src=\"./img/三体页面案例图片/threeBodydiwang2.png\" alt=\"...\" >\r\n                    <p>【文曰小强】84分钟速读《三体》大合集</p>\r\n                </div>\r\n            </div>\r\n            <div class=\"col-md-3 col-xs-6\">\r\n                <div class=\"thumbnail\">\r\n                    <img src=\"./img/三体页面案例图片/threeBodydiwang3.png\" alt=\"...\" >\r\n                    <p>【文曰小强】84分钟速读《三体》大合集</p>\r\n                </div>\r\n            </div>\r\n            <div class=\"col-md-3 col-xs-6\">\r\n                <div class=\"thumbnail\">\r\n                    <img src=\"./img/三体页面案例图片/threeBodydiwang4.png\" alt=\"...\" >\r\n                    <p>【文曰小强】84分钟速读《三体》大合集</p>\r\n                </div>\r\n            </div>\r\n        </div>\r\n    </div>\r\n    <div class=\"container\">\r\n        <div class=\"row wangshi-bottomline\">\r\n            <img src=\"./img/三体页面案例图片/threeBodyjianjie.png\" class=\"img-responsive \" alt=\"\">\r\n        </div>\r\n        <div class=\"row\">\r\n            <div class=\"col-md-4\"><img class=\"img-responsive img-jianjie\" src=\"./img/三体页面案例图片/threeBodyjianjie1.png\" alt=\"\"></div>\r\n            <div class=\"col-md-8 \">\r\n                <div class=\"row\">\r\n                    <div class=\"col-md-4\">\r\n                        <img class=\"img-responsive jianjie-logo-left\" src=\"./img/三体页面案例图片/bilibiliLogo.png\" alt=\"\">\r\n                    </div>\r\n                    <div class=\"col-md-4\">\r\n                        <img class=\"img-responsive jianjie-logo-center\" src=\"./img/三体页面案例图片/threeBodyLogo.png\" alt=\"\">\r\n                    </div>\r\n                    <div class=\"col-md-4\">\r\n                        <img class=\"img-responsive jianjie-logo-right\" src=\"./img/三体页面案例图片/threeBodyThirdLogo.png\" alt=\"\">\r\n                    </div>\r\n                </div>\r\n                <div class=\"row text-jianjie\">\r\n                    <p class=\"text-jianjie-p\">《三体》是中国科幻作家刘慈欣创作的系列长篇科幻小说，由《三体》、《三体Ⅱ·黑暗森林》、《三体Ⅲ·死神永生》组成，总篇幅达八十万余字。\r\n                        其第一部经过刘宇昆翻译后获得了第73届雨果奖最佳长篇小说奖。</p>\r\n\r\n                    <p class=\"text-jianjie-p\">20世纪70年代，探寻外星文明的绝密计划“红岸”取得了突破性进展。\r\n                        但在按下发射键的那一刻，历经劫难的叶文洁没有意识到，她彻底改变了人类的命运。\r\n                        地球文明向宇宙发出的第一声啼鸣，以太阳为中心，以光速向宇宙深处飞驰……</p>\r\n                        \r\n                     <p class=\"text-jianjie-p\">四光年外，“三体文明”正苦苦挣扎——三颗无规则运行的太阳主导下的百余次毁灭与重生逼迫他们逃离母星。\r\n                        而恰在此时，他们接收到了地球发来的信息。\r\n                        在运用智子锁死地球人的基础科学之后。\r\n                        三体人庞大的宇宙舰队开始向地球进发……</p>\r\n                </div>\r\n            </div>\r\n        </div>\r\n    </div>\r\n    <footer>\r\n        <div>\r\n            <img class=\"img-responsive img-wearetongshi\" src=\"./img/三体页面案例图片/wearetongzhi.png\" alt=\"\">\r\n        </div>\r\n    </footer>\r\n</body>\r\n</html>\r\n```\r\n\r\n# 十七、事件\r\n\r\n* 概念：某些组件被执行了某些操作后，触发某些代码的执行。\r\n  * 事件：某些操作。如： 单击，双击，键盘按下了，鼠标移动了\r\n  * 事件源：组件。如： 按钮 文本输入框...\r\n  * 监听器：代码。\r\n  * 注册监听：将事件，事件源，监听器结合在一起。 当事件源上发生了某个事件，则触发执行某个监听器代码。\r\n\r\n## 常见的事件：\r\n\r\n### 1. 点击事件：\r\n\r\n1. onclick：单击事件\r\n2. ondblclick：双击事件\r\n\r\n### 2. 焦点事件\r\n\r\n1. onblur：失去焦点\r\n\r\n   * 一般用于表单校验。当用户填完信息后，失去焦点时，判断用户输入的数据的格式是否合法。\r\n\r\n   * ```html\r\n     <body>\r\n         用户名：<input type=\"text\" name=\"\" onblur=\"blurAlart()\" id=\"\">\r\n     \r\n         <script>\r\n             function blurAlart() {\r\n                 alert(\"用户名格式错误\");\r\n             }\r\n         </script>\r\n     </body>\r\n     ```\r\n\r\n     \r\n\r\n2. onfocus:元素获得焦点。\r\n\r\n### 3. 加载事件：\r\n\r\n1. onload：一张页面或一幅图像完成加载时，触发时间。\r\n\r\n### 4. 鼠标事件：\r\n\r\n1. onmousedown	鼠标按钮被按下。\r\n\r\n   ```html\r\n   <body>\r\n       用户名：<input type=\"text\" name=\"\" id=\"username\">\r\n   \r\n       <script>\r\n           var but = document.getElementById(\"username\");\r\n           but.onmousedown = function (e) {\r\n               var i = e.button;\r\n               if(i==0)\r\n                   alert(\"左键被按下\");\r\n               else if(i==1)\r\n                   alert(\"滚轮键被按下\");\r\n               else\r\n                   alert(\"右键被按下\");\r\n           }\r\n       </script>\r\n   </body>\r\n   ```\r\n\r\n   \r\n\r\n2. onmouseup	鼠标按键被松开。\r\n\r\n3. onmousemove	鼠标被移动。\r\n\r\n4. onmouseover	鼠标移到某元素之上。\r\n\r\n5. onmouseout	鼠标从某元素移开。\r\n\r\n### 5. 键盘事件：\r\n\r\n 1. onkeydown	某个键盘按键被按下。\r\n\r\n    ```html\r\n    <body>\r\n        用户名：<input type=\"text\" name=\"\" id=\"username\">\r\n    \r\n        <script>\r\n            var but = document.getElementById(\"username\");\r\n            but.onkeydown = function (e) {\r\n                var i = e.keyCode;\r\n                if(i==13)\r\n                    alert(\"提交表单\");\r\n            }\r\n        </script>\r\n    </body>\r\n    ```\r\n\r\n\r\n	2. onkeyup		某个键盘按键被松开。\r\n	3. onkeypress	某个键盘按键被按下并松开。\r\n\r\n### 6. 选择和改变\r\n\r\n1. onchange	域的内容被改变。\r\n\r\n   ```html\r\n   <body>\r\n       <select id=\"city\">\r\n           <option>--请选择--</option>\r\n           <option>北京</option>\r\n           <option>上海</option>\r\n           <option>苏州</option>\r\n       </select>\r\n       <script>\r\n           var but = document.getElementById(\"city\");\r\n           but.onchange = function (e) {\r\n               alert(\"改变为了：\"+e.currentTarget.value);\r\n           }\r\n       </script>\r\n   </body>\r\n   ```\r\n\r\n   \r\n\r\n2. onselect	文本被选中。\r\n\r\n### 7. 表单事件：\r\n\r\n1. onsubmit	确认按钮被点击。\r\n\r\n   * 可以阻止表单提交\r\n\r\n   * onsubmit触发函数的返回值为false\r\n\r\n   * 两种方式阻止提交表单\r\n\r\n     * ```html\r\n       <body>\r\n       <form action=\"get\" action=\"#\" id=\"form\">\r\n           用户名：<input type=\"text\" name=\"username\" id=\"\">\r\n           <input type=\"submit\" value=\"提交\">\r\n       </form>\r\n           <script>\r\n               var form = document.getElementById(\"form\");\r\n               form.onsubmit = function () {\r\n                   // 提不提交表单看返回值\r\n                   return false;\r\n               }\r\n           </script>\r\n       </body>\r\n       ```\r\n\r\n     * ```html\r\n       <body>\r\n       <form action=\"get\" action=\"#\" id=\"form\" onclick=\"return check()\">\r\n           用户名：<input type=\"text\" name=\"username\" id=\"\">\r\n           <input type=\"submit\" value=\"提交\">\r\n       </form>\r\n           <script>\r\n               var form = document.getElementById(\"form\");\r\n               function check() {\r\n                   // 提不提交表单看返回值\r\n                   return true;\r\n               }\r\n           </script>\r\n       </body>\r\n       ```\r\n\r\n       \r\n\r\n2. onreset	重置按钮被点击。\r\n\r\n## 案例 - 完成表格及逻辑功能（全选、全不选、反选、鼠标放在元素上有背景色效果）\r\n\r\n![image-20210815112315987](cloudDisk/markdown/JavaWeb笔记.assets/image-20210815112315987-1628997796581.png)\r\n\r\n### 我的代码：\r\n\r\n```html\r\n<!DOCTYPE html>\r\n<html lang=\"en\">\r\n<head>\r\n    <meta charset=\"UTF-8\">\r\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\r\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\r\n    <title>Demo</title>\r\n    <style>\r\n        div{\r\n            text-align: center;\r\n            margin-top: 60px;\r\n            \r\n        }\r\n        input[type=\"text\"]{\r\n            height: 30px;\r\n            width: 240px;\r\n        }\r\n        #add{\r\n            margin-left: 40px;\r\n            height: 34px;\r\n            width: 70px;\r\n        }\r\n        table{\r\n            margin: auto;\r\n            margin-top: 10px;\r\n            width: 680px;\r\n            border: black solid 1px;\r\n        }\r\n        .title{\r\n            font-weight: bold;\r\n        }\r\n        div td, div th{\r\n            border: black solid 1px;\r\n        }\r\n        .select{\r\n            height: 34px;\r\n            width: 70px;\r\n            margin-left: 10px;\r\n            margin: auto;\r\n        }\r\n        .select-div{\r\n            margin-top: 20px;\r\n        }\r\n        .tr_color{\r\n            background-color: violet;\r\n        }\r\n    </style>\r\n</head>\r\n<body>\r\n    <div>\r\n        <input type=\"text\" placeholder=\"请输入编号\" name=\"stu_id\" id=\"stu_id\">\r\n        <input type=\"text\" placeholder=\"请输入姓名\" name=\"stu_name\" id=\"stu_name\">\r\n        <input type=\"text\" placeholder=\"请输入性别\" name=\"stu_gender\" id=\"stu_gender\">\r\n        <input type=\"button\" name=\"\" id=\"add\" value=\"添加\">\r\n    </div>\r\n    <div>\r\n        <label for=\"\" class=\"title\">学生信息表</label>\r\n        <table>\r\n            <tr>\r\n                <th>\r\n                    <input type=\"checkbox\" class=\"checkbox\" onclick=\"select_all_or_null()\" name=\"\" id=\"\">\r\n                </th>\r\n                <th>\r\n                    <label for=\"\">编号</label>\r\n                </th>\r\n                <th>\r\n                    <label for=\"\">姓名</label>\r\n                </th>\r\n                <th>\r\n                    <label for=\"\">性别</label>\r\n                </th>\r\n                <th>\r\n                    <label for=\"\">操作</label>\r\n                </th>\r\n            </tr>\r\n        </table>\r\n        <div class=\"select-div\">\r\n            <input type=\"button\" class=\"select\" value=\"全选\" onclick=\"select_all()\">\r\n            <input type=\"button\" class=\"select\"  value=\"全不选\" onclick=\"select_null()\">\r\n            <input type=\"button\" class=\"select\"  value=\"反选\" onclick=\"select_opposide()\">\r\n        </div>\r\n    </div>\r\n    <script>\r\n        function del_tr(obj) {\r\n            // 获取 obj 的上三级标签，也就是a标签的上面三级标签（table）\r\n            var obj_table = obj.parentNode.parentNode.parentNode;\r\n            var obj_tr = obj.parentNode.parentNode;\r\n            obj_table.removeChild(obj_tr);\r\n        }\r\n        function addToTable(studentId,studentName,studentGender) {\r\n            // 创建tr子节点\r\n            var ele_tr = document.createElement(\"tr\")\r\n            ele_tr.onmouseover = mouse_over_row;\r\n            ele_tr.onmouseout = mouse_out_row;\r\n            ele_table.appendChild(ele_tr);\r\n            ele_tr.innerHTML += \"<td><input type=\'checkbox\' class=\'checkbox\'></td>\";\r\n            ele_tr.innerHTML += \"<td><label>\"+studentId+\"</label></td>\";\r\n            ele_tr.innerHTML += \"<td><label>\"+studentName+\"</label></td>\";\r\n            ele_tr.innerHTML += \"<td><label>\"+studentGender+\"</label></td>\";\r\n            ele_tr.innerHTML += \"<td><a href=\'javascript:void(0);\' onclick=\'del_tr(this)\'>删除</a></td>\";// onclick=\'del_tr(this) 中的 this 是所在标签的元素对象\r\n        }\r\n\r\n        // 1. 按添加按钮后，获取添加的信息\r\n        var ele_add = document.getElementById(\"add\");\r\n        var ele_table = document.getElementsByTagName(\"table\")[0];\r\n        ele_add.onclick = function name() {\r\n            var ele_id = document.getElementById(\"stu_id\");\r\n            var ele_name = document.getElementById(\"stu_name\");\r\n            var ele_gender = document.getElementById(\"stu_gender\");\r\n            // 2. 将信息添加到table\r\n            addToTable(ele_id.value,ele_name.value,ele_gender.value)\r\n        }\r\n\r\n\r\n        function select_all(){\r\n            var checkboxes =  document.getElementsByClassName(\"checkbox\");\r\n            // alert(checkboxes.length);\r\n            for(var i=0; i<checkboxes.length; i++){\r\n                checkboxes[i].checked = true;\r\n            }\r\n        }\r\n        function select_null() {\r\n            var checkboxes =  document.getElementsByClassName(\"checkbox\");\r\n            // alert(checkboxes.length);\r\n            for(var i=0; i<checkboxes.length; i++){\r\n                checkboxes[i].checked = false;\r\n            }\r\n        }\r\n        function select_opposide() {\r\n            var checkboxes =  document.getElementsByClassName(\"checkbox\");\r\n            // alert(checkboxes.length);\r\n            for(var i=0; i<checkboxes.length; i++){\r\n                // checkboxes[i].checked = false;\r\n                checkboxes[i].checked = checkboxes[i].checked ? false : true;\r\n            }\r\n        }\r\n        function select_all_or_null() {\r\n            var flag = true;\r\n            var checkboxes =  document.getElementsByClassName(\"checkbox\");\r\n            for(var i=0; i<checkboxes.length; i++){\r\n                flag = checkboxes[i].checked;\r\n            }\r\n            if (flag)\r\n                select_null();\r\n            else\r\n                select_all();  \r\n        }\r\n        function mouse_over_row(e) {\r\n            // e.currentTarget.class = \"tr_color\";\r\n            e.currentTarget.style.backgroundColor =  \"violet\";\r\n            // alert(e.currentTarget);\r\n        }\r\n        function mouse_out_row(e) {\r\n            e.currentTarget.style.backgroundColor =  \"white\";\r\n        }\r\n    </script>\r\n</body>\r\n</html>\r\n```\r\n\r\n### 参考代码:\r\n\r\n```html\r\n<!DOCTYPE html>\r\n<html lang=\"en\">\r\n<head>\r\n    <meta charset=\"UTF-8\">\r\n    <title>表格全选</title>\r\n    <style>\r\n        table{\r\n            border: 1px solid;\r\n            width: 500px;\r\n            margin-left: 30%;\r\n        }\r\n\r\n        td,th{\r\n            text-align: center;\r\n            border: 1px solid;\r\n        }\r\n        div{\r\n            margin-top: 10px;\r\n            margin-left: 30%;\r\n        }\r\n\r\n        .over{\r\n            background-color: pink;\r\n        }\r\n        .out{\r\n            background-color: white;\r\n        }\r\n    </style>\r\n\r\n    <script>\r\n\r\n        window.onload  = function(){\r\n            document.getElementById(\"selectAll\").onclick = function(){\r\n                var cbs = document.getElementsByName(\"cb\");\r\n                for (var i = 0; i < cbs.length; i++) {\r\n                    cbs[i].checked = true;\r\n                }\r\n\r\n            }\r\n\r\n            document.getElementById(\"unSelectAll\").onclick = function(){\r\n                var cbs = document.getElementsByName(\"cb\");\r\n                for (var i = 0; i < cbs.length; i++) {\r\n                    cbs[i].checked = false;\r\n                }\r\n\r\n            }\r\n\r\n            document.getElementById(\"selectRev\").onclick = function(){\r\n                var cbs = document.getElementsByName(\"cb\");\r\n                for (var i = 0; i < cbs.length; i++) {\r\n                    cbs[i].checked = !cbs[i].checked\r\n                }\r\n\r\n            }\r\n\r\n\r\n            document.getElementById(\"firstcb\").onclick = function(){\r\n                var cbs = document.getElementsByName(\"cb\");\r\n                var firstcb = document.getElementById(\"firstcb\");\r\n                for (var i = 0; i < cbs.length; i++) {\r\n                    cbs[i].checked = firstcb.checked;\r\n                }\r\n\r\n            }\r\n\r\n            var trs = document.getElementsByTagName(\"tr\");\r\n            for (var i = 0; i < trs.length; i++) {\r\n                trs[i].onmouseover = function(){\r\n                    this.className = \"over\"\r\n                }\r\n\r\n                trs[i].onmouseout = function(){\r\n                    this.className = \"out\"\r\n                }\r\n\r\n            }\r\n\r\n        }\r\n\r\n    </script>\r\n\r\n</head>\r\n<body>\r\n\r\n<table>\r\n    <caption>学生信息表</caption>\r\n    <tr>\r\n        <th><input type=\"checkbox\" name=\"cb\" id=\"firstcb\"></th>\r\n        <th>编号</th>\r\n        <th>姓名</th>\r\n        <th>性别</th>\r\n        <th>操作</th>\r\n    </tr>\r\n\r\n    <tr>\r\n        <td><input type=\"checkbox\" name=\"cb\"></td>\r\n        <td>1</td>\r\n        <td>令狐冲</td>\r\n        <td>男</td>\r\n        <td><a href=\"javascript:void(0);\">删除</a></td>\r\n    </tr>\r\n\r\n    <tr>\r\n        <td><input type=\"checkbox\" name=\"cb\"></td>\r\n        <td>2</td>\r\n        <td>任我行</td>\r\n        <td>男</td>\r\n        <td><a href=\"javascript:void(0);\">删除</a></td>\r\n    </tr>\r\n\r\n    <tr>\r\n        <td><input type=\"checkbox\" name=\"cb\"></td>\r\n        <td>3</td>\r\n        <td>岳不群</td>\r\n        <td>?</td>\r\n        <td><a href=\"javascript:void(0);\">删除</a></td>\r\n    </tr>\r\n\r\n</table>\r\n<div>\r\n    <input type=\"button\" id=\"selectAll\" value=\"全选\">\r\n    <input type=\"button\" id=\"unSelectAll\" value=\"全不选\">\r\n    <input type=\"button\" id=\"selectRev\" value=\"反选\">\r\n</div>\r\n</body>\r\n</html>\r\n```\r\n\r\n## 案例 - 表单校验\r\n\r\n![image-20210815141406811](cloudDisk/markdown/JavaWeb笔记.assets/image-20210815141406811.png)\r\n\r\n```html\r\n<!DOCTYPE html>\r\n<html lang=\"zh-CN\">\r\n<head>\r\n    <meta charset=\"utf-8\">\r\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\r\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\r\n    <title>Demo</title>\r\n    <style>\r\n       body{\r\n         background: #FFFFFF url(\'C:/Users/Tony/Pictures/Saved Pictures/q.jpg\') no-repeat center;\r\n         padding: 50px;\r\n       }\r\n       .div-page{\r\n         background-color: #FFFFFF;\r\n         height: 700px;\r\n         width: 1200px;\r\n         margin: auto;\r\n         margin-top: 50px;\r\n         border:5px solid rgb(226, 226, 226);\r\n       }\r\n       .div-left{\r\n          width: 300px;\r\n         float: left;\r\n     \r\n       }\r\n       .div-center{\r\n          width: 500px;\r\n          padding: 50px;\r\n         float:left;\r\n         /* border: green solid 3px; */\r\n       }\r\n       .div-right{\r\n         float: right;\r\n \r\n       }\r\n       .text_1{\r\n          color: rgb(235, 216, 52);\r\n          font-size: 22px;\r\n          margin-left: 20px;\r\n\r\n          margin-bottom: 0px;\r\n       }\r\n       .text_2{\r\n          color: rgb(121, 120, 118);\r\n          font-size: 22px;\r\n          margin-left: 20px;\r\n          margin-top: 0px;\r\n\r\n       }\r\n       .div-right p{\r\n          font-size: 15px;\r\n          margin: 20px;\r\n       }\r\n       .div-right p a{\r\n          color: palevioletred;\r\n       }\r\n\r\n       .div-center table tr label{\r\n          color: rgb(121, 120, 118);\r\n          /* border: springgreen solid 2px; */\r\n           /* height: 25px;  */\r\n        width: 80px; \r\n\r\n       }\r\n       .div-center table tr input{\r\n          border: rgb(121, 120, 118) solid 1px;\r\n          border-radius: 8px;\r\n           height: 30px;\r\n           margin-left: 30px;\r\n           /* margin: auto; */\r\n           /* text-align: left; */\r\n          /* width: 200px;  */\r\n          /* border: springgreen solid 2px; */\r\n       }\r\n       .div-center table .label{\r\n          text-align: right;\r\n\r\n       }\r\n       .div-center td{\r\n         /* border: springgreen solid 2px; */\r\n         height: 50px;\r\n         /* width: 200px; */\r\n         /* text-align:right; */\r\n       }\r\n       .div-center tr{\r\n          height: 50px;\r\n          /* text-align:right; */\r\n          /* border: springgreen solid 2px; */\r\n       }\r\n       .div-center .input{\r\n          width: 300px;\r\n       }\r\n       .sexlabel{\r\n          padding: 10px;\r\n          box-sizing: border-box;  \r\n       }\r\n\r\n       .div-center table tr input[class=\"submit\"]{\r\n         background-color: palevioletred;\r\n         border-radius: 0em;\r\n         width: 150px;\r\n         height: 45px;\r\n         color: #e7e7e7;\r\n         font-size: 16px;\r\n         border-width: 0;\r\n       }\r\n        .inputWrong{\r\n            color: red;\r\n        }\r\n     </style>\r\n       <script>\r\n         window.onload  =  function () {\r\n             document.getElementById(\"username\").onblur = checkUsername;\r\n             document.getElementById(\"password\").onblur = checkPassword;\r\n             document.getElementById(\"form\").onsubmit = function (e) {\r\n                 // 调用用户校验方法 checkUsername()\r\n                 // 调用密码校验方法 checkPassword()\r\n                 return checkUsername() & checkPassword();\r\n             }\r\n             // 校验用户名\r\n             function checkUsername() {\r\n                 // 1. 获取用户名的值\r\n                 var username = document.getElementById(\"username\").value\r\n                 // 2. 定义正则表达式\r\n                 var re = /^\\w{6,12}$/;\r\n                 // 3. 判断值是否符合正则的规则\r\n                 var flag = re.test(username)\r\n                 // 4. 提示信息\r\n                 // alert(boolean);\r\n                 if (flag){\r\n                    document.getElementById(\"usernameTure\").hidden = false;\r\n                    document.getElementById(\"usernameFalse\").hidden = true;\r\n                 }else{\r\n                    document.getElementById(\"usernameFalse\").hidden = false;\r\n                    document.getElementById(\"usernameTure\").hidden = true;\r\n                 }\r\n             }\r\n            // 校验密码\r\n            function checkPassword() {\r\n                 // 1. 获取密码的值\r\n                 var password = document.getElementById(\"password\").value\r\n                 // 2. 定义正则表达式\r\n                 var re = /^\\w{6,12}$/;\r\n                 // 3. 判断值是否符合正则的规则\r\n                 var flag = re.test(password)\r\n                 // 4. 提示信息\r\n                 // alert(boolean);\r\n                 if (flag){\r\n                    document.getElementById(\"passwordTrue\").hidden = false;\r\n                    document.getElementById(\"passwordFalse\").hidden = true;\r\n                 }else{\r\n                    document.getElementById(\"passwordFalse\").hidden = false;\r\n                    document.getElementById(\"passwordTrue\").hidden = true;\r\n                 }\r\n             }\r\n         }\r\n     </script>\r\n </head>\r\n <body>\r\n       <div class=\"div-page\">\r\n          <div class=\"div-left\">\r\n             <p class=\"text_1\">新用户注册</p>\r\n             <p class=\"text_2\">USER REGISTER</p>\r\n          </div>\r\n          <div class=\"div-center\">\r\n             <form action=\"#\" method=\"get\" id=\"form\">\r\n                <table>\r\n                   <tr>\r\n                      <td class=\"label\"><label for=\"username\">用户名</label></td> \r\n                      <td colspan=\"2\"><input type=\"text\" class=\"input\" placeholder=\"请输入账号\" name=\"username\" id=\"username\">\r\n                        <span hidden=true id=\"usernameTure\">\r\n                            <!-- <span class=\"glyphicon glyphicon-ok\" aria-hidden=\"true\"></span> -->\r\n                            <img src=\"./img/登录界面/true.png\"  aria-hidden=\"true\">\r\n                        </span>\r\n                        <span  hidden=true class=\"inputWrong\" id=\"usernameFalse\">\r\n                            格式错误\r\n                        </span>\r\n                    </td>\r\n                   </tr>\r\n                   <tr>\r\n                       <td class=\"label\"><label for=\"password\">密码</label></td> \r\n                       <td colspan=\"2\"><input type=\"password\" class=\"input\" placeholder=\"请输入密码\" name=\"password\" id=\"password\">\r\n                            <span hidden=true id=\"passwordTrue\">\r\n                                <!-- <span class=\"glyphicon glyphicon-ok\" aria-hidden=\"true\"></span> -->\r\n                                <img src=\"./img/登录界面/true.png\" aria-hidden=\"true\">\r\n                            </span>\r\n                            <span  hidden=true class=\"inputWrong\" id=\"passwordFalse\">\r\n                                格式错误\r\n                            </span>\r\n                        </td>\r\n                    </tr>\r\n                    <tr>\r\n                       <td class=\"label\"><label for=\"email\">Email</label></td> \r\n                       <td colspan=\"2\"><input type=\"email\" class=\"input\" placeholder=\"请输入Email\" name=\"email\" id=\"email\"></td>\r\n                    </tr>\r\n                    <tr>\r\n                       <td class=\"label\"><label for=\"name\">姓名</label></td> \r\n                       <td colspan=\"2\"><input type=\"text\" class=\"input\" placeholder=\"请输入真实姓名\" name=\"name\" id=\"name\"></td>\r\n                    </tr>\r\n                    <tr>\r\n                       <td class=\"label\"><label for=\"phonenumber\">手机号</label></td> \r\n                       <td colspan=\"2\"><input type=\"text\" class=\"input\"  name=\"phonenumber\" placeholder=\"请输入您的手机号\" id=\"phonenumber\"></td>\r\n                    </tr>\r\n                    <tr>\r\n                       <td class=\"label\"><label>性别</label></td> \r\n                       <td>\r\n                            <table>\r\n                               <td>\r\n                                  <input type=\"radio\" name=\"gender\" value=\"male\" checked id=\"male\">\r\n                               </td>\r\n                               <td>\r\n                                  <label for=\"male\" >男</label> \r\n                               </td>\r\n                               <td>\r\n                                  <input type=\"radio\" name=\"gender\" value=\"female\" id=\"female\">\r\n                               </td>\r\n                               <td>\r\n                                  <label for=\"female\" >女</label>\r\n                               </td>\r\n                               </td>\r\n                            </table>\r\n                       </td>\r\n                    </tr>\r\n                    <tr>\r\n                       <td class=\"label\"><label>出生日期</label></td> \r\n                       <td colspan=\"2\"><input type=\"date\"class=\"input\" name=\"birthday\"></td>\r\n                    </tr>\r\n                    <tr>\r\n                       <td class=\"label\"><label for=\"key\">验证码</label></td> \r\n                       <td >\r\n                           <input type=\"text\" name=\"key\" id=\"key\">\r\n                           \r\n                       </td>\r\n                       <td>\r\n                         <img src=\"C:\\Users\\Tony\\Pictures\\Saved Pictures\\3.png\" alt=\"\" width=\"150\">\r\n                       </td>\r\n                    </tr>\r\n                    <tr>\r\n                       <td colspan=\"3\" align=\"center\"><input type=\"submit\" value=\"注册\" class=\"submit\"></td>\r\n                       \r\n                    </tr>\r\n               </table>\r\n             </form>\r\n          </div>\r\n          <div class=\"div-right\">\r\n             <p>已有账号？<a href=\"\">立即登录</a></p> \r\n             \r\n          </div>\r\n       </div>\r\n \r\n </body>\r\n </html>\r\n```\r\n\r\n# 十八、XML\r\n\r\n## 概念：Extensible Markup Language 可扩展标记语言\r\n\r\n* 可扩展：标签都是自定义的。 \r\n\r\n  ```xml\r\n  <user>  <student>\r\n  ```\r\n\r\n  \r\n\r\n* 功能\r\n\r\n  * 存储数据\r\n    1. 配置文件\r\n    2. 在网络中传输\r\n\r\n* xml与html的区别\r\n\r\n  1. xml标签都是自定义的，html标签是预定义。\r\n  2. xml的语法严格，html语法松散\r\n  3. xml是存储数据的，html是展示数据\r\n\r\n* w3c:万维网联盟\r\n\r\n## 语法：\r\n\r\n### 基本语法：\r\n\r\n1. xml文档的后缀名 .xml\r\n2. xml第一行必须定义为文档声明\r\n3. xml文档中有且仅有一个根标签\r\n4. 属性值必须使用引号(单双都可)引起来\r\n5. 标签必须正确关闭\r\n6. xml标签名称区分大小写\r\n\r\n### 快速入门：\r\n\r\n```xml\r\n<?xml version=\'1.0\' ?>\r\n<users>\r\n	<user id=\'1\'>\r\n		<name>zhangsan</name>\r\n		<age>23</age>\r\n		<gender>male</gender>\r\n		<br/>\r\n	</user>\r\n    <user id=\'2\'>\r\n        <name>lisi</name>\r\n        <age>24</age>\r\n        <gender>female</gender>\r\n	</user>\r\n</users>\r\n```\r\n\r\n\r\n\r\n### 组成部分：\r\n\r\n1. 文档声明\r\n\r\n   1. 格式：\r\n\r\n      ```xml\r\n      <?xml 属性列表 ?>\r\n      ```\r\n\r\n      \r\n\r\n   2. 属性列表：\r\n\r\n      * version：版本号，必须的属性\r\n      * encoding：编码方式。告知解析引擎当前文档使用的字符集，默认值：ISO-8859-1\r\n      * standalone：是否独立\r\n        * 取值：\r\n          * yes：不依赖其他文件\r\n          * no：依赖其他文件\r\n\r\n2. 指令(了解)：结合css的\r\n\r\n   * ```xml\r\n     <?xml-stylesheet type=\"text/css\" href=\"a.css\" ?>\r\n     ```\r\n\r\n3. 标签：标签名称自定义的\r\n\r\n   * 规则：\r\n     * 名称可以包含字母、数字以及其他的字符 \r\n     * 名称不能以数字或者标点符号开始 \r\n     * 名称不能以字母 xml（或者 XML、Xml 等等）开始 \r\n     * 名称不能包含空格 \r\n\r\n4. 属性：\r\n   id属性值唯一\r\n\r\n5. 文本：\r\n\r\n   * CDATA区：在该区域中的数据会被原样展示\r\n\r\n     * 格式： \r\n\r\n       ```xml\r\n        <![CDATA[ 数据 ]]>\r\n       ```\r\n\r\n## 约束：规定xml文档的书写规则\r\n\r\n* 作为框架的使用者(程序员)：\r\n  1. 能够在xml中引入约束文档\r\n  2. 能够简单的读懂约束文档\r\n\r\n![image-20210816141334790](cloudDisk/markdown/JavaWeb笔记.assets/image-20210816141334790.png)\r\n\r\n* 分类：\r\n  1. DTD:一种简单的约束技术\r\n  2. Schema:一种复杂的约束技术\r\n\r\n\r\n### DTD：\r\n\r\n* 引入dtd文档到xml文档中\r\n * 内部dtd：将约束规则定义在xml文档中\r\n\r\n```xml\r\n  <!DOCTYPE students [\r\n  		...\r\n  	]>\r\n```\r\n\r\n   * 外部dtd：将约束的规则定义在外部的dtd文件中\r\n\r\n     * 本地：<!DOCTYPE 根标签名 SYSTEM \"dtd文件的位置\">\r\n\r\n     * 网络：<!DOCTYPE 根标签名 PUBLIC \"dtd文件名字\" \"dtd文件的位置URL\">\r\n\r\n       ```xml\r\n       <?xml version=\"1.0\" encoding=\"UTF-8\" ?>\r\n       <!DOCTYPE students SYSTEM \"student.dtd\">\r\n       \r\n       <students>\r\n           <student number=\"itcast_0001\">\r\n               <name>tom</name>\r\n               <age>18</age>\r\n               <sex>male</sex>\r\n           </student>\r\n       \r\n       </students>\r\n       ```\r\n\r\n       ```dtd\r\n       <!ELEMENT students (student*) >\r\n       <!ELEMENT student (name,age,sex)>\r\n       <!ELEMENT name (#PCDATA)>\r\n       <!ELEMENT age (#PCDATA)>\r\n       <!ELEMENT sex (#PCDATA)>\r\n       <!ATTLIST student number ID #REQUIRED>\r\n       ```\r\n\r\n### Schema:\r\n\r\n* 引入：\r\n  	1.填写xml文档的根元素\r\n  	2.引入xsi前缀.  xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\r\n  	3.引入xsd文件命名空间.  xsi:schemaLocation=\"http://www.itcast.cn/xml  student.xsd\"\r\n  	4.为每一个xsd约束声明一个前缀,作为标识  xmlns=\"http://www.itcast.cn/xml\" \r\n\r\n  ```xml\r\n  <students   xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\r\n  	xmlns=\"http://www.itcast.cn/xml\"\r\n  	xsi:schemaLocation=\"http://www.itcast.cn/xml  student.xsd\">	  	\r\n  ```\r\n\r\n  \r\n\r\n## 解析(爬虫解析网页源码)：操作xml文档，将文档中的数据读取到内存中\r\n\r\n* 操作xml文档\r\n  1. 解析(读取)：将文档中的数据读取到内存中\r\n  2. 写入：将内存中的数据保存到xml文档中。持久化的存储\r\n\r\n* 解析xml的方式：\r\n  1. DOM：将标记语言文档一次性加载进内存，在内存中形成一颗dom树\r\n     * 优点：操作方便，可以对文档进行CRUD的所有操作\r\n     * 缺点：占内存\r\n  2. SAX：逐行读取，基于事件驱动的。\r\n     * 优点：不占内存。\r\n     * 缺点：只能读取，不能增删改\r\n\r\n* xml常见的解析器：\r\n  1. JAXP：sun公司提供的解析器，支持dom和sax两种思想\r\n  2. DOM4J：一款非常优秀的解析器\r\n  3. Jsoup：jsoup 是一款Java 的HTML解析器，可直接解析某个URL地址、HTML文本内容。它提供了一套非常省力的API，可通过DOM，CSS以及类似于jQuery的操作方法来取出和操作数据。\r\n  4. PULL：Android操作系统内置的解析器，sax方式的。\r\n\r\n### Jsoup：\r\n\r\njsoup 是一款Java 的HTML解析器，可直接解析某个URL地址、HTML文本内容。它提供了一套非常省力的API，可通过DOM，CSS以及类似于jQuery的操作方法来取出和操作数据。\r\n\r\n* 快速入门：\r\n\r\n  * 步骤：\r\n    1. 导入jar包\r\n    2. 获取Document对象\r\n    3. 获取对应的标签Element对象\r\n    4. 获取数据\r\n\r\n* 代码：\r\n\r\n  ```xml\r\n  <?xml version=\'1.0\' encoding=\"utf-8\" ?>\r\n  <users>\r\n  	<user id=\'1\'>\r\n  		<name>zhangsan</name>\r\n  		<age>23</age>\r\n  		<gender>male</gender>\r\n  		<br/>\r\n  	</user>\r\n      <user id=\'2\'>\r\n          <name>lisi</name>\r\n          <age>24</age>\r\n          <gender>female</gender>\r\n           <![CDATA[ if(a>b && c>d) ]]>\r\n           \r\n  	</user>\r\n  </users>\r\n  ```\r\n\r\n  \r\n\r\n  ```java\r\n      public static void main(String[] args) throws IOException {\r\n          // 2. 获取Document对象，根据xml文档获取\r\n          // 2.1 获取 Demo01.xml 的path\r\n          String p = JsoupDemo01.class.getClassLoader().getResource(\"Demo01.xml\").getPath();\r\n          String path = URLDecoder.decode(p, \"utf-8\"); // 由于getPath得到的String是编码过的，需要解码\r\n          // 2. 解析xml文档，加载文档进内存，获取dom树 ---> Document\r\n          Document document = Jsoup.parse(new File(path),\"utf-8\");\r\n          // 3. 获取元素对象 Element\r\n          Elements elements = document.getElementsByTag(\"name\");\r\n          System.out.println(elements.size());\r\n          // 3.1 获取第一个name的Element对象\r\n          Element element = elements.get(0);\r\n          // 3.2 获取数据\r\n          String name = element.text();\r\n          System.out.println(name);\r\n      }\r\n  ```\r\n\r\n  ```result\r\n  2\r\n  zhangsan\r\n  \r\n  进程已结束，退出代码 0\r\n  ```\r\n\r\n  \r\n\r\n#### 对象的使用：\r\n\r\n##### 1. Jsoup：工具类，可以解析html或xml文档，返回Document\r\n\r\n* parse：解析html或xml文档，返回Document\r\n  * parse(File in, String charsetName)：解析xml或html文件的。\r\n  * parse(String html)：解析xml或html字符串\r\n  * parse(URL url, int timeoutMillis)：通过网络路径获取指定的html或xml的文档对象\r\n\r\n##### 2. Document：文档对象。代表内存中的dom树\r\n\r\n* 获取Element对象\r\n  * getElementById(String id)：根据id属性值获取唯一的element对象\r\n  * getElementsByTag(String tagName)：根据标签名称获取元素对象集合\r\n  * getElementsByAttribute(String key)：根据属性名称获取元素对象集合\r\n  * getElementsByAttributeValue(String key, String value)：根据对应的属性名和属性值获取元素对象集合\r\n\r\n##### 3. Elements：元素Element对象的集合。可以当做 ArrayList\\<Element>来使用\r\n\r\n##### 4. Element：元素对象\r\n\r\n1. 获取子元素对象\r\n   * getElementById(String id)：根据id属性值获取唯一的element对象\r\n   * getElementsByTag(String tagName)：根据标签名称获取元素对象集合\r\n   * getElementsByAttribute(String key)：根据属性名称获取元素对象集合\r\n   * getElementsByAttributeValue(String key, String value)：根据对应的属性名和属性值获取元素对象集合\r\n\r\n2. 获取属性值\r\n   * String attr(String key)：根据属性名称获取属性值\r\n3. 获取文本内容\r\n   * String text():获取文本内容\r\n   * String html():获取标签体的所有内容(包括字标签的字符串内容)\r\n\r\n##### 5. Node：节点对象\r\n\r\n* 是Document和Element的父类\r\n\r\n### 快捷查询方式：selector、XPath\r\n\r\n1. selector:选择器\r\n\r\n   * 使用的方法：Elements	select(String cssQuery)\r\n     * 语法：参考Selector类中定义的语法\r\n\r\n2. XPath：XPath即为XML路径语言，它是一种用来确定XML（标准通用标记语言的子集）文档中某部分位置的语言\r\n\r\n   * 使用Jsoup的Xpath需要额外导入jar包。\r\n\r\n   * 查询w3cshool参考手册，使用xpath的语法完成查询\r\n\r\n   * ```java\r\n     代码：\r\n     //1.获取student.xml的path\r\n        String path = JsoupDemo6.class.getClassLoader().getResource(\"student.xml\").getPath();\r\n        //2.获取Document对象\r\n        Document document = Jsoup.parse(new File(path), \"utf-8\");\r\n     \r\n        //3.根据document对象，创建JXDocument对象\r\n        JXDocument jxDocument = new JXDocument(document);\r\n     \r\n        //4.结合xpath语法查询\r\n        //4.1查询所有student标签\r\n        List<JXNode> jxNodes = jxDocument.selN(\"//student\");\r\n        for (JXNode jxNode : jxNodes) {\r\n            System.out.println(jxNode);\r\n        }\r\n     \r\n        System.out.println(\"--------------------\");\r\n     \r\n        //4.2查询所有student标签下的name标签\r\n        List<JXNode> jxNodes2 = jxDocument.selN(\"//student/name\");\r\n        for (JXNode jxNode : jxNodes2) {\r\n            System.out.println(jxNode);\r\n        }\r\n     \r\n        System.out.println(\"--------------------\");\r\n     \r\n        //4.3查询student标签下带有id属性的name标签\r\n        List<JXNode> jxNodes3 = jxDocument.selN(\"//student/name[@id]\");\r\n        for (JXNode jxNode : jxNodes3) {\r\n            System.out.println(jxNode);\r\n        }\r\n        System.out.println(\"--------------------\");\r\n        //4.4查询student标签下带有id属性的name标签 并且id属性值为itcast\r\n     \r\n        List<JXNode> jxNodes4 = jxDocument.selN(\"//student/name[@id=\'itcast\']\");\r\n        for (JXNode jxNode : jxNodes4) {\r\n            System.out.println(jxNode);\r\n        }\r\n     ```\r\n\r\n# 十九、Web服务器相关软件：Tomcat\r\n\r\n## 19.1 web相关概念回顾\r\n\r\n![image-20210817125049280](cloudDisk/markdown/JavaWeb笔记.assets/image-20210817125049280.png)\r\n\r\n1. 软件架构\r\n   1. C/S : 客户端/服务器端\r\n   2. B/S : 浏览器/服务器端\r\n2. 资源分类\r\n   1. 静态资源 ：所有用户访问后，得到的结果都是一样的，称为静态资源。静态资源可以直接被浏览器解析\r\n      * 如：html,css,JS\r\n   2. 动态资源：每个用户访问相同资源后，得到的结果可能不一样，称为动态资源。动态资源被访问后，需要先转换为静态资源，返回给浏览器\r\n      * 如： servlet/jsp,php,sa...\r\n3. 网络通信三要素\r\n   1. IP：电子设备（计算机）在网络中的唯一标识\r\n   2. 端口：应用程序在计算机中的唯一标识。0 ~ 65536\r\n   3. 传输协议：规定了数据传输的规则\r\n      1. 基础协议\r\n         1. tcp : 安全协议，三次握手。速度慢\r\n         2. udp : 不安全协议。速度块\r\n\r\n## 19.2 web服务器软件：\r\n\r\n### 概述：\r\n\r\n* 服务器：安装了服务器软件的计算机\r\n* 服务器软件：接收用户的请求，处理请求，做出响应\r\n* web服务器软件：接收用户的请求，处理请求，做出相应\r\n  * 在web服务器中，可以部署web项目，让用户通过浏览器来访问这些项目\r\n  * web容器\r\n\r\n\r\n\r\n* 常见的java相关的web服务器软件：\r\n  * webLogic : oracle公司，大型的JavaEE服务器，支持所有的JavaEE规范，收费的。\r\n  * webSphere : IBM公司，大型的JavaEE服务器，支持所有的JavaEE规范，收费的。\r\n  * JBOSS : JBOSS公式，oracle公司，大型的JavaEE服务器，支持所有的JavaEE规范，收费的。\r\n  * Tomcat : Apache基金组织，中小型的JavaEE服务器，仅仅支持少量的JavaEE规范servlet/jsp。开源的、免费的。\r\n\r\n\r\n\r\n* JavaEE : Java语言在企业级开发中使用的技术规范和总和，一共规定了13项大规范\r\n\r\n\r\n\r\n### Tomcat ：web服务器软件\r\n\r\n目录结构：\r\n\r\n* ![image-20210817131650714](cloudDisk/markdown/JavaWeb笔记.assets/image-20210817131650714.png)\r\n\r\n#### 1. 下载 ： **https://tomcat.apache.org/**\r\n\r\n#### 2. 安装：解压压缩包即可\r\n\r\n* 注意：安装目录建议不要有中文和空格\r\n\r\n#### 3. 卸载：删除目录就行\r\n\r\n#### 4. 启动：\r\n\r\n* bin/startup.bat , 双击启动即可\r\n\r\n* 可能遇到的问题：\r\n\r\n  1. 黑窗口一闪而过\r\n\r\n     * 原因：没有正确配置JAVA_HOME环境变量\r\n     * 解决方案：正确配置JAVA_HOME环境变量\r\n       * ![image-20210817133632362](cloudDisk/markdown/JavaWeb笔记.assets/image-20210817133632362.png)\r\n       * ![image-20210817133709158](cloudDisk/markdown/JavaWeb笔记.assets/image-20210817133709158.png)\r\n\r\n  2. 启动错误：\r\n\r\n     1. 暴力：找到占用的端口号，并找到对应的进程，杀死该进程\r\n\r\n        * netstat -ano\r\n\r\n     2. 温柔：修改自身的端口号\r\n\r\n        * conf/server.xml\r\n\r\n        * ```xml\r\n          <Connector port=\"8501\" protocol=\"HTTP/1.1\"\r\n                     connectionTimeout=\"20000\"\r\n                     redirectPort=\"8443\" />\r\n          ```\r\n\r\n        * 一般会将tomcat的默认端口号修改为80。80端口号是http协议默认的端口号\r\n\r\n          * 好处：在访问时，就不要输入端口号\r\n\r\n#### 5. 关闭：\r\n\r\n1. 正常关闭：\r\n\r\n   * 方式一：bin/shutdown.bat\r\n\r\n   * 方式二：在这个界面按ctrl+c\r\n\r\n     ![image-20210817135747191](cloudDisk/markdown/JavaWeb笔记.assets/image-20210817135747191.png)\r\n\r\n2. 强制关闭：\r\n\r\n   * 点击启动窗口的x\r\n\r\n#### 6. 配置 \r\n\r\n##### 6.1 部署项目的方式：\r\n\r\n1. 直接将方面放到webapps目录下即可\r\n\r\n   * /hello ：项目的访问路径 --> 虚拟目录\r\n   * 简化部署：将项目打成war包，再将war包放置到webapps目录下。\r\n     * war包会自动解压缩\r\n\r\n2. 配置/conf/server.xml文件\r\n\r\n   在\\<Host>标签体中配置\r\n\r\n   ```xml\r\n   <Context docBase=\"D:\\hello\" path=\"/hehe\" />\r\n   ```\r\n\r\n   * docBase : 项目存放的路径\r\n   * path : 虚拟目录\r\n   * 浏览器通过   localhost:8080/hehe/项目文件   访问\r\n\r\n3. 在 conf\\Catalina\\localhost 创建任意名称的xml文件。在文件中编写\r\n\r\n   ```xml\r\n   <Context docBase=\"D:\\hello\" />\r\n   ```\r\n\r\n   * 虚拟目录：xml文件的名称\r\n   * 浏览器通过 localhost:8080/xml文件的名称/项目文件 访问\r\n\r\n##### 6.2 静态项目和动态项目：\r\n\r\n* 目录结构：\r\n\r\n  * java动态项目的目录结构：\r\n\r\n    --  项目的根目录\r\n\r\n    ​		--  WEB-INF\r\n\r\n    ​				--  web.xml : 项目的核心配置文件\r\n\r\n    ​				--  classes目录：放置字节码文件\r\n\r\n    ​				--  lib目录：放置项目的依赖jar包\r\n\r\n##### 6.3 将Tomcat继承到IDEA中，并且创建JavaEE的项目，部署项目。\r\n\r\n![image-20210817145633400](cloudDisk/markdown/JavaWeb笔记.assets/image-20210817145633400.png)\r\n\r\n![image-20210817150422623](cloudDisk/markdown/JavaWeb笔记.assets/image-20210817150422623.png)\r\n\r\n![image-20210817150046727](cloudDisk/markdown/JavaWeb笔记.assets/image-20210817150046727.png)\r\n\r\n![image-20210817154045561](cloudDisk/markdown/JavaWeb笔记.assets/image-20210817154045561.png)\r\n\r\n![image-20210817154151771](cloudDisk/markdown/JavaWeb笔记.assets/image-20210817154151771.png)\r\n\r\n# 二十、 servlet : server applet\r\n\r\n![image-20210818120049716](cloudDisk/markdown/JavaWeb笔记.assets/image-20210818120049716.png)\r\n\r\n#### 1. 概念：运行在服务器端的小程序\r\n\r\n* Servlet就是一个接口，定义了java类被浏览器访问到（tomcat识别）的规则。\r\n* 将来我们自定义一个类，实现Servlet接口，复写方法。\r\n\r\n#### 2. 快速入门：\r\n\r\n1. 创建JavaEE项目\r\n\r\n2. 定义一个类，实现Servlet接口\r\n\r\n   ```java\r\n   public class ServletDemo01 implements Servlet\r\n   ```\r\n\r\n3. 实现接口中的抽象方法\r\n\r\n4. 配置Servlet\r\n\r\n   * 在web.xml中配置\r\n\r\n     ```xml\r\n         <!--    配置Servlet-->\r\n         <servlet>\r\n             <servlet-name>demo1</servlet-name>\r\n             <servlet-class>com.tony.web.servlet.ServletDemo01</servlet-class>\r\n         </servlet>\r\n         <servlet-mapping>\r\n             <servlet-name>demo1</servlet-name>\r\n             <url-pattern>/demo1</url-pattern>\r\n         </servlet-mapping>\r\n     \r\n     ```\r\n\r\n#### 3. 执行原理：\r\n\r\n1. 当服务器接收到用户的浏览器请求后，会解析请求的URL路径，获取访问的Servlet的资源路径\r\n2. 查找web.xml文件，是否有对应的\\<url-pattern>标签体内容。\r\n3. 如果有，在找到对应的\\<servlet-class>全类名\r\n4. tomcat会将字节码文件加载进内存，并创建其对象\r\n5. 调用其方法\r\n\r\n![image-20210818120543041](cloudDisk/markdown/JavaWeb笔记.assets/image-20210818120543041.png)\r\n\r\n#### 4. servlet中的生命周期：\r\n\r\n1. 被创建：执行init方法，只执行一次\r\n\r\n   * Servlet什么时候被创建？\r\n\r\n     * 默认情况下，第一次访问时，Servlet被创建\r\n\r\n     * 可以配置执行Servlet的创建时机\r\n\r\n       * 在\\<servlet>标签下配置\r\n\r\n         1. 第一次被访问时创建\r\n            * \\<load-on-startup>的值为负数\r\n\r\n         2. 在服务器启动时创建\r\n            * \\<load-on-startup>的值为0或正整数\r\n\r\n   * Servlet的init方法，只执行一次，说明一个Servlet在内存中只存在一个对象，Servlet时单例的\r\n\r\n     * 多个用户访问时，可能存在线程安全问题\r\n     * 解决：尽量不要在Servlet中定义成员变量。即使定义了成员变量，也不要对其修改值\r\n\r\n     ```xml\r\n         <servlet>\r\n             <servlet-name>demo2</servlet-name>\r\n             <servlet-class>com.tony.web.servlet.ServletDemo02</servlet-class>\r\n     <!--        指定Servlet的创建时机-->\r\n     <!--        1. 第一次被访问时创建-->\r\n     <!--            * <load-on-startup>的值为负数-->\r\n     <!--        2. 在服务器启动时创建-->\r\n     <!--            * <load-on-startup>的值为0或正整数-->\r\n             <load-on-startup>5</load-on-startup>\r\n         </servlet>\r\n     ```\r\n\r\n2. 提供服务：执行service方法，执行多次\r\n\r\n   * 每次访问Servlet时，Service方法都会被调用一次\r\n\r\n3. 被销毁：执行destroy方法，只执行一次\r\n\r\n   * Servlet被销毁时执行。服务器关闭时，Servlet被销毁\r\n   * 只有服务器正常关闭时，才会执行Destroy方法\r\n   * destroy方法在Servlet被销毁之前执行，一般用于释放资源\r\n\r\n#### 5. Servlet3.0 :\r\n\r\n* 好处：\r\n\r\n  * 支持注解配置。可以不需要web.xml了\r\n\r\n* 步骤\r\n\r\n  1. 创建JavaEE项目，选择Servlet的版本3.0以上，可以不创建web.xml\r\n\r\n  2. 定义一个类，实现Servlet接口\r\n\r\n  3. 复写方法\r\n\r\n  4. 在类上使用@WebServlet注\r\n\r\n     ```java\r\n     @WebServlet(\"/demo03\") // @WebServlet(\"资源路径\")\r\n     public class ServletDemo02 implements Servlet {\r\n     ```\r\n\r\n     ```java\r\n     @Target({ElementType.TYPE})\r\n     @Retention(RetentionPolicy.RUNTIME)\r\n     @Documented\r\n     public @interface WebServlet {\r\n         String name() default \"\"; // 相当于<Servlet-name>\r\n     \r\n         String[] value() default {}; // 代表urlPatterns()属性配置\r\n     \r\n         String[] urlPatterns() default {}; // 相当于<url-pattern>\r\n     \r\n         int loadOnStartup() default -1; // 相当于<load-on-startup>\r\n     \r\n         WebInitParam[] initParams() default {};\r\n     \r\n         boolean asyncSupported() default false;\r\n     \r\n         String smallIcon() default \"\";\r\n     \r\n         String largeIcon() default \"\";\r\n     \r\n         String description() default \"\";\r\n     \r\n         String displayName() default \"\";\r\n     }\r\n     ```\r\n\r\n  5. \r\n\r\n     \r\n\r\n#### 6. IDEA与tomcat的相关配置\r\n\r\n1. 查看控制台的log : Using CATALINA_BASE:   \"C:\\Users\\Tony\\AppData\\Local\\JetBrains\\IntelliJIdea2020.1\\tomcat\\Tomcat_8_5_69_JavaEEProject\"\r\n\r\n2. 工作空间项目 和 tomcat部署的web项目\r\n   * tomcat真正访问的是“tomcat部署的web项目”，“tomcat部署的web项目”对应着“工作空间项目”的web目录下的所有资源\r\n   * WEB-INF目录下的资源不能被浏览器直接访问\r\n   * 断电调试：使用“小虫子”启动 debug 启动\r\n\r\n#### 7. Servlet的体系结构\r\n\r\nServlet  -- 接口\r\n\r\n​	|\r\n\r\nGenericServlet  -- 抽象类\r\n\r\n​	|\r\n\r\nHttpsServlet  -- 抽象类\r\n\r\n* GenericServlet ： 将Servlet接口中的其他方法做了默认空实现，只将service()方法作为抽象\r\n\r\n  * 将来定义Servlet类时，可以继承GenericServlet，实现service()方法即可\r\n\r\n* HttpServlet ： 对http协议的一种封装，简化操作\r\n\r\n  ![image-20210818151751767](cloudDisk/markdown/JavaWeb笔记.assets/image-20210818151751767.png)\r\n\r\n  1. 定义类继承HttpServlet\r\n\r\n  2. 复写doGet/doPost方法\r\n\r\n     * 举个例子：\r\n\r\n       ```java\r\n       @WebServlet(\"/demo3\")\r\n       public class ServletDemo03 extends HttpServlet {\r\n           @Override\r\n           protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\r\n               System.out.println(\"doGet...\");\r\n           }\r\n       \r\n           @Override\r\n           protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\r\n               System.out.println(\"doPost...\");\r\n           }\r\n       }\r\n       ```\r\n\r\n       ```html\r\n       login.html\r\n           <form action=\"/demo3\" method=\"post\">\r\n               <input type=\"text\" name=\"username\"><br>\r\n               <input type=\"submit\" value=\"提交\">\r\n           </form>\r\n       ```\r\n\r\n       -->http://localhost:8501/demo3\r\n\r\n       ![image-20210818153143156](cloudDisk/markdown/JavaWeb笔记.assets/image-20210818153143156.png)\r\n\r\n       -->http://localhost:8501/login.html\r\n\r\n       ![image-20210818153217279](cloudDisk/markdown/JavaWeb笔记.assets/image-20210818153217279.png)\r\n\r\n       --> 提交\r\n\r\n       ![image-20210818153303144](cloudDisk/markdown/JavaWeb笔记.assets/image-20210818153303144.png)\r\n\r\n       \r\n\r\n#### 8. Servlet相关配置\r\n\r\n1. urlpartten : Servlet访问路径\r\n\r\n   1. 一个Servlet可以定义多个访问路径 ： @WebServlet({\"/d4\",\"/dd4\",\"/ddd4\"})\r\n\r\n   2. 路径的定义规则\r\n\r\n      1. /xxx\r\n         * 如：/demo\r\n      2. /xxx/xxx\r\n         * 如：/user/demo\r\n      3. /*\r\n         * \\* 是 匹配任意的意思\r\n         * 如 /demo 、/demo1 ...\r\n      4. *.do\r\n         * 如：demo.a 、de.ac 、 asd.ddd ....\r\n\r\n# 二十一、HTTP\r\n\r\n## 21.1 概念：\r\n\r\nHyper Text Transfer Protocol 超文本传输协议\r\n\r\n* 传输协议：定义了，客户端和服务器端通讯时，发送数据的格式\r\n* 特点：\r\n  1. 基于TCP/IP的高级协议\r\n  2. 默认端口号：80\r\n  3. 基于请求响应模型的：一次请求对应一次响应\r\n  4. 无状态的：每次请求之间相互独立，不能交互数据\r\n* 历史版本：\r\n  * 1.0 每一次请求响应都会建立新的连接\r\n  * 1.1 复用连接\r\n\r\n## 21.2 请求消息数据格式\r\n\r\n1. 请求行\r\n\r\n   请求方式 请求url 请求协议/版本\r\n\r\n   GET /login.html HTTP/1.1\r\n\r\n   * 请求方式：\r\n     * HTTP协议有7种请求方式，常用的有2种\r\n       * GET：\r\n         	1. 请求参数在请求行中，在url后\r\n          	2. 请求的url长度有限制的\r\n          	3. 不太安全\r\n       * POST\r\n         1. 请求参数在请求体中\r\n         2. 请求的url长度没有限制的\r\n         3. 相对安全\r\n\r\n2. 请求头\r\n\r\n   请求头名称: 请求头值\r\n\r\n   * 常见的请求头：\r\n     1. User-Agent ：浏览器告诉服务器，我访问你使用的浏览器版本信息\r\n        * 可以在服务器端获取该头的信息，解决浏览器的兼容性问题\r\n     2. Referer: http://localhost:8501/login.html\r\n        * 作用：\r\n          1. 防盗链\r\n          2. 统计工作\r\n\r\n3. 请求空行\r\n\r\n   空行\r\n\r\n4. 请求体（正文）\r\n\r\n   * 封装POST请求消息的请求参数的\r\n   * GET没有请求体\r\n\r\n* 字符串格式：\r\n\r\n  ```http\r\n  GET /login.html HTTP/1.1\r\n  Accept:text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9\r\n  Accept-Encoding: gzip, deflate, br\r\n  Accept-Language: zh-CN,zh;q=0.9\r\n  Cache-Control: max-age=0\r\n  Connection: keep-alive\r\n  Content-Length: 12\r\n  Content-Type: application/x-www-form-urlencoded\r\n  Cookie: Idea-9f816244=45bfa818-1c93-4127-a333-c94db52b99c2; discount_free_trigger=true\r\n  Host: localhost:8501\r\n  Origin: http://localhost:8501\r\n  Referer: http://localhost:8501/login.html\r\n  sec-ch-ua: \"Chromium\";v=\"92\", \" Not A;Brand\";v=\"99\", \"Google Chrome\";v=\"92\"\r\n  sec-ch-ua-mobile: ?0\r\n  Sec-Fetch-Dest: document\r\n  Sec-Fetch-Mode: navigate\r\n  Sec-Fetch-Site: same-origin\r\n  Sec-Fetch-User: ?1\r\n  Upgrade-Insecure-Requests: 1\r\n  User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/92.0.4515.159 Safari/537.36\r\n  \r\n  username = zhangsan\r\n  ```\r\n\r\n## 21.3 Request:\r\n\r\n![image-20210819134838586](cloudDisk/markdown/JavaWeb笔记.assets/image-20210819134838586.png)\r\n\r\n### 1. request对象和response对象的原理\r\n\r\n1. request和response对象是由服务器创建的。我们来使用它们\r\n2. request对象时来获取请求消息，response对象是来设置响应消息\r\n\r\n### 2. request对象继承体系结构\r\n\r\nServletRequest 			--  接口\r\n\r\n​		|	继承\r\n\r\nHttpServletRequest	 --  接口\r\n\r\n​		|	实现\r\n\r\norg.apache.catalina.connector.RequestFacade  类（tomcat）\r\n\r\n### 3. request功能\r\n\r\n#### 3.1 获取请求消息\r\n\r\n##### 1. 获取请求行数据\r\n\r\n* GET /day14/demo1?name=zhangsan HTTP/1.1\r\n\r\n* 方法：\r\n\r\n  1. 获取请求方式：GET\r\n\r\n     * String getMethod()\r\n\r\n  2. （*）获取虚拟目录：/day14\r\n\r\n     * String getContextPath()\r\n\r\n  3. 获取Servlet路径：/demo1\r\n\r\n     * String getServletPath()\r\n\r\n  4. 获取get方式请求参数：name=zhangsan\r\n\r\n     * String getQueryString()\r\n\r\n  5. （*）获取请求URI ： /day14/demo1\r\n\r\n     * String getRequestURI() : /day14/demo1\r\n\r\n     * StringBuffer getRequestURL() : http://localhost/day14/demo1\r\n\r\n     * URL: 统一资源定位符：http://114.220.189.110:8501/day14/requestDemo1\r\n\r\n       ​										中华人民共和国\r\n\r\n     * URI : 统一资源标识符： /day14/requestDemo1\r\n\r\n       ​										共和国\r\n\r\n  6. 获取协议版本号：HTTP/1.1\r\n\r\n     * String getProtocl()\r\n\r\n  7. 获取客户机的IP地址：\r\n\r\n     * String getRemoteAddr()\r\n\r\n* 例：\r\n\r\n  * ```java\r\n    @WebServlet(\"/requestDemo1\")\r\n    public class RequestDemo1 extends HttpServlet {\r\n        protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\r\n    \r\n        }\r\n    \r\n        protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\r\n            // 1. 获取请求方式：GET\r\n            String method = request.getMethod();\r\n            System.out.println(\"1. 获取请求方式：\"+method);\r\n            // 2. 获取虚拟目录：/day14\r\n            String contextPath = request.getContextPath();\r\n            System.out.println(\"2. 获取虚拟目录：\"+contextPath);\r\n            // 3. 获取Servlet路径：/requestDemo1\r\n            String servletPath = request.getServletPath();\r\n            System.out.println(\"3. 获取Servlet路径：\"+servletPath);\r\n            // 4. 获取参数get方式请求参数：name=zhangsan\r\n            String queryString = request.getQueryString();\r\n            System.out.println(\"4. 获取参数get方式请求参数：\"+queryString);\r\n            // 5. 获取请求URI ： /day14/demo1\r\n            String requestURI = request.getRequestURI();\r\n            System.out.println(\"5. 获取请求URI ：\"+requestURI);\r\n            StringBuffer requestURL = request.getRequestURL();\r\n            System.out.println(\"5. 获取请求URL ：\"+requestURL);\r\n            // 6. 获取协议版本号：HTTP/1.1\r\n            String protocol = request.getProtocol();\r\n            System.out.println(\"6. 获取协议版本号：\"+protocol);\r\n            // 7. 获取客户机的IP地址：\r\n            String remoteAddr = request.getRemoteAddr();\r\n            System.out.println(\"7. 获取客户机的IP地址：\"+remoteAddr);\r\n        }\r\n    }\r\n    ```\r\n\r\n    ```html\r\n    <!DOCTYPE html>\r\n    <html lang=\"en\">\r\n    <head>\r\n        <meta charset=\"UTF-8\">\r\n        <title>Login</title>\r\n    </head>\r\n    <body>\r\n        <form action=\"/day14/requestDemo1\" method=\"get\">\r\n            <input type=\"text\" name=\"username\"><br>\r\n            <input type=\"submit\" value=\"提交\">\r\n        </form>\r\n    </body>\r\n    </html>\r\n    ```\r\n\r\n    -->  http://localhost:8501/day14/Login.html\r\n\r\n    ​	![image-20210819152620186](cloudDisk/markdown/JavaWeb笔记.assets/image-20210819152620186.png)\r\n\r\n    --> 提交\r\n\r\n    ​	![image-20210819152641560](cloudDisk/markdown/JavaWeb笔记.assets/image-20210819152641560.png)\r\n\r\n    --> 提交\r\n\r\n    ![image-20210819152853463](cloudDisk/markdown/JavaWeb笔记.assets/image-20210819152853463.png)\r\n\r\n    ![image-20210819152857819](cloudDisk/markdown/JavaWeb笔记.assets/image-20210819152857819.png)\r\n\r\n##### 2. 获取请求头数据\r\n\r\n* 方法：\r\n\r\n  * （*）String getHeader(String name):  通过请求头的名称获取请求头的值\r\n\r\n  * Enumeration\\<String> getHeaderNames()：获取所有请求头的名称\r\n\r\n    ```java\r\n    @WebServlet(\"/requestDemo1\")\r\n    public class RequestDemo1 extends HttpServlet {\r\n        protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\r\n    \r\n        }\r\n    \r\n        protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\r\n            // 获取请求头数据\r\n            // 1. 获取所有请求头名称\r\n            Enumeration<String> headerNames = request.getHeaderNames();\r\n            // 2. 遍历\r\n            while (headerNames.hasMoreElements()){\r\n                String name = headerNames.nextElement();\r\n                String value = request.getHeader(name);\r\n                System.out.println(name+\"---\"+value);\r\n            }\r\n        }\r\n    }\r\n    ```\r\n\r\n##### 3.获取请求体数据\r\n\r\n* 请求体：只有POST请求方式，才有请求体，在请求体中封装了POST请求的请求参数\r\n\r\n* 步骤\r\n\r\n  1. 获取流数据\r\n     * BufferedReader getReader() :  获取字符输入流，只能操作字符数据\r\n     * ServletInputStream getInputStream() ： 获取字节输入流，可以操作所有类型的数据\r\n       * 在文件上传知识点后讲解\r\n  2. 再从对象中拿数据\r\n\r\n  例：\r\n\r\n  ```java\r\n  @WebServlet(\"/requestDemo3\")\r\n  public class RequestDemo3 extends HttpServlet {\r\n      protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\r\n          // 1. 获取输入流\r\n          BufferedReader br = request.getReader();\r\n          String line = null;\r\n          // 2. 读取数据\r\n          while ((line=br.readLine())!=null){\r\n              System.out.println(line);\r\n          }\r\n      }\r\n  \r\n      protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\r\n  \r\n      }\r\n  }\r\n  \r\n  ```\r\n\r\n  ```html\r\n  <!DOCTYPE html>\r\n  <html lang=\"en\">\r\n  <head>\r\n      <meta charset=\"UTF-8\">\r\n      <title>注册</title>\r\n  </head>\r\n  <body>\r\n      <form method=\"post\" action=\"/requestDemo3\">\r\n          <input type=\"text\" name=\"username\" placeholder=\"用户名\"><br>\r\n          <input type=\"text\" name=\"password\" placeholder=\"密码\"><br>\r\n          <input type=\"submit\" value=\"提交\">\r\n      </form>\r\n  </body>\r\n  </html>\r\n  ```\r\n\r\n  ![image-20210820113310730](cloudDisk/markdown/JavaWeb笔记.assets/image-20210820113310730.png)\r\n\r\n  --> 提交\r\n\r\n  ![image-20210820113314393](cloudDisk/markdown/JavaWeb笔记.assets/image-20210820113314393.png)\r\n\r\n#### 3.2 其他功能\r\n\r\n##### 1.  获取请求参数通用方式\r\n\r\n1. String getParameter(String name): 根据参数名称获取参数值  username=admin&password=123\r\n2. String[] getParameterValues(String name): 根据参数名称获取参数值的数组\r\n3. Enumeration\\<String> getParameterNames() : 获取所有请求的参数名称\r\n4. Map\\<String, String[]> getParameterMap():获取所有参数的map集合\r\n\r\n* 中文乱码问题：\r\n\r\n  * get方式：tomcat 8 已将get方式乱码问题解决了\r\n\r\n  * post方式：会乱码\r\n\r\n  * 解决：在获取参数前，设置request的编码\r\n\r\n    * ```java\r\n      request.setCharacterEncoding(\"utf-8\");\r\n      ```\r\n\r\n例：\r\n\r\n```java\r\n@WebServlet(\"/requestDemo4\")\r\npublic class RequestDemo4 extends HttpServlet {\r\n    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\r\n        // post 获取请求参数\r\n\r\n        System.out.println(\"------1. 根据参数名称获取参数值------\");\r\n        // 根据参数名称获取参数值\r\n        String username = request.getParameter(\"username\");\r\n        System.out.println(\"post\");\r\n        System.out.println(username);\r\n\r\n        System.out.println(\"------2. 根据参数名称获取参数值的数组------\");\r\n        // 根据参数名称获取参数值的数组\r\n            // 被选中的复选框的value值\r\n        String[] hobbies = request.getParameterValues(\"hobby\");\r\n        for (String hobby :\r\n                hobbies) {\r\n            System.out.println(hobby);\r\n        }\r\n\r\n        System.out.println(\"------3. 获取所有请求参数的名称------\");\r\n        // 获取所有请求参数的名称\r\n        Enumeration<String> parameterNames = request.getParameterNames();\r\n        while (parameterNames.hasMoreElements()){\r\n            String name = parameterNames.nextElement();\r\n            System.out.println(name);\r\n            String value = request.getParameter(name);\r\n            System.out.println(value);\r\n            System.out.println(\"-------------\");\r\n        }\r\n\r\n        System.out.println(\"------4. 获取所有参数的map集合------\");\r\n        // 获取所有参数的map集合\r\n        Map<String, String[]> parameterMap = request.getParameterMap();\r\n        Set<String> keySet = parameterMap.keySet();\r\n        for (String key :\r\n                keySet) {\r\n            String[] value = parameterMap.get(key);\r\n            System.out.println(\"key: \" + key);\r\n            System.out.println(\"value: \");\r\n            Arrays.stream(value).forEach(v -> System.out.println(\"\\t\"+v));\r\n            System.out.println(\"------------\");\r\n        }\r\n    }\r\n\r\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\r\n//        // get 获取请求参数\r\n//\r\n//        // 根据参数名称获取参数值\r\n//        String username = request.getParameter(\"username\");\r\n//        System.out.println(\"get\");\r\n//        System.out.println(username);\r\n        this.doPost(request,response);\r\n    }\r\n}\r\n```\r\n\r\n```html\r\n<!DOCTYPE html>\r\n<html lang=\"en\">\r\n<head>\r\n    <meta charset=\"UTF-8\">\r\n    <title>注册</title>\r\n</head>\r\n<body>\r\n    <form method=\"get\" action=\"/requestDemo4\">\r\n        <input type=\"text\" name=\"username\" placeholder=\"用户名\"><br>\r\n        <input type=\"text\" name=\"password\" placeholder=\"密码\"><br>\r\n        <input type=\"checkbox\" name=\"hobby\" value=\"game\">游戏\r\n        <input type=\"checkbox\" name=\"hobby\" value=\"study\">学习\r\n        <input type=\"submit\" value=\"提交\">\r\n    </form>\r\n</body>\r\n</html>\r\n```\r\n\r\n![image-20210820121411495](cloudDisk/markdown/JavaWeb笔记.assets/image-20210820121411495.png)\r\n\r\n--> 提交\r\n\r\n```result\r\n运行结果：\r\n------1. 根据参数名称获取参数值------\r\npost\r\nadmin\r\n------2. 根据参数名称获取参数值的数组------\r\ngame\r\nstudy\r\n------3. 获取所有请求参数的名称------\r\nusername\r\nadmin\r\n-------------\r\npassword\r\n123\r\n-------------\r\nhobby\r\ngame\r\n-------------\r\n------4. 获取所有参数的map集合------\r\nkey: username\r\nvalue: \r\n	admin\r\n------------\r\nkey: password\r\nvalue: \r\n	123\r\n------------\r\nkey: hobby\r\nvalue: \r\n	game\r\n	study\r\n------------\r\n\r\n```\r\n\r\n\r\n\r\n##### 2. 请求转发：一种在服务器内部的资源跳转的方式\r\n\r\n1. 步骤：\r\n   1. 通过request对象获取请求转发器对象：RequestDispatcher getRequestDispatcher(String path)\r\n   2. 通过RequestDispatcher 对象来进行转发： forward(ServletRequest request, ServletResponse response)\r\n2. 特点：\r\n   1. 浏览器地址栏路径不发生变化\r\n   2. 只能转发到当前服务器内部资源中\r\n   3. 转发是一次请求\r\n\r\n##### 3. 共享数据\r\n\r\n* 域对象：一个有作用范围的对象，可以在范围内共享数据\r\n\r\n* request域：代表一次请求的范围，一般用于请求转发多个资源中共享数据\r\n\r\n* 方法：\r\n\r\n  1. setAttribute(String nam, Object obj): 存储数据\r\n  2. Object getAttribute(String name) : 通过键获取对象\r\n  3. void removeAttribute(String name) : 通过键删除对象\r\n\r\n* 例：\r\n\r\n  * ```java\r\n    @WebServlet(\"/requestDemo5\")\r\n    public class RequestDemo5 extends HttpServlet {\r\n        protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\r\n            // 转发到requestDemo6\r\n            System.out.println(\"/requestDemo5 被访问了\");\r\n            request.setAttribute(\"msg\",\"hello\");\r\n            request.getRequestDispatcher(\"/requestDemo6\").forward(request,response);\r\n        }\r\n    \r\n        protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\r\n            this.doPost(request,response);\r\n        }\r\n    }\r\n    ```\r\n\r\n    ```java\r\n    @WebServlet(\"/requestDemo6\")\r\n    public class RequestDemo6 extends HttpServlet {\r\n        protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\r\n            System.out.println(\"/requestDemo6 被访问了\");\r\n            System.out.println(request.getAttribute(\"msg\"));\r\n        }\r\n    \r\n        protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\r\n            this.doPost(request,response);\r\n        }\r\n    }\r\n    ```\r\n\r\n    --> 访问：\r\n\r\n    ![image-20210820125337508](cloudDisk/markdown/JavaWeb笔记.assets/image-20210820125337508-1629435218135.png)\r\n\r\n    --> 输出：\r\n\r\n    ![image-20210820125357390](cloudDisk/markdown/JavaWeb笔记.assets/image-20210820125357390.png)\r\n\r\n##### 4. 获取servletContext\r\n\r\n* ServletContext getServletContext()\r\n\r\n\r\n\r\n### 案例 - 用户登录\r\n\r\n* 用户登录案例需求\r\n\r\n  ![image-20210820125804910](cloudDisk/markdown/JavaWeb笔记.assets/image-20210820125804910.png)\r\n\r\n![image-20210821150353228](cloudDisk/markdown/JavaWeb笔记.assets/image-20210821150353228.png)\r\n\r\n![image-20210821150425682](cloudDisk/markdown/JavaWeb笔记.assets/image-20210821150425682.png)\r\n\r\n```html\r\n<!--login.html-->\r\n<!DOCTYPE html>\r\n<html lang=\"en\">\r\n<head>\r\n    <meta charset=\"UTF-8\">\r\n    <title>Login</title>\r\n</head>\r\n<body>\r\n    <form action=\"/tony/loginServlet\" method=\"post\">\r\n        <input type=\"text\" name=\"username\" placeholder=\"请输入账号\"><br>\r\n        <input type=\"text\" name=\"password\" placeholder=\"请输入密码\"><br>\r\n        <input type=\"submit\" value=\"提交\">\r\n    </form>\r\n</body>\r\n</html>\r\n```\r\n\r\n#### 1. 创建数据库\r\n\r\n* ```mysql\r\n  CREATE DATABASE exam01\r\n  USE exam01\r\n  CREATE TABLE USER(\r\n  	id INT PRIMARY KEY AUTO_INCREMENT,\r\n  	username VARCHAR(32) NOT NULL,\r\n  	PASSWORD VARCHAR(32) NOT NULL,\r\n  	age INT,\r\n  	sex VARCHAR(10)\r\n  )\r\n  SELECT * FROM USER\r\n  INSERT INTO USER VALUES(NULL,\"张三\",\"123\",20,\"男\")\r\n  ```\r\n\r\n  \r\n\r\n![image-20210821150536429](cloudDisk/markdown/JavaWeb笔记.assets/image-20210821150536429.png)\r\n\r\n#### 2. 编写User类：\r\n\r\n```java\r\npublic class User {\r\n    private int id;\r\n    private String username;\r\n    private String password;\r\n    private int age;\r\n    private String sex;\r\n    ...\r\n```\r\n\r\n#### 3. 新建数据存取包：dao ;  编写数据存取对象，登录验证方法\r\n\r\n##### 3.1 导入连接数据库的jar包，数据库连接池jar包，spring框架jar包\r\n\r\n![image-20210821155909499](cloudDisk/markdown/JavaWeb笔记.assets/image-20210821155909499.png)\r\n\r\n##### 3.2 创建配置文件：druid.properties\r\n\r\n```properties\r\n# druid.properties文件的配置\r\ndriverClassName=com.mysql.jdbc.Driver\r\nurl=jdbc:mysql://localhost:3306/exam01\r\nusername=root\r\npassword=123\r\n# 初始化连接数量\r\ninitialSize=5\r\n# 最大连接数\r\nmaxActive=10\r\n# 最大超时时间\r\nmaxWait=3000\r\n```\r\n\r\n##### 3.3 操作数据库连接池的工具类\r\n\r\n```java\r\npackage com.tony.exam01.utils;\r\n\r\nimport com.alibaba.druid.pool.DruidDataSourceFactory;\r\n\r\nimport javax.sql.DataSource;\r\nimport java.io.IOException;\r\nimport java.io.InputStream;\r\nimport java.sql.Connection;\r\nimport java.sql.ResultSet;\r\nimport java.sql.SQLException;\r\nimport java.sql.Statement;\r\nimport java.util.Properties;\r\n\r\npublic final class DruidUtils {\r\n    private static DataSource ds;\r\n    static {\r\n        try {\r\n            // 1. 加载配置文件\r\n            Properties prop = new Properties();\r\n            InputStream is = DruidUtils.class.getClassLoader().getResourceAsStream(\"druid.properties\");\r\n            prop.load(is);\r\n            // 2. 获取DataSource\r\n            ds = DruidDataSourceFactory.createDataSource(prop);\r\n        } catch (IOException e) {\r\n            e.printStackTrace();\r\n        } catch (Exception e) {\r\n            e.printStackTrace();\r\n        }\r\n    }\r\n\r\n    // 获取连接\r\n    public static Connection getConnection() throws SQLException {\r\n        return ds.getConnection();\r\n    }\r\n\r\n\r\n    // 释放资源\r\n    public static void close(Statement stmt, Connection connection, ResultSet rs){\r\n        if (stmt != null){\r\n            try {\r\n                stmt.close();\r\n            } catch (SQLException throwables) {\r\n                throwables.printStackTrace();\r\n            }\r\n        }\r\n        if (connection != null){\r\n            try {\r\n                connection.close(); // 归还连接\r\n            } catch (SQLException throwables) {\r\n                throwables.printStackTrace();\r\n            }\r\n        }\r\n        if (rs != null){\r\n            try {\r\n                rs.close();\r\n            } catch (SQLException throwables) {\r\n                throwables.printStackTrace();\r\n            }\r\n        }\r\n    }\r\n\r\n    // 获取连接池方法\r\n    public static DataSource getDataSource(){\r\n        return ds;\r\n    }\r\n}\r\n\r\n```\r\n\r\n##### 3.4 数据存取类，登录验证方法\r\n\r\n```java\r\npackage com.tony.exam01.dao;\r\n\r\nimport com.tony.exam01.domain.User;\r\nimport com.tony.exam01.utils.DruidUtils;\r\nimport org.springframework.dao.EmptyResultDataAccessException;\r\nimport org.springframework.jdbc.core.BeanPropertyRowMapper;\r\nimport org.springframework.jdbc.core.JdbcTemplate;\r\n\r\npublic class LoginDao {\r\n    private static JdbcTemplate jdbcTemplate;\r\n    /*\r\n    * @author Tony\r\n    * @Description\r\n    * @Date 14:22 2021/8/21\r\n    * @Param [loginUser] 只有用户名密码\r\n    * @return com.tony.exam01.domain.User 用户的全部数据，没查询到。返回Null\r\n    **/\r\n    public static User login(User loginUser){\r\n        String loginUsername = loginUser.getUsername();\r\n        String loginPassword = loginUser.getPassword();\r\n        jdbcTemplate = new JdbcTemplate(DruidUtils.getDataSource());\r\n        try{\r\n            String sql = \"SELECT * FROM USER WHERE username= ? AND PASSWORD = ?\";\r\n            User user = jdbcTemplate.queryForObject(sql,\r\n                new BeanPropertyRowMapper<User>(User.class),\r\n                loginUsername, loginPassword);\r\n            return user;\r\n        }catch (EmptyResultDataAccessException e){\r\n            // e.printStackTrace(); // 记录日志\r\n            return null;\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n\r\n\r\n#### 4. 编写LoginServlet类\r\n\r\n```java\r\npackage com.tony.exam01.web.servlet;\r\n\r\nimport com.tony.exam01.dao.LoginDao;\r\nimport com.tony.exam01.domain.User;\r\nimport org.apache.commons.beanutils.BeanUtils;\r\n\r\nimport javax.servlet.RequestDispatcher;\r\nimport javax.servlet.ServletException;\r\nimport javax.servlet.annotation.WebServlet;\r\nimport javax.servlet.http.HttpServlet;\r\nimport javax.servlet.http.HttpServletRequest;\r\nimport javax.servlet.http.HttpServletResponse;\r\nimport java.io.IOException;\r\nimport java.lang.reflect.InvocationTargetException;\r\nimport java.util.Map;\r\n\r\n@WebServlet(\"/loginServlet\")\r\npublic class LoginServlet extends HttpServlet {\r\n    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\r\n        request.setCharacterEncoding(\"utf-8\");\r\n\r\n        /*\r\n        // 1. 获取请求参数\r\n        String username = request.getParameter(\"username\");\r\n        String password = request.getParameter(\"password\");\r\n        // 2. 创建Usr对象\r\n        User loginUser = new User();\r\n        loginUser.setUsername(username);\r\n        loginUser.setPassword(password);\r\n        */\r\n        // 使用工具类，将集合数据封装到 user 对象中\r\n        // 1. 获取请求参数\r\n        Map<String, String[]> parameterMap = request.getParameterMap();\r\n        // 2. 创建Usr对象\r\n        User loginUser = new User();\r\n        // 2.2 使用 BeanUtils 封装\r\n        try {\r\n            BeanUtils.populate(loginUser,parameterMap);\r\n        } catch (IllegalAccessException e) {\r\n            e.printStackTrace();\r\n        } catch (InvocationTargetException e) {\r\n            e.printStackTrace();\r\n        }\r\n\r\n        // 3. 通过user对象，去数据库找，能找到则返回：user,否则返回：Null\r\n        User user = LoginDao.login(loginUser);\r\n        // 4. 登录成功跳转到SuccessServlet\r\n        if (user!=null){\r\n            request.setAttribute(\"username\",user); // 存储数据\r\n            RequestDispatcher requestDispatcher = request.getRequestDispatcher(\"/SuccessServlet\");\r\n            requestDispatcher.forward(request,response);\r\n        }else {\r\n            // 登录失败跳转到FailServlet\r\n            RequestDispatcher requestDispatcher = request.getRequestDispatcher(\"/FailServlet\");\r\n            requestDispatcher.forward(request,response);\r\n        }\r\n\r\n    }\r\n\r\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\r\n        this.doPost(request,response);\r\n    }\r\n}\r\n\r\n```\r\n\r\n#### 5. 编写FailServlet类\r\n\r\n```java\r\npackage com.tony.exam01.web.servlet;\r\n\r\nimport javax.servlet.ServletException;\r\nimport javax.servlet.annotation.WebServlet;\r\nimport javax.servlet.http.HttpServlet;\r\nimport javax.servlet.http.HttpServletRequest;\r\nimport javax.servlet.http.HttpServletResponse;\r\nimport java.io.IOException;\r\n\r\n@WebServlet(\"/FailServlet\")\r\npublic class FailServlet extends HttpServlet {\r\n    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\r\n        System.out.println(\"登录失败，用户名或密码错误！\");\r\n        // 给页面写一句话\r\n        // 设置编码\r\n        response.setContentType(\"text/html;charset=utf-8\");\r\n        response.getWriter().write(\"登录失败，用户名或密码错误！\");\r\n    }\r\n\r\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\r\n        this.doPost(request,response);\r\n    }\r\n}\r\n\r\n```\r\n\r\n\r\n\r\n#### 6. 编写SuccessServlet类\r\n\r\n```java\r\npackage com.tony.exam01.web.servlet;\r\nimport com.tony.exam01.domain.User;\r\nimport javax.servlet.ServletException;\r\nimport javax.servlet.annotation.WebServlet;\r\nimport javax.servlet.http.HttpServlet;\r\nimport javax.servlet.http.HttpServletRequest;\r\nimport javax.servlet.http.HttpServletResponse;\r\nimport java.io.IOException;\r\n\r\n@WebServlet(\"/SuccessServlet\")\r\npublic class SuccessServlet extends HttpServlet {\r\n    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\r\n        User user = (User) request.getAttribute(\"username\");\r\n        if(user !=null){\r\n            System.out.println(\"登录成功！\"+user.getUsername()+\"欢迎您\");\r\n            // 给页面写一句话\r\n            // 设置编码\r\n            response.setContentType(\"text/html;charset=utf-8\");\r\n            response.getWriter().write(\"登录成功！\"+user.getUsername()+\"欢迎您\");\r\n        }\r\n    }\r\n\r\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\r\n        this.doPost(request,response);\r\n    }\r\n}\r\n\r\n```\r\n\r\n### BeanUtils 工具类 - 将集合数据封装到 user 对象中\r\n\r\n##### 用于封装JavaBean的\r\n\r\n1. JavaBean : 标准的Java类  \r\n   1. 要求\r\n      1. 类必须被public修饰\r\n      2. 必须提供空参的构造器\r\n      3. 成员变量必须使用private修饰\r\n      4. 提供公共setter和getter方法\r\n   2. 功能：封装数据\r\n2. 概念：\r\n   * 成员变量：\r\n   * 属性名：setter和getter方法截取后的产物\r\n     * 例如：getUsername() --> Username --> username\r\n3. 方法：\r\n   1. setProperty(Object bean, String name, Object value)\r\n      * String name  是属性名\r\n   2. getProperty()\r\n   3. populate(Object obj, Map map): 将map集合的键值对信息，封装到对应的JavaBean对象中\r\n\r\n例：\r\n\r\n1. 导入jar包\r\n\r\n![image-20210821153954816](cloudDisk/markdown/JavaWeb笔记.assets/image-20210821153954816.png)\r\n\r\n2. ```java\r\n   public class LoginServlet extends HttpServlet {\r\n       protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\r\n           request.setCharacterEncoding(\"utf-8\");\r\n           /*\r\n           // 1. 获取请求参数\r\n           String username = request.getParameter(\"username\");\r\n           String password = request.getParameter(\"password\");\r\n           // 2. 创建Usr对象\r\n           User loginUser = new User();\r\n           loginUser.setUsername(username);\r\n           loginUser.setPassword(password);\r\n           */\r\n           \r\n           // 使用工具类，将集合数据封装到 user 对象中\r\n           // 1. 获取请求参数\r\n           Map<String, String[]> parameterMap = request.getParameterMap();\r\n           // 2. 创建Usr对象\r\n           User loginUser = new User();\r\n           // 2.2 使用 BeanUtils 封装\r\n           try {\r\n               BeanUtils.populate(loginUser,parameterMap);\r\n           } catch (IllegalAccessException e) {\r\n               e.printStackTrace();\r\n           } catch (InvocationTargetException e) {\r\n               e.printStackTrace();\r\n           }\r\n   ```\r\n\r\n   \r\n\r\n## 21.4 响应消息数据格式\r\n\r\n### http协议：\r\n\r\n1. 请求消息：客户端发送给服务器的数据\r\n\r\n   * 数据格式\r\n     1. 请求行\r\n     2. 请求头\r\n     3. 请求空行\r\n     4. 响应体\r\n\r\n2. 响应消息：服务器发送给客户端的数据\r\n\r\n   * 数据格式\r\n\r\n     1. 请求行\r\n        1. 组成：协议/版本 响应状态码 状态码描述\r\n        2. 响应状态码：服务器告诉客户端浏览器本次请求和响应的一个状态。\r\n           1. 状态码都是3位数字\r\n           2. 分类：\r\n              1. 1xx：服务器接收客户端消息，但没有接受完成，等待一段时间后，发送1xx多状态码\r\n              2. 2xx：成功。代表：200\r\n              3. 3xx：重定向。代表：302(重定向)，304（访问缓存）\r\n              4. 4xx：客户端错误。\r\n                 * 代表：\r\n                   * 404（请求路径没有对应的资源）\r\n                   * 405：请求方式没有对应的doXxx方法\r\n              5. 5xx:   服务器端错误。代表：500（服务器内部出现异常）\r\n     2. 请求头：\r\n        1. 格式：头名称：值\r\n        2. 常见的响应头：\r\n           1. Content-Type : 服务器告诉客户端本次响应体数据的格式及编码格式\r\n              * Content-Type : text/html;charset=UTF-8\r\n           2. Content-disposition : 服务器告诉客户端以什么格式打开响应体数据\r\n              * 值：\r\n                * in-line : 默认值，在当前页面内打开\r\n                * attachment : 以附件形式打开响应体。文件下载\r\n     3. 请求空行\r\n     4. 响应体：传输的数据\r\n\r\n### Response对象\r\n\r\n#### 功能：设置响应消息\r\n\r\n1. 设置响应行\r\n   1. 格式：HTTP/1.1 200 OK\r\n   2. 设置状态码：setStatus(int sc)\r\n2. 设置响应头：setHeader(String name, String value)\r\n3. 设置响应体:\r\n   * 使用步骤：\r\n     1. 获取输出流\r\n        * 字符输出流：PrintWriter getWriter()\r\n        * 字节输出流：ServletOutputStream getOutputStream()\r\n     2. 使用输出流，将数据输出到客户端浏览器\r\n\r\n#### 案例：\r\n\r\n##### 1. 完成重定向\r\n\r\n![image-20210822131557934](cloudDisk/markdown/JavaWeb笔记.assets/image-20210822131557934.png)\r\n\r\n* 重定向：资源跳转的方式\r\n* 代码实现：\r\n\r\n```java\r\n@WebServlet(\"/responseServlet1\")\r\npublic class RespnseServlet1 extends HttpServlet {\r\n    @Override\r\n    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\r\n        System.out.println(\"demo1....\");\r\n\r\n        // 访问/responseServlet1,会自动跳转到 /responseServlet2资源\r\n        // 1. 设置状态码为302\r\n        // resp.setStatus(302);\r\n        // 2. 设置响应头为location\r\n        // resp.setHeader(\"location\",\"/responseServlet2\");\r\n        // 简单的重定向方法\r\n        resp.sendRedirect(\"/responseServlet2\");\r\n    }\r\n```\r\n\r\n```java\r\n@WebServlet(\"/responseServlet2\")\r\npublic class ResponseServlet2 extends HttpServlet {\r\n    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\r\n        System.out.println(\"demo2....\");\r\n    }\r\n```\r\n\r\n-->![image-20210822131106140](cloudDisk/markdown/JavaWeb笔记.assets/image-20210822131106140.png)\r\n\r\n![image-20210822131112943](cloudDisk/markdown/JavaWeb笔记.assets/image-20210822131112943.png)\r\n\r\n![image-20210822131127109](cloudDisk/markdown/JavaWeb笔记.assets/image-20210822131127109.png)\r\n\r\n* 重定向特点：redirect \r\n  1. 地址栏发生变化\r\n  2. 重定向可以访问其他站点（服务器）的资源\r\n  3. 重定向是两次请求。不能使用request对象共享数据\r\n* 转发的特点：forward \r\n  1. 转发地址栏不变\r\n  2. 转发只能访问服务器下的资源\r\n  3. 转发是一次请求\r\n* forward 和 redirect 区别\r\n* 路径写法：\r\n  1. 路径分类\r\n     1. 相对路径：相对路径不可以确定唯一资源\r\n        * 如：./index.html\r\n        * 不以/开头，以.开头路径\r\n        * 规则：找到当前资源和目标资源之间的相对位置关系\r\n          * ./ : 当前目录\r\n          * ../ : 后退一级目录\r\n     2. 绝对路径：通过绝对路径可以确定唯一的资源\r\n        * 如：http://localhost/day15/responseDemo2      /day15/responseDemo2\r\n        * 以/开头的路径\r\n        * 规则：判断定义的路径是给谁用的？\r\n          * 给客户端浏览器使用：需要加虚拟1目录（项目的访问路径）\r\n            * 建议虚拟目录动态获取：request.getContextPath()\r\n          * 给客户端服务器用：不需要加虚拟目录\r\n            * 转发路径\r\n\r\n##### 2. 服务器输出字符数据到浏览器\r\n\r\n* 步骤：\r\n\r\n  * 步骤\r\n\r\n    1. 获取字符输出流\r\n    2. 输出数据\r\n\r\n  * 注意：\r\n\r\n    * 乱码问题：\r\n\r\n      1. PrintWriter pw = resp.getWriter(); 获取的流的默认编码是ISO-8859-1\r\n\r\n      2. 设置该流的默认编码\r\n\r\n      3. 告诉浏览器响应体使用的编码\r\n\r\n         * 简单的形式,设置编码，是在获取流之前设置\r\n\r\n           ```java\r\n           resp.setContentType(\"text/html;charset=utf-8\");\r\n           ```\r\n\r\n##### 3. 服务器输出字节数据到浏览器\r\n\r\n* 步骤：\r\n\r\n  1. 获取字节输出流\r\n\r\n  2. 输出数据\r\n\r\n  3. 例：\r\n\r\n     ```java\r\n     protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\r\n         resp.setContentType(\"text/html;charset=utf-8\");\r\n         // 1. 获取字节输出流\r\n         ServletOutputStream ops = resp.getOutputStream();\r\n         // 2. 输出数据\r\n         ops.write(\"hello 你好\".getBytes(\"utf-8\"));\r\n     }\r\n     ```\r\n\r\n##### 4. 验证码\r\n\r\n1. 本质：是张图片\r\n2. 目的：放置恶意表单注册\r\n\r\n```java\r\n@WebServlet(\"/responseServlet1\")\r\npublic class RespnseServlet1 extends HttpServlet {\r\n    @Override\r\n    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\r\n\r\n\r\n        int width = 100;\r\n        int height = 50;\r\n        // 1. 创建一个对象,在内存中图片(验证码图片对象)\r\n        BufferedImage image = new BufferedImage(width, height, BufferedImage.TYPE_INT_RGB);\r\n        // 2. 每户图片\r\n        // 2.1 填充背景色\r\n        Graphics g = image.getGraphics();// 画笔对象\r\n        g.setColor(Color.pink);\r\n        g.fillRect(0,0,width,height);\r\n\r\n        // 2.2 画边框\r\n        g.setColor(Color.blue);\r\n        g.drawRect(0,0,width-1,height - 1);\r\n        String str = \"ABCDEFGHIJKLMNPQRSTUVWXYZabcdefghijklmnpqrstuvwxyz123456789\";\r\n        // 生成随机角坐标\r\n        Random random = new Random();\r\n        for (int i = 0; i < 4; i++) {\r\n            int index = random.nextInt(str.length());\r\n            // 获取字符\r\n            char ch = str.charAt(index); // 随机字符\r\n            // 2.3 写验证码\r\n            g.drawString(ch+\"\",width/5*(i+1),height/2);\r\n        }\r\n\r\n        // 2.4 画干扰线\r\n        g.setColor(Color.green);\r\n\r\n        // 2.4 随机生成坐标点\r\n        for (int i = 0; i < 10; i++) {\r\n            int x1 = random.nextInt(width);\r\n            int x2 = random.nextInt(width);\r\n            int y1 = random.nextInt(height);\r\n            int y2 = random.nextInt(height);\r\n            g.drawLine(x1,y1,x2,y2);\r\n        }\r\n\r\n        // 2. 将图片输出到页面展示\r\n        ImageIO.write(image,\"jpg\",resp.getOutputStream());\r\n    }\r\n```\r\n\r\n```html\r\n<!DOCTYPE html>\r\n<html lang=\"en\">\r\n<head>\r\n    <meta charset=\"UTF-8\">\r\n    <title>Title</title>\r\n    <script>\r\n        window.onload = function () {\r\n            var a_ele = document.getElementById(\"changeImg\");\r\n            var img_ele = document.getElementById(\"img\");\r\n            a_ele.onclick = function () {\r\n                // 加时间戳\r\n                var date = new Date().getTime();\r\n                img_ele.src = \"/responseServlet1?\"+date;\r\n            }\r\n            img_ele.onclick =  function () {\r\n                // 加时间戳\r\n                var date = new Date().getTime();\r\n                img_ele.src = \"/responseServlet1?\"+date;\r\n            }\r\n        }\r\n    </script>\r\n</head>\r\n<body>\r\n    <img src=\"/responseServlet1\" id=\"img\">\r\n    <a id=\"changeImg\" href=\"javascript:void(0)\">看不清,换一张?</a>\r\n</body>\r\n</html>\r\n```\r\n\r\n\r\n\r\n## 21.5 ServletContext对象\r\n\r\n### 1. 概念：\r\n\r\n代表整个web应用，可以和程序的容器（服务器）通信\r\n\r\n### 2. 获取：\r\n\r\n#### 1）通过request对象获取\r\n\r\nrequest.getServletContext()\r\n\r\n#### 2） 通过HttpServlet获取\r\n\r\nthis.getServletContext();\r\n\r\n```java\r\npublic class ServletContextDemo1 extends HttpServlet {\r\n    @Override\r\n    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\r\n        // ServletContext对象获取\r\n        ServletContext context1 = req.getServletContext();\r\n        ServletContext context2 = this.getServletContext();\r\n        System.out.println(context1);\r\n        System.out.println(context2);\r\n        System.out.println(context1 == context2);\r\n    }\r\n```\r\n\r\n\r\n\r\n### 3. 功能：\r\n\r\n#### 1) 获取MIME类型：\r\n\r\n* 在互联网通信过程中定义的一种文件数据类型\r\n\r\n  * 格式：大类型/小类型   text/html        image/jpeg\r\n\r\n* 获取：\r\n\r\n  ```java\r\n  String getMimeType(String file)  \r\n  ```\r\n\r\n* 如：\r\n\r\n  ```java\r\n  protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\r\n          // ServletContext对象获取\r\n          ServletContext context = this.getServletContext();\r\n          String fileName = \"a.png\";\r\n          String mimeType = context.getMimeType(fileName);\r\n          System.out.println(mimeType); // image/png\r\n      }\r\n  ```\r\n\r\n  \r\n\r\n#### 2) 域对象：共享数据\r\n\r\n1. setAttribute(String name, Object value)\r\n2. getAttribute(String name)\r\n3. removeAttribute(String name)\r\n\r\n* ServletContext 对象范围，所有用户所有请求的数据，所有Servlet类中共享\r\n\r\n1. 获取文件的真实（服务器）路径\r\n\r\n   * ![image-20210823130520474](cloudDisk/markdown/JavaWeb笔记.assets/image-20210823130520474.png)\r\n\r\n   * ```java\r\n         protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\r\n             // 通过HttpServlet获取\r\n             ServletContext context = this.getServletContext();\r\n     \r\n             // 获取文件的服务器路径\r\n             String realPath = context.getRealPath(\"/b.txt\"); // web目录下资源访问\r\n             System.out.println(realPath);\r\n     \r\n             String realPath1 = context.getRealPath(\"/WEB-INF/c.txt\"); // WEB-INF目录下的资源访问\r\n             System.out.println(realPath1);\r\n     \r\n             String realPath2 = context.getRealPath(\"/WEB-INF/classes/a.txt\"); // src目录下资源路径访问\r\n             System.out.println(realPath2);\r\n         }\r\n     ```\r\n\r\n   * ![image-20210823130550915](cloudDisk/markdown/JavaWeb笔记.assets/image-20210823130550915.png)\r\n\r\n### 4. 案例 - 文件下载\r\n\r\n#### 1）文件下载需求：\r\n\r\n1. 页面显示超链接\r\n2. 点击超链接后弹出下载提示框\r\n3. 完成图片文件下载\r\n\r\n#### 2）分析\r\n\r\n1. 超链接指向的资源如果能够被浏览器解析，则在浏览器中展示，如果不能解析，则弹出下载提示框。不满足需求\r\n2. 任何资源都必须弹出下载提示框\r\n3. 使用响应头设置资源的打开方式\r\n   * content-disposition: attachment; filename=xxx\r\n\r\n#### 3) 步骤：\r\n\r\n1. 定义页面，编辑超链接href 属性，指向Servlet，传递资源的参数filename\r\n2. 定义Servlet\r\n   1. 获取文件名称\r\n   2. 使用字节输入流加载文件进内存\r\n   3. 指定response的响应头：content-disposition: attachment; filename=xxx\r\n   4. 将数据写出到response输出流\r\n\r\n#### 4）问题：下载文件的文件名乱码\r\n\r\n利用工具类：\r\n\r\n```java\r\npackage com.tony.utils;\r\n\r\nimport java.io.UnsupportedEncodingException;\r\nimport java.net.URLEncoder;\r\nimport java.util.Base64;\r\n\r\n\r\npublic class DownLoadUtils {\r\n\r\n    public static String getFileName(String agent, String filename) throws UnsupportedEncodingException {\r\n        if (agent.contains(\"MSIE\")) {\r\n            // IE浏览器\r\n            filename = URLEncoder.encode(filename, \"utf-8\");\r\n            filename = filename.replace(\"+\", \" \");\r\n        } else if (agent.contains(\"Firefox\")) {\r\n            // 火狐浏览器\r\n            Base64.Encoder encoder = Base64.getEncoder();\r\n            String str = encoder.encodeToString(filename.getBytes(\"utf-8\"));\r\n            filename = \"=?utf-8?B?\" + str + \"?=\";\r\n\r\n//            BASE64Encoder base64 = new BASE64Encoder();\r\n//            filename = \"=?utf-8?B?\" + base64.encode(filename.getBytes(\"utf-8\")) + \"?=\";\r\n        } else {\r\n            // 其它浏览器\r\n            filename = URLEncoder.encode(filename, \"utf-8\");\r\n        }\r\n        return filename;\r\n    }\r\n}\r\n```\r\n\r\n#### 5) 代码\r\n\r\n![image-20210823151637394](cloudDisk/markdown/JavaWeb笔记.assets/image-20210823151637394.png)\r\n\r\n```java\r\npackage com.tony.exam01;\r\n\r\nimport com.tony.utils.DownLoadUtils;\r\n\r\nimport javax.servlet.ServletContext;\r\nimport javax.servlet.ServletException;\r\nimport javax.servlet.annotation.WebServlet;\r\nimport javax.servlet.http.HttpServlet;\r\nimport javax.servlet.http.HttpServletRequest;\r\nimport javax.servlet.http.HttpServletResponse;\r\nimport java.io.*;\r\n\r\n@WebServlet(\"/servletDownload\")\r\npublic class ServletDownload1 extends HttpServlet {\r\n    @Override\r\n    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\r\n        // 设置字符集\r\n        req.setCharacterEncoding(\"utf-8\");\r\n        // 获取get请求的参数\r\n        String downloadFileName = req.getParameter(\"download\");\r\n        // 获取 ServletContext 对象\r\n        ServletContext context = this.getServletContext();\r\n        // 获取服务器的真实目录\r\n        String realPath = context.getRealPath(downloadFileName);\r\n        // 创建字节缓冲输入流对象\r\n        BufferedInputStream bis = new BufferedInputStream(new FileInputStream(realPath));\r\n        // 指定response的响应头\r\n        File file = new File(downloadFileName);\r\n            // 将文件名编码。防止下载文件的文件名乱码\r\n        String filename = DownLoadUtils.getFileName(req.getHeader(\"user-agent\"), file.getName());\r\n                                // content-disposition:attachment;filename=...\r\n                                // filename=...  弹出提示框的名字\r\n                                // attachment   告诉浏览器以附件形式打开\r\n        resp.setHeader(\"content-disposition\",\"attachment;filename=\"+ filename);\r\n        System.out.println(file.getName());\r\n            // 告诉浏览器响应体的类型 ContentType\r\n        String mimeType = context.getMimeType(file.getName());\r\n        resp.setContentType(mimeType);\r\n\r\n        // 获取字节缓冲输出流对象\r\n        BufferedOutputStream bos = new BufferedOutputStream(resp.getOutputStream());\r\n\r\n        // 写数据\r\n        byte[] bytes = new byte[1024];\r\n        int len;\r\n        while ((len=bis.read(bytes)) != -1){\r\n            bos.write(bytes,0,len);\r\n        }\r\n        bis.close();\r\n\r\n    }\r\n\r\n    @Override\r\n    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\r\n        this.doPost(req,resp);\r\n    }\r\n}\r\n\r\n```\r\n\r\n```html\r\n<!DOCTYPE html>\r\n<html lang=\"en\">\r\n<head>\r\n    <meta charset=\"UTF-8\">\r\n    <title>download</title>\r\n</head>\r\n<body>\r\n    <a href=\"/servletDownload?download=/image/图片1.jpg\">图片1.jpg</a>\r\n    <a href=\"/servletDownload?download=/video/毕业聚餐.mp4\">毕业聚餐.mp4</a>\r\n</body>\r\n</html>\r\n```\r\n\r\n#### 6) 运行测试\r\n\r\n![image-20210823151716146](cloudDisk/markdown/JavaWeb笔记.assets/image-20210823151716146.png)\r\n\r\n--> 图片1.jpg\r\n\r\n![image-20210823151737484](cloudDisk/markdown/JavaWeb笔记.assets/image-20210823151737484.png)\r\n\r\n--> 毕业聚餐.mp4\r\n\r\n![image-20210823151757460](cloudDisk/markdown/JavaWeb笔记.assets/image-20210823151757460.png)\r\n','2022-06-23 22:10:11','Java Web，是用Java技术来解决相关web互联网领域的技术栈。web包括：web服务端和web客户端两部分。Java在客户端的应用有Java Applet，不过使用得很少，Java在服务器端的应用非常的丰富，比如Servlet，JSP、第三方框架等等。Java技术对Web领域的发展注入了强大的动力。','cloudDisk\\markdown\\JavaWeb笔记.assets\\v2-a3e62eaf0fc00ea128596a53ce32563a_720w.jpg','原创','','','\0','Java Web笔记（中）','2022-06-23 22:10:11',1,101,NULL,0),(183,'','\r\n# 二十二、会话技术\r\n\r\n会话：一次会话中包含多次请求和响应\r\n\r\n* 一次会话：浏览器第一次给服务器资源发送请求，会话建立，直到有一方断开为止\r\n\r\n功能：在一次会话的范围内的多次请求间，共享数据\r\n\r\n方式：\r\n\r\n1. 客户端会话技术：Cookie\r\n2. 服务器端会话技术：Session \r\n\r\n## 22.1 客户端会话技术\r\n\r\n### 1. 概念\r\n\r\n客户端会话技术，将数据保存到客户端\r\n\r\n### 2. 快速入门\r\n\r\n* 使用步骤：\r\n\r\n  1. 创建Cookie对象，绑定数据\r\n     * new Cookie(String name, String value)\r\n  2. 发送Cookie对象\r\n     * reponse.addCookie(Cookie cookie)\r\n  3. 获取Cookie，拿到数据\r\n     * Cookie[] request.getCookies()\r\n\r\n* 代码：\r\n\r\n  * ```java\r\n    @WebServlet(\"/cookieDemo1\")\r\n    public class CookieDemo1 extends HttpServlet {\r\n        protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\r\n            // 1. 创建Cookie对象\r\n            Cookie cookie = new Cookie(\"msg\",\"hello\");\r\n            // 2. 发送cookie\r\n            response.addCookie(cookie);\r\n        }\r\n    ```\r\n\r\n  * ```java\r\n    @WebServlet(\"/cookieDemo2\")\r\n    public class CookieDemo2 extends HttpServlet {\r\n        protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\r\n            // 3. 获取Cookie\r\n            Cookie[] cookies = request.getCookies();\r\n              // 获取数据,遍历cookies\r\n            if(cookies != null){\r\n                for (Cookie c :\r\n                        cookies) {\r\n                    String name = c.getName();\r\n                    String value = c.getValue();\r\n                    System.out.println(name+\":\"+value);\r\n                }\r\n            }\r\n        }\r\n    ```\r\n\r\n  * ![image-20210824142409448](cloudDisk/markdown/JavaWeb笔记.assets/image-20210824142409448.png)\r\n\r\n  * ![image-20210824142418765](cloudDisk/markdown/JavaWeb笔记.assets/image-20210824142418765.png)\r\n\r\n  * -->![image-20210824142429875](cloudDisk/markdown/JavaWeb笔记.assets/image-20210824142429875.png)\r\n\r\n### 3. 实现原理\r\n\r\n![image-20210824143059733](cloudDisk/markdown/JavaWeb笔记.assets/image-20210824143059733.png)\r\n\r\n### 4. cookie的细节\r\n\r\n#### 1）一次可不可以发送多个cookie?\r\n\r\n* 可以\r\n* 可以创建多个Cookie对象，使用response调用多次addCookie方法发送即可\r\n\r\n#### 2）cookie在浏览器中保存多长时间？\r\n\r\n* 默认情况下，当浏览器关闭后，Cookie数据被销毁\r\n* 持久化存储：\r\n  * setMaxAge(int seconds)\r\n    1. 正数：将Cookie数据写到硬盘的文件中。持久化存储。cookie存活时间。\r\n    2. 负数 ：默认值\r\n    3. 零：删除cookie信息\r\n\r\n#### 3）cookie能不能存中文？\r\n\r\n* 在tomcat 8 之前 cookie中不能直接存储中文数据\r\n  * 需要将中文数据转码     一般采用URL编码\r\n* 在tomcat 8 之后，cookie支持中文数据\r\n\r\n#### 4）cookie共享问题(访问哪个url才带cookie)？\r\n\r\n1. 假设在一个tomcat服务器中，部署了多个web项目，那么在这些web项目中cookie能不能共享？\r\n   * 默认情况下，cookie不能共享\r\n     * setPath(String path): 设置cookie的默认获取范围。默认情况下，默认设置当前的虚拟目录\r\n       * 如果要共享，则可以将path设置为\"/\"\r\n\r\n2. 不同的tomcat服务器间cookie共享问题\r\n   * setDomain(String path) : 如果设置一级域名相同，那么多个服务器之间cookie可以共享\r\n     * setDomain(\".baidu.com\"),那么tieba.baidu.com 和 news.baidu.com 中可以共享\r\n\r\n### 5. Cookie的特点和作用\r\n\r\n1. cookie存储数据在客户端浏览器\r\n2. 浏览器对于单个cookie的大小有限制（4kb） 以及 对于同一个域名下的总cookie数量也有限制（20个）\r\n\r\n* 作用：\r\n  1. cookie一般用于存储少量的不太敏感的数据\r\n  2. 在不登录的情况下，完成服务器对客户端的身份识别\r\n\r\n### 6. 案例 ：记住上一次访问时间\r\n\r\n#### 1）需求：\r\n\r\n1. 访问一个Servlet,如果是第一次访问，则提示：您好，欢迎您首次访问。\r\n2. 如果不是第一次访问，则提示：欢迎回来，您上一次访问时间为：显示时间字符串\r\n\r\n#### 2）分析：\r\n\r\n![image-20210824174206247](cloudDisk/markdown/JavaWeb笔记.assets/image-20210824174206247.png)\r\n\r\n#### 3）代码实现:\r\n\r\n```java\r\n@WebServlet(\"/cookieServlet\")\r\npublic class CookieServlet extends HttpServlet {\r\n    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\r\n        response.setContentType(\"text/html;charset=utf-8\");\r\n        // 1. 获取cookies\r\n        Cookie[] cookies = request.getCookies();\r\n        // 2. 判断有无cookie,cookie里有无 lastTime属性\r\n        boolean flag = true;\r\n        if (cookies != null && cookies.length >= 1) {\r\n            // 3. 有cookie，不是第一次访问\r\n            // 遍历cookies\r\n            String lastTime = null;\r\n            for (Cookie cookie :\r\n                    cookies\r\n            ) {\r\n                // 获取cookie的 lastTime 的值\r\n                if (\"lastTime\".equals(cookie.getName())){\r\n                    flag = false;\r\n                    lastTime = cookie.getValue();\r\n                    // 将URL解码\r\n                    lastTime = URLDecoder.decode(lastTime, \"utf-8\");\r\n                    System.out.println(\"用户ip：\"+request.getRemoteAddr()+\"，上次访问时间：\"+lastTime);\r\n                    // 将lastTime显示在网页上\r\n                    PrintWriter writer = response.getWriter();\r\n                    writer.write(\"<h1>欢迎回来，您上一次访问时间为：\"+lastTime+\"</h1>\");\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        if (flag){\r\n            System.out.println(\"用户ip：\"+request.getRemoteAddr()+\"，第一次访问\");\r\n            // 4. 没cookie，lastTime属性,说明是第一次访问\r\n            // 将字符串数据输出到页面\r\n            PrintWriter writer = response.getWriter();\r\n            writer.write(\"<h1>您好，欢迎您首次访问。</h1>\");\r\n        }\r\n        // 5. 将当前的字符串时间，添加到cookie中\r\n            // 获取当前时间\r\n        Date date = new Date();\r\n        SimpleDateFormat sif = new SimpleDateFormat(\"y年M月d日 H:m\");\r\n        String currentTime = sif.format(date);\r\n        System.out.println(\"用户ip：\"+request.getRemoteAddr()+\"，访问时间：\"+currentTime);\r\n        System.out.println(\"------------------\");\r\n            // 由于时间含有中文，将其转化为URL编码\r\n        currentTime = URLEncoder.encode(currentTime,\"utf-8\");\r\n            // 创建Cookie对象，将时间添加为cookie\r\n        Cookie cookie = new Cookie(\"lastTime\",currentTime);\r\n            // 设置cookie为持久化存储\r\n        cookie.setMaxAge(10*365*24*60*60);\r\n            // 发送cookie\r\n        response.addCookie(cookie);\r\n\r\n    }\r\n```\r\n\r\n--> ![image-20210824173814227](cloudDisk/markdown/JavaWeb笔记.assets/image-20210824173814227.png)\r\n\r\n* ![image-20210824173831277](cloudDisk/markdown/JavaWeb笔记.assets/image-20210824173831277.png)\r\n* ![image-20210824173843658](cloudDisk/markdown/JavaWeb笔记.assets/image-20210824173843658.png)\r\n\r\n-->再次![image-20210824173902759](cloudDisk/markdown/JavaWeb笔记.assets/image-20210824173902759.png)\r\n\r\n* ![image-20210824173916685](cloudDisk/markdown/JavaWeb笔记.assets/image-20210824173916685.png)\r\n* ![image-20210824173926905](cloudDisk/markdown/JavaWeb笔记.assets/image-20210824173926905.png)\r\n\r\n## 22.2 JSP：入门学习\r\n\r\n### 1. 概念：\r\n\r\n* Java Server Pages : java服务器端页面\r\n  * 可以理解为：一个特殊的页面，其中既可以指定定义html标签，又可以定义java代码\r\n  * 九二一简化书写！！！\r\n\r\n### 2. 原理\r\n\r\n* JSP本质上就是一个Servlet\r\n\r\n### 3. JSP的脚本：JSP定义Java代码的方式\r\n\r\n1. \\<% 代码 %> ：定义的java代码，在service方法中。service方法中可以定义什么，该脚本中就可以定义什么\r\n2. \\<%! 代码 %> ：定义的java代码，在jsp转换后的java类的成员位置\r\n3. \\<%= 代码 %> ：定义的java代码，会输出到页面上。输出语句中可以定义什么，该脚本中就可以定义什么\r\n\r\n### 4. JSP的内置对象：\r\n\r\n* 在jsp页面中不需要创建，直接使用的对象\r\n* jsp一共有9个内置对象\r\n* 今天学习3个\r\n  * request\r\n  * response\r\n  * out：\r\n    * ![image-20210825144801628](cloudDisk/markdown/JavaWeb笔记.assets/image-20210825144801628.png)\r\n    * 字符输出流对象。可以将数据输出到页面上。和response.getWriter()类似\r\n      * response.getWriter()和out.writer()的区别：\r\n        * 在tomcat服务器真正给客户端做出响应之前，会先找到respnse缓冲区数据，再找out缓冲区数据。\r\n        * response.getWriter()数据输出永远在out.write()之前\r\n\r\n## 22.3 服务器端会话技术\r\n\r\n### 1. 概念：\r\n\r\n* 服务器端会话技术，在一次会话的多次请求间共享数据，将数据保存到服务器端的对象中。HttpSession\r\n\r\n### 2. 快速入门\r\n\r\n1. 获取HttpSession对象：\r\n\r\n   HttpSession session = request.getSession();\r\n\r\n2. 使用HttpSession对象:\r\n\r\n   Object getAttribute(String name)\r\n\r\n   void setAttribute(String name, Object value)\r\n\r\n   void removeAttribute(String name)\r\n\r\n   ```java\r\n   @WebServlet(\"/SessionDemo1\")\r\n   public class SessionDemo1 extends HttpServlet {\r\n       protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\r\n           // 1. 获取Seesion对象\r\n           HttpSession session = request.getSession();\r\n           // 2. 设置属性\r\n           session.setAttribute(\"meg\",\"Hello Session\");\r\n       }\r\n      \r\n   @WebServlet(\"/SessionDemo2\")\r\n   public class SessionDemo2 extends HttpServlet {\r\n       protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\r\n           // 1. 获取Seesion对象\r\n           HttpSession session = request.getSession();\r\n           // 2. 获取属性\r\n           Object meg = session.getAttribute(\"meg\");\r\n           System.out.println(meg);\r\n       }\r\n   ```\r\n\r\n   \r\n\r\n\r\n### 3. 原理\r\n\r\n![image-20210825153455600](cloudDisk/markdown/JavaWeb笔记.assets/image-20210825153455600.png)\r\n\r\n* Session的实现是依赖于Cookie的\r\n\r\n### 4. 细节：\r\n\r\n1. 当用户端关闭后，服务器不关闭，两次获取session是否为同一个？\r\n\r\n   * 默认情况下。不是。\r\n\r\n   * 如果需要相同，则可以创建Cookie，键为JSESSIONID，设置存活时间，让cookie持久化存储\r\n\r\n     ```java\r\n     // 1. 获取Seesion对象\r\n     HttpSession session = request.getSession();\r\n     // 2. 设置属性\r\n     session.setAttribute(\"meg\",\"Hello Session\");\r\n     Cookie cookie = new Cookie(\"JSESSIONID\",session.getId());\r\n     cookie.setMaxAge(60*60);\r\n     response.addCookie(cookie);\r\n     ```\r\n\r\n2. 客户端不关闭，服务器关闭后，两次获取的session是同一个吗？\r\n\r\n   * 不是同一个，但是要确保数据不丢失\r\n\r\n   * session的钝化（序列化）\r\n\r\n     * 在服务器正常关闭之前，将session对象序列化到硬盘上\r\n\r\n   * session的活化（反序列化）\r\n\r\n     * 在服务器启动后，将session文件转化为内存中的session对象即可\r\n\r\n   * 注意：tomcat在apps目录下部署的项目，会自动的完成钝化和活化工作；\r\n\r\n     但是，idea部署的服务器项目，只能钝化，不能活化\r\n\r\n3. session什么时候被销毁？\r\n\r\n   1. 服务器关闭\r\n\r\n   2. session对象调用invalidate()\r\n\r\n   3. session默认的失效时间  30分钟\r\n\r\n      * 选择性配置修改\r\n\r\n        * 找到conf>web.xml 或者在idea中新建web.xml覆盖父配置\r\n\r\n        * 修改\r\n\r\n          ```xml\r\n            <!-- ==================== Default Session Configuration ================= -->\r\n            <!-- You can set the default session timeout (in minutes) for all newly   -->\r\n            <!-- created sessions by modifying the value below.                       -->    \r\n          	<session-config>\r\n                  <session-timeout>30</session-timeout>\r\n              </session-config>\r\n          ```\r\n\r\n### 5. session特点\r\n\r\n1. session用于存储一次会话的多次请求的数据，存在服务器端\r\n2. session可以存储任意类型，任意大小的数据\r\n\r\n* session与cookie的区别\r\n  1. session存储数据在服务器端，Cookie在客户端\r\n  2. session没有数据大小限制，Cookie有\r\n  3. session数据安全，Cookie相对不安全\r\n\r\n### 6. 案例\r\n\r\n#### 1. 案例需求：\r\n\r\n1. 访问带有验证码的登录页面login.jsp\r\n2. 用户输入用户名，密码以及验证码\r\n   * 如果用户名和密码输入有误，跳转到登录页面，提示：用户名或密码错误\r\n   * 如果验证码输入有误，跳转到登录页面，提示：验证码错误\r\n   * 如果全部输入正确，则跳转到主页success.jsp，显示：用户名，欢迎你\r\n\r\n#### 2. 案例分析\r\n\r\n![image-20210826205527489](cloudDisk/markdown/JavaWeb笔记.assets/image-20210826205527489.png)\r\n\r\n![image-20210826214449502](cloudDisk/markdown/JavaWeb笔记.assets/image-20210826214449502.png)\r\n\r\n![image-20210826214512839](cloudDisk/markdown/JavaWeb笔记.assets/image-20210826214512839.png)\r\n\r\n#### 3. 程序源码\r\n\r\n##### 3.1 建立数据库：\r\n\r\n```sql\r\nSELECT * FROM USER\r\nSHOW GRANTS FOR \"zhangsan\"@\"localhost\";\r\nCREATE USER \"zhangsan\"@\"%\" IDENTIFIED BY \"456\";\r\nSELECT * FROM USER\r\nFLUSH PRIVILEGES;\r\nGRANT SELECT ON db3.`account` TO \"zhangsan\"@\"%\";\r\nDROP USER \"zhangsan\"@\"localhost\";\r\n\r\nSELECT * FROM USER WHERE username=\"zhangsan\" AND PASSWORD =\"123\"\r\nALTER DATABASE exam01 CHARACTER SET \"utf8\";\r\nCREATE DATABASE exam01\r\nUSE exam01\r\nCREATE TABLE USER(\r\n	id INT PRIMARY KEY AUTO_INCREMENT,\r\n	username VARCHAR(32) NOT NULL,\r\n	PASSWORD VARCHAR(32) NOT NULL,\r\n	age INT,\r\n	sex VARCHAR(10)\r\n)\r\nSELECT * FROM USER\r\nINSERT INTO USER VALUES(NULL,\"张三\",\"123\",20,\"男\")\r\nINSERT INTO USER VALUES(NULL,\"李四\",\"456\",28,\"男\")\r\n```\r\n\r\n##### 3.2 User类：\r\n\r\n```java\r\npublic class User {\r\n    private int id;\r\n    private String username;\r\n    private String password;\r\n    private int age;\r\n    private String sex;\r\n```\r\n\r\n##### 3.3 对user数据库增删改查\r\n\r\n```java\r\npublic class LoginDao {\r\n    private static JdbcTemplate jdbcTemplate;\r\n    /*\r\n    * @author Tony\r\n    * @Description\r\n    * @Date 14:22 2021/8/21\r\n    * @Param [loginUser] 只有用户名密码\r\n    * @return com.tony.exam01.domain.User 用户的全部数据，没查询到。返回Null\r\n    **/\r\n    public static User login(User loginUser){\r\n        String loginUsername = loginUser.getUsername();\r\n        String loginPassword = loginUser.getPassword();\r\n        System.out.println(DruidUtils.getDataSource());\r\n        jdbcTemplate = new JdbcTemplate(DruidUtils.getDataSource());\r\n        try{\r\n            String sql = \"SELECT * FROM USER WHERE username= ? AND PASSWORD = ?\";\r\n            User user = jdbcTemplate.queryForObject(sql,\r\n                new BeanPropertyRowMapper<User>(User.class),\r\n                loginUsername, loginPassword);\r\n            return user;\r\n        }catch (EmptyResultDataAccessException e){\r\n            // e.printStackTrace(); // 记录日志\r\n            return null;\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n##### 3.4 数据库连接池工具类\r\n\r\n```java\r\npublic final class DruidUtils {\r\n    private static DataSource ds;\r\n    static {\r\n        try {\r\n            // 1. 加载配置文件\r\n            Properties prop = new Properties();\r\n            InputStream is = DruidUtils.class.getClassLoader().getResourceAsStream(\"druid.properties\");\r\n            prop.load(is);\r\n            // 2. 获取DataSource\r\n            ds = DruidDataSourceFactory.createDataSource(prop);\r\n        } catch (IOException e) {\r\n            e.printStackTrace();\r\n        } catch (Exception e) {\r\n            e.printStackTrace();\r\n        }\r\n    }\r\n\r\n    // 获取连接\r\n    public static Connection getConnection() throws SQLException {\r\n        return ds.getConnection();\r\n    }\r\n\r\n\r\n    // 释放资源\r\n    public static void close(Statement stmt, Connection connection, ResultSet rs){\r\n        if (stmt != null){\r\n            try {\r\n                stmt.close();\r\n            } catch (SQLException throwables) {\r\n                throwables.printStackTrace();\r\n            }\r\n        }\r\n        if (connection != null){\r\n            try {\r\n                connection.close(); // 归还连接\r\n            } catch (SQLException throwables) {\r\n                throwables.printStackTrace();\r\n            }\r\n        }\r\n        if (rs != null){\r\n            try {\r\n                rs.close();\r\n            } catch (SQLException throwables) {\r\n                throwables.printStackTrace();\r\n            }\r\n        }\r\n    }\r\n\r\n    // 获取连接池方法\r\n    public static DataSource getDataSource(){\r\n        return ds;\r\n    }\r\n}\r\n```\r\n\r\n##### 3.5 登录Servlet\r\n\r\n```java\r\npackage com.tony.sessionLoginExam01.web.servlet;\r\n\r\n\r\nimport com.tony.sessionLoginExam01.dao.LoginDao;\r\nimport com.tony.sessionLoginExam01.domain.User;\r\nimport org.apache.commons.beanutils.BeanUtils;\r\n\r\nimport javax.servlet.ServletException;\r\nimport javax.servlet.annotation.WebServlet;\r\nimport javax.servlet.http.*;\r\nimport java.io.IOException;\r\nimport java.lang.reflect.InvocationTargetException;\r\nimport java.util.Map;\r\n\r\n\r\n@WebServlet(\"/submitServlet\")\r\npublic class SubmitServlet extends HttpServlet {\r\n    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\r\n        request.setCharacterEncoding(\"utf-8\");\r\n        // 1. 获取账号，密码，验证码 map集合\r\n        Map<String, String[]> parameterMap = request.getParameterMap();\r\n        User loginUser = new User();\r\n        // 2. 使用 BeanUtils 封装\r\n        try {\r\n            BeanUtils.populate(loginUser,parameterMap);\r\n        } catch (IllegalAccessException e) {\r\n            e.printStackTrace();\r\n        } catch (InvocationTargetException e) {\r\n            e.printStackTrace();\r\n        }\r\n        // 3. 判断验证码是否正确\r\n            // 用户输入的验证码\r\n        String userInputVerificationCode = parameterMap.get(\"userInputVerificationCode\")[0];\r\n            // 由java生成的验证码\r\n        HttpSession session = request.getSession();\r\n        String verificationCode = (String) session.getAttribute(\"verificationCode\");\r\n        session.removeAttribute(\"verificationCode\");\r\n        // 判断验证码是否正确\r\n        if (verificationCode!=null && userInputVerificationCode !=null && userInputVerificationCode.toUpperCase().equals(verificationCode.toUpperCase())) {\r\n            // 验证码输入正确\r\n            // 4. 再判断账号密码是否正确\r\n            // 传如user对象，如果存在该用户，则返回该用户所有的信息的user对象；否则返回null\r\n            User user = LoginDao.login(loginUser);\r\n            if (user != null) {\r\n                // 5. 用户密码正确\r\n                // 将user对象添加到session，发送给浏览器\r\n                session.setAttribute(\"user\", user);\r\n                // 跳转到主页success.jsp，显示：用户名，欢迎你\r\n                response.sendRedirect(request.getContextPath() + \"/success.jsp\");\r\n            } else {\r\n                // 账号或密码错误\r\n\r\n                // 方法一：\r\n                // 跳转到登录页面，提示：用户名或密码错误\r\n//                response.addCookie(new Cookie(\"error\", \"password\"));\r\n//                response.sendRedirect(\"/login.jsp\");\r\n                // 方法二：\r\n                // 转发到login.jsp\r\n                request.setAttribute(\"password_error\",\"账号或密码错误\");\r\n                request.getRequestDispatcher(\"/login.jsp\").forward(request,response);\r\n            }\r\n\r\n        } else {\r\n            // 验证码输入错误\r\n\r\n//            方法一：// 跳转到登录页面，提示：验证码错误\r\n//            response.addCookie(new Cookie(\"error\", \"verification\"));\r\n//            response.sendRedirect(\"/login.jsp\");\r\n\r\n//            方法二：转发到login.jsp\r\n            request.setAttribute(\"verification_error\",\"验证码错误\");\r\n            request.getRequestDispatcher(\"/login.jsp\").forward(request,response);\r\n        }\r\n    }\r\n\r\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\r\n        this.doPost(request, response);\r\n    }\r\n}\r\n\r\n```\r\n\r\n##### 3.6 验证码Servlet\r\n\r\n```java\r\npackage com.tony.sessionLoginExam01.web.servlet;\r\n\r\nimport javax.imageio.ImageIO;\r\nimport javax.servlet.ServletException;\r\nimport javax.servlet.annotation.WebServlet;\r\nimport javax.servlet.http.*;\r\nimport java.awt.*;\r\nimport java.awt.image.BufferedImage;\r\nimport java.io.IOException;\r\nimport java.util.Random;\r\n\r\n@WebServlet(\"/verificationServlet\")\r\npublic class VerificationServlet extends HttpServlet {\r\n    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\r\n        String verificationCode = \"\";\r\n        int width = 100;\r\n        int height = 50;\r\n        // 1. 创建一个对象,在内存中图片(验证码图片对象)\r\n        BufferedImage image = new BufferedImage(width, height, BufferedImage.TYPE_INT_RGB);\r\n        // 2. 每户图片\r\n        // 2.1 填充背景色\r\n        Graphics g = image.getGraphics();// 画笔对象\r\n        g.setColor(Color.pink);\r\n        g.fillRect(0,0,width,height);\r\n\r\n        // 2.2 画边框\r\n        g.setColor(Color.blue);\r\n        g.drawRect(0,0,width-1,height - 1);\r\n        String str = \"ABCDEFGHIJKLMNPQRSTUVWXYZabcdefghijklmnpqrstuvwxyz123456789\";\r\n        // 生成随机角坐标\r\n        Random random = new Random();\r\n        for (int i = 0; i < 4; i++) {\r\n            int index = random.nextInt(str.length());\r\n            // 获取字符\r\n            char ch = str.charAt(index); // 随机字符\r\n            verificationCode += ch;\r\n            // 2.3 写验证码\r\n            g.drawString(ch+\"\",width/5*(i+1),height/2);\r\n        }\r\n\r\n        // 2.4 画干扰线\r\n        g.setColor(Color.green);\r\n\r\n        // 2.4 随机生成坐标点\r\n        for (int i = 0; i < 10; i++) {\r\n            int x1 = random.nextInt(width);\r\n            int x2 = random.nextInt(width);\r\n            int y1 = random.nextInt(height);\r\n            int y2 = random.nextInt(height);\r\n            g.drawLine(x1,y1,x2,y2);\r\n        }\r\n\r\n        // 2. 将图片输出到页面展示\r\n        ImageIO.write(image,\"jpg\",response.getOutputStream());\r\n\r\n        // 3. 将验证码code保存到session\r\n            // 创建session对象\r\n        HttpSession session = request.getSession();\r\n            // 设置session属性\r\n        session.setAttribute(\"verificationCode\",verificationCode);\r\n            // 指定session id\r\n        Cookie cookie = new Cookie(\"JSESSIONID\",session.getId());\r\n        response.addCookie(cookie);\r\n    }\r\n\r\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\r\n        this.doPost(request, response);\r\n    }\r\n}\r\n\r\n```\r\n\r\n##### 3.7 登录页面\r\n\r\n```jsp\r\n<%@ page import=\"java.awt.image.BufferedImage\" %>\r\n<%@ page import=\"java.awt.*\" %>\r\n<%@ page import=\"java.util.Random\" %>\r\n<%@ page import=\"javax.imageio.ImageIO\" %>\r\n<%@ page import=\"com.tony.sessionLoginExam01.domain.User\" %>\r\n<%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %>\r\n<html>\r\n<head>\r\n    <title>login</title>\r\n    <script>\r\n        window.onload = function () {\r\n            var ele_verificationCode = document.getElementById(\"verificationCode\");\r\n            ele_verificationCode.onclick = function () {\r\n                var date = new Date().getTime();\r\n                ele_verificationCode.src = \"/verificationServlet?\"+date;\r\n            };\r\n        }\r\n    </script>\r\n</head>\r\n<body>\r\n<%--方法一：--%>\r\n<%--    <%--%>\r\n<%--        Cookie[] cookies = request.getCookies();--%>\r\n<%--        for (Cookie c :--%>\r\n<%--                cookies) {--%>\r\n<%--            if (\"error\".equals(c.getName())) {--%>\r\n<%--                if(\"password\".equals(c.getValue())){--%>\r\n<%--                    // 密码错误，提示：账号或密码错误--%>\r\n<%--                    out.write(\"账号或密码错误\");--%>\r\n\r\n<%--                }else if(\"verification\".equals(c.getValue())){--%>\r\n<%--                    // 验证码错误，验证码输入错误--%>\r\n<%--                    out.write(\"验证码输入错误\");--%>\r\n<%--                }--%>\r\n<%--            }--%>\r\n<%--        }--%>\r\n<%--    %>--%>\r\n    <form action=\"/submitServlet\" method=\"post\">\r\n        用户名：<input type=\"text\" name=\"username\"><br>\r\n        密码：<input type=\"password\" name=\"password\"><br>\r\n        验证码：<input type=\"text\" name=\"userInputVerificationCode\">\r\n        <img src=\"/verificationServlet\" alt=\"\" id=\"verificationCode\"><br>\r\n        <input type=\"submit\" value=\"提交\">\r\n    </form>\r\n\r\n<%--方法二：--%>\r\n    <%= request.getAttribute(\"verification_error\") == null? \"\" : request.getAttribute(\"verification_error\") %>\r\n    <%= request.getAttribute(\"password_error\") == null? \"\" : request.getAttribute(\"password_error\") %>\r\n</body>\r\n</html>\r\n\r\n```\r\n\r\n##### 3.8主页\r\n\r\n```jsp\r\n<%@ page import=\"java.util.Arrays\" %>\r\n<%@ page import=\"java.io.IOException\" %>\r\n<%@ page import=\"com.tony.sessionLoginExam01.domain.User\" %>\r\n<%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %>\r\n<html>\r\n<head>\r\n    <title>home</title>\r\n</head>\r\n<body>\r\n<%\r\n    HttpSession session1 = request.getSession();\r\n    User user = (User) session1.getAttribute(\"user\");\r\n    if (user != null) {\r\n        String username = user.getUsername();\r\n        out.write(username + \"，欢迎你\");\r\n\r\n    }\r\n%>\r\n</body>\r\n</html>\r\n\r\n```\r\n\r\n\r\n\r\n\r\n\r\n## 22.6 JSP\r\n\r\n### 1. 指令\r\n\r\n* 作用：用于配置JSP页面，导入资源文件\r\n\r\n* 格式：\r\n\r\n  <%@ 指令名称 属性名1=属性值1 属性名2=属性值2 ... %>\r\n\r\n* 分类\r\n\r\n  1. page	:配置JSP页面的\r\n     * contentType : 等同于response.setContentType()\r\n       1. 设置响应体的响应类型，和字符集\r\n       2. 设置当前jsp页面的编码（只有是高级的IDE才能生效，如果使用低级工具，则需要设置pageEncoding属性设置当前页面的字符集）\r\n     * import : 导包\r\n     * errorPage : 当前页面发送异常后，会自动跳转到指定的错误页面\r\n     * isErrorPage : 标识当前也是否是错误页面\r\n       * true：是。可以使用内置对象exception\r\n       * false：否。默认值。不可以使用内置对象exception\r\n  2. include  ：页面包含的。导入页面资源文件\r\n     * <%@include file=\"top.jsp\"%>\r\n  3. taglib   ：导入资源\r\n     * <%@ taglib prefix=\"c\" uri=\"http://java.sun.com/jsp/jst1/core\" %>\r\n       * prefix ： 前缀，自定义的\r\n\r\n### 2. 注释\r\n\r\n1. html注释：\r\n\r\n   <!-- -->   只能注释HTML代码片段\r\n\r\n2. jsp注释：\r\n\r\n   <%-- --%>   可以注释所有\r\n\r\n### 3. 内置对象\r\n\r\n* 在jsp页面中不需要创建对象，直接使用的对象\r\n\r\n* 一共有9个\r\n\r\n  ​			变量名							真实类型									作用\r\n\r\n  * pageContext			PageContext							当前页面共享数据，还可以获取其他八个内置对象\r\n  * request					HttpServletRequest	一次请求访问的第一个资源（转发）\r\n  * session					HttpSession 							一次会话的对此请求间\r\n  * application			SercletContext							所有用户间共享数据\r\n  * response				HttpServletResponse			响应对象\r\n  * page						Object								当前页面（Servlet）的对象 this\r\n  * out							JspWriter							输出对象，数据输出到页面上\r\n  * config						ServletConfig					Servlet的配置对象\r\n  * exception					Throwable							异常对象\r\n\r\n# 二十三、MVC开发模式\r\n\r\n### 1. jsp演变历史\r\n\r\n1. 早期只有servlet，只能使用response输出标签数据，非常麻烦\r\n2. 后来有jsp，简化了Servlet的开发，如果过度使用jsp，在jsp中既写大量的java代码，有写html表，造成难于维护\r\n3. 再后来，java的web开发，借鉴mvc开发模式，使得程序的设计更加合理性\r\n\r\n### 2. MVC：\r\n\r\n![image-20210827130617630](cloudDisk/markdown/JavaWeb笔记.assets/image-20210827130617630.png)\r\n\r\n1. M ： Model，模型。JavaBean\r\n   * 完成具体的业务操作，如：查询数据库，封装对象\r\n2. V：View，视图。JSP\r\n   * 展示诗句\r\n3. C：Controller，控制器。Servlet\r\n   * 获取用户的输入\r\n   * 调用模型\r\n   * 将诗句交给视图进行展示\r\n\r\n* 优缺点\r\n  1. 优点：\r\n     * 耦合性低，方便维护，可以利于开发维护\r\n     * 重用性高\r\n  2. 缺点：\r\n     * 使得项目架构变得复杂，对开发人员要求高\r\n\r\n## 23.1 EL表达式\r\n\r\n#### 1. 概念：\r\n\r\nExpression Language 表达式语言\r\n\r\n#### 2. 作用：\r\n\r\n替换或简化jsp页面中java代码的编写\r\n\r\n#### 3. 语法：\r\n\r\n${表达式}\r\n\r\n#### 4. 注意：\r\n\r\n* jsp默认支持el表达式的。如果要忽略el表达式\r\n  1. 设置jsp中page指令中：isELIgnored=\"true\" 忽略当前jsp页面中所有的el表达式\r\n  2. \\\\${表达式} ： 忽略当前这个el表达式\r\n\r\n#### 5. 使用：\r\n\r\n##### 5.1 运算：\r\n\r\n* 运算符：\r\n\r\n  1. 算数运算符：+ - * / (div) % (mod)\r\n\r\n  2. 比较运算符：> < >= <= == !=\r\n\r\n  3. 逻辑运算符：&&(and) ||(or) !(not)\r\n\r\n  4. 空运算符：empty\r\n\r\n     * 功能：用于判断字符串、集合、数组对象是否为null并且长度是否为0\r\n     * ${empty list}：表示判断字符串、集合、数组对象是否为null，并且 长度=0\r\n     * ${not empty str} : 表示判断字符串、集合、数组对象是否不为null，并且 长度>0\r\n\r\n     ```jsp\r\n         <h1>EL表达式</h1>\r\n         1. 算数运算符：+ - * / (div) % (mod)<br>\r\n         ${2+1}<br>\r\n         ${2-1}<br>\r\n         ${2*1}<br>\r\n         ${2/2}<br>\r\n         ${2%2}<br>\r\n         2. 比较运算符：> < >= <= == !=<br>\r\n         ${2>2}<br>\r\n         ${2<2}<br>\r\n         ${2>=2}<br>\r\n         ${2<=2}<br>\r\n         ${2==2}<br>\r\n         ${2!=2}<br>\r\n         3. 逻辑运算符：&&(and) ||(or) !(not)<br>\r\n         ${1<3 && 2>1}<br>\r\n         ${0!=0 || 2>1}<br>\r\n         ${!(2>1)}<br>\r\n         4. 空运算符：empty<br>\r\n     ```\r\n\r\n     \r\n\r\n##### 5.2 获取值\r\n\r\nel表达式只能从域对象中获取值\r\n\r\n###### 1）语法：\r\n\r\n1. ${域名称.键名} ： 从指定域中获取指定键的值\r\n\r\n   * 域名称：\r\n\r\n     1. pageScope --> pageContext\r\n     2. requestScope --> request\r\n     3. sessionScope --> session\r\n     4. applicationScope --> application (ServletContext)\r\n\r\n   * 举例：在request域中存储了name=张三\r\n\r\n   * 获取：${request.张三}\r\n\r\n   * ```jsp\r\n     <%\r\n         // 在域中存数据\r\n         session.setAttribute(\"name\",\"张三\");\r\n         request.setAttribute(\"name\",\"李四\");\r\n         request.setAttribute(\"age\",23);\r\n     %>\r\n     <h3>el获取值</h3>\r\n         ${requestScope.name}\r\n         ${requestScope.age}\r\n         ${sessionScope.hahahhah}\r\n     \r\n     <%--// 从最小的域中开始找name--%>\r\n         ${name}\r\n         ${sessionScope.name}\r\n     ```\r\n\r\n     \r\n\r\n2. ${键名}：表示以此从最小的域中查找是否有该键对应的值，直到找到为止。\r\n\r\n3. 获取对象、List集合、Map集合的值\r\n\r\n   1. 对象：${域名称.键名.属性名}\r\n\r\n      * 本质上会去调用对象的getter方法\r\n\r\n      * ```jsp\r\n        <%--逻辑视图--%>\r\n        <%\r\n            User user = new User();\r\n            user.setUsername(\"张三\");\r\n            user.setAge(23);\r\n            user.setBirthday(new Date());\r\n            request.setAttribute(\"user\",user);\r\n        %>\r\n        <%--这里的birthday其实是user对象的属性值，非成员变量--%>\r\n        <%--属性名是通过将user对象中的getter方法，去get,开头字母小写后的名称，其方法的返回值是属性值--%>\r\n        <%--如：getName() --> Name --> name--%>\r\n        \r\n        ${requestScope.user.username}<br>\r\n        ${requestScope.user.age}<br>\r\n        ${requestScope.user.birthday}<br>\r\n        ${requestScope.user.birthdayStr}<br>\r\n        ```\r\n\r\n   2. List集合：${域名称.键名[索引]}\r\n\r\n   3. Map集合：\r\n\r\n      * ${域名称.键名.key名称}\r\n      * ${域名称.键名[\"key名称\"]}\r\n\r\n###### 2）隐式对象\r\n\r\n* el表达式中有11个隐式对象\r\n\r\n* pageContext:\r\n\r\n  1. 获取jsp其他8个内置对象\r\n\r\n     * ```jsp\r\n       ${pageContext.request.contextPath} : 动态获取虚拟目录\r\n       ```\r\n\r\n## 23.2 JSTL标签\r\n\r\n### 1. 概念：\r\n\r\nJavaServer Pages Tah Library  JSP标准库\r\n\r\n* 是由Apache组织提供的开源的免费的jsp标签  \\<标签>\r\n\r\n### 2. 作用：用于简化和替换jsp页面上的java代码\r\n\r\n### 3. 使用步骤：\r\n\r\n1. 导入jstl相关jar包\r\n2. 引入标签库：taglib指令：<%@ taglib prefix=\"c\" uri=\"http://java.sun.com/jsp/jstl/core\" %>\r\n3. 使用标签\r\n\r\n### 4. 常用的jstl标签\r\n\r\n#### 1）if : 相当于java代码的if语句\r\n\r\n```jsp\r\n    <c:if test=\"${not empty list}\">\r\n        遍历集合...\r\n    </c:if>\r\n```\r\n\r\n1. 属性：\r\n   * test 必须属性，接收boolean表达式\r\n     * 如果表达式为true，则显示标签体内容，如果为false不显示\r\n     * 一般情况下，test属性值会结合el表达式一起使用\r\n2. 注意：\r\n   * c:if标签没有else情况，想有else情况，则可以定义一个c:if标签\r\n\r\n#### 2）choose : \r\n\r\n```jsp\r\n    <%\r\n        request.setAttribute(\"number\",3);\r\n    %>\r\n    <c:choose>\r\n        <c:when test=\"${number == 3}\">case1</c:when>\r\n        <c:when test=\"${number == 3}\">case2</c:when>\r\n        <c:otherwise>default</c:otherwise>\r\n    </c:choose>\r\n```\r\n\r\n1. 使用choose标签声明		              			相当于switch声明\r\n2. 使用when标签做判断                                  相当于case\r\n3. 使用otherwise标签做其他情况的声明        相当于default\r\n\r\n#### 3）foreach : 相当于for循环\r\n\r\n##### 1. 完成重复的操作\r\n\r\nfor(int i=0; i<=10; i++){\r\n}\r\n\r\n* 属性：\r\n  begin：表示开始值\r\n  end：结束值\r\n  var：临时变量\r\n  step：步长\r\n  varStatue：循环状态对象\r\n      index：容器中元素的索引，从0开始\r\n      count：循环次数，从1开始\r\n\r\n```jsp\r\n<c:forEach begin=\"1\" end=\"10\" var=\"i\" step=\"1\" >\r\n        ${i}<br>\r\n    </c:forEach>\r\n```\r\n\r\n##### 2. 遍历容器\r\n\r\nList<User> list;\r\nfor(User user : list)\r\n\r\n```jsp\r\n<%\r\n    List list = new ArrayList();\r\n    list.add(\"aaa\");\r\n    list.add(\"bbb\");\r\n    list.add(\"ccc\");\r\n    request.setAttribute(\"list\",list);\r\n%>\r\n    <c:forEach items=\"${list}\" var=\"str\" varStatus=\"s\">\r\n        ${s.index} ${s.count} ${str} <br>\r\n    </c:forEach>\r\n```\r\n\r\n### 5. 练习：\r\n\r\n* 需求：在request域中有一个存有User对象的List集合。需要使用jstl+el将list集合数据展示到jsp页面的table中\r\n\r\n  ![image-20210828131727747](cloudDisk/markdown/JavaWeb笔记.assets/image-20210828131727747.png)\r\n\r\n  ```jsp\r\n  <%@ taglib prefix=\"c\" uri=\"http://java.sun.com/jsp/jstl/core\" %>\r\n  <%@ page import=\"java.util.ArrayList\" %>\r\n  <%@ page import=\"java.util.List\" %>\r\n  <%@ page import=\"java.util.Date\" %>\r\n  <%@ page import=\"com.tony.sessionLoginExam01.domain.User\" %><%--\r\n    Created by IntelliJ IDEA.\r\n    User: Tony\r\n    Date: 2021/8/28\r\n    Time: 12:57\r\n    To change this template use File | Settings | File Templates.\r\n  --%>\r\n  <%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %>\r\n  <html>\r\n  <head>\r\n      <title>test</title>\r\n  </head>\r\n  <body>\r\n  <%\r\n      List list = new ArrayList();\r\n      list.add(new User(\"张三\",23,new Date()));\r\n      list.add(new User(\"李四\",28,new Date()));\r\n      list.add(new User(\"王五\",25,new Date()));\r\n      request.setAttribute(\"list\",list);\r\n  %>\r\n  </body>\r\n  <table border=\"1\">\r\n      <tr>\r\n          <th>编号</th>\r\n          <th>姓名</th>\r\n          <th>年龄</th>\r\n          <th>生日</th>\r\n      </tr>\r\n      <c:forEach items=\"${requestScope.list}\" var=\"user\" varStatus=\"i\">\r\n          <c:if test=\"${i.count%2 == 0}\">\r\n              <tr bgcolor=\"aqua\">\r\n                  <td>${i.count}</td>\r\n                  <td>${user.username}</td>\r\n                  <td>${user.age}</td>\r\n                  <td>${user.birthdayStr}</td>\r\n              </tr>\r\n          </c:if>\r\n          <c:if test=\"${i.count%2 != 0}\">\r\n              <tr bgcolor=\"#7fffd4\">\r\n                  <td>${i.count}</td>\r\n                  <td>${user.username}</td>\r\n                  <td>${user.age}</td>\r\n                  <td>${user.birthdayStr}</td>\r\n              </tr>\r\n          </c:if>\r\n      </c:forEach>\r\n  </table>\r\n  </html>\r\n  \r\n  ```\r\n\r\n## 23.3 三层架构：软件设计架构\r\n\r\n![image-20210828133556589](cloudDisk/markdown/JavaWeb笔记.assets/image-20210828133556589.png)\r\n\r\n1. 界面层（表示层）：用户看到的界面。用户可以通过界面上的组件和服务器进行交互\r\n2. 业务逻辑层：处理业务逻辑的。\r\n3. 数据访问层：操作数据存储文件的。\r\n\r\n## 案例 ：用户信息列表展示\r\n\r\n### 1. 需求：\r\n\r\n用户信息的增删改查操作\r\n\r\n### 2. 设计：\r\n\r\n#### 1）技术选型：\r\n\r\nServlet + JSP + MySQL + JDBCTemplate + Druid + BeanUtils + tomcat\r\n\r\n#### 2) 数据库设计\r\n\r\n```sql\r\nCREATE DATABASE day17;\r\nUSE day17;\r\nCREATE TABLE USER(\r\n	id INT PRIMARY KEY AUTO_INCREMENT,\r\n	NAME VARCHAR(20) NOT NULL,\r\n	gender VARCHAR(5),\r\n	age INT,\r\n	address VARCHAR(32),\r\n	qq VARCHAR(20),\r\n	email VARCHAR(50)\r\n);\r\n```\r\n\r\n#### 3）开发：\r\n\r\n1. 环境搭建\r\n   1. 创建数据库环境\r\n   2. 创建项目，导入需要的jar包\r\n2. 编码\r\n\r\n#### 4）测试\r\n\r\n#### 5）部署运维\r\n\r\n\r\n\r\n![image-20210829131120436](cloudDisk/markdown/JavaWeb笔记.assets/image-20210829131120436.png)\r\n\r\n![image-20210830155012977](cloudDisk/markdown/JavaWeb笔记.assets/image-20210830155012977.png)![image-20210901214637562](cloudDisk/markdown/JavaWeb笔记.assets/image-20210901214637562.png)\r\n\r\n![image-20210902103453428](cloudDisk/markdown/JavaWeb笔记.assets/image-20210902103453428.png)\r\n\r\n![image-20210902104548416](cloudDisk/markdown/JavaWeb笔记.assets/image-20210902104548416.png)\r\n\r\n![image-20210902124124891](cloudDisk/markdown/JavaWeb笔记.assets/image-20210902124124891.png)\r\n\r\n![image-20210902141551935](cloudDisk/markdown/JavaWeb笔记.assets/image-20210902141551935.png)\r\n\r\n# 二十四、Filter\r\n\r\n## 24.1 概念\r\n\r\n* web中的过滤器：当访问服务器的资源时，过滤器可以将请求拦截，完成一些特殊的功能\r\n* 过滤器作用：\r\n  * 一般用于完成通用的操作。如：登录验证、统一编码处理、敏感字符过滤。。。\r\n\r\n## 24.2 快速入门\r\n\r\n1. 步骤：\r\n\r\n   1. 定义一个类，实现接口Filter\r\n   2. 复写方法\r\n   3. 配置拦截路径\r\n\r\n   ```java\r\n   @WebFilter(\"/*\") //  访问所有资源前，都会执行过滤器\r\n   public class FilterDemo1 implements Filter {\r\n       @Override\r\n       public void init(FilterConfig filterConfig) throws ServletException {\r\n   \r\n       }\r\n   \r\n       @Override\r\n       public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException {\r\n           System.out.println(\"filter被执行了\");\r\n           filterChain.doFilter(servletRequest,servletResponse); // 放行\r\n       }\r\n   \r\n       @Override\r\n       public void destroy() {\r\n   \r\n       }\r\n   }\r\n   ```\r\n\r\n## 24.3 过滤器细节：\r\n\r\n### 1. web.xml配置\r\n\r\n```xml\r\n    <filter>\r\n        <filter-name>demo1</filter-name>\r\n        <filter-class>com.tony.web.filter.FilterDemo1</filter-class>\r\n    </filter>\r\n    <filter-mapping>\r\n        <filter-name>demo1</filter-name>\r\n<!--        拦截路径-->\r\n        <url-pattern>/*</url-pattern>\r\n    </filter-mapping>\r\n```\r\n\r\n### 2. 过滤器执行流程\r\n\r\n1. 执行过滤器\r\n2. 执行放行后的资源\r\n3. 回来后执行过滤器放行代码下边的代码\r\n\r\n### 3. 过滤器的生命周期方法\r\n\r\n1. init : 在服务器启动后，会创建Filter对象，然后调用init方法。只执行一次。用于加载资源\r\n2. doFilter ： 每一次请求拦截资源时，会执行。执行多次\r\n3. detroy：在服务器关闭后，Filter对象被销毁。如果服务器时正常关闭，则会执行destroy方法。用于释放资源\r\n\r\n### 4. 过滤器配置详解\r\n\r\n* 拦截路径配置\r\n  1. 具体资源路径：/index.jsp  只有访问index.jsp资源时，过滤器才会被执行\r\n  2. 目录拦截：/user/*  访问/user下的所有资源时，过滤器都会被执行\r\n  3. 后缀名拦截：*.jsp  访问所有jsp资源时，过滤器都会被执行\r\n  4. 拦截所有资源：/*\r\n* 拦截方式配置：资源被访问的方式\r\n  * 注解配置\r\n    * 设置dispatcherTypes属性\r\n      1. REQUEST : 默认值。浏览器直接请求资源\r\n      2. FORWARD : 转发访问资源\r\n      3. INCLUDE : 包含访问资源\r\n      4. ERROR : 错误跳转资源\r\n      5. ASYNC :  异步访问资源\r\n  * web.xml配置\r\n    * 设置\\<dispatcher>\\</dispatcher>标签即可\r\n\r\n### 5. 过滤器链（配置多个过滤器）\r\n\r\n* 执行顺序：如果有两个过滤器：过滤器1和过滤器2\r\n  1. 过滤器1\r\n  2. 过滤器2\r\n  3. 资源执行\r\n  4. 过滤器2\r\n  5. 过滤器1\r\n* 过滤器先后顺序问题：\r\n  1. 注解配置：按照类名的字符串比较规则比较，值小的先执行\r\n     * 如：AFilter 和 BFilter\r\n  2. web.xml 配置：\r\n\r\n## 案例\r\n\r\n### 1. 登录验证\r\n\r\n![image-20210903124307930](cloudDisk/markdown/JavaWeb笔记.assets/image-20210903124307930.png)\r\n\r\n### 2. 敏感词汇过滤\r\n\r\n#### 需求：\r\n\r\n1. 对案例的数据进行敏感词汇过滤\r\n2. 敏感词汇参考《敏感词汇.txt》\r\n3. 如果是敏感词，替换成 ***\r\n\r\n#### 分析：\r\n\r\n1. 对request对象进行增强\r\n\r\n#### 增强对象的功能：\r\n\r\n设计模式：一些通用的解决固定问题的方式\r\n\r\n##### 1. 装饰模式\r\n\r\n##### 2. 代理模式\r\n\r\n概念：\r\n\r\n1. 真实对象：被代理的对象\r\n2. 代理对象：\r\n3. 代理模式：代理对象代理真实对象，达到增强真实对象功能的目的\r\n\r\n* 实现方式：\r\n  1. 静态代理：有一个类文件描述代理模式\r\n  2. 动态代理：在内存中形成代理类\r\n     * 实现步骤：\r\n       1. 代理对象和真实对象实现相同的接口\r\n       2. 代理对象 = Proxy.newProxyInstance();\r\n       3. 使用代理对象调用方法。\r\n       4. 增强方法\r\n     * 增强方式：\r\n       1. 增强参数列表\r\n       2. 增强返回值类型\r\n       3. 增强方法体执行逻辑\r\n\r\n```java\r\npackage com.tony.userInfoDisplay.web.filter;\r\n\r\nimport javax.servlet.*;\r\nimport javax.servlet.annotation.WebFilter;\r\nimport java.io.*;\r\nimport java.lang.reflect.InvocationHandler;\r\nimport java.lang.reflect.Method;\r\nimport java.lang.reflect.Proxy;\r\n\r\n@WebFilter(value = \"/*\")\r\npublic class SensetiveWordsFilter implements Filter {\r\n    private static BufferedReader br;\r\n    @Override\r\n    public void init(FilterConfig filterConfig) throws ServletException {\r\n        // 获取 敏感词汇.txt路径\r\n        ServletContext servletContext = filterConfig.getServletContext();\r\n        String realPath = servletContext.getRealPath(\"/WEB-INF/classes/敏感词汇.txt\");\r\n        try {\r\n            br = new BufferedReader(new InputStreamReader(new FileInputStream(realPath),\"utf-8\"));\r\n        } catch (UnsupportedEncodingException e) {\r\n            e.printStackTrace();\r\n        } catch (FileNotFoundException e) {\r\n            e.printStackTrace();\r\n        }\r\n\r\n    }\r\n\r\n    @Override\r\n    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException {\r\n        // 当调用request.getParameter()时候，提前将value值中的敏感词汇变成***\r\n        ServletRequest request = (ServletRequest)Proxy.newProxyInstance(servletRequest.getClass().getClassLoader(), servletRequest.getClass().getInterfaces(), new InvocationHandler() {\r\n            @Override\r\n            public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\r\n                // 获取被调用的方法的名字\r\n                String methodName = method.getName();\r\n                // 如果是：getParameter方法，则加强它\r\n                if (\"getParameter\".equals(methodName)){\r\n//                    System.out.println(methodName);\r\n                    // 运行该方法，获取返回值\r\n                    String result = (String)method.invoke(servletRequest, args);\r\n                    // 加强返回值\r\n                    // 替换返回值中的敏感词汇\r\n                          // 读取 取敏感词汇.txt\r\n                    String line;\r\n                    while ((line=br.readLine()) != null){\r\n//                        System.out.println(line);\r\n                        // 替换敏感词汇\r\n                        result = result.replace(line,\"***\");\r\n                    }\r\n                    return result;\r\n                }\r\n                // 如果不是getParameter方法，则方法正常执行，并返回\r\n                return method.invoke(servletRequest,args);\r\n            }\r\n        });\r\n        // 放行\r\n        filterChain.doFilter(request,servletResponse);\r\n    }\r\n\r\n    @Override\r\n    public void destroy() {\r\n        try {\r\n            br.close();\r\n        } catch (IOException e) {\r\n            e.printStackTrace();\r\n        }\r\n    }\r\n}\r\n\r\n```\r\n\r\n```java\r\n@WebServlet(\"/TestServlet\")\r\npublic class TestServlet extends HttpServlet {\r\n    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\r\n        String name = request.getParameter(\"name\");\r\n        String info = request.getParameter(\"info\");\r\n        System.out.println(name+\":\"+info);\r\n    }\r\n```\r\n\r\n![image-20210904162038032](cloudDisk/markdown/JavaWeb笔记.assets/image-20210904162038032.png)\r\n\r\n![image-20210904162050277](cloudDisk/markdown/JavaWeb笔记.assets/image-20210904162050277.png)\r\n\r\n# 二十五、Listener : 监听器\r\n\r\n## 概念：\r\n\r\nweb的三大组件之一\r\n\r\n* 事件监听机制\r\n  * 事件：一件事情\r\n  * 事件源：事情发生的地方\r\n  * 监听器：一个对象\r\n  * 注册监听：将事件。事件源、监听器绑定在一起、当事件源上发送某个事件后，执行监听器代码\r\n\r\n## ServletContextListener : \r\n\r\n### 监听器ServletContext对象的创建和销毁\r\n\r\n#### 方法\r\n\r\n* void contextDestroyed(ServletContextEvent sce) : ServletContext对象被销毁之前会调用该方法\r\n* void contextInitialized(ServletContextEvent sce) : ServletContext对象创建后会调用该方法\r\n\r\n#### 步骤\r\n\r\n1. 定义一个类，实现ServletContextListener接口\r\n\r\n2. 复写方法\r\n\r\n3. 配置方式\r\n\r\n   1. web.xml:\r\n\r\n      ```xml\r\n          <listener>\r\n              <listener-class>com.tony.web.listener.ContextLoaderListener</listener-class>\r\n          </listener>\r\n      ```\r\n\r\n      * 指定初始化参数：\r\n\r\n        ```xml\r\n            <context-param>\r\n                <param-name>contextConfigLocation</param-name>\r\n                <param-value>WEB-INF/classes/applicationContext.xml</param-value>\r\n            </context-param>\r\n        ```\r\n\r\n   2. 注解：\r\n\r\n      * @WebListener\r\n\r\n#### 例 - 初始化全局的资源文件：\r\n\r\n![image-20210904165751547](cloudDisk/markdown/JavaWeb笔记.assets/image-20210904165751547.png)\r\n\r\n资源文件：applicationContext.xml\r\n\r\n配置文件：web.xml\r\n\r\n```xml\r\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<web-app xmlns=\"http://xmlns.jcp.org/xml/ns/javaee\"\r\n         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\r\n         xsi:schemaLocation=\"http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd\"\r\n         version=\"4.0\">\r\n    <listener>\r\n        <!--    指定监听器的类    -->\r\n        <listener-class>com.tony.web.listener.ContextLoaderListener</listener-class>\r\n    </listener>\r\n    <context-param>\r\n        <param-name>contextConfigLocation</param-name>\r\n        <param-value>WEB-INF/classes/applicationContext.xml</param-value>\r\n    </context-param>\r\n</web-app>\r\n```\r\n\r\n监听器：ContextLoaderListener.java\r\n\r\n```java\r\npackage com.tony.web.listener;\r\n\r\nimport javax.servlet.ServletContext;\r\nimport javax.servlet.ServletContextEvent;\r\nimport javax.servlet.ServletContextListener;\r\nimport java.io.FileInputStream;\r\nimport java.io.FileNotFoundException;\r\n\r\npublic class ContextLoaderListener implements ServletContextListener {\r\n    @Override\r\n    public void contextInitialized(ServletContextEvent servletContextEvent) {\r\n        /*\r\n        *监听ServletContext对象创建的。ServletContext对象服务器启动后自动创建\r\n        *\r\n        * 服务器启动后自动调用\r\n        */\r\n        // 加载资源文件\r\n        // 1. 获取ServletContext对象\r\n        ServletContext servletContext = servletContextEvent.getServletContext();\r\n\r\n        // 2. 加载资源文件\r\n        String contextConfigLocation = servletContext.getInitParameter(\"contextConfigLocation\");\r\n\r\n        // 3. 获取真实路径\r\n        String realPath = servletContext.getRealPath(contextConfigLocation);\r\n\r\n        // 4. 加载进内存\r\n        try {\r\n            FileInputStream fis = new FileInputStream(realPath);\r\n            System.out.println(fis);\r\n        } catch (FileNotFoundException e) {\r\n            e.printStackTrace();\r\n        }\r\n        System.out.println(\"对象被创建了\");\r\n\r\n    }\r\n\r\n    @Override\r\n    public void contextDestroyed(ServletContextEvent servletContextEvent) {\r\n\r\n    }\r\n}\r\n\r\n```\r\n\r\n# 二十六、JQuery\r\n\r\n## 26.1 JQery 基础\r\n\r\n### 1. 概念\r\n\r\n* 一个JavaScript框架。简化JS开发\r\n* jQuery是一个快速、简洁的JavaScript框架，是继Prototype之后又一个优秀的JavaScript代码库（框架）于2006年1月由John Resig发布。jQuery设计的宗旨是“write Less，Do More”，即倡导写更少的代码，做更多的事情。它封装JavaScript常用的功能代码，提供一种简便的JavaScript设计模式，优化HTML文档操作、事件处理、动画设计和Ajax交互。\r\n* javaScript框架：本质上就是一些js文件，封装了js的原生代码而已\r\n\r\n### 2. 快速入门\r\n\r\n* 步骤：\r\n  1. 下载JQuery\r\n     * ![image-20210905130209295](cloudDisk/markdown/JavaWeb笔记.assets/image-20210905130209295.png)\r\n  2. 导入JQuery的js文件：导入min.js文件\r\n  3. 使用\r\n\r\n### 3. JQuery对象和JS对象区别与转换\r\n\r\n1. JQuery对象在操作时，更加方便\r\n2. JQuery对象和js对象方法不通用\r\n3. 两者相互转换\r\n   * jq --> js ： jq对象[索引] 或者   jq对象.get(索引)\r\n   * js --> jq ： $(js对象)\r\n\r\n### 4. 选择器 : 筛选具有相似特征的元素（标签）\r\n\r\n#### 1）基本语法学习\r\n\r\n##### 1. 事件绑定\r\n\r\n```javascript\r\n// 1. 获取b1按钮\r\n$(\"#b1\").click(function(){\r\n	alert(\"abc\");\r\n})\r\n```\r\n\r\n##### 2. 入口函数\r\n\r\n```javascript\r\n// window.onload = function () {\r\n//     alert(123);\r\n// }\r\n// window.onload = function () {\r\n//     alert(456);\r\n// }\r\n$(function () {\r\n	alert(123);\r\n})\r\n$(function () {\r\n	alert(456)\r\n})\r\n```\r\n\r\nwindow.onload  和  $(function) 区别\r\n\r\n* window.onload 只能定义一次，如果多次定义，后边的会将前边的覆盖掉\r\n* $(function)可以定义多次的\r\n\r\n##### 3. 样式控制\r\n\r\n```javascript\r\n// $(\"#div1\").css(\"background-color\",\"red\");\r\n$(\"#div1\").css(\"backgroundColor\",\"pink\");\r\n```\r\n\r\n###### 基本选择器\r\n\r\n1. 标签选择器（元素选择器）\r\n   * 语法：$(\"html标签名\") 获得多有匹配标签名称的元素\r\n2. id选择器\r\n   * 语法：$(\"#id的属性值\") 获得与指定id属性值匹配的元素\r\n\r\n3. 类选择器\r\n   * 语法： $(\".class的属性值\") 获得与指定的class属性值匹配的元素\r\n\r\n4. 并集选择器：\r\n   * 语法： $(\"选择器1,选择器2....\") 获取多个选择器选中的所有元素\r\n\r\n###### 层级选择器\r\n\r\n1. 后代选择器\r\n   * 语法： $(\"A B \") 选择A元素内部的所有B元素,包括子子孙孙  \r\n2. 子选择器\r\n   * 语法： $(\"A > B\") 选择A元素内部的所有B子元素\r\n\r\n###### 属性选择器\r\n\r\n      1. 属性名称选择器\r\n         * 语法： $(\"A[属性名]\") 包含指定属性的选择器\r\n   2. 属性选择器\r\n      * 语法： $(\"A[属性名=\'值\']\") 包含指定属性等于指定值的选择器\r\n   3. 复合属性选择器\r\n          * 语法： $(\"A\\[属性名=\'值\'][]...\") 包含多个属性条件的选择器\r\n\r\n```javascript\r\n$(function () {\r\n             //含有属性title 的div元素背景色为红色\r\n			 $(\"#b1\").click(function () {\r\n				 $(\"div[title]\").css(\"backgroundColor\",\"red\");\r\n             });\r\n \r\n             //属性title值等于test的div元素背景色为红色\r\n             $(\"#b2\").click(function () {\r\n                 $(\"div[title = \'test\']\").css(\"backgroundColor\",\"red\");\r\n             });\r\n             //属性title值不等于test的div元素(没有属性title的也将被选中)背景色为红色\r\n             $(\"#b3\").click(function () {\r\n                 $(\"div[title != \'test\']\").css(\"backgroundColor\",\"red\");\r\n             });\r\n             //属性title值 以te开始 的div元素背景色为红色\r\n             $(\"#b4\").click(function () {\r\n                 $(\"div[title ^=\'te\']\").css(\"backgroundColor\",\"red\");\r\n             });\r\n             //属性title值 以est结束 的div元素背景色为红色\r\n             $(\"#b5\").click(function () {\r\n                 $(\"div[title $= \'te\']\").css(\"backgroundColor\",\"red\");\r\n             });\r\n             //属性title值 含有es的div元素背景色为红色\r\n             $(\"#b6\").click(function () {\r\n                 $(\"div[title *= \'te\']\").css(\"backgroundColor\",\"red\");\r\n             });\r\n \r\n             //选取有属性id的div元素，然后在结果中选取属性title值含有“es”的 div 元素背景色为红色\r\n             $(\"#b7\").click(function () {\r\n                 $(\"div[id][title *= \'es\']\").css(\"backgroundColor\",\"red\");\r\n             });\r\n         })\r\n\r\n```\r\n\r\n###### 过滤选择器\r\n\r\n    1. 首元素选择器 \r\n        * 语法： :first 获得选择的元素中的第一个元素\r\n    2. 尾元素选择器 \r\n        * 语法： :last 获得选择的元素中的最后一个元素\r\n    3. 非元素选择器\r\n        * 语法： :not(selector) 不包括指定内容的元素\r\n    4. 偶数选择器\r\n        * 语法： :even 偶数，从 0 开始计数\r\n    5. 奇数选择器\r\n        * 语法： :odd 奇数，从 0 开始计数\r\n    6. 等于索引选择器\r\n        * 语法： :eq(index) 指定索引元素\r\n    7. 大于索引选择器 \r\n        * 语法： :gt(index) 大于指定索引元素\r\n    8. 小于索引选择器 \r\n        * 语法： :lt(index) 小于指定索引元素\r\n    9. 标题选择器\r\n        * 语法： :header 获得标题（h1~h6）元素，固定写法\r\n\r\n```javascript\r\n$(function () {\r\n            //改变第一个 div 元素的背景色为 红色\r\n			$(\"#b1\").click(function () {\r\n				$(\"div:first\").css(\"background\",\"red\");\r\n            });\r\n \r\n            //改变最后一个 div 元素的背景色为 红色\r\n            $(\"#b2\").click(function () {\r\n                $(\"div:last\").css(\"background\",\"red\");\r\n            });\r\n \r\n			//改变class不为 one 的所有 div 元素的背景色为 红色\r\n            $(\"#b3\").click(function () {\r\n                $(\"div:not([class = \'one\'])\").css(\"background\",\"red\");\r\n            });\r\n \r\n            //改变索引值为偶数的 div 元素的背景色为 红色\r\n            $(\"#b4\").click(function () {\r\n                $(\"div:even\").css(\"background\",\"red\");\r\n            });\r\n \r\n            //改变索引值为奇数的 div 元素的背景色为 红色\r\n            $(\"#b5\").click(function () {\r\n                $(\"div:odd\").css(\"background\",\"red\");\r\n            });\r\n \r\n            //改变索引值为大于 3 的 div 元素的背景色为 红色\r\n            $(\"#b6\").click(function () {\r\n                $(\"div:gt(3)\").css(\"background\",\"red\");\r\n            });\r\n \r\n            //改变索引值为等于 3 的 div 元素的背景色为 红色\r\n            $(\"#b7\").click(function () {\r\n                $(\"div:eq(3)\").css(\"background\",\"red\");\r\n            });\r\n \r\n            //改变索引值为小于 3 的 div 元素的背景色为 红色\r\n            $(\"#b8\").click(function () {\r\n                $(\"div:lt(3)\").css(\"background\",\"red\");\r\n            });\r\n \r\n            //改变所有的标题元素的背景色为 红色\r\n            $(\"#b9\").click(function () {\r\n                $(\":header\").css(\"background\",\"red\");\r\n            });\r\n        })\r\n\r\n```\r\n\r\n###### 表单过滤选择器\r\n\r\n1. 可用元素选择器 \r\n   * 语法： :enabled 获得可用元素\r\n2. 不可用元素选择器 \r\n   * 语法： :disabled 获得不可用元素\r\n3. 选中选择器 \r\n   * 语法： :checked 获得单选/复选框选中的元素\r\n4. 选中选择器 \r\n   * 语法： :selected 获得下拉框选中的元素\r\n\r\n```javascript\r\n	$(function () {\r\n            //利用 jQuery 对象的 val() 方法改变表单内可用 <input> 元素的值\r\n			$(\"#b1\").click(function () {\r\n				$(\"input[type=\'text\']:disabled\").val(\"aaa\")\r\n            });\r\n \r\n            //利用 jQuery 对象的 val() 方法改变表单内不可用 <input> 元素的值\r\n            $(\"#b2\").click(function () {\r\n                $(\"input[type=\'text\']:enabled\").val(\"bbb\")\r\n            });\r\n \r\n            //利用 jQuery 对象的 length 属性获取复选框选中的个数\r\n            $(\"#b3\").click(function () {\r\n                var length = $(\"input[type=\'checkbox\']:checked\").length;\r\n                alert(length);\r\n            });\r\n \r\n            //利用 jQuery 对象的 length 属性获取下拉框选中的个数\r\n            $(\"#b4\").click(function () {\r\n                var length = $(\"#job>option:selected\").length;\r\n                alert(length);\r\n            });\r\n        })\r\n```\r\n\r\n### 5. DOM操作\r\n\r\n#### 1）内容操作\r\n\r\n##### 1. html()\r\n\r\n* 获取/设置元素的标签体内容\r\n\r\n* ```html\r\n  <a><font>内容</font></a>  -->  <font>内容</font>\r\n  ```\r\n\r\n##### 2. text()\r\n\r\n* 获取/设置元素的标签体纯文本内容\r\n\r\n* ```html\r\n  <a><font>内容</font></a>  -->  内容\r\n  ```\r\n\r\n##### 3. val()\r\n\r\n* 获取/设置元素的value属性值\r\n\r\n```html\r\n    <script>\r\n        $(function () {\r\n            // 获取myinput 的value值\r\n            var value = $(\"#myinput\").val();\r\n            alert(value);\r\n            $(\"#myinput\").val(\"李四\");\r\n            // 获取mydiv的标签体内容\r\n            var html = $(\"#mydiv\").html();\r\n            alert(html);\r\n            $(\"#mydiv\").html(\"<p>aaaa</p>\");\r\n            // 获取mydiv文本内容\r\n            var text = $(\"#mydiv\").text();\r\n            alert(text);\r\n            $(\"#mydiv\").text(\"bbb\");\r\n        })\r\n    </script>\r\n</head>\r\n<body>\r\n    <input id=\"myinput\" type=\"text\" name=\"username\" value=\"张三\"> <br>\r\n    <div id=\"mydiv\"><p><a href=\"#\">标题标签</a></p></div>\r\n</body>\r\n```\r\n\r\n#### 2）属性操作\r\n\r\n##### 1. 通用属性操作\r\n\r\n1. attr(): 获取/设置元素的属性\r\n2. removeAttr()：删除属性\r\n3. prop(): 获取/设置元素的属性\r\n4. removeProp()：删除属性\r\n\r\n* attr和prop区别？\r\n  1. 如果操作的是元素的固有属性，比如a标签中的href，则建议使用prop\r\n  2. 如果操作的是元素自定义的属性，比如所有标签都有name，则建议使用attr\r\n\r\n```html\r\n    <script>\r\n\r\n        $(function () {\r\n            //获取北京节点的name属性值\r\n            var attr1 = $(\"#bj\").attr(\"name\");\r\n            alert(attr1);\r\n            //设置北京节点的name属性的值为dabeijing---测试的时候可以通过在浏览器按F12查看\r\n            $(\"#bj\").attr(\"name\",\"dabeijing\");\r\n            //新增北京节点的discription属性 属性值是didu\r\n            $(\"#bj\").attr(\"discription\",\"didu\");\r\n            var b = confirm(\"删除name属性\");\r\n            if (b) {\r\n                //删除北京节点的name属性并检验name属性是否存在\r\n                $(\"#bj\").removeAttr(\"name\");\r\n            }\r\n            //获得hobby的的选中状态\r\n            var prop = $(\"#hobby\").prop(\"checked\");\r\n            alert(prop);\r\n            //var checked = $(\"#hobby\").attr(\"checked\"); //获取不到，弹出undefined\r\n        })\r\n    </script>\r\n</head>\r\n<body>\r\n    <ul>\r\n        <li id=\"bj\" name=\"beijing\" xxx=\"yyy\">北京</li>\r\n        <li id=\"tj\" name=\"tianjin\">天津</li>\r\n    </ul>\r\n    <input type=\"checkbox\" id=\"hobby\"/>\r\n</body>\r\n```\r\n\r\n\r\n\r\n##### 2. 对class属性操作\r\n\r\n1. addClass(): 添加class属性值\r\n2. removeClass(): 删除class属性值\r\n3. toggleClass()：切换class属性\r\n   * toggleClass(\"one\"):\r\n     * 判断如果元素对象上存在class=\"one\"，则将属性值one删除掉；如果元素对象上不存在class=\"one\"，则添加。\r\n4. css()\r\n\r\n```javascript\r\n$(function () {\r\n            //通过通用属性方法来添加class样式\r\n            $(\"#b1\").click(function () {\r\n                $(\"#one\").attr(\"class\",\"second\");\r\n            });\r\n\r\n            //通过addClass来添加class样式\r\n            $(\"#b2\").click(function () {\r\n                $(\"#one\").addClass(\"second\");\r\n            });\r\n\r\n            //删除样式\r\n            $(\"#b3\").click(function () {\r\n                $(\"#one\").removeClass(\"second\");\r\n            });\r\n\r\n            //切换样式\r\n            $(\"#b4\").click(function () {\r\n                $(\"#one\").toggleClass(\"second\");\r\n            });\r\n\r\n            //通过css()获得id为one背景颜色\r\n            $(\"#b5\").click(function () {\r\n                var css = $(\"one\").css(\"backgroundColor\");\r\n                alert(css)\r\n            });\r\n\r\n            // 通过css()设置id为one背景颜色为绿色\r\n            $(\"#b6\").click(function () {\r\n                $(\"one\").css(\"backgroundColor\",\"green\");\r\n            });\r\n        });\r\n```\r\n\r\n\r\n\r\n#### 3）CRUD操作\r\n\r\n##### 1. append(): 父元素将子元素追加到末尾\r\n\r\n* 对象1.append(\"对象2\")：将对象2添加到对象1元素内部，并且在末尾\r\n\r\n##### 2. prepared() : 父元素将子元素追加到开头\r\n\r\n* 对象1.prepared(\"对象2\")：将对象2添加到对象1元素内部，并且在开头\r\n\r\n##### 3. appendTo():\r\n\r\n* 对象1.append(对象2)：将对象1添加到对象2内部，并且在末尾\r\n\r\n##### 4. prependTo():\r\n\r\n* 对象1.prependTo(\"对象2\")：将对象1添加到对象2元素内部，并且在开头\r\n\r\n##### 5. after(): 添加元素到元素后边\r\n\r\n* 对象1.after(对象2)：将对象2添加到对象1后边。对象1和对象2是兄弟关系\r\n\r\n##### 6. before(): 添加元素到元素前边\r\n\r\n* 对象1.after(对象2)：将对象2添加到对象1前边。对象1和对象2是兄弟关系\r\n\r\n##### 7. insertAfter()\r\n\r\n* 对象1.insertAfter(对象2)：将对象1添加到对象2后边。对象1和对象2是兄弟关系\r\n\r\n##### 8. insertBefore()\r\n\r\n* 对象1.insertBefore(对象2)：将对象1添加到对象2前边。对象1和对象2是兄弟关系\r\n\r\n##### 9. remove() : 移除元素\r\n\r\n* 对象.remove() : 将对象删除掉\r\n\r\n##### 10. empty() : 清空元素的所有后代元素\r\n\r\n* 对象.empty() : 将对象的后代元素全部清空，但是保留当前对象以及其属性节点\r\n\r\n##### 11. clone() : 复制当前JQuery对象\r\n\r\n### 6. 案例\r\n\r\n#### 1）需求：将数据行的奇数行背景色设置为 green，偶数行背景色设置为 blue\r\n\r\n```html\r\n<script>\r\n    //需求：将数据行的奇数行背景色设置为 green，偶数行背景色设置为 blue---要抛出首行标题行\r\n    $(function () {\r\n        $(\"table tr:gt(1):odd\").css(\"backgroundColor\",\"green\");\r\n        $(\"table tr:gt(1):even\").css(\"backgroundColor\",\"blue\");\r\n    });\r\n</script>\r\n```\r\n\r\n![image-20210906130556917](cloudDisk/markdown/JavaWeb笔记.assets/image-20210906130556917.png)\r\n\r\n#### 2）需求：使用JQuery实现表单选项的全选与全不选\r\n\r\n![image-20210906131356708](cloudDisk/markdown/JavaWeb笔记.assets/image-20210906131356708.png)\r\n\r\n```html\r\n <script>\r\n        //分析：需要保证下边的选中状态和第一个复选框的选中状态一致即可\r\n        function selectAll(object) {\r\n            // object是触发该函数的对象\r\n            // 获取所有的checkbox对象 : $(\"table tr td input[type=\'checkbox\']\")\r\n            // 将checkbox对象的固有属性设置成和触发当前函数的checkbox对象的状态一致\r\n            $(\"table tr td input[type=\'checkbox\']\").prop(\"checked\",object.checked);\r\n        }\r\n    </script>\r\n</head>\r\n<body>\r\n<table id=\"tab1\" border=\"1\" width=\"800\" align=\"center\" >\r\n    <tr>\r\n        <td colspan=\"5\"><input type=\"button\" value=\"删除\"></td>\r\n    </tr>\r\n    <tr>\r\n        //下面的this是整个<input>标签\r\n        <th><input type=\"checkbox\" onclick=\"selectAll(this)\" ></th>\r\n        <th>分类ID</th>\r\n        <th>分类名称</th>\r\n        <th>分类描述</th>\r\n        <th>操作</th>\r\n    </tr>\r\n    <tr>\r\n        <td><input type=\"checkbox\" class=\"itemSelect\"></td>\r\n        <td>1</td>\r\n        <td>手机数码</td>\r\n        <td>手机数码类商品</td>\r\n        <td><a href=\"\">修改</a>|<a href=\"\">删除</a></td>\r\n    </tr>\r\n```\r\n\r\n#### 3）模拟实现在留言里面添加QQ表情\r\n\r\n![image-20210906131721898](cloudDisk/markdown/JavaWeb笔记.assets/image-20210906131721898.png)\r\n\r\n```javascript\r\n        //需求：点击qq表情，将其追加到发言框中\r\n        $(function () {\r\n            $(\"ul img\").click(function () {\r\n                //$(\".word\").append(this); //不能这样世界使用this，因为这里的this是js，不是jquery的方法，需要转换\r\n\r\n                //$(\".word\").append($(this).clone()); //这里这样使用，点击图标后虽然添加到了新位置，但是原先位置的图标没了\r\n\r\n                $(\".word\").append($(this).clone()); //我们需要使用JQuery克隆功能\r\n            });\r\n        })\r\n```\r\n\r\n## 26.2 JQuery 高级\r\n\r\n### 1. 动画 - 三种方式显示和隐藏元素\r\n\r\n#### 1） 默认显示和隐藏方式\r\n\r\n1. show([speed,[easing],[fn]])\r\n\r\n   * 参数：\r\n\r\n     1. speed：动画的速度。三个预定义的值(\"slow\",\"normal\",\"fast\")或表示动画时长的毫秒值（如：1000）\r\n\r\n     2. easing：用来指定切换效果，默认是\"swing\"，可用参数\"linear\"\r\n        * swing：动画执行时效果是：先慢，中间快，最后又慢\r\n        * linear：动画执行时速度时匀速的\r\n\r\n     3. fn：在动画完成时执行的函数，每个元素执行一次\r\n\r\n2. hide([speed,[easing],[fn]])\r\n\r\n3. toggle([speed],[easing],[fn])\r\n\r\n#### 2）默认显示和隐藏方式\r\n\r\n1. slideDown([speed,[easing],[fn]])\r\n2. slideUp([speed,[easing],[fn]])\r\n3. sideToggle([speed,[easing],[fn]])\r\n\r\n#### 3）淡入淡出显示和隐藏方式\r\n\r\n1. fadeIn([speed,[easing],[fn]])\r\n2. fadeOut([speed,[easing],[fn]])\r\n3. fadeToggle([speed,[easing],[fn]])\r\n\r\n```html\r\n<script>\r\n        $(function () {\r\n            $(\"#b1\").click(function () {\r\n                // 默认方式\r\n                // $(\"#div\").show(\"slow\",\"swing\");\r\n\r\n                // 滑动方式\r\n                // $(\"#div\").slideDown(\"slow\");\r\n\r\n                // 淡入淡出方式\r\n                $(\"#div\").fadeIn(\"slow\");\r\n            })\r\n\r\n            $(\"#b2\").click(function () {\r\n                // 默认方式\r\n                // $(\"#div\").hide(\"slow\",\"swing\");\r\n\r\n                // 滑动方式\r\n                // $(\"#div\").slideUp(\"slow\");\r\n\r\n                // 淡入淡出方式\r\n                $(\"#div\").fadeOut(\"slow\");\r\n            })\r\n\r\n            $(\"#b3\").click(function () {\r\n                // 默认方式\r\n                // $(\"#div\").toggle(\"slow\",\"swing\");\r\n\r\n                // 滑动方式\r\n                // $(\"#div\").slideToggle(\"slow\");\r\n\r\n                // 淡入淡出方式\r\n                $(\"#div\").fadeToggle(\"slow\");\r\n            })\r\n        })\r\n    </script>\r\n</head>\r\n<body>\r\n    <input type=\"button\" id=\"b1\" value=\"show\">\r\n    <input type=\"button\" id=\"b2\" value=\"hide\">\r\n    <input type=\"button\" id=\"b3\" value=\"toggle\">\r\n    <div id=\"div\"></div>\r\n```\r\n\r\n### 2. 遍历\r\n\r\n#### 1）js的遍历方式\r\n\r\n* for(初始化值; 循环结束条件; 步长)\r\n\r\n#### 2）jq的遍历方式\r\n\r\n1. jq对象.each(callback)\r\n2. $.each(object,[callback])\r\n3. for..of:\r\n\r\n```html\r\n    <script>\r\n        $(function () {\r\n            var cities = $(\"#city li\");\r\n\r\n            // for循环遍历\r\n            /*for (var i=0; i<cities.length; i++){\r\n                alert(i+\"：\"+cities[i].innerHTML);\r\n            }*/\r\n\r\n            // 1. jq对象.each(callback) 遍历\r\n       /*     cities.each(function () {\r\n                // 获取li对象(JS对象) 第一种方式 this\r\n                alert(this.innerHTML);\r\n            })*/\r\n    /*\r\n            // 2.\r\n                cities.each(function (index,element) {\r\n                // 获取li对象 第二种方式 在回调函数中定义参数\r\n                // alert(index+\"：\"+element.innerHTML)\r\n                if (\"北京\" == $(element).html()){\r\n                    // 如果当前的function返回为false，则结束循环（break）\r\n                    // 如果返回为true，则结束本次循环，继续下次循环（continue）\r\n                    return false;\r\n                }\r\n                alert(index+\"：\"+$(element).html());\r\n            })*/\r\n            \r\n            /*\r\n            // 3. $.each(object,[callback])\r\n            $.each(cities,function () {\r\n                alert($(this).html())\r\n            })*/\r\n            \r\n            // 4. for ... of : jquery 3.0 版本之后提供的方式\r\n         /*   for (li of cities){\r\n                alert($(li).html());\r\n            }*/\r\n        })\r\n    </script>\r\n</head>\r\n<body>\r\n<ul id=\"city\">\r\n    <li>上海</li>\r\n    <li>北京</li>\r\n    <li>天津</li>\r\n    <li>重庆</li>\r\n</ul>\r\n```\r\n\r\n\r\n\r\n### 3. 事件绑定\r\n\r\n#### 1) jquery标准的绑定方式\r\n\r\n* jq对象.事件方法(回调函数);\r\n\r\n  ```html\r\n      <script>\r\n          $(function () {\r\n              // 1. 获取name对象，绑定click事件\r\n              /*$(\"#id\").click(function () {\r\n                  alert(\"我被点击了。。。\");\r\n              })*/\r\n  \r\n              // 给name绑定鼠标事件移动到元素之上事件。绑定鼠标移除事件\r\n          /*    $(\"#name\").mouseover(function () {\r\n                  alert(\"鼠标来了。。。\")\r\n              })\r\n              $(\"#name\").mouseout(function () {\r\n                  alert(\"鼠标走了。。。\")\r\n              })*/\r\n              // 简化操作，链式编程\r\n             /* $(\"#name\").mouseover(function () {\r\n                  alert(\"鼠标来了。。。\")\r\n              }).mouseout(function () {\r\n                  alert(\"鼠标走了。。。\")\r\n              })*/\r\n              alert(\"我要获得焦点了。。。\")\r\n              $(\"#name\").focus(); // 让文本输入框获得焦点\r\n              // 表单对象.submit(); // 让表单提交\r\n  \r\n          })\r\n  \r\n  \r\n      </script>\r\n  </head>\r\n  <body>\r\n  <input type=\"text\" id=\"name\" value=\"绑定点击事件\">\r\n  ```\r\n\r\n#### 2）on绑定事件/off接触绑定\r\n\r\n* jq对象.on(\"事件名称\",回调函数)\r\n* jq对象.off(\"事件名称\");\r\n\r\n```html\r\n    <script>\r\n        $(function () {\r\n            // 1. 使用on给按钮绑定单机事件\r\n            $(\"#b1\").click(function () {\r\n                alert(\"我被点击了。。。\")\r\n            })\r\n            // 2. 用off给按钮解绑单机事件\r\n            $(\"#b2\").click(function () {\r\n                // $(\"#b1\").off(\"click\");\r\n                $(\"#b1\").off(); // 将组件上的所有事件解除\r\n            })\r\n        })\r\n    </script>\r\n</head>\r\n<body>\r\n<input type=\"button\" id=\"b1\" value=\"使用on绑定单机事件\">\r\n<input type=\"button\" id=\"b2\" value=\"使用off解绑单机事件\">\r\n```\r\n\r\n\r\n\r\n#### 3）事件切换 ：toggle\r\n\r\n* jq对象.toggle(fn1,fn2,...)\r\n  * 单击jq对象对应的组件后，会执行fn1，第二次点击会执行fn2 . . . . . \r\n  * 注意：1.9版本 .toggle() 方法被删除了，jquery Migrate（迁移）插件可以恢复此功能\r\n\r\n```html\r\n    <script>\r\n        $(function () {\r\n            // 获取按钮，调用toggle方法\r\n            $(\"#b1\").toggle(function () {\r\n                $(\"#div\").css(\"backgroundColor\",\"green\");\r\n            },function () {\r\n                $(\"#div\").css(\"backgroundColor\",\"pink\");\r\n            })\r\n        })\r\n    </script>\r\n</head>\r\n<body>\r\n    <input type=\"button\" id=\"b1\" value=\"使用on绑定单机事件\">\r\n    <div id=\"div\" style=\"width: 300px; height: 300px; background-color: aliceblue\">\r\n        点击按钮变成绿色，再点击红色\r\n    </div>\r\n```\r\n\r\n\r\n\r\n### 4. 案例\r\n\r\n#### 1）广告显示和隐藏 \r\n\r\n*  注意：如果直接使用CSS的display属性，可以显示/隐藏，但是很生硬，所以使用jQuery的显示隐藏功能\r\n\r\n*  需求：\r\n\r\n   1. 当页面加载完，3秒后。自动显示广告\r\n\r\n   2. 广告显示5秒后，自动消失。\r\n\r\n*  分析：\r\n\r\n   1. 使用定时器来完成。setTimeout (执行一次定时器)\r\n   2. 分析发现JQuery的显示和隐藏动画效果其实就是控制display\r\n   3. 使用 show/hide方法来完成广告的显示\r\n\r\n```html\r\n    <script>\r\n        $(function () {\r\n            setTimeout(showImg,3000)\r\n            setTimeout(hideImg,6000)\r\n        })\r\n        function showImg() {\r\n            $(\"#div\").fadeIn(\"slow\");\r\n        }\r\n        function hideImg() {\r\n            $(\"#div\").fadeOut(\"slow\");\r\n        }\r\n    </script>\r\n</head>\r\n<body>\r\n    <div id=\"div\" style=\"display: none\">\r\n        <img src=\"WEB-INF/img/5.jpg\">\r\n    </div>\r\n```\r\n\r\n#### 2）抽奖\r\n\r\n![image-20210906165634935](cloudDisk/markdown/JavaWeb笔记.assets/image-20210906165634935.png)\r\n\r\n![image-20210906165649168](cloudDisk/markdown/JavaWeb笔记.assets/image-20210906165649168.png)\r\n\r\n```html\r\n<!DOCTYPE html>\r\n<html>\r\n<head>\r\n    <meta charset=\"UTF-8\" />\r\n    <title>抽奖</title>\r\n    <script  src=\"js/jquery-3.3.1.min.js\"></script>\r\n    <style>\r\n    </style>\r\n    <script>\r\n        $(function () {\r\n            var interval;\r\n            // 给点击开始绑定点击事件\r\n            $(\"#b1\").click(function () {\r\n                // 循环播放图片\r\n                // 调用setTimeout（）\r\n                interval = setInterval(changePic,100);\r\n                // 当前按钮属性设置为disabled\r\n                $(this).prop(\"disabled\",true);\r\n                // 停止按钮取消disabled\r\n                $(\"#b2\").prop(\"disabled\",false);\r\n            })\r\n            // 给停止按钮绑定单机事件\r\n            $(\"#b2\").click(function () {\r\n                // 停止interval\r\n                clearInterval(interval);\r\n                // 当前按钮属性设置为disabled\r\n                $(this).prop(\"disabled\",true);\r\n                // 开始按钮取消disabled\r\n                $(\"#b1\").prop(\"disabled\",false);\r\n\r\n                // 将当前暂停的图片显示到右侧中\r\n                // 将当前图片隐藏\r\n                $(\"#img2\").hide(\"fast\");\r\n                // 将图片路径改为暂停到的图片 img2.src = img1.src\r\n                $(\"#img2\").prop(\"src\",$(\"#img1\").prop(\"src\"));\r\n                // 图片显示\r\n                $(\"#img2\").show(\"slows\")\r\n            })\r\n        })\r\n        function changePic() {\r\n            // 当前图片的编号\r\n            var re1 = /(\\d*)\\.jpg/\r\n            var imgNum = parseInt(re1.exec($(\"#img1\").prop(\"src\"))[1])\r\n\r\n            // 当前图片的路径\r\n            var re2 = /(.*?)\\d*\\.jpg/\r\n            var imgPath = re2.exec($(\"#img1\").prop(\"src\"))[1]\r\n\r\n            // 循环播放图片\r\n            if (imgNum==12)\r\n                imgNum = 1;\r\n            $(\"#img1\").prop(\"src\",imgPath+(imgNum+1)+\".jpg\")\r\n\r\n        }\r\n    </script>\r\n</head>\r\n<body>\r\n    <span id=\"div\" style=\"width: 200px\">\r\n        <img id=\"img1\" style=\"width: 200px;height: 120px\" src=\"WEB-INF/img/1.jpg\">\r\n    </span>\r\n    <span>\r\n        <img id=\"img2\" style=\"float: right;width: 800px;margin: 50px\" src=\"WEB-INF/img/1.jpg\">\r\n    </span>\r\n    <br>\r\n    <input id=\"b1\" style=\"width: 100px;height: 60px\" type=\"button\" value=\"点击开始\">\r\n    <input id=\"b2\" style=\"width: 100px;height: 60px\" type=\"button\" value=\"点击停止\" disabled>\r\n</body>\r\n</html>\r\n```\r\n\r\n\r\n\r\n### 5. 插件 ： 增强JQuery的功能\r\n\r\n1. 实现方式：\r\n\r\n   1. $.fn.extend(object)\r\n\r\n      * 增强通过Jquery获取的对象的功能 $(\"#id\")\r\n\r\n      ```html\r\n      <script>\r\n              $.fn.extend({\r\n                  // 定义了一个check()方法，所有的js对象都可以调用该方法\r\n                  check:function () {\r\n                      // 让复选框选中\r\n                      this.prop(\"checked\",true);\r\n                  },\r\n                  uncheck:function () {\r\n                      // 让复选框不选中\r\n                      this.prop(\"checked\",false);\r\n                  }\r\n      \r\n              })\r\n              $(function () {\r\n                  $(\"#btn-check\").click(function () {\r\n                      // 获取复选框对象\r\n                      $(\"input[type=\'checkbox\']\").check();\r\n                  })\r\n                  $(\"#btn-uncheck\").click(function () {\r\n                      $(\"input[type=\'checkbox\']\").uncheck();\r\n                  })\r\n              })\r\n          </script>\r\n      </head>\r\n      <body>\r\n          <input id=\"btn-check\" type=\"button\" value=\"点击选中复选框\" onclick=\"checkFn()\">\r\n          <input id=\"btn-uncheck\" type=\"button\" value=\"点击取消复选框选中\" onclick=\"uncheckFn()\">\r\n          <br/>\r\n          <input type=\"checkbox\" value=\"football\">足球\r\n          <input type=\"checkbox\" value=\"basketball\">篮球\r\n          <input type=\"checkbox\" value=\"volleyball\">排球\r\n      </body>\r\n      ```\r\n\r\n      \r\n\r\n   2. $.extend(object)\r\n\r\n      * 增强JQuery对象自身的功能 $/JQuery\r\n\r\n      ```html\r\n          <script type=\"text/javascript\">\r\n              //对全局方法扩展2个方法，扩展min方法：求2个值的最小值；扩展max方法：求2个值最大值\r\n              $.extend({\r\n                  //求两个数中的较大者\r\n                  max:function (a,b) {\r\n                      return a>b?a:b;\r\n                  },\r\n                  //求两个数中的较小者\r\n                  min:function (a,b) {\r\n                      return a<b?a:b;\r\n                  }\r\n              })\r\n      \r\n              $(function () {\r\n                  var max = $.max(10,11);\r\n                  alert(max);\r\n      \r\n                  var min = $.min(8,9);\r\n                  alert(min);\r\n              })\r\n          </script>\r\n      ```\r\n\r\n# 二十七、AJAX\r\n\r\n## 1. 概念：\r\n\r\n![image-20210907113124886](cloudDisk/markdown/JavaWeb笔记.assets/image-20210907113124886.png)\r\n\r\n* ASynchronous JavaScript And XML 异步的javaScript 和 XML\r\n\r\n* 异步和同步：客户端和服务器端相互通信的基础上\r\n\r\n  * 客户端必须等待服务器端的响应。再等待的期间客户端不能做其他操作\r\n  * 客户端不需要等待服务器端的响应。再服务器端处理请求的过程中，客户端可以进行其他的操作\r\n\r\n  Ajax 在浏览器与 Web 服务器之间使用异步数据传输（HTTP 请求），这样就可使网页从服务器请求少量的信息，而不是整个页面。\r\n\r\n  提升用户体验\r\n\r\n## 2. 实现方式：\r\n\r\n### 1）原生的JS实现方式（了解）\r\n\r\n```java\r\n@WebServlet(\"/AjaxServlet\")\r\npublic class AjaxServlet extends HttpServlet {\r\n    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\r\n        String username = request.getParameter(\"username\");\r\n        System.out.println(username);\r\n        try {\r\n            Thread.sleep(5000);\r\n        } catch (InterruptedException e) {\r\n        }\r\n        response.getWriter().write(\"hello: \" + username);\r\n    }\r\n```\r\n\r\n```html\r\n <script src=\"jq/jquery-3.3.1.min.js\"></script>\r\n    <script>\r\n        $(function () {\r\n            $(\"input\").click(function () {\r\n                var xhttp = new XMLHttpRequest();\r\n                if (window.XMLHttpRequest) {\r\n                    // 用于现代浏览器的代码\r\n                    xhttp = new XMLHttpRequest();\r\n                } else {\r\n                    // 应对老版本 IE 浏览器的代码\r\n                    xhttp = new ActiveXObject(\"Microsoft.XMLHTTP\");\r\n                }\r\n                // 建立连接\r\n                /*\r\n                * 参数：\r\n                * 1.请求方式：GET、POST\r\n                *   * get方式，请求参数在URL后边拼接。send方法为空参\r\n                *   * post方式，请求参数在send方法中定义\r\n                * 2.请求的URL：\r\n                * 3. 同步或异步请求：true（异步） 或 false（同步）\r\n                * */\r\n                xhttp.open(\"GET\", \"/AjaxServlet?username=tony\", true);\r\n                // 发送请求\r\n                xhttp.send();\r\n                // 接收并处理来自服务器的响应结果\r\n                // 获取方式：xmlhttp.responseText\r\n                // 什么时候获取？当服务器响应成功后获取\r\n                // 当xmlhttp对象的就绪状态改变时，触发事件onreadystatechange\r\n                xhttp.onreadystatechange = function () {\r\n                    // 判断readyState就绪状态是否为4，判断status响应状态码是否为200\r\n                    if (xhttp.readyState==4 && xhttp.status==200){\r\n                        // 获取服务器的响应结果\r\n                        var responseTest = xhttp.responseText;\r\n                        alert(responseTest)\r\n                    }\r\n                }\r\n            })\r\n        })\r\n    </script>\r\n</head>\r\n<body>\r\n    <input type=\"button\" value=\"发送ajax请求\">\r\n    <input type=\"text\">\r\n```\r\n\r\n\r\n\r\n### 2）JQuery实现方式\r\n\r\n#### 1. $.ajax()\r\n\r\n* 语法：$.ajax({键值对});\r\n\r\n```javascript\r\n$.ajax({\r\n    url : \"/AjaxServlet\",\r\n    type : \"POST\",\r\n    data : {\"username\" : \"jack\", \"age\" : 23},\r\n    success : function (data) {\r\n        alert(data)\r\n    }, // 响应成功后，回调函数\r\n    error : function () {\r\n        alert(\"出错了。。。\")\r\n    }, // 表示如果请求响应出现错误，会执行的回调函数\r\n    dataType : \"text\"// 设置接收到的响应数据的格式\r\n})\r\n```\r\n\r\n\r\n\r\n#### 2. $.get() : 发送get请求\r\n\r\n* 参数：\r\n  * url ：请求路径\r\n  * data ： 请求参数\r\n  * callback ： 回调函数\r\n  * type ： 响应类型\r\n\r\n```html\r\n    <script>\r\n        function fun() {\r\n            $.get(\"/AjaxServlet\",{username:\"rose\"},function (data) {\r\n                alert(data);\r\n            },\"text\")\r\n        }\r\n    </script>\r\n```\r\n\r\n\r\n\r\n#### 3. $.post() ： 发送post请求\r\n\r\n# 二十八、JSON\r\n\r\n## 1. 概念：\r\n\r\n* JavaScript Object Notation    JavaScript对象表示法\r\n\r\n  Person p = new Person();\r\n\r\n  p.setName(\"张三\");\r\n\r\n  p.setAge(23);\r\n\r\n  p.setGender(\"男\");\r\n\r\n  var p = {\"name\":\"张三\",\"age\":23,\"gender\":\"男\"}\r\n\r\n* json 现在多用于存储和交换文本信息的语法\r\n\r\n* 进行数据的传输\r\n\r\n* JSON 比 XML 更小、更快，更易于解析。\r\n\r\n## 2. 语法\r\n\r\n### 1）基本规则\r\n\r\n* 数据在名称/值对中：json数据是由键值对构成的\r\n  * 键用引号（单引都行）引起来，也可以不使用引号\r\n  * 值的取值类型：\r\n    1. 数字（整数或浮点数）\r\n    2. 字符串（在双引号中）\r\n    3. 逻辑值（true 或 false）\r\n    4. 数组（在方括号中）{\"persons\":[{},{}]}\r\n    5. 对象（在花括号中）{\"address\":{\"province\":\"陕西\"...}}\r\n    6. null\r\n* 数据由逗号分隔：多个键值对由逗号分隔\r\n* 花括号保存对象：使用{}定义json格式\r\n* 方括号保存数组：[]\r\n\r\n### 2）获取数据：\r\n\r\n1. json对象.键名\r\n2. json对象.[\"键名\"]\r\n3. 数组对象[索引]\r\n\r\n```html\r\n <script>\r\n        var person = {\"name\":\"张三\", \"age\":23, \"gender\":true};\r\n        var ps = [{\"name\":\"张三\", \"age\":23, \"gender\":true},\r\n            {\"name\":\"李四\", \"age\":28, \"gender\":true},\r\n            {\"name\":\"王五\", \"age\":25, \"gender\":false}\r\n        ];\r\n\r\n        // 获取person对象中的所有键和值\r\n        // for in 循环\r\n      /*  for(var key in person){\r\n            alert(key + \" : \" + person[key]);\r\n        }\r\n*/\r\n        // 获取ps中的所有值\r\n        for (var i=0; i < ps.length; i++){\r\n            var p = ps[i]\r\n            for(var key in p) {\r\n                alert(key + \" : \" + p[key]);\r\n            }\r\n        }\r\n\r\n    </script>\r\n```\r\n\r\n### 3）JSON数据和Java对象的相互转换\r\n\r\n![image-20210907143519326](cloudDisk/markdown/JavaWeb笔记.assets/image-20210907143519326.png)\r\n\r\n* JSON解析器\r\n  * 常见的解析器：Jsonlib，Gson，fastjson，jackson。\r\n\r\n#### 1. JSON转换为Java对象\r\n\r\n1. 导入jackson的相关jar包 ：下载地址：https://repo1.maven.org/maven2/com/fasterxml/jackson/\r\n2. 创建jackson核心对象  ObjectMapper\r\n3. 调用ObjectMapper的相关方法进行转换\r\n\r\n```java\r\npublic class Person {\r\n    private String name;\r\n    private int age;\r\n    private String gender;\r\n    @JsonFormat(pattern=\"yyyy-mm-dd\")\r\n    private Date date;\r\n```\r\n\r\n\r\n\r\n```java\r\n        // 初始化JSON字符串\r\n        String json = \"{\\\"name\\\":\\\"张三\\\",\\\"age\\\":23,\\\"gender\\\":\\\"男\\\",\\\"date\\\":\\\"2021-09-07\\\"}\";\r\n        // 转化\r\n        ObjectMapper mapper = new ObjectMapper();\r\n        Person person = mapper.readValue(json, Person.class);\r\n        System.out.println(person); // Person{name=\'张三\', age=23, gender=\'男\', date=Thu Jan 07 08:09:00 CST 2021}\r\n    \r\n```\r\n\r\n\r\n\r\n#### 2. Java对象转化为JSON对象\r\n\r\n使用步骤：\r\n\r\n1. 导入jackson的相关jar包 ：下载地址：https://repo1.maven.org/maven2/com/fasterxml/jackson/\r\n\r\n2. 创建jackson核心对象  ObjectMapper\r\n\r\n3. 调用ObjectMapper的相关方法进行转换\r\n\r\n   1. 转化方法：\r\n      * writerValue(参数1, obj)\r\n            参数1：\r\n                File ：将obj对象转换为JSON字符串，并保存到指定文件中\r\n                Writer ： 将obj对象转换为JSON字符串，并将数据填充到字符输出流中\r\n                OutputStream ： 将obj对象转换为JSON字符串，并将数据填充到字符节输出流中\r\n      * writeValueAsString(obj) : 将对象转化为json字符串\r\n\r\n   2. 注解：\r\n      1. @JsonIgnore : 排除属性\r\n      2. @JsonFormat ： 属性值的格式化\r\n\r\n   ```java\r\n       @JsonFormat(pattern=\"yyyy-mm-dd\")\r\n       private Date date;\r\n   ```\r\n\r\n   ```java\r\n           // 1. 创建Person对象\r\n   ...\r\n           // 2. 转化\r\n           ObjectMapper mapper = new ObjectMapper();\r\n           String json = mapper.writeValueAsString(p);\r\n           // 没加@JsonFormat(pattern=\"yyyy-mm-dd\") 时：\r\n   //        System.out.println(json); // {\"name\":\"张三\",\"age\":23,\"gender\":\"男\",\"date\":1630998453743}\r\n           // 加了@JsonFormat(pattern=\"yyyy-mm-dd\") 时：\r\n           System.out.println(json); // {\"name\":\"张三\",\"age\":23,\"gender\":\"男\",\"date\":\"2021-09-07\"}\r\n   ```\r\n\r\n   3. 复杂java对象转化\r\n      1. List ： 数组\r\n      2. Map ： 对象格式一致\r\n\r\n## 案例：校验用户名是否存在\r\n\r\n### 1. 服务器响应数据，在客户端使用时，要想当作json数据格式使用\r\n\r\n1. $.get(type) : 将最后一个参数type指定位\"json\"\r\n\r\n2. 在服务i其端设置MIME类型\r\n\r\n   ```java\r\n   response.setContentType(\"application/json;charset=utf-8\");\r\n   ```\r\n\r\n### 2. 代码：\r\n\r\n```html\r\n    <script>\r\n        $(function () {\r\n            // 给username绑定blur事件\r\n            $(\"#username\").blur(function () {\r\n                // 获取username文本框值\r\n                var username = $(\"#username\").val();\r\n                // 发送ajax请求\r\n                // 期望服务器响应回的数据格式：{\"userExsit\":true,\"msg\":\"此用户名太受欢迎，请更换一个\"}\r\n                                    // {\"userExsit\":false,\"msg\":\"用户名可用\"}\r\n                $.get(\"/findUserServlet\",{username:username},function (data) {\r\n                    // data = JSON.parse(data);\r\n                    if (data.userExsit){\r\n                        // 存在\r\n                        $(\"#span\").text(data.msg);\r\n                        $(\"#span\").css(\"color\",\"red\");\r\n                    }else {\r\n                        // 不存在\r\n                        $(\"#span\").text(data.msg);\r\n                        $(\"#span\").css(\"color\",\"green\");\r\n                    }\r\n                })\r\n            })\r\n        })\r\n    </script>\r\n</head>\r\n<body>\r\n    <form>\r\n        <input type=\"text\" id=\"username\" name=\"username\" placeholder=\"请输入用户名\"><span id=\"span\"></span><br>\r\n        <input type=\"password\" id=\"password\" name=\"password\" placeholder=\"请输入密码\"><br>\r\n        <input type=\"submit\" value=\"注册\">\r\n    </form>\r\n```\r\n\r\n```java\r\n@WebServlet(\"/findUserServlet\")\r\npublic class FindUserServlet extends HttpServlet {\r\n    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\r\n        request.setCharacterEncoding(\"utf-8\");\r\n        String username = request.getParameter(\"username\");\r\n        ObjectMapper mapper = new ObjectMapper();\r\n        Map<String,Object> map = new HashMap<String,Object>();\r\n        response.setContentType(\"application/json;charset=utf-8\");\r\n        if (\"tom\".equals(username)){\r\n            // 用户名存在\r\n            map.put(\"userExsit\",true);\r\n            map.put(\"msg\",\"此用户名太受欢迎，请更换一个\");\r\n            response.getWriter().write(mapper.writeValueAsString(map));\r\n        }else {\r\n            // 用户名不存在\r\n            map.put(\"userExsit\",false);\r\n            map.put(\"msg\",\"用户名可用\");\r\n            System.out.println(mapper.writeValueAsString(map));\r\n            response.getWriter().write(mapper.writeValueAsString(map));\r\n        }\r\n    }\r\n\r\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\r\n        this.doPost(request, response);\r\n    }\r\n```\r\n\r\n# 二十八、redis\r\n\r\n## 28.1 概念\r\n\r\n![image-20210908142033749](cloudDisk/markdown/JavaWeb笔记.assets/image-20210908142033749.png)\r\n\r\n1.1.什么是NOSQL\r\n            NoSQL(NoSQL = Not Only SQL)，意即“不仅仅是SQL”，是一项全新的数据库理念，泛指非关系型的数据库。\r\n            随着互联网web2.0网站的兴起，传统的关系数据库在应付web2.0网站，特别是超大规模和高并发的SNS类型的web2.0纯动态网站已经显得力不从心，暴露了很多难以克服的问题，而非关系型的数据库则由于其本身的特点得到了非常迅速的发展。NoSQL数据库的产生就是为了解决大规模数据集合多重数据种类带来的挑战，尤其是大数据应用难题。\r\n\r\n​        1.1.1.    NOSQL和关系型数据库比较\r\n​            优点：\r\n​                1）成本：nosql数据库简单易部署，基本都是开源软件，不需要像使用oracle那样花费大量成本购买使用，相比关系型数据库价格便宜。\r\n​                2）查询速度：nosql数据库将数据存储于缓存之中，关系型数据库将数据存储在硬盘中，自然查询速度远不及nosql数据库。\r\n​                3）存储数据的格式：nosql的存储格式是key,value形式、文档形式、图片形式等等，所以可以存储基础类型以及对象或者是集合等各种格式，而数据库则只支持基础类型。\r\n​                4）扩展性：关系型数据库有类似join这样的多表查询机制的限制导致扩展很艰难。\r\n\r\n​            缺点：\r\n​                1）维护的工具和资料有限，因为nosql是属于新的技术，不能和关系型数据库10几年的技术同日而语。\r\n​                2）不提供对sql的支持，如果不支持sql这样的工业标准，将产生一定用户的学习和使用成本。\r\n​                3）不提供关系型数据库对事务的处理。\r\n\r\n​        1.1.2.    非关系型数据库的优势：\r\n​            1）性能NOSQL是基于键值对的，可以想象成表中的主键和值的对应关系，而且不需要经过SQL层的解析，所以性能非常高。\r\n​            2）可扩展性同样也是因为基于键值对，数据之间没有耦合性，所以非常容易水平扩展。\r\n\r\n​        1.1.3.    关系型数据库的优势：\r\n​            1）复杂查询可以用SQL语句方便的在一个表以及多个表之间做非常复杂的数据查询。\r\n​            2）事务支持使得对于安全性能很高的数据访问要求得以实现。对于这两类数据库，对方的优势就是自己的弱势，反之亦然。\r\n\r\n​        1.1.4.    总结\r\n​            关系型数据库与NoSQL数据库并非对立而是互补的关系，即通常情况下使用关系型数据库，在适合使用NoSQL的时候使用NoSQL数据库，\r\n​            让NoSQL数据库对关系型数据库的不足进行弥补。\r\n​            一般会将数据存储在关系型数据库中，在nosql数据库中备份存储关系型数据库的数据\r\n\r\n​    1.2.主流的NOSQL产品\r\n​        •    键值(Key-Value)存储数据库\r\n​                相关产品： Tokyo Cabinet/Tyrant、Redis、Voldemort、Berkeley DB\r\n​                典型应用： 内容缓存，主要用于处理大量数据的高访问负载。 \r\n​                数据模型： 一系列键值对\r\n​                优势： 快速查询\r\n​                劣势： 存储的数据缺少结构化\r\n​        •    列存储数据库\r\n​                相关产品：Cassandra, HBase, Riak\r\n​                典型应用：分布式的文件系统\r\n​                数据模型：以列簇式存储，将同一列数据存在一起\r\n​                优势：查找速度快，可扩展性强，更容易进行分布式扩展\r\n​                劣势：功能相对局限\r\n​        •    文档型数据库\r\n​                相关产品：CouchDB、MongoDB\r\n​                典型应用：Web应用（与Key-Value类似，Value是结构化的）\r\n​                数据模型： 一系列键值对\r\n​                优势：数据结构要求不严格\r\n​                劣势： 查询性能不高，而且缺乏统一的查询语法\r\n​        •    图形(Graph)数据库\r\n​                相关数据库：Neo4J、InfoGrid、Infinite Graph\r\n​                典型应用：社交网络\r\n​                数据模型：图结构\r\n​                优势：利用图结构相关算法。\r\n​                劣势：需要对整个图做计算才能得出结果，不容易做分布式的集群方案。\r\n​    1.3 什么是Redis\r\n​        Redis是用C语言开发的一个开源的高性能键值对（key-value）数据库，官方提供测试数据，50个并发执行100000个请求,读的速度是110000次/s,写的速度是81000次/s ，且Redis通过提供多种键值数据类型来适应不同场景下的存储需求，目前为止Redis支持的键值数据类型如下：\r\n​            1) 字符串类型 string\r\n​            2) 哈希类型 hash\r\n​            3) 列表类型 list\r\n​            4) 集合类型 set\r\n​            5) 有序集合类型 sortedset\r\n​        1.3.1 redis的应用场景\r\n​            •    缓存（数据查询、短连接、新闻内容、商品内容等等）\r\n​            •    聊天室的在线好友列表\r\n​            •    任务队列。（秒杀、抢购、12306等等）\r\n​            •    应用排行榜\r\n​            •    网站访问统计\r\n​            •    数据过期处理（可以精确到毫秒\r\n​            •    分布式集群架构中的session分离\r\n\r\n## 28.2 下载安装 \r\n\r\n1. 官网：https://redis.io/\r\n2. 中文网：http://www.redis.net.cn/\r\n3. https://www.runoob.com/redis/redis-install.html\r\n4. 解压直接可以使用：\r\n   * redis.windows.conf ： 配置文件\r\n   * redis-cli.exe ： redis客户端\r\n   * redis-server.exe ： redis服务器端\r\n\r\n## 28.3 命令操作\r\n\r\n### 1. redis的数据结构：\r\n\r\n* redis存储的是：key，value格式的数据，其中key都是字符串，value有5种不同的数据结构\r\n\r\n  * value的数据结构：\r\n\r\n    | 类型     |           | 备注                         |\r\n    | -------- | --------- | ---------------------------- |\r\n    | 字符串   | string    | String                       |\r\n    | 哈希     | hash      | map格式                      |\r\n    | 列表     | list      | linkedlist格式。支持重复元素 |\r\n    | 集合     | set       | 不允许重复元素               |\r\n    | 有序集合 | sortedset | 不允许重复元素，且元素有顺序 |\r\n\r\n### 2. 字符串 String\r\n\r\n1. 存储：set key value\r\n\r\n   ```sql\r\n   127.0.0.1:6379> set username zhangsan\r\n   OK\r\n   ```\r\n\r\n2. 获取：get key\r\n\r\n   ```sql\r\n   127.0.0.1:6379> get username\r\n   \"zhangsan\"\r\n   ```\r\n\r\n3. 删除：del key\r\n\r\n   ```sql\r\n   127.0.0.1:6379> del zhangsan\r\n   (integer) 0\r\n   ```\r\n\r\n### 3. 哈希类型 hash\r\n\r\n1. 存储：hash key field value\r\n\r\n   ```sql\r\n   127.0.0.1:6379> hset myhash username lisi\r\n   (integer) 1\r\n   ```\r\n\r\n   ```sql\r\n   127.0.0.1:6379> hset myhash password 123\r\n   (integer) 1\r\n   ```\r\n\r\n2. 获取：\r\n\r\n   * hget key field : 获取指定的field对应的值\r\n\r\n     ```sql\r\n     127.0.0.1:6379> hget myhash username\r\n     \"lisi\"\r\n     ```\r\n\r\n   * hgetall key : 获取所有的field和值\r\n\r\n     ```sql\r\n     127.0.0.1:6379> hgetall myhash\r\n     1) \"username\"\r\n     2) \"lisi\"\r\n     3) \"password\"\r\n     4) \"123\"\r\n     ```\r\n\r\n3. 删除：hdel key field\r\n\r\n   ```sql\r\n   127.0.0.1:6379> hdel myhash username\r\n   (integer) 1\r\n   ```\r\n\r\n### 4. 列表类型 list ：\r\n\r\n* 可以添加一个元素到列表的头部（左边） 或者尾部（右边）\r\n\r\n![image-20210908150633377](cloudDisk/markdown/JavaWeb笔记.assets/image-20210908150633377.png)\r\n\r\n1. 添加：\r\n\r\n   1. lpush key value : 将元素加入列表左边\r\n\r\n      ```sql\r\n      127.0.0.1:6379> lpush myList a\r\n      (integer) 1\r\n      127.0.0.1:6379> lpush myList b\r\n      (integer) 2\r\n      ```\r\n\r\n   2. rpush key value : 将元素加入列表右边\r\n\r\n      ```sql\r\n      127.0.0.1:6379> rpush myList c\r\n      (integer) 3\r\n      ```\r\n\r\n2. 获取：\r\n\r\n   * lrangekey start end : 获取获取\r\n\r\n     ```sql\r\n     127.0.0.1:6379> lrange myList 0 -1\r\n     1) \"b\"\r\n     2) \"a\"\r\n     3) \"c\"\r\n     ```\r\n\r\n3. 删除：\r\n\r\n   * lpop key : 删除列表最左边的元素，并将元素返回\r\n\r\n     ```sql\r\n     127.0.0.1:6379> lpop myList\r\n     \"b\"\r\n     127.0.0.1:6379> lrange myList 0 -1\r\n     1) \"a\"\r\n     2) \"c\"\r\n     ```\r\n\r\n   * rpop key : 删除列表最右边的元素，并将元素返回\r\n\r\n     ```sql\r\n     127.0.0.1:6379> rpop myList\r\n     \"c\"\r\n     127.0.0.1:6379> lrange myList 0 -1\r\n     1) \"a\"\r\n     ```\r\n\r\n### 5. 集合类型 set\r\n\r\n* 不允许重复元素\r\n\r\n1. 存储：sadd key value\r\n\r\n   ```sql\r\n   127.0.0.1:6379> sadd myset a\r\n   (integer) 1\r\n   127.0.0.1:6379> sadd myset a\r\n   (integer) 0\r\n   ```\r\n\r\n2. 获取：smembers key : 获取set集合种所有元素\r\n\r\n   ```sql\r\n   127.0.0.1:6379> smembers myset\r\n   1) \"a\"\r\n   ```\r\n\r\n   ```sql\r\n   127.0.0.1:6379> sadd myset b c d\r\n   (integer) 3\r\n   127.0.0.1:6379> smembers myset\r\n   1) \"c\"\r\n   2) \"b\"\r\n   3) \"d\"\r\n   4) \"a\"\r\n   ```\r\n\r\n3. 删除：srem key value : 删除set集合中的某个元素\r\n\r\n   ```sql\r\n   127.0.0.1:6379> srem myset a\r\n   (integer) 1\r\n   127.0.0.1:6379> smembers myset\r\n   1) \"c\"\r\n   2) \"b\"\r\n   3) \"d\"\r\n   ```\r\n\r\n### 6. 有序集合 sortedset \r\n\r\n* 不允许重复元素，且元素有序\r\n\r\n1. 存储：zadd key score value\r\n\r\n   ```sql\r\n   127.0.0.1:6379> zadd mysort 60 zhangsan\r\n   (integer) 1\r\n   127.0.0.1:6379> zadd mysort 50 lisi\r\n   (integer) 1\r\n   127.0.0.1:6379> zadd mysort 80 wangwu\r\n   (integer) 1\r\n   ```\r\n\r\n2. 获取：zrange key end\r\n\r\n   ```sql\r\n   127.0.0.1:6379> zrange mysort 0 -1\r\n   1) \"lisi\"\r\n   2) \"zhangsan\"\r\n   3) \"wangwu\"\r\n   ```\r\n\r\n   ```sql\r\n   127.0.0.1:6379> zrange mysort 0 -1 withscores\r\n   1) \"lisi\"\r\n   2) \"50\"\r\n   3) \"zhangsan\"\r\n   4) \"60\"\r\n   5) \"wangwu\"\r\n   6) \"80\"\r\n   ```\r\n\r\n3. 删除：zren key value\r\n\r\n   ```sql\r\n   127.0.0.1:6379> zrem mysort lisi\r\n   (integer) 1\r\n   127.0.0.1:6379> zrange mysort 0 -1 withscores\r\n   1) \"zhangsan\"\r\n   2) \"60\"\r\n   3) \"wangwu\"\r\n   4) \"80\"\r\n   ```\r\n\r\n### 7. 通用命令\r\n\r\n1. keys * : 查询所有的键\r\n\r\n   ```sql\r\n   127.0.0.1:6379> keys *\r\n   1) \"username\"\r\n   2) \"myhash\"\r\n   3) \"myList\"\r\n   4) \"myset\"\r\n   5) \"mysort\"\r\n   6) \"mylist\"\r\n   7) \"mylish\"\r\n   ```\r\n\r\n2. type key ：获取键对应的value的类型\r\n\r\n   ```sql\r\n   127.0.0.1:6379> type username\r\n   string\r\n   127.0.0.1:6379> type myList\r\n   list\r\n   ```\r\n\r\n3. del key ： 删除指定的key value\r\n\r\n   ```sql\r\n   127.0.0.1:6379> del mylish\r\n   (integer) 1\r\n   127.0.0.1:6379> del mylist\r\n   (integer) 1\r\n   127.0.0.1:6379> keys *\r\n   1) \"username\"\r\n   2) \"myhash\"\r\n   3) \"myList\"\r\n   4) \"myset\"\r\n   5) \"mysort\"\r\n   ```\r\n\r\n## 28.4 持久化操作\r\n\r\n1. redis是一个内存数据库，当redis服务器重启，电脑重启，数据会丢失，我们可以将reids内存中的数据持久化保存到硬盘的文件中。\r\n\r\n2. redis持久化机制\r\n\r\n   1. RDB：默认方式，不需要进行配置，默认就可以使用这种机制\r\n\r\n      * 在一定的间隔时间中，检测key的变化情况，然后持久化数据\r\n\r\n      1. 编辑redis.windows.conf文件\r\n\r\n         ```conf\r\n         #   after 900 sec (15 min) if at least 1 key changed\r\n         save 900 1\r\n         #   after 300 sec (5 min) if at least 10 keys changed\r\n         save 300 10\r\n         #   after 60 sec if at least 10000 keys changed\r\n         save 60 10000\r\n         ```\r\n\r\n      2. 重启服务器并指定配置文件\r\n\r\n         ```cmd\r\n         D:\\Redis-x64-5.0.10>redis-server.exe redis.windows.conf\r\n         ```\r\n\r\n   2. AOF：日志记录的方式，可以记录每一条命令的操作。可以每一次命令操作后，持久化数据\r\n\r\n      1. 编辑redis.windows.conf文件\r\n\r\n         appendonly no (关闭aof) --> appendonly yes (开启aof)\r\n\r\n         ```\r\n         # appendfsync always : 每一次操作都进行持久化\r\n         appendfsync everysec : 每隔一秒进行一次持久化\r\n         # appendfsync no     : 不进行持久化\r\n         ```\r\n\r\n## 28.5 使用Java客户端操作redis\r\n\r\n* jedis：一款java操作的jar包\r\n\r\n### 1. 使用步骤：\r\n\r\n#### 1.1 获取连接\r\n\r\nJedis jedis = new Jedis(\"localhost\",6379);\r\n\r\n#### 1.2 操作\r\n\r\njedis.set(\"username\",\"zhangsan\");\r\n\r\n#### 1.3 关闭连接\r\n\r\n### 2. Jedis操作各种redis中的数据结构\r\n\r\n#### 1）字符串类型 string\r\n\r\n* set\r\n* get\r\n\r\n```java\r\n    public void test01(){\r\n        // 1. 获取连接\r\n        Jedis jedis = new Jedis(\"localhost\",6379);\r\n        // 2. 操作\r\n        jedis.set(\"username\",\"zhangsan\");\r\n        // 获取\r\n        String username = jedis.get(\"username\");\r\n        System.out.println(username);\r\n        // 可以使用setex()方法存储可以指定过期时间的 key value\r\n        jedis.setex(\"activecode\",20,\"hehe\");\r\n        // 3. 关闭连接\r\n```\r\n\r\n```cmd\r\n127.0.0.1:6379> keys *\r\n1) \"activecode\"\r\n2) \"username\"\r\n127.0.0.1:6379> keys *\r\n1) \"username\"\r\n```\r\n\r\n#### 2) 哈希类型 hash\r\n\r\n* hset\r\n* hget\r\n\r\n```java\r\n    @Test\r\n    public void test01(){\r\n        // 1. 获取连接\r\n        Jedis jedis = new Jedis(\"localhost\",6379);\r\n        // 2. 操作\r\n        // 存储\r\n        jedis.hset(\"user\",\"name\",\"lisi\");\r\n        jedis.hset(\"user\",\"age\",\"23\");\r\n        jedis.hset(\"user\",\"gender\",\"male\");\r\n\r\n        // 获取hash\r\n        String name = jedis.hget(\"user\", \"name\");\r\n        System.out.println(name);\r\n        // 获取hash的所有map中的数据\r\n        Map<String, String> user = jedis.hgetAll(\"user\");\r\n        Set<String> set = user.keySet();\r\n        for (String key :\r\n                set) {\r\n            String value = user.get(key);\r\n            System.out.println(key +\" : \"+ value);\r\n        }\r\n        // 3. 关闭连接\r\n```\r\n\r\n```\r\n\"C:\\Program Files\\Java\\jdk-11.0.11\\bin\\java.exe\" -rsion5 -junit4 com.tony.jdedis.test.JedisTest,test01\r\nlisi\r\ngender : male\r\nname : lisi\r\nage : 23\r\n\r\n进程已结束，退出代码 0\r\n```\r\n\r\n#### 3) 列表类型 list\r\n\r\n* lpush / rpush\r\n* lpop / rpop\r\n\r\n```java\r\n    @Test\r\n    public void test02(){\r\n        // 1. 获取连接\r\n        Jedis jedis = new Jedis(\"localhost\",6379);\r\n        // 2. 操作\r\n        // 存储 a b c c b a\r\n        jedis.lpush(\"mylist\",\"a\",\"b\",\"c\"); // 从左边存\r\n        jedis.rpush(\"mylist\",\"a\",\"b\",\"c\"); // 从右边存\r\n        // 获取 范围获取\r\n        List<String> mylist = jedis.lrange(\"mylist\", 0, -1);\r\n        System.out.println(mylist);\r\n        // list 弹出\r\n        String element1 = jedis.lpop(\"mylist\");\r\n        System.out.println(element1);\r\n\r\n        String element2 = jedis.rpop(\"mylist\");\r\n        System.out.println(element2);\r\n\r\n        List<String> mylist1 = jedis.lrange(\"mylist\", 0, -1);\r\n        System.out.println(mylist1);\r\n        // 3. 关闭连接\r\n    }\r\n```\r\n\r\n```\r\n[c, b, a, a, b, c]\r\nc\r\nc\r\n[b, a, a, b]\r\n\r\n进程已结束，退出代码 0\r\n```\r\n\r\n#### 4) 集合类型 set\r\n\r\n* sadd\r\n\r\n```java\r\n    @Test\r\n    public void test03(){\r\n        // 1. 获取连接\r\n        Jedis jedis = new Jedis(\"localhost\",6379);\r\n        // 2. 操作\r\n        // 存储\r\n        jedis.sadd(\"myset\",\"java\",\"php\",\"python\");\r\n\r\n        // 获取\r\n        Set<String> myset = jedis.smembers(\"myset\");\r\n        System.out.println(myset);\r\n        // 3. 关闭连接\r\n    }\r\n```\r\n\r\n```\r\n[python, java, php]\r\n\r\n进程已结束，退出代码 0\r\n```\r\n\r\n#### 5) 有序集合类型 sortedset\r\n\r\n* zadd\r\n\r\n```java\r\n    @Test\r\n    public void test04(){\r\n        // 1. 获取连接\r\n        Jedis jedis = new Jedis(\"localhost\",6379);\r\n        // 2. 操作\r\n        // 存储\r\n        jedis.zadd(\"mysortedset\",30,\"花鸟卷\");\r\n        jedis.zadd(\"mysortedset\",15,\"茨木童子\");\r\n        jedis.zadd(\"mysortedset\",2,\"酒吞童子\");\r\n\r\n        // sortedset 获取\r\n        Set<String> mysortedset = jedis.zrange(\"mysortedset\", 0, -1);\r\n        System.out.println(mysortedset);\r\n        // 3. 关闭连接\r\n    }\r\n```\r\n\r\n```\r\n[酒吞童子, 茨木童子, 花鸟卷]\r\n\r\n进程已结束，退出代码 0\r\n```\r\n\r\n### 3. jedis 连接池：JedisPool\r\n\r\n* 使用：\r\n\r\n  1. 创建JedisPool连接池对象\r\n  2. 调用方法 getResource()方法获取Jedis连接\r\n\r\n  ```java\r\n      @Test\r\n      public void test05(){\r\n          // 0. 创建一个配置对象\r\n          JedisPoolConfig config = new JedisPoolConfig();\r\n          config.setMaxActive(500);\r\n          config.setMaxIdle(10);\r\n  \r\n          // 1. 创建Jedis连接池对象\r\n          JedisPool jedisPool = new JedisPool(\"localhost\",6379);\r\n  \r\n          // 2. 获取连接\r\n          Jedis jedis = jedisPool.getResource();\r\n  \r\n          // 3. 使用\r\n          jedis.set(\"username\",\"lisi\");\r\n          String username = jedis.get(\"username\");\r\n          System.out.println(username);\r\n      }\r\n  ```\r\n\r\n  ```\r\n  lisi\r\n  \r\n  进程已结束，退出代码 0\r\n  ```\r\n\r\n  ![image-20210909102736540](cloudDisk/markdown/JavaWeb笔记.assets/image-20210909102736540.png)\r\n\r\n#### 提取工具类\r\n\r\n##### 1）jedis.properties\r\n\r\n```properties\r\nhost=127.0.0.1\r\nport=6379\r\nmaxTotal=50\r\nmaxIdle=10\r\n```\r\n\r\n##### 2) JedisPoolUtils\r\n\r\n```java\r\npackage com.tony.jdedis.util;\r\n\r\nimport redis.clients.jedis.Jedis;\r\nimport redis.clients.jedis.JedisPool;\r\nimport redis.clients.jedis.JedisPoolConfig;\r\n\r\nimport java.io.IOException;\r\nimport java.io.InputStream;\r\nimport java.util.Properties;\r\n\r\npublic class JedisPoolUtils {\r\n    private static JedisPool jedisPool;\r\n    static {\r\n        // 读取配置文件\r\n        InputStream is = JedisPoolUtils.class.getClassLoader().getResourceAsStream(\"jedis.properties\");\r\n        // 创建Properties对象\r\n        Properties prop = new Properties();\r\n        try {\r\n            // 关联文件\r\n            prop.load(is);\r\n        } catch (IOException e) {\r\n            e.printStackTrace();\r\n        }\r\n        // 获取数据，设置到JedisPoolConfig中\r\n        JedisPoolConfig config = new JedisPoolConfig();\r\n        config.setMaxActive(Integer.parseInt(prop.getProperty(\"maxTotal\")));\r\n        config.setMaxIdle(Integer.parseInt(prop.getProperty(\"maxIdle\")));\r\n\r\n        // 初始化JedisPool\r\n        jedisPool = new JedisPool(config, prop.getProperty(\"host\"), Integer.parseInt(prop.getProperty(\"port\")));\r\n    }\r\n    public static Jedis getJedis(){\r\n        return jedisPool.getResource();\r\n    }\r\n}\r\n\r\n```\r\n\r\n##### 3) Test\r\n\r\n```java\r\n    @Test\r\n    public void test06(){\r\n        // 通过连接池工具类获取\r\n        Jedis jedis = JedisPoolUtils.getJedis();\r\n\r\n        // 3. 使用\r\n        jedis.set(\"hello\",\"world\");\r\n        String username = jedis.get(\"hello\");\r\n        System.out.println(username);\r\n    }\r\n```\r\n\r\n```\r\nworld\r\n\r\n进程已结束，退出代码 0\r\n```\r\n\r\n## 28.6 案例\r\n\r\n### 1. 案例需求：\r\n\r\n![image-20210909104356720](cloudDisk/markdown/JavaWeb笔记.assets/image-20210909104356720.png)\r\n\r\n1. 提供index.html页面，页面中有一个省份，下拉列表\r\n2. 当页面加载完成后，发送ajax请求，加载所有省份\r\n\r\n* 注意使用redis缓存一些**不经常发送变化的数据**。\r\n  * 数据库一旦发送改变，则需要更新缓存\r\n    * 数据库的表执行了：增删改的相关操作，需要将redis缓存数据清空，再次存入\r\n    * 在service对应的我增删改方法中，将redis数据删除。为防止查询redis缓存数据时，是没更新的。\r\n\r\n### 2. 环境搭建&代码编写\r\n\r\n![image-20210909124316426](cloudDisk/markdown/JavaWeb笔记.assets/image-20210909124316426.png)\r\n\r\n#### 1）数据库\r\n\r\n```mysql\r\nCREATE DATABASE day23; -- 创建数据库\r\nUSER day32; -- 使用数据库\r\nCREATE TABLE province( -- 创建表\r\n	id INT PRIMARY KEY AUTO_INCREMENT,\r\n	NAME VARCHAR(32) NOT NULL\r\n);\r\n-- 插入数据\r\nINSERT INTO province VALUES(NULL,\"北京\");\r\nINSERT INTO province VALUES(NULL,\"上海\");\r\nINSERT INTO province VALUES(NULL,\"江苏\");\r\nINSERT INTO province VALUES(NULL,\"浙江\");\r\n```\r\n\r\n\r\n\r\n#### 2) 一些配置文件\r\n\r\n```properties\r\n# druid.properties文件的配置\r\ndriverClassName=com.mysql.jdbc.Driver\r\nurl=jdbc:mysql://localhost:3306/day23\r\nusername=root\r\npassword=123\r\n# 初始化连接数量\r\ninitialSize=5\r\n# 最大连接数\r\nmaxActive=10\r\n# 最大超时时间\r\nmaxWait=3000\r\n```\r\n\r\n```properties\r\nhost=127.0.0.1\r\nport=6379\r\nmaxTotal=50\r\nmaxIdle=10\r\n```\r\n\r\n#### 3) 工具类 utils\r\n\r\n```java\r\npublic class DruidUtils {\r\n    static DataSource ds;\r\n    static {\r\n        try {\r\n            Properties prop = new Properties();\r\n            InputStream is = DruidUtils.class.getClassLoader().getResourceAsStream(\"druid.properties\");\r\n            prop.load(is);\r\n            ds = new DruidDataSourceFactory().createDataSource(prop);\r\n        } catch (IOException e) {\r\n            e.printStackTrace();\r\n        } catch (Exception e) {\r\n            e.printStackTrace();\r\n        }\r\n    }\r\n    public static DataSource getDataSouorce(){\r\n        return ds;\r\n    }\r\n}\r\n```\r\n\r\n```java\r\npublic class JedisPoolUtils {\r\n    private static JedisPool jedisPool;\r\n    static {\r\n        // 读取配置文件\r\n        InputStream is = JedisPoolUtils.class.getClassLoader().getResourceAsStream(\"jedis.properties\");\r\n        // 创建Properties对象\r\n        Properties prop = new Properties();\r\n        try {\r\n            // 关联文件\r\n            prop.load(is);\r\n        } catch (IOException e) {\r\n            e.printStackTrace();\r\n        }\r\n        // 获取数据，设置到JedisPoolConfig中\r\n        JedisPoolConfig config = new JedisPoolConfig();\r\n        config.setMaxActive(Integer.parseInt(prop.getProperty(\"maxTotal\")));\r\n        config.setMaxIdle(Integer.parseInt(prop.getProperty(\"maxIdle\")));\r\n\r\n        // 初始化JedisPool\r\n        jedisPool = new JedisPool(config, prop.getProperty(\"host\"), Integer.parseInt(prop.getProperty(\"port\")));\r\n    }\r\n    public static Jedis getJedis(){\r\n        return jedisPool.getResource();\r\n    }\r\n}\r\n```\r\n\r\n#### 4) domain > province\r\n\r\n```java\r\npublic class Province {\r\n    private int id;\r\n    private String name;\r\n    ...\r\n```\r\n\r\n#### 5)  数据库查询 ProvinceDaoImpl\r\n\r\n```java\r\npublic class ProvinceDaoImpl implements ProvinceDao {\r\n    private JdbcTemplate jdbcTemplate = new JdbcTemplate(DruidUtils.getDataSouorce());\r\n    @Override\r\n    public List<Province> findAll() {\r\n        String sql = \"select * from province\";\r\n        return jdbcTemplate.query(sql,new BeanPropertyRowMapper<Province>(Province.class));\r\n    }\r\n}\r\n```\r\n\r\n#### 6）service\r\n\r\n```java\r\npublic class ProvinceServiceImpl implements ProvinceService {\r\n    private ProvinceDao provinceDao = new ProvinceDaoImpl();\r\n    @Override\r\n    public List<Province> findAll() {\r\n        return provinceDao.findAll();\r\n    }\r\n\r\n    @Override\r\n    public String findAllJson() {\r\n        // 返回Json类型的字符串数据\r\n        // 先查看缓存，判断是否有数据\r\n        // 如果有：直接获取redis缓存内的数据，将Json类型的字符串数据返回\r\n        // 如果没有：首先查询mysql数据库，再将数据转化为Json字符串，存入redis缓存内\r\n        // 1. 查看缓存内数据\r\n        Jedis jedis = JedisPoolUtils.getJedis();\r\n        String province = jedis.get(\"province\");\r\n        if(province==null || \"\".equals(province)){\r\n            System.out.println(\"缓存内没有数据\");\r\n            // 2. 缓存内没数据\r\n            // 2.1 查询mysql数据库\r\n            List<Province> provinceList = provinceDao.findAll();\r\n            // 2.2 序列化为Json类型\r\n            ObjectMapper mapper = new ObjectMapper();\r\n            try {\r\n                // 直接赋值给province\r\n                province = mapper.writeValueAsString(provinceList);\r\n            } catch (JsonProcessingException e) {\r\n                e.printStackTrace();\r\n            }\r\n            // 2.3 存入redis缓存内\r\n            jedis.set(\"province\",province);\r\n        }else {\r\n            System.out.println(\"缓存内有数据\");\r\n            // 3. 缓存内有数据\r\n        }\r\n        return province;\r\n    }\r\n}\r\n```\r\n\r\n#### 7) servlet\r\n\r\n```java\r\n@WebServlet(\"/provinceServlet\")\r\npublic class ProvinceServlet extends HttpServlet {\r\n    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\r\n        // 1. 调用Service查询\r\n        ProvinceService provinceService = new ProvinceServiceImpl();\r\n/*        // 2. 序列化list为json\r\n        ObjectMapper mapper = new ObjectMapper();\r\n        String json = mapper.writeValueAsString(provinceService.findAll());*/\r\n\r\n        // 2. 直接调用Service查询，获取json\r\n        String json = provinceService.findAllJson();\r\n\r\n        // 3. 响应结果\r\n            // 设置响应类型\r\n        System.out.println(json);\r\n        response.setContentType(\"application/json;charset=utf-8\");\r\n        response.getWriter().write(json);\r\n    }\r\n\r\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\r\n        this.doPost(request, response);\r\n    }\r\n}\r\n```\r\n\r\n#### 8) html\r\n\r\n```html\r\n    <script src=\"js/jquery-3.3.1.min.js\"></script>\r\n    <script>\r\n        $(function () {\r\n            // 发送ajax请求，加载所有省份\r\n            $.get(\"/provinceServlet\",{},function (date) {\r\n                for (var i=0;i<date.length; i++){\r\n                    // alert(date[i])\r\n                    $(\"#province\").append(\"<option>\"+date[i].name+\"</option>\")\r\n                }\r\n            })\r\n        })\r\n    </script>\r\n</head>\r\n<body>\r\n    <select id=\"province\">\r\n        <option>--请选择省份--</option>\r\n    </select>\r\n</body>\r\n</html>\r\n```\r\n\r\n### 3. 运行测试\r\n\r\n#### 1）打开redis服务器\r\n\r\n![image-20210909125003003](cloudDisk/markdown/JavaWeb笔记.assets/image-20210909125003003.png)\r\n\r\n#### 2）访问：http://localhost:8501/index.html\r\n\r\n![image-20210909125104865](cloudDisk/markdown/JavaWeb笔记.assets/image-20210909125104865.png)\r\n\r\n![image-20210909125125262](cloudDisk/markdown/JavaWeb笔记.assets/image-20210909125125262.png)\r\n\r\n#### 2）再次访问 http://localhost:8501/index.html\r\n\r\n![image-20210909125150626](cloudDisk/markdown/JavaWeb笔记.assets/image-20210909125150626.png)\r\n\r\n# 二十九、maven\r\n\r\n环境搭建：https://www.cnblogs.com/phpdragon/p/7216626.html![image-20210910095003282](cloudDisk/markdown/JavaWeb笔记.assets/image-20210910095003282.png)\r\n\r\n## maven仓库\r\n\r\n### 配置阿里云仓库\r\n\r\n```xml\r\n	<mirror>\r\n		<id>alimaven</id>\r\n		<name>aliyun maven</name>\r\n		<url>http://maven.aliyun.com/nexus/content/qroups/public/</url>\r\n		<mirrorOf>central</mirrorOf>\r\n	</mirror>\r\n	\r\n  </mirrors>\r\n```\r\n\r\n### 配置本地仓库\r\n\r\n```xml\r\n<localRepository>D:/apache-maven-3.8.2/mvn_respository</localRepository>\r\n```\r\n\r\n## 生命周期\r\n\r\n![image-20210910100338981](cloudDisk/markdown/JavaWeb笔记.assets/image-20210910100338981.png)\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n## idea 集成maven\r\n\r\n![image-20210910101132232](cloudDisk/markdown/JavaWeb笔记.assets/image-20210910101132232.png)\r\n\r\n\r\n\r\n![image-20210910101457548](cloudDisk/markdown/JavaWeb笔记.assets/image-20210910101457548.png)\r\n\r\n![image-20210910101926011](cloudDisk/markdown/JavaWeb笔记.assets/image-20210910101926011.png)![image-20210910101926454](cloudDisk/markdown/JavaWeb笔记.assets/image-20210910101926454.png)\r\n\r\n## 创建java项目\r\n\r\n\r\n\r\n![image-20210910102035302](cloudDisk/markdown/JavaWeb笔记.assets/image-20210910102035302.png)\r\n\r\n![image-20210910105310122](cloudDisk/markdown/JavaWeb笔记.assets/image-20210910105310122.png)\r\n\r\n## 创建web项目，启动tomcat服务器，并运行\r\n\r\n### 1）空Project\r\n\r\n![image-20210910182509333](cloudDisk/markdown/JavaWeb笔记.assets/image-20210910182509333.png)\r\n\r\n### 2）新建module\r\n\r\n![image-20210910182539817](cloudDisk/markdown/JavaWeb笔记.assets/image-20210910182539817.png)\r\n\r\n![image-20210910182626720](cloudDisk/markdown/JavaWeb笔记.assets/image-20210910182626720.png)\r\n\r\n![image-20210910182737975](cloudDisk/markdown/JavaWeb笔记.assets/image-20210910182737975.png)\r\n\r\n![image-20210910182800263](cloudDisk/markdown/JavaWeb笔记.assets/image-20210910182800263.png)\r\n\r\n![image-20210910182834017](cloudDisk/markdown/JavaWeb笔记.assets/image-20210910182834017.png)\r\n\r\n### 3) 新建目录\r\n\r\n![image-20210910183240987](cloudDisk/markdown/JavaWeb笔记.assets/image-20210910183240987.png)\r\n\r\n### 4）添加tomcat7插件\r\n\r\n![image-20210910185006521](cloudDisk/markdown/JavaWeb笔记.assets/image-20210910185006521.png)\r\n\r\n**注意：不要放在pluginManagement便签里，否则下图不会显示tomcat7**\r\n\r\n![image-20210910185045104](cloudDisk/markdown/JavaWeb笔记.assets/image-20210910185045104.png)\r\n\r\n### 5）run添加到上方\r\n\r\n![image-20210910185246818](cloudDisk/markdown/JavaWeb笔记.assets/image-20210910185246818.png)\r\n\r\n![image-20210910185315702](cloudDisk/markdown/JavaWeb笔记.assets/image-20210910185315702.png)\r\n\r\n![image-20210910185334742](cloudDisk/markdown/JavaWeb笔记.assets/image-20210910185334742.png)\r\n\r\n![image-20210910185436484](cloudDisk/markdown/JavaWeb笔记.assets/image-20210910185436484.png)\r\n\r\n## Maven中的依赖作用范围概述\r\n\r\n**Maven**中使用 `scope` 来指定当前包的依赖范围和依赖的传递性。常见的可选值有：**compile**, **provided**, **runtime**, **test**, **system** 等。`scope` 主要是用在 `pom.xml` 文件中的依赖定义部分，例如：\r\n\r\n```xml\r\n <dependency>\r\n            <groupId>org.springframework</groupId>\r\n            <artifactId>spring-test</artifactId>\r\n            <version>3.2.1.RELEASE</version>\r\n            <scope>test</scope>\r\n        </dependency>\r\n```\r\n\r\n### scope各种取值详解\r\n\r\n|              |                                    |          |             |\r\n| :----------- | :--------------------------------- | :------- | :---------- |\r\n| scope取值    | 有效范围（compile, runtime, test） | 依赖传递 | 例子        |\r\n| **compile**  | all                                | 是       | spring-core |\r\n| **provided** | compile, test                      | 否       | servlet-api |\r\n| **runtime**  | runtime, test                      | 是       | JDBC驱动    |\r\n| **test**     | test                               | 否       | JUnit       |\r\n| **system**   | compile, test                      | 是       |             |\r\n\r\n**compile** ：为默认的依赖有效范围。如果在定义依赖关系的时候，没有明确指定依赖有效范围的话，则默认采用该依赖有效范围。此种依赖，在编译、运行、测试时均有效。\r\n\r\n**provided** ：在编译、测试时有效，但是在运行时无效。例如：servlet-api，运行项目时，容器已经提供，就不需要Maven重复地引入一遍了。\r\n\r\n**runtime** ：在运行、测试时有效，但是在编译代码时无效。例如：JDBC驱动实现，项目代码编译只需要JDK提供的JDBC接口，只有在测试或运行项目时才需要实现上述接口的具体JDBC驱动。\r\n\r\n**test** ：只在测试时有效，例如：JUnit。\r\n\r\n**system** ：在编译、测试时有效，但是在运行时无效。和provided的区别是，使用system范围的依赖时必须通过systemPath元素显式地指定依赖文件的路径。由于此类依赖不是通过Maven仓库解析的，而且往往与本机系统绑定，可能造成构建的不可移植，因此应该谨慎使用。systemPath元素可以引用环境变量。\r\n\r\n```xml\r\n        <dependency>\r\n            <groupId>javax.sql</groupId>\r\n            <artifactId>jdbc-stdext</artifactId>\r\n            <version>2.0</version>\r\n            <scope>system</scope>\r\n            <systemPath>${java.home}/lib/rt.jar</systemPath>\r\n        </dependency\r\n```\r\n\r\n# 三十、黑马旅游网项目\r\n\r\n## 技术选型\r\n\r\n1. Web层\r\n\r\n   a) Servlet：前端控制器\r\n\r\n   b）html：视图\r\n\r\n   c）Filter：过滤器\r\n\r\n   d）BeanUtils：数据封装\r\n\r\n   e）Jackson：json序列化工具\r\n\r\n2. Service层\r\n\r\n   a）Javamail：java发送邮件的工具\r\n\r\n   b）Redis：nosql内存数据库\r\n\r\n   c）jedis：java的redis客户端\r\n\r\n3. Dao层\r\n\r\n   a）Mysql：数据库\r\n\r\n   b）Druid：数据库连接池\r\n\r\n   c）jdbcTemplate：jdbc工具\r\n\r\n## 初始化项目导入\r\n\r\n```mysql\r\n-- 创建数据库\r\nCREATE DATABASE travel;\r\n-- 使用数据库\r\nUSE travel;\r\n-- 创建表。。。\r\n```\r\n\r\n![image-20210916130807583](cloudDisk/markdown/JavaWeb笔记.assets/image-20210916130807583.png)\r\n\r\n## 项目实现的功能分析\r\n\r\n- **注册功能**\r\n- **登录功能**\r\n- **退出功能**\r\n- **分类数据展示功能**\r\n- **旅游线路分页展示功能**\r\n- **旅游线路名称关键字检索功能**\r\n- **旅游线路详情展示**\r\n- **旅游线路收藏功能**\r\n- **我的收藏页面展示**\r\n\r\n## 功能实现\r\n\r\n### 1. 注册\r\n\r\n当input输入框失去焦点时，使用JS的正则表达式对输入的内容进行判断看其是否符合规则。 		不符合规则：将边框变成红色 		符合规则：不做任何改变 当所有需要判断的内容都符合规则时，提交按钮才会提交数据。\r\n\r\n![image-20210914170840707](cloudDisk/markdown/JavaWeb笔记.assets/image-20210914170840707.png)\r\n\r\n1. 前台效果：\r\n\r\n   1. 表单校验\r\n\r\n   2. 异步表单提交\r\n\r\n      使用异步提交表单，是为了获取服务器响应的数据，且我们前台使用了html作为视图层，不能从servlet相关的域对象中获取数据，只能通过ajax获取响应数据\r\n\r\n      * ```javascript\r\n        // serialize() 将form序列化成：username=zhangsan&password=123\r\n        // 校验通过，发生ajax请求，提交表单数据\r\n        $.post(\"register\",$(this).serialize(),function () {\r\n        	...\r\n        });\r\n          \r\n        ```\r\n\r\n2. 验证码校验\r\n\r\n   为了减轻服务器的压力，查询数据库之前，先校验验证码。\r\n   	每随机生成一个验证码，就会存入session中。\r\n   	校验验证码时，提取session中的验证码与input中提取的验证码相比较。\r\n   			验证码正确：点击提交按钮时会将所有数据发送到数据库中进行操作。\r\n   			验证码错误：弹出提示框，提示验证码错误。这时候点击提交按钮时无效的。\r\n\r\n### 2. 激活\r\n\r\n![image-20210915133332239](cloudDisk/markdown/JavaWeb笔记.assets/image-20210915133332239.png)\r\n\r\n用户点击注册表单校验无误后，将数据存入数据库，并发生激活邮件，前台给用户提示“去查看邮箱，并点击激活链接”，用户点击该链接后，携带着随机的激活码，去访问servlet，服务器此时根据激活码找到用户，将激活状态改成true，让用户去登录吧\r\n\r\n#### 部分代码：\r\n\r\n```java\r\npublic Boolean regist(User user) {\r\n        User u = userDao.findByUsername(user.getUsername());\r\n//        System.out.println(\"<<<\"+u);\r\n        if(u!=null){\r\n            // 用户名存在，注册失败\r\n            return false;\r\n        }\r\n        // 设置激活码，唯一字符串\r\n        user.setCode(UuidUtil.getUuid());\r\n        // 设置激活状态\r\n        user.setStatus(\"N\");\r\n        // 保存用户信息\r\n        userDao.save(user);\r\n\r\n        // 激活邮件发生，邮件正文\r\n        String content = \"<a href=\'http://localhost:8511/travel/activeUserServlet?code=\"+user.getCode()+\"\'>点击激活</a>\";\r\n        MailUtils.sendMail(user.getEmail(),content,\"激活邮件\");\r\n        return true;\r\n    }\r\n```\r\n\r\n```java\r\n@WebServlet(\"/activeUserServlet\")\r\npublic class ActiveUserServlet extends HttpServlet {\r\n    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\r\n        // 获取激活码\r\n        String code = request.getParameter(\"code\");\r\n        System.out.println(code);\r\n        if(code != null){\r\n            // 2. 调用service完成激活\r\n            UserService userService = new UserServiceImpl();\r\n            boolean flag = userService.active(code);\r\n\r\n            // 3. 判断标记\r\n            String msg = null;\r\n            if (flag){\r\n                // 激活成功\r\n                msg = \"激活成功，请<a href=\'login.html\'>登录</a>\";\r\n            }else{\r\n                // 激活失败\r\n                msg = \"激活失败，请联系管理员\";\r\n            }\r\n            response.setContentType(\"text/html;charset=utf-8\");\r\n            response.getWriter().write(msg);\r\n        }\r\n    }\r\n\r\n```\r\n\r\n```java\r\n@Override\r\npublic boolean active(String code) {\r\n    // 1. 根据激活码查询用户对象\r\n    User user = userDao.findByCode(code);\r\n    if(user != null){\r\n        // 2. 调用dao的修改激活状态的方法\r\n        userDao.updateStatus(user);\r\n        return true;\r\n    }else {\r\n        return false;\r\n    }\r\n}\r\n```\r\n\r\n### 3. 登录\r\n\r\n![image-20210915164928659](cloudDisk/markdown/JavaWeb笔记.assets/image-20210915164928659.png)\r\n\r\n用户输入无误后，服务器根据拿到的数据查询数据库，若正确则给客户端存入session\r\n\r\n```java\r\n@WebServlet(\"/loginServlet\")\r\npublic class LoginServlet extends HttpServlet {\r\n    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\r\n        // 验证码校验\r\n       ...\r\n        \r\n        // 获取数据，封装user对象\r\n       ...\r\n           \r\n        // 调用service查询user\r\n        UserService userService = new UserServiceImpl();\r\n        User user = userService.findUser(loginUser);\r\n        ResultInfo resultInfo = new ResultInfo();\r\n        if (user == null){\r\n            // 用户名密码错误\r\n            resultInfo.setFlag(false);\r\n            resultInfo.setErrorMsg(\"用户名或密码错误\");\r\n        }\r\n        if (user!=null && !\"Y\".equals(user.getStatus())){\r\n            // 用户没有激活\r\n            resultInfo.setFlag(false);\r\n            resultInfo.setErrorMsg(\"您尚未激活，请激活\");\r\n        }\r\n        if (user!=null && \"Y\".equals(user.getStatus())){\r\n            // 登录成功\r\n            resultInfo.setFlag(true);\r\n            // 将user对象存入session\r\n            request.getSession().setAttribute(\"user\",user);\r\n        }\r\n        // 响应数据\r\n        ObjectMapper mapper = new ObjectMapper();\r\n        String s = mapper.writeValueAsString(resultInfo);\r\n        response.setContentType(\"application/json;charset=utf-8\");\r\n        response.getWriter().write(s);\r\n    }\r\n```\r\n\r\n前端带着session访问getUserServlet，将用户信息返回\r\n\r\n```html\r\n<script>\r\n    $(function () {\r\n        $.get(\"getUserServlet\",{},function (data) {\r\n            // {uid:1,name:\"李四\"}\r\n            var msg = \"欢迎回来，\" + data.name;\r\n            $(\"#span_username\").html(msg);\r\n        })\r\n    })\r\n\r\n</script>\r\n```\r\n\r\n```java\r\n@WebServlet(\"/getUserServlet\")\r\npublic class GetUserServlet extends HttpServlet {\r\n    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\r\n        // 从session中获取登录用户\r\n        Object user = request.getSession().getAttribute(\"user\");\r\n        // 将user写回客户端\r\n        ObjectMapper mapper = new ObjectMapper();\r\n        String s = mapper.writeValueAsString(user);\r\n        response.setContentType(\"application/json;charset=utf-8\");\r\n        response.getWriter().write(s);\r\n    }\r\n```\r\n\r\n### 4. 退出登录\r\n\r\n用户点击退出：\r\n\r\n```java\r\n<a href=\"javascript:location.href=\'logoutServlet\'\">退出</a>\r\n```\r\n\r\n访问 logoutServlet\r\n\r\n服务器将session删除,跳转到登录界面\r\n\r\n```java\r\n@WebServlet(\"/logoutServlet\")\r\npublic class LogoutServlet extends HttpServlet {\r\n    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\r\n        // 销毁session\r\n        request.getSession().invalidate();\r\n        // 2. 跳转到登录页面\r\n        response.sendRedirect(request.getContextPath()+\"/login.html\");\r\n    }\r\n```\r\n\r\n### 5. 优化servlet\r\n\r\n减少servlet的数量，现在是一个功能一个servlet，将其优化为一个模块一个Servlet，相当于在数据库中一张表对应一个Servlet，在Servlet中提供不同的方法，完成用户的请求。\r\n\r\n​      ![image-20210916153311085](cloudDisk/markdown/JavaWeb笔记.assets/image-20210916153311085.png)\r\n\r\n​                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           \r\n\r\nIdea控制台中午乱码问题：-Dfile.encoding=gb2312\r\n\r\n![image-20210916153420699](cloudDisk/markdown/JavaWeb笔记.assets/image-20210916153420699.png)\r\n\r\n\r\n\r\n```java\r\npublic class BaseServlet extends HttpServlet {\r\n    @Override\r\n    protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\r\n        // 完成方法分发\r\n        String uri = req.getRequestURI(); // travel/user/add\r\n        System.out.println(\"请求uri：\"+uri);\r\n        // 获取方法名称\r\n        String methodName = uri.substring(uri.lastIndexOf(\'/\') + 1);\r\n        System.out.println(\"方法名称：\"+methodName);\r\n        // 获取方法对象Method\r\n        try {\r\n            Method method = this.getClass().getDeclaredMethod(methodName, HttpServletRequest.class, HttpServletResponse.class);\r\n            method.invoke(this,req,resp);\r\n        } catch (NoSuchMethodException e) {\r\n            // e.printStackTrace();\r\n        } catch (IllegalAccessException e) {\r\n            e.printStackTrace();\r\n        } catch (InvocationTargetException e) {\r\n            e.printStackTrace();\r\n        }\r\n    }\r\n}\r\n\r\n```\r\n\r\n```java\r\n@WebServlet(\"/user/*\")\r\npublic class UserServlet extends BaseServlet {\r\n    public void add(HttpServletRequest request,HttpServletResponse response){\r\n        System.out.println(\"add被执行了\");\r\n    }\r\n}\r\n```\r\n\r\n\r\n\r\n### 6. 分类数据展示\r\n\r\n效果：\r\n\r\n![image-20210916155930873](cloudDisk/markdown/JavaWeb笔记.assets/image-20210916155930873.png)\r\n\r\n![image-20210918140816312](cloudDisk/markdown/JavaWeb笔记.assets/image-20210918140816312.png)\r\n\r\n#### 后台代码：\r\n\r\nCategoryServlet\r\n\r\n```java\r\npublic void findAll(HttpServletRequest request,HttpServletResponse response) throws  ServletException, IOException {\r\n    // 调用Service查询所有\r\n    List<Category> list = categoryService.findAll();\r\n    // 序列化json返回\r\n    writeValue(list,response);\r\n}\r\n```\r\n\r\nCategoryService\r\n\r\n```java\r\npublic List<Category> findAll() {\r\n        return categoryDao.findAll();\r\n    }\r\n```\r\n\r\nCategoryDao\r\n\r\n```java\r\n    @Override\r\n    public List<Category> findAll() {\r\n        String sql = \"select * from tab_category\";\r\n        return template.query(sql,new BeanPropertyRowMapper<Category>(Category.class));\r\n    }\r\n```\r\n\r\n#### 前台代码:\r\n\r\n```javascript\r\n    // 查询分类数据\r\n    $.get(\"category/findAll\",{},function (data) {\r\n        var lis = \"<li class=\\\"nav-active\\\"><a href=\\\"index.html\\\">首页</a></li>\"\r\n        // 遍历数值，拼接字符串\r\n        for (var i=0; i<data.length; i++){\r\n            // alert(data[i].cname); // [{cid:1,cname:...},{...},{...}]\r\n            lis += \"<li><a href=\\\"route_list.html\\\">\"+data[i].cname+\"</a></li>\";\r\n        }\r\n        lis += \'<li><a href=\"favoriterank.html\">收藏排行榜</a></li>\';\r\n        $(\"#nav\").append(lis);\r\n    })\r\n```\r\n\r\n#### 对分类数据进行缓存优化：\r\n\r\n```java\r\n    @Override\r\n    public List<Category> findAll() {\r\n        // 判断缓存中是否有categoryList\r\n        Jedis jedis = JedisUtil.getJedis();\r\n        // 使用sortedset排序查询\r\n        Set<Tuple> categories = jedis.zrangeWithScores(\"category\", 0, -1);\r\n        List<Category> categoryList = new ArrayList<Category>();\r\n//        System.out.println(\">>>\"+categories);\r\n        if (categories == null || categories.size() == 0){\r\n            System.out.println(\"从数据库查询\");\r\n            // 从mysql中取数据\r\n//            categoryList = categoryDao.findAll();\r\n            // 将categoryList保存到缓存中\r\n            for (Category c :\r\n                    categoryList) {\r\n                jedis.zadd(\"category\",c.getCid(),c.getCname());\r\n            }\r\n        }else {\r\n//            System.out.println(\"缓存中查询\");\r\n//             将set的数据存到list(类型转换)\r\n            for (Tuple tuple :\r\n                    categories) {\r\n                Category category = new Category();\r\n                category.setCid((int)tuple.getScore());\r\n                category.setCname(tuple.getElement());\r\n                categoryList.add(category);\r\n            }\r\n        }\r\n//        System.out.println(\">>>\"+categoryList);\r\n        return categoryList;\r\n```\r\n\r\n### 7. 旅游线路分页展示\r\n\r\n#### 页面传递cid\r\n\r\nredis查询cid\r\n\r\n```java\r\nSet<Tuple> categories = jedis.zrangeWithScores(\"category\", 0, -1);\r\n```\r\n\r\nheader.html 传递 cid\r\n\r\n```javascript\r\nlis += \'<li><a href=\"route_list.html?cid=\'+data[i].cid+\'\">\'+data[i].cname+\'</a></li>\';\r\n```\r\n\r\n获取cid\r\n\r\n```html\r\n    <script>\r\n        $(function () {\r\n            var search = location.search;\r\n            var cid = search.split(\"=\")[1];\r\n            alert(cid);\r\n        })\r\n    </script>\r\n```\r\n\r\n#### 根据id查询不同的旅游线路及分页\r\n\r\n![image-20210918175340112](cloudDisk/markdown/JavaWeb笔记.assets/image-20210918175340112.png)\r\n\r\n#### 客户端\r\n\r\n```html\r\n    <script>\r\n        $(function () {\r\n            var search = location.search;\r\n            var cid = search.split(\"=\")[1];\r\n            load(cid,1)\r\n        })\r\n        function load(cid,currentPage) {\r\n            $.get(\"route/pageQuery\",{cid:cid,currentPage:currentPage,pageSize:5},function (data) {\r\n                // 解析pagebean数据，展示到页面上\r\n                // 分页条的展示\r\n                $(\"#totalPage\").text(data[\"totalPage\"]);\r\n                $(\"#totalCount\").text(data[\"totalCount\"]);\r\n                // 展示分页页码\r\n                var lis = \"\";\r\n                var firstPage = \'<li onclick=\"javascript:load(\'+cid+\',1)\"><a href=\"javascript:void()\">首页</a></li>\'\r\n                var beforeNum = currentPage-1;\r\n                if (beforeNum < 1)\r\n                    beforeNum = 1;\r\n                var prePage = \'<li class=\"threeword\" onclick=\"javascript:load(\'+cid+\',\'+beforeNum+\')\"><a href=\"javascript:void()\">上一页</a></li>\'\r\n                lis += firstPage;\r\n                lis += prePage;\r\n\r\n                /*\r\n                * 展示分页页码\r\n                *   1. 一共展示10个页码，达到前5，后4的效果\r\n                *   2. 如果前面不够5个，展示1-10个\r\n                *   3. 如果后面不够4个，展示最后十个\r\n                * */\r\n                var begin;\r\n                var end;\r\n                if (data[\"totalPage\"]<10){\r\n                    // 总的页码超过10页\r\n                    begin = 1;\r\n                    end = data[\"totalPage\"];\r\n                }else {\r\n                    // 总页码超过10个\r\n                    begin = currentPage - 5;\r\n                    end = currentPage + 4;\r\n                    if (begin<1){\r\n                        // 2. 如果前面不够5个，展示1-10个\r\n                        begin = 1;\r\n                        end = 10;\r\n                    }\r\n                    if (end>data[\"totalPage\"]){\r\n                        // 3. 如果后面不够4个，展示最后十个\r\n                        begin = data[\"totalPage\"] - 9;\r\n                        end = data[\"totalPage\"];\r\n                    }\r\n                }\r\n\r\n\r\n                // alert(begin + \",\" + end)\r\n                for (var i=begin; i<=end; i++){\r\n                    var li;\r\n                    if (i==currentPage){\r\n                        // 当前页码\r\n                        li = \'<li class=\"curPage\" onclick=\"javascript:load(\'+cid+\',\'+i+\');\"><a href=\"javascript:void()\">\'+ i +\'</a></li>\';\r\n                    }else {\r\n                        li = \'<li onclick=\"javascript:load(\'+cid+\',\'+i+\');\"><a href=\"javascript:void()\">\'+ i +\'</a></li>\';\r\n                    }\r\n                    // 拼接页码的li\r\n                    lis += li;\r\n                }\r\n\r\n\r\n                // for (var i=1; i<=data[\"totalPage\"]; i++){\r\n                //     var li;\r\n                //     if (i==currentPage){\r\n                //         // 当前页码\r\n                //         li = \'<li class=\"curPage\" onclick=\"javascript:load(\'+cid+\',\'+i+\');\"><a href=\"javascript:void()\">\'+ i +\'</a></li>\';\r\n                //     }else {\r\n                //         li = \'<li onclick=\"javascript:load(\'+cid+\',\'+i+\');\"><a href=\"javascript:void()\">\'+ i +\'</a></li>\';\r\n                //     }\r\n                //     // 拼接页码的li\r\n                //     lis += li;\r\n                // }\r\n                var nextNum = currentPage+1;\r\n                if (nextNum > data[\"totalPage\"])\r\n                    nextNum = data[\"totalPage\"];\r\n                var nextPage = \'<li class=\"threeword\" onclick=\"javascript:load(\'+cid+\',\'+nextNum+\')\"><a href=\"javascript:void()\">下一页</a></li>\'\r\n                var endPage = \'<li onclick=\"javascript:load(\'+cid+\',\'+(data[\"totalPage\"])+\')\" class=\"threeword\"><a href=\"javascript:void();\">末页</a></li>\'\r\n                lis += nextPage;\r\n                lis += endPage;\r\n                // 添加到ul标签中\r\n                $(\"#pageNum\").html(lis);\r\n\r\n                // list数据展示\r\n                var route_lis = \"\";\r\n                for (var i=0;i<data[\"list\"].length;i++){\r\n                    // 获取{rid:1,rname:...}\r\n                    var route = data[\"list\"][i];\r\n                    li = \'                        <li>\\n\' +\r\n                        \'                            <div class=\"img\"><img style=\"width: 299px\" src=\"\'+ route.rimage +\'\" alt=\"\"></div>\\n\' +\r\n                        \'                            <div class=\"text1\">\\n\' +\r\n                        \'                                <p>\'+ route.rname +\'</p>\\n\' +\r\n                        \'                                <br/>\\n\' +\r\n                        \'                                <p>\'+ route.routeIntroduce +\'</p>\\n\' +\r\n                        \'                            </div>\\n\' +\r\n                        \'                            <div class=\"price\">\\n\' +\r\n                        \'                                <p class=\"price_num\">\\n\' +\r\n                        \'                                    <span>&yen;</span>\\n\' +\r\n                        \'                                    <span>\'+ route.price +\'</span>\\n\' +\r\n                        \'                                    <span>起</span>\\n\' +\r\n                        \'                                </p>\\n\' +\r\n                        \'                                <p><a href=\"route_detail.html\">查看详情</a></p>\\n\' +\r\n                        \'                            </div>\\n\' +\r\n                        \'                        </li>\';\r\n                    route_lis += li;\r\n                }\r\n                $(\"#routeLi\").html(route_lis);\r\n                // 定位到页面的顶部\r\n                window.scrollTo(0,0);\r\n            })\r\n        }\r\n    </script>\r\n```\r\n\r\n\r\n\r\n#### 服务器端\r\n\r\nPageBean类\r\n\r\n```java\r\npublic class PageBean<T> {\r\n    private int totalCount; // 总记录数\r\n    private int totalPage; // 总页数\r\n    private int currentPage; // 当前页码\r\n    private int pageSize; // 每页显示条数\r\n    private List<T> list; // 每页显示的数据集合\r\n\r\n```\r\n\r\nRouteServlet\r\n\r\n```java\r\n    /*\r\n    * 分页查询\r\n    * */\r\n    public void pageQuery(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException, InvocationTargetException, IllegalAccessException {\r\n        // 接受参数\r\n        String cidStr = request.getParameter(\"cid\");\r\n        String currentPageStr = request.getParameter(\"currentPage\");\r\n        String pageSizeStr = request.getParameter(\"pageSize\");\r\n        int cid = 0;\r\n        if (cidStr!=null && !\"\".equals(cidStr)){\r\n            cid = Integer.parseInt(cidStr);\r\n        }\r\n        int currentPage = 0; // 当前页码，如果不传递该参数，则默认第一页\r\n        if (currentPageStr!=null && !\"\".equals(currentPageStr)){\r\n            currentPage = Integer.parseInt(currentPageStr);\r\n        }else {\r\n            currentPage = 1;\r\n        }\r\n        int pageSize = 0; // 当前页显示条数，如果不传递，则显示5条每页\r\n        if (pageSizeStr!=null && !\"\".equals(pageSizeStr)){\r\n            pageSize = Integer.parseInt(pageSizeStr);\r\n        } else {\r\n            pageSize = 5;\r\n        }\r\n\r\n        // 调用service查询pageBean对象\r\n        PageBean<Route> routePageBean = routeService.pageQuery(cid, currentPage, pageSize);\r\n        System.out.println(routePageBean);\r\n        // 将pageBean对象序列化返回\r\n        writeValue(routePageBean,response);\r\n```\r\n\r\nRouteService\r\n\r\n```java\r\n@Override\r\npublic PageBean<Route> pageQuery(int cid, int currentPage, int pageSize) {\r\n    // 获取数据总数\r\n    int totalCount = routeDao.getTotalCount();\r\n    // 计算总页数\r\n    int totalPage = totalCount%pageSize==0?totalCount/pageSize:totalCount/pageSize+1;\r\n    // 获取 从第start条数据开始的第pageSize条数据\r\n    // start = 当前页码 * pageSize\r\n    int start = (currentPage-1) * pageSize;\r\n    // 获取数据\r\n    List<Route> list = routeDao.findByCid(cid, start, pageSize);\r\n    // 封装PageBean对象\r\n    PageBean<Route> routePageBean = new PageBean<>();\r\n    routePageBean.setCurrentPage(currentPage);\r\n    routePageBean.setPageSize(pageSize);\r\n    routePageBean.setTotalCount(totalCount);\r\n    routePageBean.setTotalPage(totalPage);\r\n    routePageBean.setList(list);\r\n    return routePageBean;\r\n}\r\n```\r\n\r\nRouteDao\r\n\r\n```java\r\npublic class RouteDaoImpl implements RouteDao {\r\n    private JdbcTemplate template = new JdbcTemplate(JDBCUtils.getDataSource());\r\n    @Override\r\n    public List<Route> findByCid(int cid, int start, int pageSize) {\r\n        String sql = \"select * from tab_route where cid=? limit ?,?\";\r\n        List<Route> list = template.query(sql, new BeanPropertyRowMapper<Route>(Route.class), cid, start, pageSize);\r\n        return list;\r\n    }\r\n\r\n    @Override\r\n    public int getTotalCount() {\r\n        String sql = \"select count(*) from tab_route\";\r\n        return template.queryForObject(sql,Integer.class);\r\n    }\r\n```\r\n\r\n测试\r\n\r\n```url\r\nhttp://localhost:8511/travel/route/pageQuery?cid=5&pageSize=5&currentPage=1\r\n```\r\n\r\n![image-20210918193601763](cloudDisk/markdown/JavaWeb笔记.assets/image-20210918193601763.png)\r\n\r\n### 8. 旅游线路查询\r\n\r\n![image-20210919135501798](cloudDisk/markdown/JavaWeb笔记.assets/image-20210919135501798.png)\r\n\r\n#### 查询参数的传递\r\n\r\n动态获取url中的参数\r\n\r\n```javascript\r\n//根据传递过来的参数name获取对应的值\r\nfunction getParameter(name) {\r\n    var reg = new RegExp(\"(^|&)\" + name + \"=([^&]*)(&|$)\",\"i\");\r\n    var r = location.search.substr(1).match(reg);\r\n    if (r!=null) return (r[2]); return null;\r\n}\r\n```\r\n\r\n获取，解码\r\n\r\n```javascript\r\nvar rname = getParameter(\"rname\");\r\n// 判断rame不为空\r\nif (rname){\r\n    // 解码\r\n    rname = window.decodeURIComponent(rname);\r\n}\r\n```\r\n\r\n#### 修改后台的代码\r\n\r\nRouteServlet\r\n\r\n```java\r\n public void pageQuery(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException, InvocationTargetException, IllegalAccessException {\r\n        // 接受参数\r\n        String cidStr = request.getParameter(\"cid\");\r\n        String currentPageStr = request.getParameter(\"currentPage\");\r\n        String pageSizeStr = request.getParameter(\"pageSize\");\r\n        String rname = request.getParameter(\"rname\");\r\n        rname = new String(rname.getBytes(\"iso-8859-1\"),\"utf-8\");\r\n        int cid = 0;\r\n        if (cidStr!=null && !\"\".equals(cidStr) && !\"null\".equals(cidStr)){\r\n            cid = Integer.parseInt(cidStr);\r\n        }\r\n        int currentPage = 0; // 当前页码，如果不传递该参数，则默认第一页\r\n        if (currentPageStr!=null && !\"\".equals(currentPageStr)){\r\n            currentPage = Integer.parseInt(currentPageStr);\r\n        }else {\r\n            currentPage = 1;\r\n        }\r\n        int pageSize = 0; // 当前页显示条数，如果不传递，则显示5条每页\r\n        if (pageSizeStr!=null && !\"\".equals(pageSizeStr)){\r\n            pageSize = Integer.parseInt(pageSizeStr);\r\n        } else {\r\n            pageSize = 5;\r\n        }\r\n\r\n        // 调用service查询pageBean对象\r\n        PageBean<Route> routePageBean = routeService.pageQuery(cid, currentPage, pageSize, rname);\r\n        System.out.println(routePageBean);\r\n        // 将pageBean对象序列化返回\r\n        writeValue(routePageBean,response);\r\n    }\r\n```\r\n\r\nService\r\n\r\n```java\r\n    @Override\r\n    public PageBean<Route> pageQuery(int cid, int currentPage, int pageSize, String rname) {\r\n        // 获取数据总数\r\n        int totalCount = routeDao.getTotalCount(cid, rname);\r\n        // 计算总页数\r\n        int totalPage = totalCount%pageSize==0?totalCount/pageSize:totalCount/pageSize+1;\r\n        // 获取 从第start条数据开始的第pageSize条数据\r\n        // start = 当前页码 * pageSize\r\n        int start = (currentPage-1) * pageSize;\r\n        // 获取数据\r\n        List<Route> list = routeDao.findByCid(cid, start, pageSize,rname);\r\n        // 封装PageBean对象\r\n        PageBean<Route> routePageBean = new PageBean<>();\r\n        routePageBean.setCurrentPage(currentPage);\r\n        routePageBean.setPageSize(pageSize);\r\n        routePageBean.setTotalCount(totalCount);\r\n        routePageBean.setTotalPage(totalPage);\r\n        routePageBean.setList(list);\r\n        return routePageBean;\r\n    }\r\n```\r\n\r\nDao\r\n\r\n```java\r\n@Override\r\n    public List<Route> findByCid(int cid, int start, int pageSize, String rname) {\r\n        // 定义一个sql模板\r\n        String sql = \"select  * from tab_route where 1=1 \";\r\n        StringBuilder sb = new StringBuilder(sql);\r\n        List params = new ArrayList(); // 参数\r\n        // 判断这些参数是否有值\r\n        if (cid != 0){\r\n            sb.append(\" and cid=? \");\r\n            params.add(cid);\r\n        }\r\n        if (rname!=null && !\"\".equals(rname)){\r\n            sb.append(\" and rname like ? \");\r\n            params.add(\"%\"+rname+\"%\");\r\n        }\r\n        sb.append(\" limit ?,? \");\r\n        params.add(start);\r\n        params.add(pageSize);\r\n        List<Route> list = template.query(sb.toString(), new BeanPropertyRowMapper<Route>(Route.class), params.toArray());\r\n        System.out.println(sb.toString());\r\n        System.out.println(params.toString());\r\n//        String sql = \"select * from tab_route where cid=? and rname=? limit ?,?\";\r\n//        List<Route> list = template.query(sql, new BeanPropertyRowMapper<Route>(Route.class),start, pageSize);\r\n        return list;\r\n    }\r\n\r\n    @Override\r\n    public int getTotalCount(int cid, String rname) {\r\n//        String sql = \"select count(*) from tab_route where cid=?\";\r\n        String sql = \"select count(*) from tab_route where 1=1 \";\r\n        StringBuilder sb = new StringBuilder(sql);\r\n        List params = new ArrayList(); // 参数\r\n        // 判断这些参数是否有值\r\n        if (cid != 0){\r\n            sb.append(\" and cid=? \");\r\n            params.add(cid);\r\n        }\r\n        if (rname!=null && !\"\".equals(rname)){\r\n            sb.append(\" and rname like ? \");\r\n            params.add(\"%\"+rname+\"%\");\r\n        }\r\n        return template.queryForObject(sb.toString(), Integer.class, params.toArray());\r\n//        return template.queryForObject(sql,Integer.class,cid);\r\n    }\r\n```\r\n\r\n#### 前端代码优化\r\n\r\n```javascript\r\n    // 搜索按钮绑定事件\r\n    $(\"#search_button\").click(function () {\r\n        // 获取输入框文本\r\n        var rname = $(\"#search_input\").val();\r\n        var cid = getParameter(\"cid\");\r\n        // 跳转到 http://localhost:8511/travel/route_list.html\r\n        location.href = \"http://localhost:8511/travel/route_list.html?cid=\"+cid+\"&rname=\"+rname+\"\";\r\n    });\r\n```\r\n\r\n\r\n\r\n```html\r\n    <script>\r\n        $(function () {\r\n            // 获取url携带的参数\r\n            var cid = getParameter(\"cid\");\r\n            var rname = getParameter(\"rname\");\r\n            // 判断rame不为空\r\n            if (rname){\r\n                rname = window.decodeURIComponent(rname);\r\n            }\r\n            // alert(cid+\":\"+rname);\r\n            load(cid,null,rname)\r\n        })\r\n        function load(cid,currentPage,rname) {\r\n            $.get(\"route/pageQuery\",{cid:cid,currentPage:currentPage,pageSize:5,rname:rname},function (data) {\r\n                // 解析pagebean数据，展示到页面上\r\n                // 分页条的展示\r\n                $(\"#totalPage\").text(data[\"totalPage\"]);\r\n                $(\"#totalCount\").text(data[\"totalCount\"]);\r\n                // 展示分页页码\r\n                var lis = \"\";\r\n                var firstPage = \'<li onclick=\"javascript:load(\'+cid+\',1,\\\'\'+rname+\'\\\')\"><a href=\"javascript:void()\">首页</a></li>\'\r\n                var beforeNum = currentPage-1;\r\n                if (beforeNum < 1)\r\n                    beforeNum = 1;\r\n                var prePage = \'<li class=\"threeword\" onclick=\"javascript:load(\'+cid+\',\'+beforeNum+\',\\\'\'+rname+\'\\\')\"><a href=\"javascript:void()\">上一页</a></li>\'\r\n                lis += firstPage;\r\n                lis += prePage;\r\n\r\n                /*\r\n                * 展示分页页码\r\n                *   1. 一共展示10个页码，达到前5，后4的效果\r\n                *   2. 如果前面不够5个，展示1-10个\r\n                *   3. 如果后面不够4个，展示最后十个\r\n                * */\r\n                var begin;\r\n                var end;\r\n                if (data[\"totalPage\"]<10){\r\n                    // 总的页码超过10页\r\n                    begin = 1;\r\n                    end = data[\"totalPage\"];\r\n                }else {\r\n                    // 总页码超过10个\r\n                    begin = currentPage - 5;\r\n                    end = currentPage + 4;\r\n                    if (begin<1){\r\n                        // 2. 如果前面不够5个，展示1-10个\r\n                        begin = 1;\r\n                        end = 10;\r\n                    }\r\n                    if (end>data[\"totalPage\"]){\r\n                        // 3. 如果后面不够4个，展示最后十个\r\n                        begin = data[\"totalPage\"] - 9;\r\n                        end = data[\"totalPage\"];\r\n                    }\r\n                }\r\n\r\n\r\n                // alert(begin + \",\" + end)\r\n                for (var i=begin; i<=end; i++){\r\n                    var li;\r\n                    if (i==currentPage){\r\n                        // 当前页码\r\n                        li = \'<li class=\"curPage\" onclick=\"javascript:load(\'+cid+\',\'+i+\',\\\'\'+rname+\'\\\');\"><a href=\"javascript:void()\">\'+ i +\'</a></li>\';\r\n                    }else {\r\n                        li = \'<li onclick=\"javascript:load(\'+cid+\',\'+i+\',\\\'\'+rname+\'\\\');\"><a href=\"javascript:void()\">\'+ i +\'</a></li>\';\r\n                    }\r\n                    // 拼接页码的li\r\n                    lis += li;\r\n                }\r\n\r\n\r\n                // for (var i=1; i<=data[\"totalPage\"]; i++){\r\n                //     var li;\r\n                //     if (i==currentPage){\r\n                //         // 当前页码\r\n                //         li = \'<li class=\"curPage\" onclick=\"javascript:load(\'+cid+\',\'+i+\');\"><a href=\"javascript:void()\">\'+ i +\'</a></li>\';\r\n                //     }else {\r\n                //         li = \'<li onclick=\"javascript:load(\'+cid+\',\'+i+\');\"><a href=\"javascript:void()\">\'+ i +\'</a></li>\';\r\n                //     }\r\n                //     // 拼接页码的li\r\n                //     lis += li;\r\n                // }\r\n                var nextNum = currentPage+1;\r\n                if (nextNum > data[\"totalPage\"])\r\n                    nextNum = data[\"totalPage\"];\r\n                var nextPage = \'<li class=\"threeword\" onclick=\"javascript:load(\'+cid+\',\'+nextNum+\',\\\'\'+rname+\'\\\')\"><a href=\"javascript:void()\">下一页</a></li>\'\r\n                var endPage = \'<li onclick=\"javascript:load(\'+cid+\',\'+(data[\"totalPage\"])+\',\\\'\'+rname+\'\\\')\" class=\"threeword\"><a href=\"javascript:void();\">末页</a></li>\'\r\n                lis += nextPage;\r\n                lis += endPage;\r\n                // 添加到ul标签中\r\n                $(\"#pageNum\").html(lis);\r\n\r\n                // list数据展示\r\n                var route_lis = \"\";\r\n                for (var i=0;i<data[\"list\"].length;i++){\r\n                    // 获取{rid:1,rname:...}\r\n                    var route = data[\"list\"][i];\r\n                    li = \'                        <li>\\n\' +\r\n                        \'                            <div class=\"img\"><img style=\"width: 299px\" src=\"\'+ route.rimage +\'\" alt=\"\"></div>\\n\' +\r\n                        \'                            <div class=\"text1\">\\n\' +\r\n                        \'                                <p>\'+ route.rname +\'</p>\\n\' +\r\n                        \'                                <br/>\\n\' +\r\n                        \'                                <p>\'+ route.routeIntroduce +\'</p>\\n\' +\r\n                        \'                            </div>\\n\' +\r\n                        \'                            <div class=\"price\">\\n\' +\r\n                        \'                                <p class=\"price_num\">\\n\' +\r\n                        \'                                    <span>&yen;</span>\\n\' +\r\n                        \'                                    <span>\'+ route.price +\'</span>\\n\' +\r\n                        \'                                    <span>起</span>\\n\' +\r\n                        \'                                </p>\\n\' +\r\n                        \'                                <p><a href=\"route_detail.html\">查看详情</a></p>\\n\' +\r\n                        \'                            </div>\\n\' +\r\n                        \'                        </li>\';\r\n                    route_lis += li;\r\n                }\r\n                $(\"#routeLi\").html(route_lis);\r\n                // 定位到页面的顶部\r\n                window.scrollTo(0,0);\r\n            })\r\n        }\r\n    </script>\r\n```\r\n\r\n### 9. 旅游线路详情\r\n\r\n#### 分析\r\n\r\n![image-20210919214934264](cloudDisk/markdown/JavaWeb笔记.assets/image-20210919214934264.png)\r\n\r\n![image-20210919214954221](cloudDisk/markdown/JavaWeb笔记.assets/image-20210919214954221.png)\r\n\r\n#### 后台代码\r\n\r\nrouteServlet\r\n\r\n\r\n\r\nrouteService\r\n\r\n```java\r\n@Override\r\npublic Route findOne(int rid) {\r\n    // rid查询tab_route\r\n    Route route = routeDao.findOne(rid);\r\n    // 根据rid查询tab_route_img对于线路的图片\r\n    List<RouteImg> routeImgList = routeImgDao.findByRid(rid);\r\n    route.setRouteImgList(routeImgList);\r\n    // 根据sid查询对于的商家\r\n        // 获取sid\r\n    int sid = route.getSid();\r\n    Seller seller = sellerDao.findOne(sid);\r\n    route.setSeller(seller);\r\n    return route;\r\n}\r\n```\r\n\r\nRouteDao\r\n\r\n```java\r\n@Override\r\npublic Route findOne(int rid) {\r\n    String sql = \"select * from tab_route where rid=?\";\r\n    return template.queryForObject(sql,new BeanPropertyRowMapper<Route>(Route.class),rid);\r\n}\r\n```\r\n\r\nRouteImgDao\r\n\r\n```java\r\n    @Override\r\n    public List<RouteImg> findByRid(int rid) {\r\n        String sql = \"select * from tab_route_img where rid=?\";\r\n        return template.query(sql,new BeanPropertyRowMapper<RouteImg>(RouteImg.class),rid);\r\n    }\r\n```\r\n\r\nSellerDao\r\n\r\n```java\r\n    @Override\r\n    public Seller findOne(int sid) {\r\n        String sql = \"select * from tab_seller where sid=?\";\r\n        return template.queryForObject(sql,new BeanPropertyRowMapper<Seller>(Seller.class),sid);\r\n    }\r\n```\r\n\r\n\r\n\r\n#### 前台代码\r\n\r\nroute_detail.html 中加载\r\n\r\n1. 获取rid\r\n2. 发送ajax请求，获取route对象\r\n3. 解析对象数据\r\n\r\n### 10. 旅游线路收藏\r\n\r\n#### 分析\r\n\r\n判断当前登录用户是否收藏过该线路\r\n\r\n当页面加载完后，发送ajax请求，获取用户是否收藏标记\r\n\r\n根据不同的标记，展示不同的样式\r\n\r\n![image-20210920113919835](cloudDisk/markdown/JavaWeb笔记.assets/image-20210920113919835.png)\r\n\r\n#### 前台代码\r\n\r\n```javascript\r\n// 判断用户是否收藏\r\n$.get(\"route/isFavorite\",{rid:rid},function (data) {\r\n    if (data.flag){\r\n        // 用户收藏了\r\n        $(\"#favorite_but\").addClass(\"already\");\r\n        $(\"#favorite_but\").attr(\"disabled\",\"disabled\");\r\n    }else {\r\n        // 用户没收藏\r\n        $(\"#favorite_but\").removeClass(\"already\")\r\n        $(\"#favorite_but\").removeAttr(\"disabled\");\r\n    }\r\n})\r\n```\r\n\r\n#### 后台代码\r\n\r\nrouteServlet\r\n\r\n```java\r\n    /*\r\n    * 判断用户是否收藏该路线\r\n    * */\r\n    public void isFavorite(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException, InvocationTargetException, IllegalAccessException {\r\n        ResultInfo resultInfo = new ResultInfo();\r\n        // 获取参数\r\n        String ridStr = request.getParameter(\"rid\");\r\n        int rid=1;\r\n        if (ridStr!=null && !\"\".equals(ridStr)){\r\n            // 类型转换\r\n            rid = Integer.parseInt(ridStr);\r\n        }\r\n        // 判断用户是否登录\r\n        User user = (User)request.getSession().getAttribute(\"user\");\r\n        int uid;\r\n        if (user == null) {\r\n            // 用户没登录\r\n            uid = 0;\r\n            resultInfo.setErrorMsg(\"用户没有登录\");\r\n        }else {\r\n            // 获取用户的uid\r\n            uid = user.getUid();\r\n        }\r\n        // 调用favoriteService 查询uid，rid\r\n        Boolean flag = favoriteService.isFavorite(uid,rid);\r\n        resultInfo.setFlag(flag);\r\n        if (flag==false && user!=null){\r\n            // 设置错误信息\r\n            resultInfo.setErrorMsg(\"用户没有收藏\");\r\n        }\r\n        resultInfo.setData(flag);\r\n        writeValue(resultInfo,response);\r\n    }\r\n```\r\n\r\nfavoriteService\r\n\r\n```java\r\n    @Override\r\n    public Boolean isFavorite(int uid, int rid) {\r\n        // 查询收藏表\r\n        Favorite favorite = favoriteDao.findByUidAndRid(uid,rid);\r\n        return favorite != null;\r\n    }\r\n```\r\n\r\nfavoriteDao\r\n\r\n```java\r\n    @Override\r\n    public Favorite findByUidAndRid(int uid, int rid) {\r\n        System.out.println(uid +\":\"+rid);\r\n        String sql = \"select * from tab_favorite where uid=? and rid=?\";\r\n        Favorite favorite = null;\r\n        try {\r\n            favorite = template.queryForObject(sql,new BeanPropertyRowMapper<Favorite>(Favorite.class),uid,rid);\r\n        } catch (EmptyResultDataAccessException e){\r\n            // e.printStackTrace();\r\n            return null;\r\n        }\r\n        return favorite;\r\n    }\r\n```\r\n\r\n### 11. 收藏次数的动态展示\r\n\r\n#### 后台\r\n\r\nfavoruteDao\r\n\r\n```java\r\n    @Override\r\n    public int getFavoriteCount(int rid) {\r\n        String sql = \"select count(*) from tab_favorite where rid=?\";\r\n        return template.queryForObject(sql,Integer.class,rid);\r\n    }\r\n```\r\n\r\nrouteService.findOne (修改)\r\n\r\n```java\r\n// 收藏数量查询\r\nint count = favoriteDao.getFavoriteCount(rid);\r\nroute.setCount(count);\r\n```\r\n\r\n#### 前台\r\n\r\n```javascript\r\n$(\"#favorite_count\").html(\"已收藏\"+route.count+\"次\")\r\n```\r\n\r\n### 12. 点击按钮收藏线路\r\n\r\n#### 分析\r\n\r\n![image-20210920125936860](cloudDisk/markdown/JavaWeb笔记.assets/image-20210920125936860.png)\r\n\r\n#### 后台\r\n\r\nrouteServlet\r\n\r\n```java\r\n/*\r\n * 给用户添加收藏线路\r\n * */\r\npublic void addFavorite(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException, InvocationTargetException, IllegalAccessException {\r\n    ResultInfo resultInfo = new ResultInfo();\r\n    // 获取参数\r\n    String ridStr = request.getParameter(\"rid\");\r\n    int rid=0;\r\n    if (ridStr!=null && !\"\".equals(ridStr)){\r\n        // 类型转换\r\n        rid = Integer.parseInt(ridStr);\r\n    }\r\n    // 判断用户是否登录\r\n    User user = (User)request.getSession().getAttribute(\"user\");\r\n    int uid;\r\n    if (user == null) {\r\n        // 用户没登录\r\n        uid = 0;\r\n        resultInfo.setErrorMsg(\"请先登录\");\r\n    }else {\r\n        // 获取用户的uid\r\n        uid = user.getUid();\r\n    }\r\n    // 调用favoriteService 将uid和rid添加到收藏表\r\n    Boolean flag = favoriteService.addFavorite(uid,rid);\r\n    resultInfo.setFlag(flag);\r\n    if (flag==false && user!=null){\r\n        // 设置错误信息\r\n        resultInfo.setErrorMsg(\"已收藏\");\r\n    }\r\n    resultInfo.setData(flag);\r\n    writeValue(resultInfo,response);\r\n}\r\n```\r\n\r\nfavoriteService\r\n\r\n```java\r\n@Override\r\npublic Boolean addFavorite(int uid, int rid) {\r\n    SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy-MM-dd\");\r\n    String date = sdf.format(new Date()); // 收藏时间\r\n    return favoriteDao.addFavorite(uid, date, rid);\r\n}\r\n```\r\n\r\nfavoriteDao\r\n\r\n```java\r\n@Override\r\npublic Boolean addFavorite(int uid, String date, int rid) {\r\n    String sql = \"insert into tab_favorite values(?,?,?)\";\r\n    try {\r\n        template.update(sql, rid, date, uid);\r\n    }catch (Exception e){\r\n        return false;\r\n    }\r\n    return true;\r\n}\r\n```\r\n\r\n#### 前台\r\n\r\n```javascript\r\n            // 收藏按钮绑定点击事件\r\n            $(\"#favorite_but\").click(function () {\r\n                // 发生ajax请求，让用户收藏\r\n                $.get(\"route/addFavorite\",{rid:rid},function (data) {\r\n                    if (data.flag){\r\n                        // 设置收藏样式\r\n                        // $(\"#favorite_but\").addClass(\"already\");\r\n                        // $(\"#favorite_but\").attr(\"disabled\",\"disabled\");\r\n                        // 刷新\r\n                        location.reload();\r\n\r\n                    } else {\r\n                        alert(data.errorMsg);\r\n                        // location.reload();\r\n                    }\r\n                })\r\n            })\r\n```\r\n\r\n\r\n\r\n# 三十一、Linux\r\n\r\n镜像下载：http://mirrors.ustc.edu.cn/centos/7/isos/x86_64/\r\n\r\n虚拟机下载：https://www.vmware.com/cn/products/workstation-pro.html\r\n\r\n## 1. 目录结构\r\n\r\n![image-20210923093445123](cloudDisk/markdown/JavaWeb笔记.assets/image-20210923093445123.png)\r\n\r\n根目录，一般根目录下只存放目录，不要存放文件，/etc、/bin、/dev、/lib、/sbin应该和根目录放置在一个分区中。\r\n\r\n/bin 普通用户执行的命令存放的地方\r\n\r\n/sbin 管理员执行的命令存放的地方\r\n\r\n/usr应用程序存放的目录\r\n\r\n　　/usr/bin 存放应用程序　　\r\n\r\n　　/usr/lib 存放不能直接运行的，却是许多程序运行所必需的一些函数库文件\r\n\r\n　　/usr/local 存放软件升级包\r\n\r\n/lib 系统使用的函数库的目录\r\n\r\n/root 管理员的家目录(宿主目录)\r\n\r\n/home 普通用户的家目录\r\n\r\n/var 放置系统执行过程中经常变化的文件，如随时更改的日志文件 \r\n\r\n/etc 存放各种配置文件\r\n\r\n/srv 服务启动之后要访问的目录\r\n\r\n/mnt 光盘默认挂载点\r\n\r\n/dev 存放linux系统下的设备文件，访问该目录下某个文件，相当于访问某个设备\r\n\r\n/opt 给主机额外安装软件所存放的目录\r\n\r\n/tmp 一般用户或正在执行的程序临时存放文件的目录\r\n\r\n## 2. \r\n\r\n## 1. 常用命令\r\n\r\nls 当前目录下的文件\r\n\r\nls -a 并且显示隐藏文件\r\n\r\nls -l 显文件详细信息（简写：ll）\r\n\r\n## 4. jdk安装\r\n\r\nhttps://blog.csdn.net/pdsu161530247/article/details/81582980\r\n\r\n### 1.下载jdk8\r\n\r\n方法一：官网手动下载\r\n\r\n下载Linux环境下的jdk1.8\r\n\r\nhttp://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html\r\n\r\n![image-20210926130636854](cloudDisk/markdown/JavaWeb笔记.assets/image-20210926130636854.png)\r\n\r\n### 2.源码包解压\r\n\r\n使用xftp将jdk源码包，上传到/usr/local（软件一般安装到这个目录）![image-20210926130706393](cloudDisk/markdown/JavaWeb笔记.assets/image-20210926130706393.png)\r\n\r\n使用解压命令解压\r\n\r\n```\r\n[root@localhost local]*# tar -zxvf jdk-8u181-linux-x64.tar.gz*\r\n```\r\n\r\n解压完成\r\n\r\n![image-20210926130734505](cloudDisk/markdown/JavaWeb笔记.assets/image-20210926130734505.png)\r\n\r\n顺手删掉jdk源码包\r\n\r\n```\r\n[root@localhost local]# rm -f jdk-8u181-linux-x64.tar.gz\r\n```\r\n\r\n### 3.配置jdk环境变量\r\n\r\n/etc/profile文件的改变会涉及到系统的环境，也就是有关Linux环境变量的东西\r\n\r\n所以，我们要将jdk配置到/etc/profile，才可以在任何一个目录访问jdk\r\n\r\n```\r\n[root@localhost local]# vim /etc/profile\r\n```\r\n\r\n按i进入编辑，在profile文件尾部添加如下内容\r\n\r\n```\r\nexport JAVA_HOME=/usr/local/jdk1.8.0_181  #jdk安装目录\r\n \r\nexport JRE_HOME=${JAVA_HOME}/jre\r\n \r\nexport CLASSPATH=.:${JAVA_HOME}/lib:${JRE_HOME}/lib:$CLASSPATH\r\n \r\nexport JAVA_PATH=${JAVA_HOME}/bin:${JRE_HOME}/bin\r\n \r\nexport PATH=$PATH:${JAVA_PATH}\r\n```\r\n\r\n添加后如下\r\n\r\n![image-20210926130835684](cloudDisk/markdown/JavaWeb笔记.assets/image-20210926130835684.png)\r\n\r\nEsc --> :wq\r\n\r\n保存并退出编辑\r\n\r\n通过命令source /etc/profile让profile文件立即生效\r\n\r\n```\r\n[root@localhost local]# source /etc/profile\r\n```\r\n\r\n### 4.测试是否安装成功\r\n\r\n```\r\n[root@localhost local]# javac\r\n```\r\n\r\n![image-20210926130907082](cloudDisk/markdown/JavaWeb笔记.assets/image-20210926130907082.png)\r\n\r\n```\r\n[root@localhost local]# java -version\r\n```\r\n\r\n![image-20210926130918840](cloudDisk/markdown/JavaWeb笔记.assets/image-20210926130918840.png)\r\n\r\nlinux下jdk8安装成功\r\n\r\n## 5. mysql 安装\r\n\r\nhttps://blog.csdn.net/weixin_44198965/article/details/91891985\r\n\r\n### 1. 下载Mysql rpm包\r\n\r\n官网下载：https://dev.mysql.com/downloads/mysql/\r\n\r\n![image-20210926130958316](cloudDisk/markdown/JavaWeb笔记.assets/image-20210926130958316.png)\r\n\r\n![image-20210926131004617](cloudDisk/markdown/JavaWeb笔记.assets/image-20210926131004617.png)\r\n\r\n**如果你到了这里，本地应该有了如下四个rpm包：**\r\n\r\n![image-20210926131020467](cloudDisk/markdown/JavaWeb笔记.assets/image-20210926131020467.png)\r\n\r\n最后，把它们保存起来等待使用。\r\n\r\n### 2. 远端上传（Xftp）或者使用rz命令\r\n\r\n**注意：如果你了解ssh协议、远端连接、Xshell、Xftp，那么请继续往下看，反之，你需要先学习这些。**\r\n\r\n**一、建立mysql文件夹**\r\n在/opt目录下建立mysql文件夹：\r\n\r\n```\r\n/opt/mysql\r\n```\r\n\r\n二、把rpm包上传到/opt/mysql目录下\r\n\r\n![image-20210926131106422](cloudDisk/markdown/JavaWeb笔记.assets/image-20210926131106422.png)\r\n\r\n做完如上步骤，你可以断开Xftp连接释放内存了。\r\n\r\n### 3. 删除系统自带mariadb\r\n\r\n**一、检查是否自带mariadb数据库**\r\n\r\n```\r\nrpm -qa|grep mariadb\r\n1\r\n```\r\n\r\n如果有，则返回给你一个标志，反之则没有返回。\r\n**二、删除mariadb数据库**\r\n**注意：如果你【rpm -qa|grep mariadb】没有返回值，则不需要执行如下命令。**\r\n\r\n```\r\nrpm -e --nodeps mariadb-libs-5.5.56-2.el7.x86_64\r\n```\r\n\r\n我的mariadb版本为：【5.5.56-2.el7.x86_64】\r\nmariadb版本可能会有差异，请以自己的版本为准，修改如上命令版本关键数。\r\n\r\n### 4. 安装Mysql\r\n\r\n一、进入/opt/mysql目录\r\n\r\n```\r\ncd /opt/mysql\r\n```\r\n\r\n二、rpm -ivh命令安装3个rpm包（第4个单拿出来谈）\r\n注意：你一定要按照顺序进行安装，因为rpm包之间相互依赖。\r\n注意：你一定要按照顺序进行安装，因为rpm包之间相互依赖。\r\n注意：你一定要按照顺序进行安装，因为rpm包之间相互依赖。\r\n\r\n```\r\nrpm -ivh mysql-community-common-5.7.26-1.el6.x86_64.rpm\r\nrpm -ivh mysql-community-libs-5.7.26-1.el6.x86_64.rpm\r\nrpm -ivh mysql-community-client-5.7.26-1.el6.x86_64.rpm\r\n```\r\n\r\n按照上述代码顺序，依次执行。\r\n\r\n![image-20210926131249287](cloudDisk/markdown/JavaWeb笔记.assets/image-20210926131249287.png)\r\n\r\n每次执行后，你如果看到了如图进度标志，则恭喜你安装成功了。\r\n最后，你需要再一次确认是否成功安装了3个rpm包，键入命令：\r\n\r\n```\r\nrpm -qa | grep mysql\r\n```\r\n\r\n它可以帮你查看当前mysql安装情况，请看下图，如果你也有则证明你可以继续进行了。\r\n\r\n![image-20210926131310292](cloudDisk/markdown/JavaWeb笔记.assets/image-20210926131310292.png)\r\n\r\n三、安装第四个rpm包（mysql-community-server-5.7.26-1.el6.x86_64.rpm）\r\n\r\n如果采用前3个npm包的安装方式（如果你的Linux系统yum安装了旧版本的GPG keys），就会出现报错，导致无法安装。但也很有可能yum安装的是新版本的GPG keys，那么将不会报错，为了不浪费你的时间，我宁愿多写一些。\r\n想了解【mysql-community-server-5.7.26-1.el6.x86_64.rpm】报错显示及解决方案请点击此处查看。\r\n\r\n进入正题，我们执行如下命令：\r\n\r\n```\r\nrpm -ivh mysql-community-server-5.7.26-1.el6.x86_64.rpm --force --nodeps\r\n```\r\n\r\n如果也出现了【#######100%】标志，那么恭喜你完成了Mysql的全部安装。\r\n\r\n### 5. 启动Mysql服务\r\n\r\n```\r\nservice mysqld start\r\n```\r\n\r\n![image-20210926131407526](cloudDisk/markdown/JavaWeb笔记.assets/image-20210926131407526.png)\r\n\r\n如果你看到了绿颜色的【OK】，那么你的Mysql可以工作了，但还需要以下设置。\r\n\r\n### 6. 获取自动生成的临时密码\r\n\r\n首次安装后，必须生成临时密码才能登录到Mysql客户端。\r\n注意：此命令是rpm方式安装Mysql才有的【mysqld.log】文件。\r\n如果你不是从本篇博客从前到后安装，请谨慎，因为它只对rpm方式安装的mysql有效\r\n\r\n```\r\ngrep \'temporary password\' /var/log/mysqld.log\r\n```\r\n\r\n![image-20210926131434413](cloudDisk/markdown/JavaWeb笔记.assets/image-20210926131434413-16326332749551.png)\r\n\r\n【 l)a_gg2R;21! 】就是你的临时密码\r\n\r\n### 7. 利用临时密码登录到Mysql客户端\r\n\r\nsudo mysql -u root -p \r\n\r\n会看到如图所示的password标志，输入刚刚临时生成的密码（输入密码时不可见）。\r\n\r\n![image-20210926131507871](cloudDisk/markdown/JavaWeb笔记.assets/image-20210926131507871.png)\r\n\r\n最后，你会看到如图状态，恭喜你，你成功了。\r\n\r\n### 8. 设置新的Mysql密码（不再使用临时密码）\r\n\r\n注意：在执行以下命令之前，请先看下方加粗字体 ↓\r\n\r\n```\r\nalter user \'root\'@\'localhost\' identified by \'@wjb13191835106\';\r\n```\r\n\r\n**我设置的密码为：@wjb13191835106**\r\n**注意：Mysql有自己的密码策略，【@wjb13191835106】不符合策略，如果没有修改过相关值，则这样执行会报错。**\r\n\r\n![image-20210926131601015](cloudDisk/markdown/JavaWeb笔记.assets/image-20210926131601015.png)\r\n\r\n（1）如果你只想设置一个简单的密码（关闭密码策略），请访问[这篇博文](https://blog.csdn.net/weixin_44198965/article/details/91870959)。\r\n（2）设置一个符合Mysql密码策略的复杂密码\r\n\r\n### 9. 授权root允许远程访问（可视化软件可以建立链接）\r\n\r\n请访问[这篇博文](https://blog.csdn.net/weixin_44198965/article/details/91877208)完成详细的设置\r\n\r\n```\r\ngrant all privileges on *.* to \'root\'@\'%\' identified by \'@wjb13191835106\'; \r\n```\r\n\r\n完成授权\r\n\r\n```\r\nflush privileges;\r\n```\r\n\r\n刷新授权\r\n\r\n### 10. 连接mysql\r\n\r\n关闭防火墙\r\n\r\n```\r\nservice iptables stop\r\nsystemctl stop firewalld\r\n```\r\n\r\n## 6. tomcat安装\r\n\r\nhttps://downloads.apache.org/tomcat/','2022-06-23 22:10:53','Java Web，是用Java技术来解决相关web互联网领域的技术栈。web包括：web服务端和web客户端两部分。Java在客户端的应用有Java Applet，不过使用得很少，Java在服务器端的应用非常的丰富，比如Servlet，JSP、第三方框架等等。Java技术对Web领域的发展注入了强大的动力。','cloudDisk\\markdown\\JavaWeb笔记.assets\\v2-a3e62eaf0fc00ea128596a53ce32563a_720w.jpg','原创','','','\0','Java Web笔记（下）','2022-06-23 22:10:53',5,101,NULL,0),(184,'','# Spring\r\ndi：依赖注入，表示创建对象，给属性赋值。\r\n\r\ndi：实现的方式语法有两种：\r\n\r\n1. 在spring的配置文件中，使用标签和属性完成，叫做基于XML和di实现\r\n2. 使用spring中的注解，完成属性的复制，叫做基于注解的di实现\r\n\r\ndi的语法分类：\r\n\r\n1. set注入（设置注入）：spring调用类的set方法，在set方法中可以以实现属性的赋值。80左右都是使用set注入\r\n2. 构造注入，spring调用类的有参构造方法，创建对象。在构造方法中完成赋值。\r\n\r\n实现步骤：\r\n\r\n1. 创建maven项目\r\n2. 加入maven的依赖\r\n   * spring的依赖\r\n   * junit依赖\r\n3. 创建类（接口和其他实现类）\r\n4. 创建spring需要的配置文件\r\n   * 声明类的信息，这些类由spring创建和管理\r\n5. 测试spring创建的\r\n\r\n# spring配置文件\r\n\r\n![image-20210929190801337](cloudDisk/markdown/Spring框架.assets/image-20210929190801337.png)\r\n\r\n```xml\r\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\r\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\r\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\">\r\n<!--\r\n    告诉spring创建对象\r\n    声明bean，就是告诉spring要创建某个类对象\r\n    id：对象的自定义名称，唯一值、spring通过这个名称找到对象\r\n    class：类的全限定名称（不能是就扣，因为spring是反射机制创建对象，必须是使用类）\r\n\r\n    spring就完成 SomeService someservice = new SomeServiceImpl();\r\n    spring是把创建好的对象放入map中，spring框架有一个存放的对象的。\r\n        spring.put(id的值，对象)；\r\n        例如 spring.put(\"someService\", new SomeServiceImpl());\r\n\r\n        一个bean标签声明一个对象\r\n-->\r\n\r\n    <bean id=\"someService\" class=\"com.tony.service.impl.SomeServicesImpl\"></bean>\r\n</beans>\r\n<!--\r\n    spring的配置文件\r\n    1. beans：根标签，spring把java对象转成bean\r\n    2. spring-beans.xsd 是约束文件，和mybatis指定 dtd是一样的\r\n-->\r\n```\r\n\r\n\r\n\r\n# 通过容器对象\r\n\r\n\r\n\r\n![image-20210929190712154](cloudDisk/markdown/Spring框架.assets/image-20210929190712154.png)\r\n\r\n```java\r\n    @Override\r\n    public void doSome() {\r\n        System.out.println(\"doSome执行了\");\r\n    }\r\n```\r\n\r\n测试\r\n\r\n```java\r\n    /*\r\n    * spring默认创建的时间：在创建spring容器时，会创建配置文件中的所有对象\r\n    * spring创建对象：默认调用的是无参构造方法\r\n    * */\r\n	@Test\r\n    public void test02(){\r\n        // 使用spring容器创建对象\r\n        // 1. 指定spring配置文件的名称\r\n        String config = \"spring.xml\";\r\n        // 2. 创建表示spring容器的对象，ApplicationContext\r\n        // ApplicationContext就是表示Spring容器，通过容器获取对象\r\n        // ClassPathXmlApplicationContext：表示类路径中加载spring的配置文件\r\n        ApplicationContext ac = new ClassPathXmlApplicationContext(config);\r\n\r\n        // 从容器中获取对象，你要调用对象的方法\r\n        // getBean(\"配置文件中的id值\")\r\n        SomeServices services = (SomeServices) ac.getBean(\"someService\");\r\n\r\n        // 使用spring创建好的方法\r\n        services.doSome();\r\n\r\n    }\r\n```\r\n\r\n# 获取spring容器中信息\r\n\r\n```java\r\n    /*\r\n    * 获取spring容器中 Java 对象的信息\r\n    * */\r\n    @Test\r\n    public void test03(){\r\n        String config = \"spring.xml\";\r\n        ApplicationContext ac = new ClassPathXmlApplicationContext(config);\r\n        // 使用spring提供的方法，获取容器中定义的对象的数量\r\n        int nums = ac.getBeanDefinitionCount();\r\n        System.out.println(\" 容器中定义的对象数量：\"+nums);\r\n        // 容器中每个定义对象的名称\r\n        String[] names = ac.getBeanDefinitionNames();\r\n        Arrays.stream(names).forEach(name -> System.out.println(name));\r\n    }\r\n```\r\n\r\n# 获取一个非自定义的对象\r\n\r\n```xml\r\n<bean id=\"myDate\" class=\"java.util.Date\"></bean>\r\n```\r\n\r\n```java\r\n    /*\r\n     * 获取一个非自定义的对象\r\n     * */\r\n    @Test\r\n    public void test04(){\r\n        String config = \"spring.xml\";\r\n        ApplicationContext ac = new ClassPathXmlApplicationContext(config);\r\n        Date date = (Date)ac.getBean(\"myDate\");\r\n        System.out.println(date.getTime());\r\n    }\r\n```\r\n\r\n# 设值注入，给student对象赋值\r\n\r\n```java\r\npublic class Student {\r\n    private String name;\r\n    private int age;\r\n\r\n    @Override\r\n    public String toString() {\r\n        return \"Student{\" +\r\n                \"name=\'\" + name + \'\\\'\' +\r\n                \", age=\" + age +\r\n                \'}\';\r\n    }\r\n\r\n    public void setName(String name) {\r\n        this.name = name;\r\n    }\r\n\r\n    public void setAge(int age) {\r\n        this.age = age;\r\n    }\r\n```\r\n\r\n```xml\r\n    <!--声明student对象\r\n        注入：就是赋值的意思\r\n        简单类型：spring中规定java的基本类型和string都是简单类型\r\n        di：给属性赋值\r\n        1. set注入（设置注入）：spring调用类的set方法，你可以在set方法中完成属性赋值\r\n        1）简单类型的set注入\r\n            <bean id=\"xx\" calss=\"yyy\">\r\n                <property name=\"属性名字\" value=\"此属性的值\"/>\r\n                一个property只能给一个属性赋值\r\n            </bean>\r\n    -->\r\n    <bean id=\"student\" class=\"com.tony.ba01.Student\">\r\n        <property name=\"name\" value=\"李四\"/>\r\n        <property name=\"age\" value=\"20\"/>\r\n    </bean>\r\n```\r\n\r\n```java\r\n    @Test\r\n    public void test01(){\r\n        String config = \"ba01/applicationContext.xml\";\r\n        ApplicationContext ac = new ClassPathXmlApplicationContext(config);\r\n\r\n        // 从容器中获取Student对象\r\n        Student student = (Student) ac.getBean(\"student\");\r\n        System.out.println(\"Student对象=\"+student);\r\n        // result:Student对象=Student{name=\'李四\', age=20}\r\n    }\r\n}\r\n```\r\n\r\n# 引用类型的set注入\r\n\r\n新建两个类\r\n\r\n```java\r\npublic class School {\r\n    private String name;\r\n    private String address;\r\n```\r\n\r\n```java\r\npublic class Student {\r\n    private String name;\r\n    private int age;\r\n    private School school;\r\n```\r\n\r\n配置文件\r\n\r\n```xml\r\n        2）引用类型的set注入：spring调用类的set方法\r\n        <bean id=\"xxx\" class=\"yyy\">\r\n            <property name=\"属性名称\" ref=\"bean的id(对象的名称)\">\r\n        </bean>\r\n    -->\r\n    <bean id=\"student\" class=\"com.tony.ba01.Student\">\r\n        <property name=\"name\" value=\"李四\"/>\r\n        <property name=\"age\" value=\"20\"/>\r\n        <property name=\"school\" ref=\"school\" />\r\n    </bean>\r\n    \r\n<!--    声明School对象-->\r\n    <bean id=\"school\" class=\"com.tony.ba01.School\">\r\n        <property name=\"name\" value=\"苏州大学\" />\r\n        <property name=\"address\" value=\"相门\" />\r\n    </bean>\r\n\r\n</beans>\r\n```\r\n\r\n```java\r\n    /*\r\n    * 非框架的创建方式\r\n    * */\r\n    @Test\r\n    public void test02(){\r\n        Student student = new Student();\r\n        student.setAge(20);\r\n        student.setName(\"张三\");\r\n        School school = new School();\r\n        school.setAddress(\"相门\");\r\n        school.setName(\"苏州大学\");\r\n        student.setSchool(school);\r\n        System.out.println(student);\r\n    }\r\n    /*\r\n    * 使用框架的创建方式\r\n    * */\r\n    @Test\r\n    public void test03(){\r\n        String config = \"ba01/applicationContext.xml\";\r\n        ApplicationContext ac = new ClassPathXmlApplicationContext(config);\r\n        Student student = (Student)ac.getBean(\"student\");\r\n        System.out.println(student);\r\n    }\r\n```\r\n\r\n# 构造注入\r\n\r\n配置文件\r\n\r\n```xml\r\n        2. 构造注入：spring调用类的有参构造方法，在创建对象的同时，在构造方法中给属性赋值\r\n           构造注入使用<constructor-arg> 标签\r\n           <constructor-arg> 标签：一个<constructor-arg>表示构造方法的一个参数\r\n           <constructor-arg>标签属性：\r\n                name：表示构造方法的形参名\r\n                index：表示构造方法的参数位置，参数从左往右的位置是 0 ，1， 2\r\n                value：构造方法的形参类型是简单类型的：使用value\r\n                ref：构造方法的形参类型是简单类型的：ref\r\n    -->\r\n<!--    使用name属性实现构造注入-->\r\n    <bean id=\"zhangsan\" class=\"com.tony.ba01.Student\" >\r\n        <constructor-arg name=\"name\" value=\"张三\" />\r\n        <constructor-arg name=\"age\" value=\"20\"/>\r\n        <constructor-arg name=\"school\" ref=\"school\"/>\r\n    </bean>\r\n\r\n    <bean id=\"wuliu\" class=\"com.tony.ba01.Student\" >\r\n        <constructor-arg index=\"0\" value=\"五六\" />\r\n        <constructor-arg index=\"1\" value=\"20\"/>\r\n        <constructor-arg index=\"2\" ref=\"school\"/>\r\n    </bean>\r\n               <!--    声明School对象-->\r\n    <bean id=\"school\" class=\"com.tony.ba01.School\">\r\n        <property name=\"name\" value=\"苏州大学\" />\r\n        <property name=\"address\" value=\"相门\" />\r\n    </bean>\r\n```\r\n\r\nStudent类\r\n\r\n```java\r\npublic class Student {\r\n    private String name;\r\n    private int age;\r\n    private School school;\r\n\r\n    public Student() {\r\n    }\r\n\r\n    public Student(String name, int age, School school) {\r\n        this.name = name;\r\n        this.age = age;\r\n        this.school = school;\r\n    }\r\n```\r\n\r\n测试\r\n\r\n```java\r\npublic class MyTest {\r\n    @Test\r\n    public void test01(){\r\n        String config = \"ba01/applicationContext.xml\";\r\n        ApplicationContext ac = new ClassPathXmlApplicationContext(config);\r\n        Student student = (Student)ac.getBean(\"zhangsan\");\r\n        System.out.println(\"student对象：\"+student);\r\n    }\r\n```\r\n\r\nresult\r\n\r\n```\r\nstudent对象：Student{name=\'张三\', age=20, school=School{name=\'苏州大学\', address=\'相门\'}}\r\n\r\n```\r\n\r\n# 复习\r\n\r\n```\r\n注入：就是赋值的意思\r\n简单类型：spring中规定java的基本类型和string都是简单类型\r\ndi：给属性赋值\r\n1. set注入（设置注入）：spring调用类的set方法，你可以在set方法中完成属性赋值\r\n1）简单类型的set注入\r\n    <bean id=\"xx\" calss=\"yyy\">\r\n        <property name=\"属性名字\" value=\"此属性的值\"/>\r\n        一个property只能给一个属性赋值\r\n    </bean>\r\n2）引用类型的set注入：spring调用类的set方法\r\n<bean id=\"xxx\" class=\"yyy\">\r\n    <property name=\"属性名称\" ref=\"bean的id(对象的名称)\">\r\n</bean>\r\n2. 构造注入：spring调用类的有参构造方法，在创建对象的同时，在构造方法中给属性赋值\r\n   构造注入使用<constructor-arg> 标签\r\n   <constructor-arg> 标签：一个<constructor-arg>表示构造方法的一个参数\r\n   <constructor-arg>标签属性：\r\n        name：表示构造方法的形参名\r\n        index：表示构造方法的参数位置，参数从左往右的位置是 0 ，1， 2\r\n        value：构造方法的形参类型是简单类型的：使用value\r\n        ref：构造方法的形参类型是简单类型的：ref\r\n```\r\n\r\n## Spring\r\n\r\n### 什么是spring\r\n\r\n1. 是一个框架，核心技术是ioc，aop，实现解耦合\r\n\r\n2. spring是一个容器，容器中存放的是java对象，需要做的是把对象放入到容器中\r\n\r\n### 怎么使用spring\r\n\r\n1. spring是一个容器，把项目中的对象存放到容器中\r\n2. 让容器完成对象的创建，对象之间关系的管理（属性赋值）\r\n3. 我们在程序中从容器中获取要使用的对象\r\n\r\n### 什么样的对象存放在容器中\r\n\r\n#### 1）dao类，service类，controller类，工具类\r\n\r\n1. 使用xml配置文件，使用\\<bean>\r\n2. 注解\r\n\r\n#### 2) spring中的对象默认都是单例的，在容器中叫1名称的1对象只有一个\r\n\r\n### 不放到spring容器中的对象\r\n\r\n1. 实体类对象，实体类的数据来自于数据库\r\n2. servlet，listener，filter等\r\n\r\n### 使用spring的步骤\r\n\r\n1. 加入依赖\r\n\r\n   * ```xml\r\n         <dependency>\r\n           <groupId>org.springframework</groupId>\r\n           <artifactId>spring-context</artifactId>\r\n           <version>5.2.5.RELEASE</version>\r\n         </dependency>\r\n     ```\r\n\r\n2. 创建类：接口，实现类，没有接口的类\r\n\r\n3. 创建spring的配置文件，使用<bean>声明对象\r\n\r\n4. 使用容器中的对象，通过ApplicationContext几口和他的实现类ClassPathXmlApplicationContext的方法getBean()\r\n\r\n### 核心技术\r\n\r\n#### ioc：控制反转\r\n\r\n1. 理论，思想，概念：指导开发人员在容器中，代码之外管理对象，给属性赋值，管理依赖\r\n2. ioc技术实现使用di（依赖注入）：开发人员在项目中只需要提供对象的名称，对象的创建，查找，赋值都由容器内部自己实现\r\n3. spring使用的是di的技术，底层使用的是反射机制\r\n4. di给属性赋值\r\n   1. set注入：spring调用类的set方法实现属性的赋值\r\n      * 简单类型的set注入<property name=\"属性名\" value=\"属性的值\" />\r\n      * 引用类型的set注入<property name=\"属性名\" ref=\"bean的i的id\"/>\r\n   2. 构造注入：spring调用有参构造方法\r\n      * <constructor-arg>的name属性，name表示构造方法的形参名\r\n      * <constructor-arg> 的index属性，表示构造方法的形参位置，从0开始\r\n\r\n# 案例 - 不改变代码，mysqlUserDaoImpl换成oracleUserDaoImpl\r\n\r\nservice\r\n\r\n```java\r\npublic class UserServiceImpl implements UserService {\r\n    // 引用类型，在xml文件中给属性赋值，要求属性有set方法\r\n    private UserDao dao = null;\r\n\r\n    public void setDao(UserDao dao) {\r\n        this.dao = dao;\r\n    }\r\n\r\n    @Override\r\n    public void addUser(User user) {\r\n        dao.insertUser(user);\r\n    }\r\n```\r\n\r\ndomain - User\r\n\r\n```java\r\npublic class User {\r\n    private String name;\r\n    private int age;\r\n```\r\n\r\nuserDao\r\n\r\n```java\r\npublic interface UserDao {\r\n    void insertUser(User user);\r\n}\r\n```\r\n\r\nuserDaoImpl - mysqlUserDaoImpl\r\n\r\n```java\r\npublic class mysqlUserDaoImpl implements UserDao {\r\n    @Override\r\n    public void insertUser(User user) {\r\n        System.out.println(\"mysql插入一个用户\");\r\n    }\r\n}\r\n\r\n```\r\n\r\nuserDaoImpl - OracleUserDaoImpl\r\n\r\n```java\r\npublic class OracleUserDaoImpl implements UserDao {\r\n    @Override\r\n    public void insertUser(User user) {\r\n        System.out.println(\"Oracle插入用户\");\r\n    }\r\n}\r\n```\r\n\r\nspring配置wenjian\r\n\r\n```xml\r\n<!--    你要用那个对象，就是要bean声明哪个对象-->\r\n    <bean id=\"mysqlDao\" class=\"com.tony.dao.impl.mysqlUserDaoImpl\"></bean>\r\n    <bean id=\"oracleDao\" class=\"com.tony.dao.impl.OracleUserDaoImpl\"></bean>\r\n\r\n\r\n<!--    声明service对象-->\r\n    <bean id=\"userService\" class=\"com.tony.service.Impl.UserServiceImpl\">\r\n<!--        set注入-->\r\n<!--        <property name=\"dao\" ref=\"mysqlDao\"/>-->\r\n        <property name=\"dao\" ref=\"oracleDao\"/>\r\n    </bean>\r\n```\r\n\r\nmain\r\n\r\n```java\r\npublic class MyApp {\r\n    public static void main(String[] args) {\r\n        String config = \"ba01/applicationContext.xml\";\r\n        ApplicationContext ac = new ClassPathXmlApplicationContext(config);\r\n        UserService userService = (UserService)ac.getBean(\"userService\");\r\n        User user = new User();\r\n        user.setAge(20);\r\n        user.setName(\"李四\");\r\n        userService.addUser(user);\r\n\r\n    }\r\n```\r\n\r\n# 自动注入\r\n\r\n引用类型的自动注入：spring框架根据某些规则可以给引用类型赋值。不用你在给引用类型赋值了\r\n\r\n使用的规则常用的是byName，byType\r\n\r\n1. byName（按名称注入）：java类中引用类型的属性名和spring容器中（配置文件）<bean>的id名称一样，且数据类型是一致的，这样的容器的bean，spring能够赋值给引用类型\r\n\r\n   * 语法：\r\n\r\n     ```xml\r\n         <bean id=\"student\" class=\"com.tony.Student\" autowire=\"byName\">\r\n             <property name=\"name\" value=\"李四\"/>\r\n             <property name=\"age\" value=\"20\" />\r\n         </bean>\r\n     ```\r\n\r\n2. byType(按类型注入)：java类中引用类型的数据类型和spring容器中（配置文件）<bean>的class属性是同源关系的，这样的bean能够赋值给引用类型\r\n\r\n   同源就是一类的意思：\r\n\r\n   1. java类中引用类型的数据类型和bean的class的值是一样的。\r\n   2. java类中引用类型的数据类型和bean的class的值父子类关系的。\r\n   3. java类中引用类型的数据类型和bean的class的值接口和实现类关系的。\r\n\r\n   * 语法：\r\n\r\n     ```\r\n     \r\n     ```\r\n\r\n# 多配置文件\r\n\r\n## 优势\r\n\r\n1. 每个文件的大小比一个文件要小很多，效率高\r\n2. 避免多人竞争带来的冲突\r\n\r\n如果项目有多个模块（相关的功能在一起），一个模块一个配置文件\r\n\r\n学生考勤模块一个配置文件，张三\r\n\r\n学生成绩一个配置文件，李四\r\n\r\n多配置文件分配方式\r\n\r\n1. 按功能模块，一个模块一个配置文件\r\n2. 按类的功能，数据库相关的配置一个配置文件，做事务的功能一个配置文件，做service功能的一个配置文件等\r\n\r\n示例：\r\n\r\n![image-20211005174233261](cloudDisk/markdown/Spring框架.assets/image-20211005174233261.png)\r\n\r\n```xml\r\n    <!--\r\n        关系配置文件\r\n        spring-total表示主配置文件：包含其他的配置文件的，主配置文件一般是不定义对象的。\r\n        语法：<import resource=\"其他配置文件路径\"/>\r\n        关键字：\"classpath=\" 表示类路径（class文件所在目录），\r\n	        在spring的配置文件中指定其他配置文件位置，需要实验classpath，告诉spring到哪去加载配置文件-->\r\n<!--加载的是文件列表-->\r\n<!--    <import resource=\"classpath:ba01/spring-school.xml\"/>-->\r\n<!--    <import resource=\"classpath:ba01/spring-student.xml\"/>-->\r\n\r\n<!--    在包含关系配置文件中，可以通配符(*:表示通配符)\r\n        注意：主配置文件名不能包含在通配符的范围内（不能叫做spring-total.xml）\r\n-->\r\n    <import resource=\"classpath:ba01/spring-*.xml\"/>\r\n```\r\n\r\n```xml\r\n    <bean id=\"shcool\" class=\"com.tony.School\" autowire=\"byType\">\r\n        <property name=\"name\" value=\"苏州大学\"/>\r\n        <property name=\"address\" value=\"苏州\" />\r\n    </bean>\r\n```\r\n\r\n```xml\r\n    <bean id=\"student\" class=\"com.tony.Student\" autowire=\"byType\">\r\n        <property name=\"name\" value=\"李四\"/>\r\n        <property name=\"age\" value=\"20\" />\r\n    </bean>\r\n```\r\n\r\n```result\r\nStudent{name=\'李四\', age=20, school=School{name=\'苏州大学\', address=\'苏州\'}}\r\n```\r\n\r\n# 注解\r\n\r\n## 创建对象\r\n\r\n基于注解的di：通过注解完成java对象的创建，属性赋值。\r\n\r\n使用注解的步骤\r\n\r\n1. 加入maven的依赖 spring-context，在你加入spring-context的同时，间接加入spring-aop的依赖\r\n\r\n   使用注解必须使用spring-aop依赖\r\n\r\n2. 在类中加入spring的注解（多个不同功能的注解）\r\n\r\n3. 在spring的配置文件中，加入一个组件扫描器的标签，说明注解在你的项目中的位置\r\n\r\n   学习的注解：\r\n\r\n   1. @Component\r\n   2. @Respotory\r\n   3. @Service\r\n   4. @Controller\r\n   5. @Value\r\n   6. Autowried\r\n   7. @ \r\n\r\n实例：\r\n\r\n配置文件\r\n\r\n```xml\r\n    <!--\r\n        声明组件三秒其（component-scan），组件就是java对象\r\n        base-package：指定注解在你的项目中的包名\r\n        component-scan工作方式：spring会扫描遍历base-package指定的包\r\n        把包中和子包中的所有类，找到类中的注解，按照注解的功能创建对象，或给属性赋值\r\n\r\n        加入了component-scan标签，配置文件的变化：\r\n            1. 加入一个新的约束文件spring-context.xsd\r\n            2. 给新的约束文件起个命名空间的名称\r\n    -->\r\n    <context:component-scan base-package=\"com.tony\"/>\r\n```\r\n\r\nStudent类\r\n\r\n```java\r\nimport org.springframework.stereotype.Component;\r\n/*\r\n* 创建对象的，等同于<bean>的功能\r\n*   属性：value 就是对象的名称，也就是bean的id值，\r\n*        value的值是唯一的，创建的对象在spring容器中就一个\r\n*   位置：在类的上面\r\n*\r\n* @Component(value = \"myStudent\") 等同于：\r\n* <bean id=\"myStudent\" class=\"com.tony.Student\">\r\n\r\n* spring中和@Component功能一致，创建对象的注解还有：\r\n* 1. @Repository（用在持久层类上面）：放在dao的实现类上面\r\n*   表示创建dao对象，dao对象是能访问数据库的\r\n* 2. @Service（用在业务层上面）：放在service的实现类上面\r\n*   创建service对象，service对象是做业务处理，可以有事务等功能的\r\n* 3. @Controller（用在控制器上米娜）：放在控制器（处理器）类的上面，创建控制器对象\r\n*   控制器对象能接受用户提交的参数，显示请求的处理结果\r\n* 以上的三个注解的使用语法和Component一样，都能够有创建对象，但是这三个注解还有额外的功能。\r\n* @Controller， @Service，@Repository 是给项目对象分层的。\r\n*\r\n* */\r\n// 使用value属性指定对象名称\r\n//@Component(value = \"myStudent\")\r\n//@Component(\"myStudent\")\r\n@Component\r\npublic class Student {\r\n    private String name;\r\n    private int age;\r\n    private School school;\r\n```\r\n\r\n测试\r\n\r\n```java\r\npublic class MyTest {\r\n    @Test\r\n    public void test01(){\r\n        String config = \"applicationContext.xml\";\r\n\r\n        ApplicationContext ac = new ClassPathXmlApplicationContext(config);\r\n        Student student = (Student)ac.getBean(\"student\");\r\n        System.out.println(student);\r\n    }\r\n```\r\n\r\n## @Value(\"北京\")基本类型属性赋值\r\n\r\n```java\r\n    /*\r\n    * 简单类型赋值\r\n    * 属性：value，表示简单类型的属性值\r\n    * 位置：1.属性定义上面，无需set方法，推荐使用\r\n    *       2. 在set方法的上面\r\n    * */\r\n    @Value(value = \"张三\")\r\n    private String name;\r\n    @Value(\"20\")\r\n    private int age;\r\n```\r\n\r\n## @Autowired引用类型的属性赋值(byType)\r\n\r\n```java\r\n@Component(\"mySchool\")\r\npublic class School {\r\n    @Value(\"北京大学\")\r\n    private String name;\r\n    @Value(\"北京\")\r\n    private String address;\r\n```\r\n\r\n```java\r\n    /*\r\n    * 引用类型\r\n    * @Autowired: spring框架提供的注解，实现引用类型赋值，使用的是自动注入原理，支持byName，byType\r\n    默认使用的是byType自动注入\r\n     */\r\n    @Autowired\r\n    private School school;\r\n```\r\n\r\n\r\n\r\n![image-20211010225941943](cloudDisk/markdown/Spring框架.assets/image-20211010225941943.png)\r\n\r\n## 引用类型的属性赋值(byName)\r\n\r\n```java\r\n    * 使用byName方式\r\n    * 1. 属性上方加注解\r\n    * 2. 属性上面加入@Qualifier(value=\"bean的id\") ： 表示使用指定名称的bean完成属性的赋值\r\n    * 如：   @Autowired\r\n            @Qualifier(value = \"mySchool\")\r\n            private School school;\r\n     */\r\n    @Autowired\r\n    @Qualifier(value = \"mySchool\")\r\n    private School school;\r\n```\r\n\r\n### 注解属性\r\n\r\n```java\r\n    * 属性：required：是一个boolen类型，默认true\r\n    *   required=true  表示：引用类型属性赋值失败，代码终止执行\r\n    *   required=false  表示：引用类型如果赋值失败，程序正常执行，引用类型被设置为null\r\n```\r\n\r\n## 使用resource注解，给引用类型属性赋值（相比上面两个智能）\r\n\r\n```java\r\n    /*\r\n    @Resource：来自jdk的注解，spring框架提供了对这个注解的功能指出，可以使用他给的引用类型赋值\r\n        使用的也是自动注入原理，支持byName，byType，默认byName\r\n    位置：1. 定义在属性上面，无需set方法，推荐使用\r\n        2. 在set方法上面\r\n* */\r\n    // 默认使用byName:先使用byName自动注入，如果byName赋值失败，再使用byType\r\n//    @Resource(name = \"mySchool\")\r\n    @Autowired(required = true)\r\n    @Resource\r\n    private School school;\r\n```\r\n\r\n## @Configuration注解\r\n\r\nSpring @Configuration注解\r\n\r\nSpring3.0开始，@Configuration用于定义配置类，定义的配置类可以替换xml文件，一般和@Bean注解联合使用。\r\n\r\n@Configuration注解主要标注在某个类上，相当于xml配置文件中的<beans>\r\n\r\n@Bean注解主要标注在某个方法上，相当于xml配置文件中的<bean>\r\n\r\n![img](cloudDisk/markdown/Spring框架.assets/202004161021529.png)\r\n\r\n等价于\r\n\r\n![img](cloudDisk/markdown/Spring框架.assets/2020041610215210.png)\r\n\r\n注意：@Configuration注解的配置类有如下要求：\r\n\r\n- @Configuration不可以是final类型；\r\n- @Configuration不可以是匿名类；\r\n- 嵌套的configuration必须是静态类。\r\n\r\nConfiguration里面有一个component组件来标识，说明此类也是一个bean，可以被调用，来看看哪些主要的注解含有component：\r\n\r\nAnnotation 的装配 Spring 中，尽管使用 XML 配置文件可以实现 Bean 的装配工作，但如果应用中有很多 Bean 时，会导致 XML 配置文件过于靡肿，给后续的维护和升级工作带来一定的困难 为此， Spring 提供了对 Annotation (注解)技术的全面支持 Spring 中定义了一系列的注解，常用的注解如下所示\r\n\r\n- • @Component: 可以使用此注解描述 Spring 中的 Bean ，但它是一个泛化的概念，仅仅表 示一个组件 (Bean ，并且可以作用在任何层次 使用时只需将该注解标注在相应类上即可\r\n- • @Repository: 用于将数据访问层( DAO 层)的类标识为 Spring 中的 Bean ，其功能与 @Component 相同\r\n- • @Service: 通常作用在业务层( Service ，用于将业务层的类标识为 Spring 中的 Bean 其功能与@Component 相同\r\n- • @Controller: 通常作用在控制层(如 Spring MVC Controller ，用于将控制层的类标识 Spring 中的 Bean ，其功能与@Component 相同\r\n- • @Autowired: 用于对 Bean 的属性变量、属性的 setter 方法及构造方法进行标注，配合对 应的注解处理器完成 Bean 的自动配置工作 默认按照 Bean 的类型进行装配\r\n- • @Resource: 其作用与 Autowired 一样 其区别在于@Autowired 默认按照 Bean 类型装 配，而@Resource 默认按照 Bean 实例名称进行装配 @Resource 中有两个重要属性: name type Spring name 属性解析为 Bean 实例名称， type 属性解析为 Bean 实例类型 如果 指定 name 属性，贝IJ 按实例名称进行装配;如果指定 type 属性，则按 Bean 类型进行装配;如 果都不指定，则先按 Bean 实例名称装配，如果不能匹配，再按照 Bean 类型进行装自己;如果都 无法匹配，则抛出 NoSuchBeanDefinitionException 异常\r\n- • @Qualifier: @Autowired 注解配合使用，会将默认的按 Bean 类型装配修改为接 Bean 的实例名称装配， Bean 的实例名称由 @Qualifier 注解的参数指定 在上面几个注解中，虽然@Repository @Service @Controller 功能与@Component 注解 的功能相同，但为了使标注类本身用途更加清晰，建议在实际开发中使用@Repository @Service @Controller 分别对实现类进行标注 下面。\r\n\r\n**@Configuration\r\n\r\n**\r\n\r\n这里的@Configuration对我们来说不陌生，它就是JavaConfig形式的Spring Ioc容器的配置类使用的那个@Configuration，SpringBoot社区推荐使用基于JavaConfig的配置形式，所以，这里的启动类标注了@Configuration之后，本身其实也是一个IoC容器的配置类。\r\n\r\n举几个简单例子回顾下，XML跟config配置方式的区别：\r\n\r\n表达形式层面\r\n\r\n基于XML配置的方式是这样：\r\n\r\n```xml\r\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\r\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\r\n    xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd\"\r\n    default-lazy-init=\"true\">\r\n  <!--bean定义-->\r\n</beans>\r\n```\r\n\r\n而基于JavaConfig的配置方式是这样：\r\n\r\n```java\r\n@Configuration\r\npublic class MockConfiguration{\r\n  //bean定义\r\n}\r\n```\r\n\r\n任何一个标注了@Configuration的Java类定义都是一个JavaConfig配置类。\r\n\r\n注册bean定义层面\r\n基于XML的配置形式是这样：\r\n\r\n```xml\r\n<``bean` `id``=``\"mockService\"` `class``=``\"..MockServiceImpl\"``>\r\n ``...\r\n</``bean``>\r\n```\r\n\r\n而基于JavaConfig的配置形式是这样的：\r\n\r\n```java\r\n@Configuration\r\npublic class MockConfiguration{\r\n  @Bean\r\n  public MockService mockService(){\r\n    return new MockServiceImpl();\r\n  }\r\n}\r\n```\r\n\r\n任何一个标注了@Bean的方法，其返回值将作为一个bean定义注册到Spring的IoC容器，方法名将默认成该bean定义的id。\r\n\r\n表达依赖注入关系层面\r\n为了表达bean与bean之间的依赖关系，在XML形式中一般是这样：\r\n\r\n```xml\r\n<bean id=\"mockService\" class=\"..MockServiceImpl\">\r\n  <propery name =\"dependencyService\" ref=\"dependencyService\" />\r\n</bean>\r\n \r\n<bean id=\"dependencyService\" class=\"DependencyServiceImpl\"></bean>\r\n```\r\n\r\n而基于JavaConfig的配置形式是这样的：\r\n\r\n```java\r\n@Configuration\r\npublic` `class` `MockConfiguration{\r\n ``@Bean\r\n ``public` `MockService mockService(){\r\n  ``return` `new` `MockServiceImpl(dependencyService());\r\n ``}\r\n ``@Bean\r\n ``public` `DependencyService dependencyService(){\r\n  ``return` `new` `DependencyServiceImpl();\r\n ``}\r\n}\r\n```\r\n\r\n```java\r\npublic class SpringConfigurationApplication {\r\n    public static void main(String[] args) {\r\n//        AnnotationConfigApplicationContext context = = new AnnotationConfigApplicationContext(MyConfiguration.class)\r\n          // 因为我们加载的@Configuration 是基于注解形式的，所以需要创建AnnotationConfigApplicationContext\r\n        AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext();\r\n        // 注册MyConfiguration 类并刷新bean 容器。\r\n        context.register(MyConfiguration.class);\r\n        context.refresh();\r\n    }\r\n}\r\n```\r\n\r\n## @Bean注解\r\n\r\n```java\r\n@Component\r\n@Data\r\n@AllArgsConstructor\r\n@NoArgsConstructor\r\npublic class User {\r\n    private Integer id;\r\n    private String name;\r\n    private String password;\r\n\r\n    @Bean\r\n    public User u1(User u2){\r\n        System.out.println(u2);\r\n        return new User(1, \"tony\", \"123\");\r\n    }\r\n    @Bean(name = \"u2\")\r\n    public User u2(){\r\n        return new User(2, \"王五\", \"123\");\r\n    }\r\n    @Bean\r\n    public User u3(){\r\n        return new User(3, \"李四\", \"123\");\r\n    }\r\n\r\n}\r\n```\r\n\r\n* @Component spring扫描该包\r\n* @Bean将该方法的返回值注入到spring容器中\r\n  * 默认的bean标签的id为方法名\r\n  * @Bean(name = \"u2\")，指定bean的id为u2\r\n\r\n测试：\r\n\r\n```java\r\n    @Qualifier(value = \"u1\")\r\n    @Autowired\r\n    User user1;\r\n\r\n    @Resource(name = \"u2\")\r\n    User user2;\r\n    \r\n    @Autowired\r\n    User user;\r\n\r\n    @Test\r\n    void test(){\r\n        System.out.println(\"u1: \" + user1); // User(id=1, name=tony, password=123)\r\n        System.out.println(\"u2: \" + user2); // User(id=2, name=王五, password=123)\r\n        System.out.println(\"user: \" + user); // User(id=null, name=null, password=null)\r\n    }\r\n```\r\n\r\n## @ComponentScan\r\n\r\n```java\r\n@Configuration  //作为配置类,替代xml配置文件\r\n@ComponentScan(basePackages = {\"com.yys\"}) //  扫描这个包下注解\r\npublic class SpringConfig {\r\n}\r\n```\r\n','2022-06-23 22:15:55','“We use a lot of the tools that come with the Spring framework and reap the benefits of having a lot of the out of the box solutions, and not having to worry about writing a ton of additional code—so ','/cloudDisk/markdown/20220623093950_df751c4a_1655948390627.png','原创','','','\0','Spring框架学习笔记（上）','2022-06-23 22:15:55',4,102,NULL,0),(185,'','# AOP面向切面编程\r\n\r\n## 动态代理\r\n\r\n* 不改变代码，使代码功能增强\r\n\r\n## jdk动态代理实现步骤\r\n\r\n1. 创建目标类，SomerServiceImpl目标类，给他的doSome，doOther增加输出时间，事务\r\n2. 创建InvocationHandler接口实现类，在这个类实现给目标方法增加功能\r\n3. 使用jdk中类Proxy，创建代理对象，实现创建对象的能力\r\n\r\n### 代码实现\r\n\r\n![image-20211011222110227](cloudDisk/markdown/Spring框架.assets/image-20211011222110227.png)\r\n\r\nutil\r\n\r\n```java\r\npublic class ServiceTools {\r\n    public static void doLogs(){\r\n        System.out.println(\"非业务方法，logs\");\r\n    }\r\n    public static void doTrans(){\r\n        System.out.println(\"非业务方法，trans\");\r\n    }\r\n}\r\n\r\n```\r\n\r\n现有两个业务方法，对他们进行功能加强\r\n\r\n```java\r\npublic class SomeServiceImpl implements SomeService {\r\n    @Override\r\n    public void doSome() {\r\n        System.out.println(\"doSome方法\");\r\n    }\r\n\r\n    @Override\r\n    public void doOthers() {\r\n        System.out.println(\"doOthers方法\");\r\n    }\r\n}\r\n```\r\n\r\n创建一个类，实现InvocationHandler\r\n\r\n```java\r\npublic class MyInvocationHandler implements InvocationHandler {\r\n    // 目标对象\r\n    private Object target; // SomeServiceImpl类\r\n\r\n    public MyInvocationHandler(Object target) {\r\n        this.target = target;\r\n    }\r\n\r\n    @Override\r\n    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\r\n        // 通过代理对象执行方法时，会调用这个invoke（）\r\n        // 执行目标类的方法，通过Method类实现\r\n        Object res = null;\r\n        String methodName = method.getName();\r\n\r\n        if (\"doSome\".equals(methodName)){\r\n            ServiceTools.doLogs();\r\n            // 执行目标类方法，通过Method类实现\r\n            res = method.invoke(target, args);\r\n            ServiceTools.doTrans();\r\n        }else {\r\n            res = method.invoke(target, args);\r\n        }\r\n        // 目标方法执行结果\r\n        return res;\r\n    }\r\n}\r\n```\r\n\r\n测试\r\n\r\n```java\r\n    @Test\r\n    public void test(){\r\n        //        使用jdk的Proxy创建代理对象\r\n        SomeService target = new SomeServiceImpl();\r\n\r\n//        创建invocationHandler对象\r\n        InvocationHandler handler = new MyInvocationHandler(target);\r\n\r\n        // 使用Proxy创建代理\r\n        SomeService someService = (SomeService)Proxy.newProxyInstance(target.getClass().getClassLoader(),\r\n                target.getClass().getInterfaces(),\r\n                handler);\r\n\r\n        // 通过代理执行方法，会调用Handler中的invoke（）\r\n        someService.doSome();\r\n        System.out.println(\"__________________________________\");\r\n        someService.doOthers();\r\n    }\r\n```\r\n\r\n![image-20211011222326826](cloudDisk/markdown/Spring框架.assets/image-20211011222326826.png)\r\n\r\n## AOP\r\n\r\n1. 动态代理\r\n\r\n   **实现方式：**jdk动态代理，使用jdk中的Proxy，Method，InocationHandler创建代理对象\r\n\r\n   ​	jdk动态代理要求目标类必须实现接口\r\n\r\n   **oglib动态代理：**第三方的工具库，创建代理对象，原理是继承，通过继承目标类，创建子类\r\n\r\n   ​	子类就是代理对象。要求目标不能是final的，方法也不能是final的\r\n\r\n2. 动态代理作用\r\n\r\n   1. 在目标类代码不改变的情况下增加功能\r\n   2. 减少代码的重复\r\n   3. 专注业务逻辑代码\r\n   4. 解耦合，让业务功能和日志，事务非业务功能分离\r\n\r\n3. **Aop：面向切面编程**，基于动态代理的，可以使用jdk，oglib两种代理方式\r\n\r\n   Aop就是动态代理的规范化，把动态代理的实现步骤，方法都定义好了，让开发人员用一种统一的方式，就用使用动态代理。\r\n\r\n4. AOP(Aspect Orient Programmin) 面向切面编程\r\n\r\n   Asepect：切面，给你的目标类增加的功能，就是切面。像上面用的日志，事务都是切面\r\n\r\n   * 切面的特点：一般都是非业务方法，独立使用的。\r\n\r\n   Orient：面向，对着\r\n\r\n   Programming：编程\r\n\r\n   oop：面向对象编程\r\n\r\n   怎么理解面向切面编程？\r\n\r\n   1. **需要在分析项目功能时，找出切面**\r\n   2. **合理的安排切面的执行时间（在目标方法前，还是目标方法后）**\r\n   3. **合理的安排切面执行的位置，在哪个类，哪个方法增加增强功能**\r\n\r\n   术语：\r\n\r\n   1. Aspect：切面，表示增强的功能，就是一堆代码，完成某个功能，非业务功能\r\n      * 常见的切面有日志，事务，统计信息，参数检查，权限验证\r\n   2. JoinPoint：连接点，连接业务方法和切面的位置。就是某个类的业务方法\r\n   3. Pointcut：切入点，指多个连接点的集合。多个方法\r\n   4. 目标对象：给哪个类的方法增加功能，这个类就是目标对象\r\n   5. Adivice：通知，通知表示切面功能执行的时间。\r\n\r\n   说一个切面有三个关键要素\r\n\r\n   1. 切面的功能代码，功能是什么\r\n   2. 切面的执行位置，使用Pointcut表示切面执行的位置\r\n   3. 切面的执行时间，使用Advice表示时间，在目标方法之前，还是目标方法之后、\r\n\r\n5. aop实现\r\n\r\n   aop是一个规范，是动态的一个规范化，一个标准\r\n\r\n   aop的技术框架：\r\n\r\n   1. spring：spring在内部实现了aop规范，能做aop工作\r\n      * spring主要在事务处理时使用aop\r\n      * 我们的项目开发中很少使用spring的aop实现。因为spring的aop比较笨重。\r\n   2. aspectJ：一个开源的专门做aop的框架。spring框架中集成了aspectJ框架，通过spring就能使用aspectJ的功能。aspectJ框架实现aop有两种方式\r\n      1. 使用xml的配置文件：配置全局事务\r\n      2. 使用注解，我们在项目中要做aop功能，一般使用注解，aspectJ有5个注解\r\n\r\n6. 学习aspectJ框架的使用\r\n\r\n   1. 切面的执行时间，这个执行时间在规范中叫做Advice（通知，增强）\r\n\r\n      * 在aspectJ框架中使用注解表示的。也可以使用xml配置文件中的标签\r\n        1. @Before\r\n        2. @AfterReturning\r\n        3. @Around\r\n        4. @AfterThrowing\r\n        5. @After\r\n\r\n   2. 表示切面的执行位置，使用的是切面表达式![image-20211012190759050](cloudDisk/markdown/Spring框架.assets/image-20211012190759050.png)\r\n\r\n      ![image-20211012191209808](cloudDisk/markdown/Spring框架.assets/image-20211012191209808.png)\r\n\r\n      ![image-20211012192603193](cloudDisk/markdown/Spring框架.assets/image-20211012192603193.png)\r\n\r\n      \r\n\r\n## 使用aspectJ框架实现aop\r\n\r\n使用aspectJ实现aop的基本步骤：\r\n\r\n1. 新建maven项目\r\n\r\n2. 加入依赖\r\n\r\n   1. spring依赖\r\n   2. aspectJ依赖\r\n   3. junit单元测试\r\n\r\n3. 创建目标类：接口和它的实现类\r\n\r\n   要做的是给类中的方法进行增强\r\n\r\n4. 创建切面类：普通类\r\n\r\n   1. 在类的上面加入 @Aspect\r\n\r\n   2. 在类中定义方法，方法就是切面要执行的功能代码\r\n\r\n      在方法的上面加入apectj中的通知注解，例如@Before\r\n\r\n      在需要指定切入点表达式execution()\r\n\r\n5. 创建spring配置文件：声明对象，把对象交给容器统一管理\r\n\r\n   声明对象可以使用注解或者xml配置文件<bean>\r\n\r\n   1. 声明目标对象\r\n\r\n   2. 声明切面类对象\r\n\r\n   3. 声明aspectj框架中的自动代理生成器标签\r\n\r\n      自动代理生成器：用来完成代理对象的自动创建功能的\r\n\r\n6. 创建测试类，从spring容器中获取目标对象（实际就是代理对象）\r\n\r\n   通过代理执行方法，实现aop的功能增强。\r\n\r\n### 代码实现- 前置通知\r\n\r\n![image-20211013193102426](cloudDisk/markdown/Spring框架.assets/image-20211013193102426.png)\r\n\r\n#### 加入依赖\r\n\r\n```xml\r\n <dependencies>\r\n    <dependency>\r\n      <groupId>junit</groupId>\r\n      <artifactId>junit</artifactId>\r\n      <version>4.11</version>\r\n      <scope>test</scope>\r\n    </dependency>\r\n    <dependency>\r\n      <groupId>org.springframework</groupId>\r\n      <artifactId>spring-context</artifactId>\r\n      <version>5.2.5.RELEASE</version>\r\n    </dependency>\r\n    <dependency>\r\n      <groupId>org.springframework</groupId>\r\n      <artifactId>spring-aspects</artifactId>\r\n      <version>5.2.17.RELEASE</version>\r\n    </dependency>\r\n  </dependencies>\r\n```\r\n\r\n#### 目标类/实现类\r\n\r\n```java\r\npublic class SomeServiceImpl implements SomeService {\r\n    @Override\r\n    public void doSome(String name, Integer age) {\r\n        // 给doSome方法增加一个功能，在doSome方法执行之前，打印时间\r\n        System.out.println(\"目标方法doSome\");\r\n    }\r\n}\r\n```\r\n\r\n#### 切面类\r\n\r\n```java\r\n/*\r\n* @Aspect : 是aspectj框架中注解\r\n*   作用：表示当前类是切面类\r\n*   切面类：是用来给业务方法增加功能的类，这个类中有切面的功能代码\r\n*   位置：在类定义上面\r\n*\r\n* */\r\n@Aspect\r\npublic class MyAspect {\r\n    /*\r\n    * 定义方法，方法是实现切面功能的\r\n    * 方法的定义要求：\r\n    *   1. 公共方法 public\r\n    *   2. 方法没有返回值\r\n    *   3. 方法名称自定义\r\n    *   4. 方法可有参，也可无\r\n    *   如果有参数，参数不是自定义的，有几个参数类型可以使用\r\n    *\r\n    * */\r\n    /*\r\n    * @Before: 前置通知注解\r\n    * 属性：value，切入点表达式，表示切面的功能执行位置\r\n    * 位置：方法的上面\r\n    * 特点：\r\n    *   1. 在目标方法之前执行\r\n    *   2. 不会改变目标方法的执行结果\r\n    *   3. 不会影响目标方法的执行\r\n    * */\r\n    @Before(value = \"execution(public void com.tony.service.impl.SomeServiceImpl.doSome(String,Integer))\")\r\n    public void myBefore(){\r\n        // 就是切面执行的功能代码\r\n        System.out.println(\"前置通知，切面功能，在目标方法前输出执行时间：\"+ new Date());\r\n\r\n    }\r\n}\r\n```\r\n\r\n#### 配置文件\r\n\r\n```xml\r\n<!--    声明目标对象-->\r\n    <bean id=\"someService\" class=\"com.tony.service.impl.SomeServiceImpl\"/>\r\n<!--    声明切面类对象-->\r\n    <bean id=\"myAspect\" class=\"com.tony.MyAspect\"/>\r\n<!--    声明自动代理生成器：使用aspectj矿建内部的功能，创建目标对象的代理对象\r\n        创建代理对象是在内存中实现的，修改目标对象的内存中结构。创建为代理对象\r\n        所以目标对象就是被修改后的代理对象\r\n\r\n        aspectj-autoproxy: 会把spring容器中的所有目标对象，都生成代理对象\r\n    -->\r\n    <aop:aspectj-autoproxy />\r\n```\r\n\r\n#### 测试类\r\n\r\n```java\r\n    @Test\r\n    public void test01(){\r\n        String config = \"applicationContext.xml\";\r\n        ApplicationContext ac = new ClassPathXmlApplicationContext(config);\r\n        SomeService someService = (SomeService) ac.getBean(\"someService\");\r\n        someService.doSome(\"tony\",21);\r\n\r\n    }\r\n```\r\n\r\n### 通知方法中的参数\r\n\r\n```java\r\n   /*\r\n    * 指定通知方法中的参数 joinPoint\r\n    * joinPoint：业务方法，要加入切面功能的业务方法\r\n    *   作用是：可以在通知方法中获取方法执行时的信息，例如方法名称，方法的实参\r\n    *   如果你的功能中需要用到方法的信息，就加入joinPoint\r\n    * 这个joinPoint参数值是由框架赋予，必须是第一个位置的参数\r\n    * */\r\n    @Before(value = \"execution(* com.tony..doSome(..))\")\r\n    public void myBefore(JoinPoint jp){\r\n        // 获取方法的完整定义\r\n        System.out.println(\"方法的定义：\"+jp.getSignature());\r\n        System.out.println(\"方法的名称：\"+jp.getSignature().getName());\r\n        // 获取方法的实参\r\n        Object[] args = jp.getArgs();\r\n        for (Object arg :\r\n                args) {\r\n            System.out.println(\"参数：\"+arg);\r\n        }\r\n        // 就是切面执行的功能代码\r\n        System.out.println(\"前置通知，切面功能，在目标方法前输出执行时间：\"+ new Date());\r\n    }\r\n```\r\n\r\n![image-20211014195225566](cloudDisk/markdown/Spring框架.assets/image-20211014195225566.png)\r\n\r\n### 后置通知\r\n\r\n#### 目标类\r\n\r\n```java\r\n    @Override\r\n    public Student doOther(String name, Integer age) {\r\n        System.out.println(\"目标方法doOther\");\r\n        Student student = new Student();\r\n        student.setAge(age);\r\n        student.setName(name);\r\n        return student;\r\n    }\r\n```\r\n\r\n#### Student类\r\n\r\n```java\r\npublic class Student {\r\n    private String name;\r\n    private int age;\r\n```\r\n\r\n#### 切片类\r\n\r\n```java\r\n    /*\r\n    * 后置通知定义方法，方法是实现切面功能的\r\n    * 方法的定义要素：\r\n    *   1. 公共方法 public\r\n    *   2. 方法没有返回值\r\n    *   3. 方法名称自定义\r\n    *   4. 方法有参数的，推荐Object，参数名自定义\r\n    * */\r\n    /*\r\n    * @AfterReturning : 后置通知\r\n    *   属性： 1. value 切入点表达式\r\n    *         2. returning 自定义的变量，表示目标方法的返回值的\r\n    *           自定义的变量名必须和通知方法的形参名必须一样\r\n    *   位置：在方法定义的上面\r\n    * 特点：\r\n    *   1. 在目标方法之后执行\r\n    *   2. 能够获取到目标方法的返回值，可以根据这个返回值做不同的处理功能\r\n    *   3. 可以修改这个返回值\r\n    * 后置通知的执行：\r\n    *   Object res = doOther();\r\n    *   myAfterReturning(res);\r\n    *   sout(\"res=\"+res)\r\n    * */\r\n    /*\r\n    * 改目标方法的返回值res，测试方法执行后，会不会改变？\r\n    * 如果目标方法的返回值是基本数据类型，在此改变返回值，测试类中执行是不会改变的\r\n    * 如果目标方法的返回值是引用数据类型，在此改变返回值，测试类中执行是会改变的\r\n    * */\r\n    @AfterReturning(value = \"execution(* *..SomeServiceImpl.doOther(..))\",returning = \"res\")\r\n    public void myAfter(Object res){\r\n        // Object res: 是目标方法执行后的返回值，根据返回值做切面功能的处理\r\n        System.out.println(\"后置通知：在目标方法后执行，获取的返回值是\"+res);\r\n        Student student = (Student) res;\r\n        student.setName(\"tony\");\r\n    }\r\n```\r\n\r\n#### 测试类\r\n\r\n```java\r\n    @Test\r\n    public void test01(){\r\n        String config = \"applicationContext.xml\";\r\n        ApplicationContext ac = new ClassPathXmlApplicationContext(config);\r\n        SomeService someService = (SomeService) ac.getBean(\"someService\");\r\n        someService.doSome(\"tony\",21);\r\n        System.out.println(\"----------------\");\r\n        Student student = someService.doOther(\"zxx\", 21);\r\n        System.out.println(student);\r\n    }\r\n```\r\n\r\n![image-20211014203308993](cloudDisk/markdown/Spring框架.assets/image-20211014203308993.png)\r\n\r\n### 环绕通知\r\n\r\n#### 配置文件\r\n\r\n```xml\r\n<!--    声明目标对象-->\r\n    <bean id=\"someService\" class=\"com.tony.service.impl.SomeServiceImpl\"/>\r\n<!--    声明切面类对象-->\r\n    <bean id=\"myAspect\" class=\"com.tony.MyAspect\"/>\r\n<!--    声明自动代理生成器：使用aspectj矿建内部的功能，创建目标对象的代理对象\r\n        创建代理对象是在内存中实现的，修改目标对象的内存中结构。创建为代理对象\r\n        所以目标对象就是被修改后的代理对象\r\n\r\n        aspectj-autoproxy: 会把spring容器中的所有目标对象，都生成代理对象\r\n    -->\r\n    <aop:aspectj-autoproxy />\r\n```\r\n\r\n\r\n\r\n#### 目标方法\r\n\r\n```java\r\n    @Override\r\n    public String doFirst(String name, Integer age) {\r\n        System.out.println(\"目标方法doFirst\");\r\n        return null;\r\n    }\r\n```\r\n\r\n#### 切面类\r\n\r\n```java\r\n/*\r\n* @Aspect : 是aspectj框架中注解\r\n*   作用：表示当前类是切面类\r\n*   切面类：是用来给业务方法增加功能的类，这个类中有切面的功能代码\r\n*   位置：在类定义上面\r\n*\r\n* */\r\n@Aspect\r\npublic class MyAspect {\r\n    /*\r\n    * 环绕通知方法的定义格式\r\n    * 1. public\r\n    * 2. 必会有一个返回值，推荐使用Object\r\n    * 3. 方法名称自定义\r\n    * 4. 方法有参数，固定的参数： PeoceedingJoinPoint\r\n    */\r\n\r\n    /*\r\n    * @Around：环绕通知\r\n        属性：value 切入点表达式\r\n        位置：在方法的定义什么\r\n      特点：\r\n        1. 它是功能最强的通知\r\n        2. 在目标方法前后都能增强功能\r\n        3. 控制目标方法是否被调用执行\r\n        4. 修改原来的目标方法的执行结果。影响最后的调用结果、\r\n\r\n    * 环绕通知，等同于JDK动态代理中的，InvocationHandler接口\r\n    * 参数：ProceedingJoinPoint 等同于Method\r\n    *   作用：执行目标方法\r\n    * 返回值：就是目标方法的执行结果，可以被修改\r\n    *\r\n    * 环绕通知：经常做事务，在目标方法之前开启事务，执行目标方法，在目标方法之后，提交事务\r\n     */\r\n    @Around(value = \"execution(* *..SomeServiceImpl.doFirst(..))\")\r\n    public Object myAround(ProceedingJoinPoint pjp) throws Throwable {\r\n        String name=\"\";\r\n        // 获取第一个参数的值\r\n        Object[] args = pjp.getArgs();\r\n        if (args!=null && args.length > 1){\r\n            Object arg = args[0];\r\n            name = (String)arg;\r\n        }\r\n        // 实现环绕通知\r\n        Object result = null;\r\n        System.out.println(\"环绕通知：在目标方法之前：\"+new Date());\r\n        // 1. 目标方法调用\r\n\r\n        if (\"zhangsan\".equals(name))\r\n            result = pjp.proceed(); // method.invoke(); Object result = doFirst();\r\n        // 2. 在目标方法的钱啊后加入功能\r\n        System.out.println(\"环绕通知：在目标方法之后,提交事务\");\r\n        // 修改方法的执行结果\r\n        if (\"zhangsan\".equals(name)){\r\n            return \"hello aop\";\r\n        }\r\n        return result;\r\n    }\r\n}\r\n\r\n```\r\n\r\n#### 测试类1\r\n\r\n```java\r\n/**\r\n * Unit test for simple App.\r\n */\r\npublic class AppTest \r\n{\r\n    @Test\r\n    public void test01(){\r\n        String config = \"applicationContext.xml\";\r\n        ApplicationContext ac = new ClassPathXmlApplicationContext(config);\r\n        SomeService someService = (SomeService) ac.getBean(\"someService\");\r\n//        someService.doSome(\"tony\",21);\r\n        System.out.println(\"----------------\");\r\n//        Student student = someService.doOther(\"zxx\", 21);\r\n//        System.out.println(student);\r\n        String str = someService.doFirst(\"zhangsan\", 21);// myAround\r\n        System.out.println(str);\r\n    }\r\n}\r\n```\r\n\r\n![image-20211014222456522](cloudDisk/markdown/Spring框架.assets/image-20211014222456522.png)\r\n\r\n#### 测试类2\r\n\r\n```java\r\n/**\r\n * Unit test for simple App.\r\n */\r\npublic class AppTest \r\n{\r\n    @Test\r\n    public void test01(){\r\n        String config = \"applicationContext.xml\";\r\n        ApplicationContext ac = new ClassPathXmlApplicationContext(config);\r\n        SomeService someService = (SomeService) ac.getBean(\"someService\");\r\n//        someService.doSome(\"tony\",21);\r\n        System.out.println(\"----------------\");\r\n//        Student student = someService.doOther(\"zxx\", 21);\r\n//        System.out.println(student);\r\n        String str = someService.doFirst(\"zxx\", 21);// myAround\r\n        System.out.println(str);\r\n    }\r\n}\r\n```\r\n\r\n![image-20211014222656054](cloudDisk/markdown/Spring框架.assets/image-20211014222656054.png)\r\n\r\n## （了解）异常通知\r\n\r\n#### 配置文件\r\n\r\n```xml\r\n<!--    声明目标对象-->\r\n    <bean id=\"someService\" class=\"com.tony.service.impl.SomeServiceImpl\"/>\r\n<!--    声明切面类对象-->\r\n    <bean id=\"myAspect\" class=\"com.tony.MyAspect\"/>\r\n<!--    声明自动代理生成器：使用aspectj矿建内部的功能，创建目标对象的代理对象\r\n        创建代理对象是在内存中实现的，修改目标对象的内存中结构。创建为代理对象\r\n        所以目标对象就是被修改后的代理对象\r\n\r\n        aspectj-autoproxy: 会把spring容器中的所有目标对象，都生成代理对象\r\n    -->\r\n    <aop:aspectj-autoproxy />\r\n```\r\n\r\n#### 目标方法\r\n\r\n```java\r\n    @Override\r\n    public void doSecond(String name, Integer age) {\r\n        System.out.println(\"目标方法doSecond\"+10/0);\r\n    }\r\n```\r\n\r\n#### 切面类\r\n\r\n```java\r\n@Aspect\r\npublic class MyAspect {\r\n  /*\r\n  * 异常通知方法的定义格式\r\n  * 1. public\r\n  * 2. 没有返回值\r\n  * 3. 方法名称自定义\r\n  * 4. 方法有一个Exception，如果还有就是joinPoint\r\n  * */\r\n\r\n    /*\r\n    * @AfterThrowing:异常通知\r\n    * 属性： 1. value 切入点表达式\r\n    *       2. throwing 自定义的变量，表示目标方法抛出的异常对象\r\n    *           变量名必须和方法的参数名一样\r\n    * 特点：\r\n    *   1. 在目标方法爬出异常时执行\r\n    *   2. 可以做异常监控的程序，监控目标方法执行时是不是有异常\r\n    *       如果有异常，可以发送邮件，短信进行通知\r\n    * */\r\n    @AfterThrowing(value = \"execution(* *..SomeServiceImpl.doSecond(..))\",throwing = \"e\")\r\n    public void myAfterThrowing(Exception e){\r\n        System.out.println(\"异常通知：方法发送异常时，执行\"+e.getMessage());\r\n        // 发送邮件，短信来通知开发人员\r\n    }\r\n```\r\n\r\n#### 测试类\r\n\r\n```java\r\n    @Test\r\n    public void test01(){\r\n        String config = \"applicationContext.xml\";\r\n        ApplicationContext ac = new ClassPathXmlApplicationContext(config);\r\n        SomeService someService = (SomeService) ac.getBean(\"someService\");\r\n        someService.doSecond(\"zxx\",21);\r\n    }\r\n```\r\n\r\n![image-20211015193517948](cloudDisk/markdown/Spring框架.assets/image-20211015193517948.png)\r\n\r\n### (了解)最终通知\r\n\r\n#### 目标方法\r\n\r\n```java\r\n@Override\r\npublic void doThird() {\r\n    System.out.println(\"目标方法doThird\"+10/0);\r\n}\r\n```\r\n\r\n#### 切面类\r\n\r\n```java\r\n@Aspect\r\npublic class MyAspect {\r\n  /*\r\n  * 最终通知方法的定义格式\r\n  * 1. public\r\n  * 2. 没有返回值\r\n  * 3. 方法名称自定义\r\n  * 4. 方法有一个Exception，如果还有就是joinPoint\r\n  * */\r\n\r\n    /*\r\n    * @After : 最终通知\r\n    *   属性：value 切入点表达式\r\n    *   位置：在方法的上面\r\n    * 特点：\r\n    * 1. 总是会执行\r\n    * 2. 在目标方法之后执行\r\n    *\r\n    * */\r\n//    @AfterThrowing(value = \"execution(* *..SomeServiceImpl.doSecond(..))\",throwing = \"e\")\r\n    @After(\"execution(* *..SomeServiceImpl.doThird(..))\")\r\n    public void myAfterThrowing(){\r\n        System.out.println(\"最终通知。总是会被执行的方法\");\r\n        // 一般做资源清楚工作\r\n    }\r\n}\r\n```\r\n\r\n#### 测试类\r\n\r\n```java\r\n@Test\r\npublic void test01(){\r\n    String config = \"applicationContext.xml\";\r\n    ApplicationContext ac = new ClassPathXmlApplicationContext(config);\r\n    SomeService someService = (SomeService) ac.getBean(\"someService\");\r\n    someService.doThird();\r\n}\r\n```\r\n\r\n![image-20211015194316278](cloudDisk/markdown/Spring框架.assets/image-20211015194316278.png)\r\n\r\n### 切入点管理\r\n\r\n#### 切面类\r\n\r\n```java\r\n@Aspect\r\npublic class MyAspect {\r\n    @Before(value = \"mypt()\")\r\n    public void myBefore(){\r\n        System.out.println(\"前置通知\");\r\n    }\r\n\r\n    @After(value = \"mypt()\")\r\n    public void myAfter(){\r\n        System.out.println(\"后置通知\");\r\n    }\r\n    /*\r\n    * @Pointcut : 定义和管理切入点，如果你项目中有多个切入点表达式是重复的\r\n    *   可以使用@Pointcut\r\n    *   属性：value：切入点表达式\r\n    *   位置：自定义方法之上\r\n    *\r\n    * */\r\n    @Pointcut(value = \"execution(* *..SomeServiceImpl.doThird(..))\")\r\n    private void mypt(){\r\n        // 无需代码\r\n    }\r\n}\r\n```\r\n\r\n#### 目标方法\r\n\r\n```java\r\n    @Override\r\n    public void doThird() {\r\n        System.out.println(\"目标方法doThird\");\r\n    }\r\n}\r\n```\r\n\r\n#### 测试方法\r\n\r\n```java\r\n    @Test\r\n    public void test01(){\r\n        String config = \"applicationContext.xml\";\r\n        ApplicationContext ac = new ClassPathXmlApplicationContext(config);\r\n        SomeService someService = (SomeService) ac.getBean(\"someService\");\r\n        someService.doThird();\r\n    }\r\n}\r\n```\r\n\r\n### 代理方式\r\n\r\n```xml\r\n    <!--\r\n        如果是接口，spring默认会用jdk的代理\r\n        如果是普通类，spring默认会用cglib代理\r\n\r\n        如果期望目标接口使用cglib代理\r\n        proxy-target-class=\"true\" 告诉框架使用cglib代理\r\n    -->\r\n    <aop:aspectj-autoproxy proxy-target-class=\"true\" />\r\n</beans>\r\n```\r\n\r\n# 把mybatis和spring集成在一起，像一个框架一样使用\r\n\r\n使用的技术：ioc\r\n\r\n能把mybatis和spring集成在一起，像一个框架，是因为ioc能创建对象\r\n\r\n可以把mybatis框架中的对象交给spring统一创建，开发人员从spring中获取对象。\r\n\r\n开发人员就不用同时面对两个或东哥框架了，就面对一个spring\r\n\r\nmybatis使用步骤\r\n\r\n1. 定义dao接口，StudentDao\r\n\r\n2. 定义mapper文件 StudentDao.xml\r\n\r\n3. 定义mybatis的主配置文件 mybatis.xml\r\n\r\n4. 创建dao的代理对象，StudentDao dao = SqlSession.getMapper(StudentDao.class);\r\n\r\n   List<Student> students = dao.selectStuents();\r\n\r\n要使用dao对象，需要使用getMapper()方法\r\n怎么能使用getMapper()方法，需要什么条件\r\n\r\n1. 获取SqlSession对象，需要使用SqlSessionFactory的openSession()方法\r\n2. 创建SqlSessionFactory对象。通过读取mybatis的主配置文件，能创建SqlSessionFactory对象\r\n\r\n需要SqlSessionFactory对象，使用Factory能获取SqlSessio，有了SqlSessio就有dao，目的就是获取dao对象。Factory创建需要读取主配置文件\r\n\r\n我们会使用独立的数据库连接池类替换mybatis默认自带的，把连接池类也交给spring创建\r\n\r\n主配置文件：\r\n\r\n![image-20211016185311976](cloudDisk/markdown/Spring框架.assets/image-20211016185311976.png)\r\n\r\n通过以上的说明，我们需要让spring创建以下对象\r\n\r\n1. 独立的连接池类的对象，使用阿里的druid连接池\r\n2. SqlSessionFactory对象\r\n3. 创建出dao对象\r\n\r\n需要学的就是上面三个对象的创建语法，使用xml的bean标签\r\n\r\n步骤\r\n\r\n1. 新建maven项目\r\n\r\n2. 加入maven依赖\r\n\r\n   1. spring依赖\r\n   2. mybatis依赖\r\n   3. mysql驱动\r\n   4. spring的事务依赖\r\n   5. mybatis和spring集成的依赖：mybatis官方用的，用来个在spring项目中创建mybatis的SqlSessionFactory，dao对象\r\n\r\n   ```xml\r\n     <dependencies>\r\n   <!--    单元测试-->\r\n       <dependency>\r\n         <groupId>junit</groupId>\r\n         <artifactId>junit</artifactId>\r\n         <version>4.11</version>\r\n         <scope>test</scope>\r\n       </dependency>\r\n   <!--    spring核心-->\r\n       <dependency>\r\n         <groupId>org.springframework</groupId>\r\n         <artifactId>spring-context</artifactId>\r\n         <version>5.2.5.RELEASE</version>\r\n       </dependency>\r\n   <!--    做spring事务用到的-->\r\n       <dependency>\r\n         <groupId>org.springframework</groupId>\r\n         <artifactId>spring-tx</artifactId>\r\n         <version>4.1.2.RELEASE</version>\r\n       </dependency>\r\n   <!--    mybatis依赖-->\r\n       <dependency>\r\n         <groupId>org.mybatis</groupId>\r\n         <artifactId>mybatis</artifactId>\r\n         <version>3.5.1</version>\r\n       </dependency>\r\n   <!--    mybatis和spring集成的依赖-->\r\n       <dependency>\r\n         <groupId>org.mybatis</groupId>\r\n         <artifactId>mybatis-spring</artifactId>\r\n         <version>1.3.1</version>\r\n       </dependency>\r\n   <!--    mysql驱动-->\r\n       <dependency>\r\n         <groupId>mysql</groupId>\r\n         <artifactId>mysql-connector-java</artifactId>\r\n         <version>5.1.26</version>\r\n       </dependency>\r\n   <!--    阿里公司的数据库连接池-->\r\n       <dependency>\r\n         <groupId>com.alibaba</groupId>\r\n         <artifactId>druid</artifactId>\r\n         <version>1.0.9</version>\r\n       </dependency>\r\n     </dependencies>\r\n     <build>\r\n   <!--    目的是把src/main/java目录中的xml文件包含到输出结果中，输出到classes目录中-->\r\n       <resources>\r\n         <resource>\r\n           <directory>src/main/java</directory><!--所在的目录-->\r\n           <includes><!--包括目录下的.properties，.xml文件都会扫描到-->\r\n             <include>**/*.properties</include>\r\n             <include>**/*.xml</include>\r\n           </includes>\r\n           <filtering>false</filtering>\r\n         </resource>\r\n       </resources>\r\n   ```\r\n\r\n   \r\n\r\n3. 创建实体类\r\n\r\n4. 创建dao接口和mapper文件\r\n\r\n5. 创建mybatis主配置文件\r\n\r\n6. 创建Service接口和实现类，属性是dao\r\n\r\n7. 创建spring的配置文件：声明mybatis的对象交给spring创建\r\n\r\n   1. 数据源\r\n   2. SqlSessionFactory\r\n   3. Dao对象\r\n   4. s声明自定义的service\r\n\r\n8. 创建测试类，获取Service对象，通过service调用dao完成数据库的访问\r\n','2022-06-23 22:17:26','“We use a lot of the tools that come with the Spring framework and reap the benefits of having a lot of the out of the box solutions, and not having to worry about writing a ton of additional code—so ','/cloudDisk/markdown/20220623093950_df751c4a_1655948390627.png','原创','','','\0','Spring框架学习笔记（中）','2022-06-23 22:17:26',2,102,NULL,0),(186,'','# 事务管理\r\n\r\n## 1）什么是事务？\r\n\r\n事务是逻辑上的一组操作，组成这组操作的各个逻辑单元，要么一起成功，要么一起失败。\r\n\r\n## 2）事务的特性（ACID）\r\n\r\n- [原子性](https://so.csdn.net/so/search?q=原子性&spm=1001.2101.3001.7020)（Atomicity）：事务是一个原子操作，由一系列动作组成。事务的原子性确保动作要么全部完成，要么完全不起作用。\r\n- 一致性（Consistency）：一旦事务完成（不管成功还是失败），系统必须确保它所建模的业务处于一致的状态，而不会是部分完成部分失败。在现实中的数据不应该被破坏。\r\n- 隔离性（Isolation）：可能有许多事务会同时处理相同的数据，因此每个事务都应该与其他事务隔离开来，防止数据损坏。\r\n- 持久性（Durability）：一旦事务完成，无论发生什么系统错误，它的结果都不应该受到影响，这样就能从任何系统崩溃中恢复过来。通常情况下，事务的结果被写到持久化存储器中。\r\n\r\n## 3）TransactionDefinition：事务定义信息\r\n\r\n事务定义信息有：\r\n\r\n- 隔离级别\r\n- **传播行为**\r\n- 超时信息\r\n- 是否只读\r\n\r\n## 4）如果不考虑隔离性会引发安全性问题\r\n\r\n**隔离级别：定义了一个事务可能受其他并发事务影响的程度。**\r\n**并发事务引起的问题**：典型的应用程序中，多个事务并发运行，经常会操作相同的数据来完成各自的任务。并发虽然是必须的，但可能会导致以下的问题。\r\n\r\n- [脏读](https://so.csdn.net/so/search?q=脏读&spm=1001.2101.3001.7020)（Dirty reads）——脏读发生在一个事务读取了另一个事务改写但尚未提交的数据时。如果改写在稍后被回滚了，那么第一个事务获取的数据就是无效的。\r\n- 不可重复读（Nonrepeatable read）——不可重复读发生在一个事务执行相同的查询两次或两次以上，但是每次都得到不同的数据时。这通常是因为另一个并发事务在两次查询期间进行了更新。\r\n- 幻读（Phantom read）——幻读与不可重复读类似。它发生在一个事务（T1）读取了几行数据，接着另一个并发事务（T2）插入了一些数据时。在随后的查询中，第一个事务（T1）就会发现多了一些原本不存在的记录。\r\n\r\n## 5）解决读问题：设置事务的隔离级别\r\n\r\n- 未提交读：脏读，不可重复读，虚读都有可能发生\r\n- 已提交读：避免脏读。但是不可重复读和虚读都有可能发生\r\n- 可重复读：避免脏读和不可重复读。但是虚读有可能发生\r\n- 串行化的：避免以上所有读问题\r\n\r\n**mysql数据库的默认隔离级别就是可重复读,Oracle默认是已提交读**\r\n\r\n## 6）事务的传播行为\r\n\r\nPROPAGATION_XXX：事务的传播行为。\r\n\r\n- 保证在同一个事务中\r\n  **PROPAGATION_REQUIRED：required , 必须。支持当前事务，如果不存在，就新建一个(默认)**\r\n  PROPAGATION_SUPPORTS：supports ，支持。支持当前事务，如果不存在，就不使用事务\r\n  PROPAGATION_MANDATORY：mandatory ，强制。支持当前事务，如果不存在，就抛出异常\r\n- 保证没有在同一个事务中\r\n  **PROPAGATION_REQUIRES_NEW：requires_new，必须新的。如果有事务存在，挂起当前事务，创建一个新的事务**\r\n  PROPAGATION_NOT_SUPPORTED：not_supported ,不支持。以非事务方式运行，如果有事务存在，挂起当前事务\r\n  PROPAGATION_NEVER：never，从不。以非事务方式运行，如果有事务存在，抛出异常\r\n  **PROPAGATION_NESTED：nested ，嵌套。如果当前事务存在，则嵌套事务执行**\r\n\r\n关于事务的传播行为我会另起一篇详细介绍，最好要理解，实在不理解也没关系，随着时间的推移，代码的进步会慢慢理解的。\r\n\r\n## 7）事务超时\r\n\r\n为了使应用程序很好地运行，事务不能运行太长的时间。因为事务可能涉及对后端数据库的锁定，所以长时间的事务会不必要的占用数据库资源。事务超时就是事务的一个定时器，在特定时间内事务如果没有执行完毕，那么就会自动回滚，而不是一直等待其结束。\r\n\r\n## 8）只读\r\n\r\n这是事务的第三个特性，是否为只读事务。如果事务只对后端的数据库进行该操作，数据库可以利用事务的只读特性来进行一些特定的优化。通过将事务设置为只读，你就可以给数据库一个机会，让它应用它认为合适的优化措施。\r\n\r\n# Spring进行事务管理的常用API\r\n\r\n## 1）PlatformTransactionManager：平台事务管理器\r\n\r\nSpring进行事务操作时候，主要使用一个PlatformTransactionManager接口，它表示事务管理器，即真正管理事务的对象。\r\nSpring并不直接管理事务，通过这个接口，Spring为各个平台如JDBC、Hibernate等都提供了对应的事务管理器，也就是将事务管理的职责委托给Hibernate或者JTA等持久化机制所提供的相关平台框架的事务来实现。\r\nSpring针对不同的持久化框架，提供了不同PlatformTransactionManager接口的实现类：\r\n\r\n- org.springframework.jdbc.datasource.DataSourceTransactionManager ：使用 Spring JDBC或iBatis 进行持久化数据时使用\r\n- org.springframework.orm.hibernate3.HibernateTransactionManager ：使用 Hibernate版本进行持久化数据时使用\r\n\r\n## 2）Spring的这组接口是如何进行事务管理的\r\n\r\n平台事务管理器根据事务定义的信息进行事务的管理，事务管理的过程中产生一些状态，将这些状态记录到TrancactionStatus里面。\r\n\r\n## 3）TransactionStatus：事务的状态\r\n\r\n在上面 PlatformTransactionManager 接口有一个方法getTransaction()，这个方法返回的是 TransactionStatus对象，然后程序根据返回的对象来获取事务状态，然后进行相应的操作。\r\n而 TransactionStatus 这个接口的内容如下：\r\n\r\n![在这里插入图片描述](cloudDisk/markdown/Spring框架.assets/20181107114318612.png)\r\n\r\n这个接口描述的是一些处理事务提供简单的控制事务执行和查询事务状态的方法，在回滚或提交的时候需要应用对应的事务状态。\r\n\r\n# Spring中进行事务操作–案例\r\n\r\n## Spring进行事务操作的方式\r\n\r\n- 编程式事务管理\r\n- 声明式事务管理\r\n  - 基于xml配置文件方式\r\n  - 基于注解方式\r\n\r\n## 搭建案例环境\r\n\r\n例子就是模拟银行转账，首先要搭建好转账的环境。\r\n\r\n#### 1）搭建数据库环境\r\n\r\n```sql\r\n## 创建表\r\nCREATE TABLE `NewTable` (\r\n`id`  int(4) NOT NULL AUTO_INCREMENT ,\r\n`name`  varchar(7) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL ,\r\n`balance`  decimal(11,0) NOT NULL DEFAULT 0 ,\r\nPRIMARY KEY (`id`)\r\n)\r\nENGINE=InnoDB\r\nDEFAULT CHARACTER SET=utf8 COLLATE=utf8_general_ci;\r\n## 插入数据\r\nINSERT INTO `spring_jdbc`.`account` (`id`, `name`, `balance`) VALUES (\'1\', \'zs\', \'1000\');\r\nINSERT INTO `spring_jdbc`.`account` (`id`, `name`, `balance`) VALUES (\'2\', \'ls\', \'1000\');\r\n123456789101112\r\n```\r\n\r\n#### 2）创建一个web项目，导入jar包\r\n\r\n![在这里插入图片描述](cloudDisk/markdown/Spring框架.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM0NTk4NjY3,size_16,color_FFFFFF,t_70.png)\r\n\r\n\r\n\r\n#### 3）在Spring配置文件中开启组件扫描，配置数据库连接池环境以及jdbcTemplate\r\n\r\n```xml\r\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\r\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\r\n    xmlns:context=\"http://www.springframework.org/schema/context\"\r\n     xmlns:aop=\"http://www.springframework.org/schema/aop\"\r\n    xsi:schemaLocation=\"http://www.springframework.org/schema/beans\r\n        http://www.springframework.org/schema/beans/spring-beans.xsd\r\n        http://www.springframework.org/schema/aop \r\n        http://www.springframework.org/schema/aop/spring-aop-4.2.xsd\r\n        http://www.springframework.org/schema/context\r\n        http://www.springframework.org/schema/context/spring-context-4.2.xsd\">\r\n   	<!--指定注解扫描包路径-->\r\n	<context:component-scan base-package=\"com.oak\"/>\r\n\r\n   	<!-- 导入资源文件 -->\r\n  	<context:property-placeholder location=\"classpath:dbutil.properties\"/>\r\n  	\r\n  	<!-- 配置dbcp连接池参数 -->\r\n	<bean id=\"dataSource\" class=\"org.apache.commons.dbcp.BasicDataSource\"\r\n   destroy-method=\"close\">\r\n	    <property name=\"driverClassName\" value=\"${driver}\" />\r\n	    <property name=\"url\"\r\n	        value=\"${url}\" />\r\n	    <property name=\"username\" value=\"${user}\" />\r\n	    <property name=\"password\" value=\"${password}\" />\r\n	    <!-- 连接池启动时的初始值 -->\r\n	    <property name=\"initialSize\" value=\"${initsize}\" />\r\n	    <!-- 连接池的最大值 -->\r\n	    <property name=\"maxActive\" value=\"${maxsize}\" />\r\n	    <!-- 最大空闲值。当经过一个高峰时间后，连接池可以慢慢将已经用不到的连接慢慢释放一部分，一直减少到maxIdle为止 -->\r\n	    <property name=\"maxIdle\" value=\"${maxIdle}\" />\r\n	    <!-- 最小空闲值。当空闲的连接数少于阀值时，连接池就会预申请去一些连接，以免洪峰来时来不及申请 -->\r\n	    <property name=\"minIdle\" value=\"${minIdle}\" />\r\n	</bean>\r\n	\r\n	<!-- 配置 Spring 的 jdbcTemplate -->\r\n	<bean id=\"jdbcTemplate\" class=\"org.springframework.jdbc.core.JdbcTemplate\">\r\n		<property name=\"dataSource\" ref=\"dataSource\"/>    \r\n	</bean>\r\n</beans>\r\n```\r\n\r\n#### 4）创建dao层转账的具体实现（接口以及实现类）\r\n\r\n- dao接口AccountDao\r\n\r\n```java\r\npublic interface AccountDao {\r\n	//减少余额\r\n	void lessenBalance(int id,double balance);\r\n	//增加余额\r\n	void addBalance(int id,double balance);\r\n}\r\n```\r\n\r\n- dao实现类AccountDaoImpl\r\n\r\n```java\r\n@Repository\r\npublic class AccountDaoImpl implements AccountDao{\r\n	@Autowired\r\n	private JdbcTemplate jdbcTemplate;\r\n	@Override\r\n	public void lessenBalance(int id, double balance) {\r\n		jdbcTemplate.update(\"update account set balance-=? where id=?\",balance,id);\r\n	}\r\n\r\n	@Override\r\n	public void addBalance(int id, double balance) {\r\n		jdbcTemplate.update(\"update account set balance+=? where id=?\",balance,id);\r\n	}\r\n}\r\n```\r\n\r\n#### 5）编写service层业务实现(接口和实现类)\r\n\r\n- AccountService接口\r\n\r\n```java\r\npublic interface AccountService {\r\n	//实现转账的业务方法\r\n	void accountBalance(int lessenId,int addId,double balance);\r\n}\r\n```\r\n\r\n- AccountServiceImpl实现类\r\n\r\n```java\r\n@Service\r\npublic class AccountServiceImpl implements AccountService{\r\n	@Autowired\r\n	AccountDao accountDao;\r\n	@Override\r\n	public void accountBalance(int lessenId, int addId, double balance) {\r\n		//某个账号减少金额\r\n		accountDao.lessenBalance(lessenId, balance);\r\n		//走个账号增加金额\r\n		accountDao.addBalance(addId, balance);\r\n	}\r\n}\r\n```\r\n\r\n#### 6）在测试类中编程accountTest测试方法\r\n\r\n```java\r\n@Test\r\npublic void testAccount(){\r\n	ApplicationContext ctx=new ClassPathXmlApplicationContext(\"applicationContext.xml\");\r\n	AccountService accService=ctx.getBean(\"accountServiceImpl\",AccountService.class);\r\n	//从id为1的用户转账给id为2的用户500元\r\n	accService.accountBalance(1, 2, 500);\r\n}\r\n```\r\n\r\n运行测试查看数据库：\r\n\r\n![在这里插入图片描述](cloudDisk/markdown/Spring框架.assets/20181107110341620.png)\r\n\r\n\r\n\r\n#### 7）转账中出现的问题\r\n\r\n加入在转账的过程中出现了一些异常，例如服务器宕机，银行断电等，那这是就会出现一个问题，一个账号的钱转了，另一账号却没收到钱，如下,修改accountBalance方法，模拟出现异常：\r\n\r\n```java\r\n	public void accountBalance(int lessenId, int addId, double balance) {\r\n		//某个账号减少金额\r\n		accountDao.lessenBalance(lessenId, balance);\r\n		//模拟出现异常\r\n		int a=5/0;\r\n		//走个账号增加金额\r\n		accountDao.addBalance(addId, balance);\r\n	}\r\n}\r\n```\r\n\r\n测试查看数据库：\r\n\r\n![在这里插入图片描述](cloudDisk/markdown/Spring框架.assets/20181107112406841.png)\r\n\r\n\r\n\r\n查看结果，zs转了500，但是ls没收到，这时应该怎么解决这个问题呢？就可使用事务来解决。\r\n\r\n\r\n\r\n\r\n\r\n# Spring进行事务操作\r\n\r\n## Spring进行事务操作方式\r\n\r\n- 编程式事务管理（了解就行，不要求掌握，这里就不做案例了）\r\n- 声明式事务管理\r\n  - 基于xml配置文件方式\r\n  - 基于注解方式\r\n\r\n## Spring的声明式事务管理——XML方式：思想就是AOP\r\n\r\n基于xml配置文件的方式来进行声明式事务的操作，不需要进行手动编写代码，通过一段配置完成事务管理。下面我们在以上案例的基础上实现它。\r\n\r\n#### 1）配置事务管理器\r\n\r\n我们已经讲过Spring针对不同的持久化框架，提供了不同PlatformTransactionManager接口的实现类：\r\n\r\n- org.springframework.jdbc.datasource.DataSourceTransactionManager ：使用 Spring JDBC或iBatis 进行持久化数据时使用\r\n- org.springframework.orm.hibernate3.HibernateTransactionManager ：使用 Hibernate版本进行持久化数据时使用\r\n\r\n所以要在Spring配置文件中加入以下配置：\r\n\r\n```xml\r\n<!-- 1.配置事务的管理器 -->\r\n<bean id=\"transactionManager\" class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\">\r\n    <!-- 指定要对哪个数据库进行事务操作 -->\r\n    <property name=\"dataSource\" ref=\"dataSource\"></property>\r\n</bean>\r\n```\r\n\r\n#### 2）配置事务的增强，指定对哪个事务管理器进行增强\r\n\r\n**需要在xml中引入命名空间**\r\n\r\n```xml\r\nxmlns:tx=\"http://www.springframework.org/schema/tx\"\r\n\r\nhttp://www.springframework.org/schema/tx\r\nhttp://www.springframework.org/schema/tx/spring-tx.xsd\r\n```\r\n\r\n**配置事务的增强**\r\n\r\n```xml\r\n<!-- 2.配置事务的增强，指定对哪个事务管理器进行增强 -->\r\n<tx:advice id=\"txadvice\" transaction-manager=\"transactionManager\">\r\n    <tx:attributes>\r\n        <!--\r\n	            表示来配置你要增强的方法的匹配的一个规则，\r\n	            注意：只须改方法的命名规则，其他都是固定的！\r\n            propagation：事务的传播行为。\r\n        -->\r\n        <tx:method name=\"account*\" propagation=\"REQUIRED\"></tx:method>\r\n        <!-- <tx:method name=\"insert*\" propagation=\"REQUIRED\"></tx:method> -->\r\n    </tx:attributes>\r\n</tx:advice>\r\n```\r\n\r\n#### 3）配置切入点和切面\r\n\r\n```xml\r\n<!-- 3.配置切入点和切面(最重要的一步) -->\r\n<aop:config>\r\n    <!-- 切入点 -->\r\n   	<aop:pointcut expression=\"execution(* com.oak.service.AccountService.*(..))\" id=\"pointcut\"/>\r\n   	<!-- 切面，即表示把哪个增强用在哪个切入点上 -->\r\n    <aop:advisor advice-ref=\"txadvice\" pointcut-ref=\"pointcut\"/>\r\n</aop:config>\r\n```\r\n\r\n#### 4）直接测试上个案例中的testAccount方法\r\n\r\n先把数据库中的数据恢复到初始的相同余额状态。\r\n\r\n![在这里插入图片描述](cloudDisk/markdown/Spring框架.assets/20181107150748969.png)\r\n\r\n直接运行测试方法，运行时异常，查看数据库中的数据，并没有减少，事务被回滚了\r\n\r\n![在这里插入图片描述](cloudDisk/markdown/Spring框架.assets/20181107150813584.png)\r\n\r\n## Spring的声明式事务的注解方式\r\n\r\n基于注解方式来进行声明式事务的操作会更加简单，在实际开发中我们也会用的比较多,我们基于以上案例继续完成\r\n\r\n#### 1）配置事务管理器(同上1)\r\n\r\n```xml\r\n<!-- 1.配置事务的管理器 -->\r\n<bean id=\"transactionManager\" class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\">\r\n    <!-- 指定要对哪个数据库进行事务操作 -->\r\n    <property name=\"dataSource\" ref=\"dataSource\"></property>\r\n</bean>\r\n```\r\n\r\n#### 2）注释掉事务的其他配置，开启事务注解\r\n\r\n```xml\r\n<!-- 2.开启事务的注解 -->\r\n<tx:annotation-driven transaction-manager=\"transactionManager\"></tx:annotation-driven>\r\n```\r\n\r\n完成之后的配置文件问：\r\n\r\n```xml\r\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\r\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\r\n    xmlns:context=\"http://www.springframework.org/schema/context\"\r\n     xmlns:aop=\"http://www.springframework.org/schema/aop\"\r\n     xmlns:tx=\"http://www.springframework.org/schema/tx\"\r\n    xsi:schemaLocation=\"http://www.springframework.org/schema/beans\r\n        http://www.springframework.org/schema/beans/spring-beans.xsd\r\n        http://www.springframework.org/schema/aop \r\n        http://www.springframework.org/schema/aop/spring-aop-4.2.xsd\r\n        http://www.springframework.org/schema/context\r\n        http://www.springframework.org/schema/context/spring-context-4.2.xsd\r\n        http://www.springframework.org/schema/tx\r\n		http://www.springframework.org/schema/tx/spring-tx.xsd\">\r\n\r\n   	<!--指定注解扫描包路径-->\r\n	<context:component-scan base-package=\"com.oak\"/>\r\n\r\n   	<!-- 导入资源文件 -->\r\n  	<context:property-placeholder location=\"classpath:dbutil.properties\"/>\r\n  	<!-- 配置dbcp连接池参数 -->\r\n	<bean id=\"dataSource\" class=\"org.apache.commons.dbcp.BasicDataSource\"\r\n   destroy-method=\"close\">\r\n	    <property name=\"driverClassName\" value=\"${driver}\" />\r\n	    <property name=\"url\"\r\n	        value=\"${url}\" />\r\n	    <property name=\"username\" value=\"${user}\" />\r\n	    <property name=\"password\" value=\"${password}\" />\r\n	    <!-- 连接池启动时的初始值 -->\r\n	    <property name=\"initialSize\" value=\"${initsize}\" />\r\n	    <!-- 连接池的最大值 -->\r\n	    <property name=\"maxActive\" value=\"${maxsize}\" />\r\n	    <!-- 最大空闲值。当经过一个高峰时间后，连接池可以慢慢将已经用不到的连接慢慢释放一部分，一直减少到maxIdle为止 -->\r\n	    <property name=\"maxIdle\" value=\"${maxIdle}\" />\r\n	    <!-- 最小空闲值。当空闲的连接数少于阀值时，连接池就会预申请去一些连接，以免洪峰来时来不及申请 -->\r\n	    <property name=\"minIdle\" value=\"${minIdle}\" />\r\n	</bean>\r\n	<!-- 配置 Spring 的 jdbcTemplate -->\r\n	<bean id=\"jdbcTemplate\" class=\"org.springframework.jdbc.core.JdbcTemplate\">\r\n		<property name=\"dataSource\" ref=\"dataSource\"/>    \r\n	</bean>\r\n	\r\n	<!-- 1.配置事务的管理器 -->\r\n	<bean id=\"transactionManager\" class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\">\r\n	    <!-- 指定要对哪个数据库进行事务操作 -->\r\n	    <property name=\"dataSource\" ref=\"dataSource\"></property>\r\n	</bean>\r\n	\r\n	<!-- 2.开启事务的注解 -->\r\n	<tx:annotation-driven transaction-manager=\"transactionManager\">	</tx:annotation-driven>\r\n</beans>\r\n```\r\n\r\n#### 3）在具体使用事务的方法所在的类上面添加注解：@Transactional\r\n\r\n在AccountServiceImpl上加上该注解\r\n\r\n```java\r\n@Service//业务层注解\r\n@Transactional//事务控制注解\r\npublic class AccountServiceImpl implements AccountService{\r\n	@Autowired//依赖注入\r\n	AccountDao accountDao;\r\n	@Override\r\n	public void accountBalance(int lessenId, int addId, double balance) {\r\n		//某个账号减少金额\r\n		accountDao.lessenBalance(lessenId, balance);\r\n		//模拟出现异常\r\n		int a=5/0;\r\n		//走个账号增加金额\r\n		accountDao.addBalance(addId, balance);\r\n	}\r\n}\r\n```\r\n\r\n#### 4）直接测试\r\n\r\n直接测试上个案例的测试方法，数据库中的数据没有发生变法。\r\n\r\n![在这里插入图片描述](cloudDisk/markdown/Spring框架.assets/20181107150813584-165452715809520.png)\r\n\r\n# 一些事务细节\r\n\r\n## 1、事务定义\r\n\r\n## 2、事务的四大特性\r\n\r\n1. 原子性(Atomicity)\r\n   事务是数据库的逻辑工作单位，事务中包括的诸操作要么全做，要么全不做。\r\n2. 一致性(Consistency)\r\n   事务执行的结果必须是使数据库从一个一致性状态变到另一个一致性状态。一致性与原子性是密切相关的。\r\n3. 隔离性(Isolation)\r\n   一个事务的执行不能被其他事务干扰。\r\n4. 持续性/永久性(Durability)\r\n   一个事务一旦提交，它对数据库中数据的改变就应该是永久性的。\r\n\r\n## 3、并发事务引起的问题\r\n\r\n- 脏读（Dirty reads）——脏读发生在一个事务读取了另一个事务改写但尚未提交的数据时。如果改写在稍后被回滚了，那么第一个事务获取的数据就是无效的。\r\n- 不可重复读（Nonrepeatable read）——不可重复读发生在一个事务执行相同的查询两次或两次以上，但是每次都得到不同的数据时。这通常是因为另一个并发事务在两次查询期间进行了更新。\r\n- 幻读（Phantom read）——幻读与不可重复读类似。它发生在一个事务（T1）读取了几行数据，接着另一个并发事务（T2）插入了一些数据时。在随后的查询中，第一个事务（T1）就会发现多了一些原本不存在的记录。\r\n\r\n## 4、事务的隔离级别\r\n\r\n| 隔离级别                    | 解决的并发事务问题           |\r\n| --------------------------- | ---------------------------- |\r\n| Read uncommitted (读未提交) | 最低级别，任何情况都无法保证 |\r\n| Read committed (读已提交)   | 脏读                         |\r\n| Repeatable read (可重复读)  | 脏读、不可重复读             |\r\n| Serializable (串行化)       | 脏读、不可重复读、幻读       |\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nSpring事务管理我相信大家都用得很多，但可能仅仅局限于一个`@Transactional`注解或者在`XML`中配置事务相关的东西。不管怎么说，日常**可能**足够我们去用了。但作为程序员，无论是为了面试还是说更好把控自己写的代码，还是应该得多多了解一下Spring事务的一些细节。\r\n\r\n这里我抛出几个问题，看大家能不能瞬间答得上：\r\n\r\n- 如果**嵌套调用**含有事务的方法，在Spring事务管理中，这属于哪个知识点？\r\n- 我们使用的框架可能是`Hibernate/JPA`或者是`Mybatis`，都知道的底层是需要一个`session/connection`对象来帮我们执行操作的。要保证事务的完整性，我们需要多组数据库操作要使用**同一个**`session/connection`对象，而我们又知道Spring IOC所管理的对象默认都是**单例**的，这为啥我们在使用的时候不会引发线程安全问题呢？内部Spring到底干了什么？\r\n- 人家所说的BPP又是啥东西？\r\n- Spring事务管理重要接口有哪几个？\r\n\r\n\r\n\r\n## 二、两个不靠谱直觉的例子\r\n\r\n## 2.1第一个例子\r\n\r\n之前朋友问了我一个例子：\r\n\r\n在Service层抛出Exception，在Controller层捕获，那如果在Service中有异常，那会事务回滚吗？\r\n\r\n```java\r\n// Service方法\r\n	\r\n@Transactional\r\npublic Employee addEmployee() throws Exception {\r\n\r\n    Employee employee = new Employee(\"3y\", 23);\r\n    employeeRepository.save(employee);\r\n	// 假设这里出了Exception\r\n    int i = 1 / 0;\r\n\r\n    return employee;\r\n}\r\n\r\n// Controller调用\r\n@RequestMapping(\"/add\")\r\npublic Employee addEmployee() {\r\n    Employee employee = null;\r\n    try {\r\n        employee = employeeService.addEmployee();\r\n    } catch (Exception e) {\r\n        e.printStackTrace();\r\n    }\r\n    return employee;\r\n\r\n}\r\n```\r\n\r\n我**第一反应**：不会回滚吧。\r\n\r\n- 我当时是这样想的：因为Service层已经抛出了异常，由Controller捕获。那是否回滚应该由Controller的catch代码块中逻辑来决定，如果catch代码块没有回滚，那应该是不会回滚。\r\n\r\n但朋友经过测试说，可以回滚阿。(pappapa打脸)\r\n\r\n![img](cloudDisk/markdown/Spring框架.assets/v2-a27e4f8ca53204c7fe7942c8c4c27100_720w.jpg)\r\n\r\n\r\n\r\n看了一下文档，原来文档有说明：\r\n\r\n> By default checked exceptions do not result in the transactional interceptor marking the transaction for rollback and instances of RuntimeException and its subclasses do\r\n\r\n结论：如果是编译时异常不会自动回滚，**如果是运行时异常，那会自动回滚**！\r\n\r\n## 2.2第二个例子\r\n\r\n第二个例子来源于知乎@柳树文章，文末会给出相应的URL\r\n\r\n我们都知道，带有`@Transactional`注解所包围的方法就能被Spring事务管理起来，那如果我在**当前类下使用一个没有事务的方法去调用一个有事务的方法**，那我们这次调用会怎么样？是否会有事务呢？\r\n\r\n用代码来描述一下：\r\n\r\n```java\r\n// 没有事务的方法去调用有事务的方法\r\npublic Employee addEmployee2Controller() throws Exception {\r\n\r\n    return this.addEmployee();\r\n}\r\n\r\n@Transactional\r\npublic Employee addEmployee() throws Exception {\r\n\r\n    employeeRepository.deleteAll();\r\n    Employee employee = new Employee(\"3y\", 23);\r\n\r\n    // 模拟异常\r\n    int i = 1 / 0;\r\n\r\n    return employee;\r\n}\r\n```\r\n\r\n我第一直觉是：这跟Spring事务的传播机制有关吧。\r\n\r\n其实这跟Spring事务的传播机制**没有关系**，下面我讲述一下：\r\n\r\n- Spring事务管理用的是AOP，AOP底层用的是动态代理。所以如果我们在类或者方法上标注注解`@Transactional`，那么会生成一个**代理对象**。\r\n\r\n![img](cloudDisk/markdown/Spring框架.assets/v2-ace1123f6a162a90121b002d19864970_720w.jpg)\r\n\r\n显然地，我们拿到的是代理(Proxy)对象，调用`addEmployee2Controller()`方法，而`addEmployee2Controller()`方法的逻辑是`target.addEmployee()`，调用回原始对象(target)的`addEmployee()`。所以这次的调用**压根就没有事务存在**，更谈不上说Spring事务传播机制了。\r\n\r\n原有的数据：\r\n\r\n![img](cloudDisk/markdown/Spring框架.assets/v2-fec3d6e70f9bab5072bb84cb595483bf_720w.jpg)\r\n\r\n测试结果：压根就没有事务的存在\r\n\r\n![img](cloudDisk/markdown/Spring框架.assets/v2-6c0ed660b2c7fba0aacf92bd495c302f_720w.jpg)\r\n\r\n\r\n\r\n## 2.2.1再延伸一下\r\n\r\n从上面的测试我们可以发现：如果是在本类中没有事务的方法来调用标注注解`@Transactional`方法，最后的结论是没有事务的。那如果我将这个标注注解的方法**移到**别的Service对象上，有没有事务？\r\n\r\n```java\r\n@Service\r\npublic class TestService {\r\n\r\n    @Autowired\r\n    private EmployeeRepository employeeRepository;\r\n    \r\n    @Transactional\r\n    public Employee addEmployee() throws Exception {\r\n\r\n        employeeRepository.deleteAll();\r\n\r\n        Employee employee = new Employee(\"3y\", 23);\r\n\r\n        // 模拟异常\r\n        int i = 1 / 0;\r\n\r\n        return employee;\r\n    }\r\n\r\n}\r\n```\r\n\r\n```java\r\n@Service\r\npublic class EmployeeService {\r\n\r\n    @Autowired\r\n    private TestService testService;\r\n    // 没有事务的方法去调用别的类有事务的方法\r\n    public Employee addEmployee2Controller() throws Exception {\r\n        return testService.addEmployee();\r\n    }\r\n}\r\n```\r\n\r\n因为我们用的是代理对象(Proxy)去调用`addEmployee()`方法，那就当然有事务了。\r\n\r\n> 看完这两个例子，有没有觉得**3y的直觉是真的水**！\r\n\r\n\r\n\r\n## 三、Spring事务传播机制\r\n\r\n> 如果**嵌套调用**含有事务的方法，在Spring事务管理中，这属于哪个知识点？\r\n\r\n在当前**含有事务方法内部调用其他的方法**(无论该方法是否含有事务)，这就属于Spring事务传播机制的知识点范畴了。\r\n\r\nSpring事务基于Spring AOP，Spring AOP底层用的动态代理，动态代理有两种方式：\r\n\r\n- 基于接口代理(JDK代理)\r\n\r\n- - 基于接口代理，凡是类的方法**非public修饰**，或者**用了static关键字**修饰，那这些方法都不能被Spring AOP增强\r\n\r\n- 基于CGLib代理(子类代理)\r\n\r\n- - 基于子类代理，凡是类的方法**使用了private、static、final修饰**，那这些方法都不能被Spring AOP增强\r\n\r\n> 至于为啥以上的情况不能增强，用你们的脑瓜子想一下就知道了。\r\n\r\n值得说明的是：那些不能被Spring AOP增强的方法**并不是不能**在事务环境下工作了。只要它们**被外层的事务方法调用了**，由于Spring事务管理的传播级别，内部方法也可以**工作**在外部方法所启动的**事务上下文中**。\r\n\r\n## 四、多线程问题\r\n\r\n我们使用的框架可能是`Hibernate/JPA`或者是`Mybatis`，都知道的底层是需要一个`session/connection`对象来帮我们执行操作的。要保证事务的完整性，我们需要**多组数据库操作要使用同一个**`session/connection`对象，而我们又知道Spring IOC所管理的对象默认都是**单例**的，这为啥我们在使用的时候不会引发线程安全问题呢？内部Spring到底干了什么？\r\n\r\n回想一下当年我们学Mybaits的时候，是怎么编写[Session工具类](https://link.zhihu.com/?target=https%3A//mp.weixin.qq.com/s%3F__biz%3DMzI4Njg5MDA5NA%3D%3D%26mid%3D2247483937%26idx%3D2%26sn%3D28c7827639bb6ac0296746c4c4343c59%26chksm%3Debd74320dca0ca36b763b3975665fc38a7e921f9ecaef1aaea3a7c757063a29222cd00b3d3b6%26scene%3D21%23%23wechat_redirect)？\r\n\r\n![img](cloudDisk/markdown/Spring框架.assets/v2-12c0491b29126fc580ec59c1f631a295_720w.jpg)\r\n\r\n没错，用的就是ThreadLocal，同样地，Spring也是用的ThreadLocal。\r\n\r\n以下内容来源《精通 Spring4.x》\r\n\r\n我们知道在一般情况下，只有无状态的Bean才可以在多线程环境下共享，在Spring中，绝大部分Bean都可以声明为singleton作用域。就是因为Spring对一些Bean（如RequestContextHolder、**TransactionSynchronizationManager**、LocaleContextHolder等）中非线程安全状态的“状态性对象”采用ThreadLocal封装，让它们也成为线程安全的“状态性对象”，因此，有状态的Bean就能够以singleton的方式在多线程中工作。\r\n\r\n我们可以试着点一下进去TransactionSynchronizationManager中看一下：\r\n\r\n![img](cloudDisk/markdown/Spring框架.assets/v2-cd6b9f0bbc12d0fdcd94fd9a52851707_720w.jpg)\r\n\r\n\r\n\r\n## 五、啥是BPP？\r\n\r\nBBP的全称叫做：BeanPostProcessor，一般我们俗称**对象后处理器**\r\n\r\n- 简单来说，通过BeanPostProcessor可以对我们的对象进行“**加工处理**”。\r\n\r\nSpring管理Bean(或者说Bean的生命周期)也是一个**常考**的知识点，我在秋招也**重新**整理了一下步骤，因为比较重要，所以还是在这里贴一下吧：\r\n\r\n1. ResouceLoader加载配置信息\r\n2. BeanDefintionReader解析配置信息，生成一个一个的BeanDefintion\r\n3. BeanDefintion由BeanDefintionRegistry管理起来\r\n4. BeanFactoryPostProcessor对配置信息进行加工(也就是处理配置的信息，一般通过PropertyPlaceholderConfigurer来实现)\r\n5. 实例化Bean\r\n6. 如果该Bean`配置/实现`了InstantiationAwareBean，则调用对应的方法\r\n7. 使用BeanWarpper来完成对象之间的属性配置(依赖)\r\n8. 如果该Bean`配置/实现了`Aware接口，则调用对应的方法\r\n9. 如果该Bean配置了BeanPostProcessor的before方法，则调用\r\n10. 如果该Bean配置了`init-method`或者实现InstantiationBean，则调用对应的方法\r\n11. 如果该Bean配置了BeanPostProcessor的after方法，则调用\r\n12. 将对象放入到HashMap中\r\n13. 最后如果配置了destroy或者DisposableBean的方法，则执行销毁操作\r\n\r\n![img](cloudDisk/markdown/Spring框架.assets/v2-8ba0d9e2e79a05088cc11031b75f0963_720w.jpg)\r\n\r\n其中也有关于BPP图片：\r\n\r\n![img](cloudDisk/markdown/Spring框架.assets/v2-7474b16c7104043047ed35014ac957a8_720w.jpg)\r\n\r\n## 5.1为什么特意讲BPP？\r\n\r\nSpring AOP编程底层通过的是动态代理技术，在调用的时候肯定用的是**代理对象**。那么Spring是怎么做的呢？\r\n\r\n> 我只需要写一个BPP，在postProcessBeforeInitialization或者postProcessAfterInitialization方法中，对对象进行判断，看他需不需要织入切面逻辑，如果需要，那我就根据这个对象，生成一个代理对象，然后返回这个代理对象，那么最终注入容器的，自然就是代理对象了。\r\n\r\nSpring提供了BeanPostProcessor，就是让我们可以对有需要的对象进行“**加工处理**”啊！\r\n\r\n## 六、认识Spring事务几个重要的接口\r\n\r\nSpring事务可以分为两种：\r\n\r\n- 编程式事务(通过代码的方式来实现事务)\r\n- 声明式事务(通过配置的方式来实现事务)\r\n\r\n编程式事务在Spring实现相对简单一些，而声明式事务因为封装了大量的东西(一般我们使用简单，里头都非常复杂)，所以声明式事务实现要难得多。\r\n\r\n在编程式事务中有以下几个重要的了接口：\r\n\r\n- TransactionDefinition：定义了Spring兼容的**事务属性**(比如事务隔离级别、事务传播、事务超时、是否只读状态)\r\n- TransactionStatus：代表了事务的具体**运行状态**(获取事务运行状态的信息，也可以通过该接口**间接**回滚事务等操作)\r\n- PlatformTransactionManager：事务管理器接口(定义了一组行为，具体实现交由不同的持久化框架来完成---**类比**JDBC)\r\n\r\n![img](cloudDisk/markdown/Spring框架.assets/v2-0ffc9bddb8a1bc719545bc71ba42438c_720w.jpg)\r\n\r\n在声明式事务中，除了TransactionStatus和PlatformTransactionManager接口，还有几个重要的接口：\r\n\r\n- TransactionProxyFactoryBean：生成代理对象\r\n- TransactionInterceptor：实现对象的拦截\r\n- TransactionAttrubute：事务配置的数据\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n# Spring事务总结\r\n\r\n首先澄清一个误点：Spring本身是没有事务一说的，数据库对事务的支持才是Spring事务的本质。\r\n\r\n假设我们经常使用的MySQL数据库不提供事务功能，毫无疑问Spring也就无法提供事务功能了。纯粹使用jdbc来操作数据库，必须通过以下步骤才能使用到数据库的事务，步骤如下：\r\n\r\n获取连接 Connection con = DriverManager.getConnection()开启事务con.setAutoCommit(true/false);执行CRUD提交事务/回滚事务 con.commit() / con.rollback();关闭连接 conn.close();Spring的事务管理会自动帮我们完成上面的2和4的步骤，不再需要我们自己去手动开启和关闭。这里就可以提出一个问题：Spring是如何再CRUD的前后开启和关闭事务的呢？要回答这个问题就必须中整体上去了解Spring的事务管理实现原理了。\r\n\r\n下面我以注解方式来向大家做介绍：\r\n\r\n首先再配置文件中开启事务的注解驱动，在需要使用到事务的类和方法上使用@Transactional标识。Spring 在启动的时候会去解析生成相关的bean，这个过程中会检测拥有相关注解的类和方法，同时给带有该注解的类和方法生成相应的代理，Spring会根据在注解@Transaction上的相关参数设置进行配置注入。Spring就是在生成的代理中为我们把相关的事务问题解决了，比如开始事务，遇到异常进行事务回灌等等。在数据库中是通过binlog或者redo log来实现事务提交和回滚的。\r\n\r\n**Spring的事务机制**\r\n\r\n向我们经常使用的JPA、mybatis，hibernate等数据访问技术都有事务处理机制，他们提供了用来开启事务、提交事务来完成数据操作的相关API，或者在发生错误的时候回滚数据。\r\n\r\n当前所有的数据访问技术都能够很友好的和Spring进行集成，Spring统一处理不同数据访问技术的事务处理。在Spring中提供了一个叫做PlatformTransactionManager接口，不同的数据访问技术都会对该接口进行实现，如表所示。\r\n\r\n![img](cloudDisk/markdown/Spring框架.assets/314e251f95cad1c81a2877b6de9ffa0fc83d513c.jpeg)\r\n\r\n\r\n\r\n在程序中我们可以使用如下方式来定义事务管理器：\r\n\r\n![img](cloudDisk/markdown/Spring框架.assets/d439b6003af33a875eb25f7a59fd8d3e5243b51f.jpeg)\r\n\r\n**声明式事务**\r\n\r\nSpring中使用注解@Transactional来声明事务，添加该注解的类和方法，Spring就此处需要事务的支持。这个操作是通过AOP实现的。\r\n\r\n特别声明：@Transactional注解来自org.springframework.transaction.annotation包，而不是javax.transaction。\r\n\r\n**AOP 代理的两种实现**\r\n\r\njdk是代理接口，私有方法必然不会存在在接口里，故此也就不会被拦截到；cglib是子类，private的方法照样不会出现在子类里，也不能被拦截。**Java 动态代理**\r\n\r\n步骤：\r\n\r\n创建调用处理器，通过实现 InvocationHandler 接口完成；创建动态代理类，通过为 Proxy 类指定 ClassLoader 对象和一组 interface 来完成；使用反射技术获得动态代理类的构造方法，调用处理器接口类型是唯一参数类型；创建动态代理类实例，使用构造方法创建，调用处理器对象作为参数被传入。**GCLIB代理**\r\n\r\ncglib（Code Generation Library）是一个强大的代码生成类库。它能够在运行期扩展Java类与实现Java接口。\r\n\r\ncglib封装了asm，可以在运行期动态生成新的class（子类）。cglib用于AOP，jdk中的proxy必须基于接口，cglib却没有这个限制。**原理区别**\r\n\r\njava动态代理实质是生成了一个实现了代理接口的匿名类，这个过程使用的是反射技术来完成的，在调用具体方法前调用InvokeHandler来处理。\r\n\r\ncglib动态代理是对代理对象类的class文件加载进来，修改其字节码生成子类来处理，这个过程是通过asm开源包来实现的，具体大家可以百度，本文不做介绍。\r\n\r\n默认情况下，实现了接口的目标对象会采用JDK的动态代理实现AOP也可以强制使用CGLIB实现AOP目标对象没有实现接口，必须采用CGLIB库，Spring会自动在JDK动态代理和CGLIB之间转换**如果是类内部方法直接不是走代理，这个时候可以通过维护一个自身实例的代理。**\r\n\r\n![img](cloudDisk/markdown/Spring框架.assets/80cb39dbb6fd526652e31c2803b90a2dd507366d.jpeg)\r\n\r\n\r\n\r\n**Spring 事务的传播属性**\r\n\r\nSpring事务传播性，就是当多个事务同时存在的时候Spring如何处理这些事务的行为。这些属性都定义在在TransactionDefinition类中，相关常量含义见下表：\r\n\r\n![img](cloudDisk/markdown/Spring框架.assets/55e736d12f2eb9383123d53577c31833e7dd6fd7.jpeg)\r\n\r\n**数据库隔离级别**\r\n\r\n![img](cloudDisk/markdown/Spring框架.assets/4afbfbedab64034fe3d7eba60e62e4370b551d9b.jpeg)\r\n\r\n**脏读：**一个事务可以读取到另一个事务未提交的修改后的数据。假设这个事务发生了异常进行了事务回滚，那么这个时候另一个事务就读取到了脏数据。\r\n\r\n**不可重复读：**如果在一个事务中有两次或多次多操作，在这些读取操作之间，另一个事务对数据进行了修改，这时候读取的数据是不一致的。\r\n\r\n**幻读：**一个事务对一定范围的数据进行批量修改，另一个事务在这个范围增加一条数据，此时该事务就会丢失对新增数据的修改。\r\n\r\n**总结**\r\n\r\n隔离级别越高，越能保证数据的完整性和一致性，但是对并发性能的影响也越大。\r\n\r\n一般数据库默认隔离级别： Read Commited，比如 SqlServer、Oracle\r\n\r\n少数数据库默认隔离级别为：Repeatable Read 比如：MySQL InnoDB\r\n\r\n\r\n\r\n**Spring中的隔离级别**\r\n\r\n![img](cloudDisk/markdown/Spring框架.assets/d058ccbf6c81800a4757b2021394aefc838b47b7.jpeg)\r\n\r\n**事务的嵌套**\r\n\r\n接下来我们通过分析一些嵌套事务的场景，来深入理解spring事务传播的机制。\r\n\r\n假设外层事务 Service A 的 Method A() 调用 内层Service B 的 Method B()\r\n\r\n**PROPAGATION_REQUIRED(Spring 默认)**\r\n\r\n如果ServiceB.methodB() 的事务级别定义为 PROPAGATION_REQUIRED，那么执行 ServiceA.methodA() 的时候spring已经起了事务，这时调用 ServiceB.methodB()，ServiceB.methodB() 看到自己已经运行在 ServiceA.methodA() 的事务内部，就不再起新的事务。\r\n\r\n假如 ServiceB.methodB() 运行的时候发现自己没有在事务中，他就会为自己分配一个事务。\r\n\r\n这样，在 ServiceA.methodA() 或者在 ServiceB.methodB() 内的任何地方出现异常，事务都会被回滚。\r\n\r\n**PROPAGATION_REQUIRES_NEW**\r\n\r\n比如我们设计 ServiceA.methodA() 的事务级别为 PROPAGATION_REQUIRED，ServiceB.methodB() 的事务级别为 PROPAGATION_REQUIRES_NEW。\r\n\r\n那么当执行到 ServiceB.methodB() 的时候，ServiceA.methodA() 所在的事务就会挂起，ServiceB.methodB() 会起一个新的事务，等待 ServiceB.methodB() 的事务完成以后，它才继续执行。\r\n\r\n他与 PROPAGATION_REQUIRED 的事务区别在于事务的回滚程度了。因为 ServiceB.methodB() 是新起一个事务，那么就是存在两个不同的事务。如果 ServiceB.methodB() 已经提交，那么 ServiceA.methodA() 失败回滚，ServiceB.methodB() 是不会回滚的。如果 ServiceB.methodB() 失败回滚，如果他抛出的异常被 ServiceA.methodA() 捕获，ServiceA.methodA() 事务仍然可能提交(主要看B抛出的异常是不是A会回滚的异常)。\r\n\r\n**PROPAGATION_SUPPORTS**\r\n\r\n假设ServiceB.methodB() 的事务级别为 PROPAGATION_SUPPORTS，那么当执行到ServiceB.methodB()时，如果发现ServiceA.methodA()已经开启了一个事务，则加入当前的事务，如果发现ServiceA.methodA()没有开启事务，则自己也不开启事务。这种时候，内部方法的事务性完全依赖于最外层的事务。\r\n\r\n**PROPAGATION_NESTED**\r\n\r\n现在的情况就变得比较复杂了, ServiceB.methodB() 的事务属性被配置为 PROPAGATION_NESTED, 此时两者之间又将如何协作呢? ServiceB#methodB 如果 rollback, 那么内部事务(即 ServiceB#methodB) 将回滚到它执行前的 SavePoint 而外部事务(即 ServiceA#methodA) 可以有以下两种处理方式:\r\n\r\na、捕获异常，执行异常分支逻辑\r\n\r\n![img](cloudDisk/markdown/Spring框架.assets/0ff41bd5ad6eddc472f0f823a77a2bfb5366337e.jpeg)\r\n\r\n这种方式也是嵌套事务最有价值的地方, 它起到了分支执行的效果, 如果 ServiceB.methodB 失败, 那么执行 ServiceC.methodC(), 而 ServiceB.methodB 已经回滚到它执行之前的 SavePoint, 所以不会产生脏数据(相当于此方法从未执行过), 这种特性可以用在某些特殊的业务中, 而 PROPAGATION_REQUIRED 和 PROPAGATION_REQUIRES_NEW 都没有办法做到这一点。\r\n\r\nb、 外部事务回滚/提交 代码不做任何修改， 那么如果内部事务(ServiceB#methodB) rollback, 那么首先 ServiceB.methodB 回滚到它执行之前的 SavePoint(在任何情况下都会如此), 外部事务(即 ServiceA#methodA) 将根据具体的配置决定自己是 commit 还是 rollback\r\n\r\n另外三种事务传播属性基本用不到，在此不做分析。\r\n\r\n**总结**\r\n\r\n对于项目中需要使用到事务的地方，我建议开发者还是使用spring的TransactionCallback接口来实现事务，不要盲目使用spring事务注解，如果一定要使用注解，那么一定要对spring事务的传播机制和隔离级别有个详细的了解，否则很可能发生意想不到的效果。\r\n\r\n**Spring Boot 对事务的支持**\r\n\r\n通过org.springframework.boot.autoconfigure.transaction.TransactionAutoConfiguration类。我们可以看出Spring Boot自动开启了对注解事务的支持 Spring\r\n\r\n**只读事务（@Transactional(readOnly = true)）的一些概念**\r\n\r\n概念：从这一点设置的时间点开始（时间点a）到这个事务结束的过程中，其他事务所提交的数据，该事务将看不见！（查询中不会出现别人在时间点a之后提交的数据）。@Transcational(readOnly=true) 这个注解一般会写在业务类上，或者其方法上，用来对其添加事务控制。当括号中添加readOnly=true, 则会告诉底层数据源，这个是一个只读事务，对于JDBC而言，只读事务会有一定的速度优化。\r\n\r\n而这样写的话，事务控制的其他配置则采用默认值，事务的隔离级别(isolation) 为DEFAULT,也就是跟随底层数据源的隔离级别，事务的传播行为(propagation)则是REQUIRED，所以还是会有事务存在，一代在代码中抛出RuntimeException，依然会导致事务回滚。\r\n\r\n应用场合：如果你一次执行单条查询语句，则没有必要启用事务支持，数据库默认支持SQL执行期间的读一致性；如果你一次执行多条查询语句，例如统计查询，报表查询，在这种场景下，多条查询SQL必须保证整体的读一致性，否则，在前条SQL查询之后，后条SQL查询之前，数据被其他用户改变，则该次整体的统计查询将会出现读数据不一致的状态，此时，应该启用事务支持。【注意是一次执行多次查询来统计某些信息，这时为了保证数据整体的一致性，要用只读事务】\r\n\r\n\r\n\r\n','2022-06-23 22:17:57','“We use a lot of the tools that come with the Spring framework and reap the benefits of having a lot of the out of the box solutions, and not having to worry about writing a ton of additional code—so ','/cloudDisk/markdown/20220623093950_df751c4a_1655948390627.png','原创','','','\0','Spring框架学习笔记（下）','2022-06-23 22:17:57',4,102,NULL,0),(187,'','# 一、微服务框架\r\n\r\nJavase：OOP\r\n\r\nmySQL：持久化\r\n\r\nhtml + css + js + jquert + 框架：视图，框架不熟练，css不好\r\n\r\njavaweb：独立开发MVC三层架构的网站：原始\r\n\r\nssm：框架：简化了我们的开发流程，配置也开始较为复杂\r\n\r\n**war：tomcat运行**\r\n\r\nspring再简化：SpringBoot - jar：内嵌tomcat；微服务架构！\r\n\r\n服务越来越多：springCloud\r\n\r\n![image-20220513172057061](cloudDisk/markdown/springBoot笔记.assets/image-20220513172057061.png)\r\n\r\n\r\n\r\nMVC三层架构、MVVM、微服务架构\r\n\r\n业务：service：userService\r\n\r\npsringmvc，controller >>> 提供接口\r\n\r\n\r\n\r\n# 二、第一个SpringBoot程序\r\n\r\n* jdk1.8\r\n* maven 3.6.1\r\n* springboot: 最新版\r\n* IDEA\r\n\r\n## 1） 项目创建\r\n\r\n![image-20220513190922275](cloudDisk/markdown/springBoot笔记.assets/image-20220513190922275.png)\r\n\r\n![image-20220513190932897](cloudDisk/markdown/springBoot笔记.assets/image-20220513190932897.png)\r\n\r\n![image-20220513191011319](cloudDisk/markdown/springBoot笔记.assets/image-20220513191011319.png)\r\n\r\n![image-20220513191024831](cloudDisk/markdown/springBoot笔记.assets/image-20220513191024831.png)\r\n\r\n![image-20220513191104394](cloudDisk/markdown/springBoot笔记.assets/image-20220513191104394.png)\r\n\r\n## 2）程序入口 DemoApplication\r\n\r\n![image-20220513191129482](cloudDisk/markdown/springBoot笔记.assets/image-20220513191129482.png)\r\n\r\n## 3) 核心配置文件\r\n\r\n![image-20220513191159547](cloudDisk/markdown/springBoot笔记.assets/image-20220513191159547.png)\r\n\r\n## 4）controller\r\n\r\n![image-20220513191218997](cloudDisk/markdown/springBoot笔记.assets/image-20220513191218997.png)\r\n\r\n## 4）maven依赖\r\n\r\n```xml\r\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\r\n         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\">\r\n    <modelVersion>4.0.0</modelVersion>\r\n    <!--有一个父项目-->\r\n    <parent>\r\n        <groupId>org.springframework.boot</groupId>\r\n        <artifactId>spring-boot-starter-parent</artifactId>\r\n        <version>2.6.7</version>\r\n        <relativePath/> <!-- lookup parent from repository -->\r\n    </parent>\r\n    <groupId>com.example</groupId>\r\n    <artifactId>demo</artifactId>\r\n    <version>0.0.1-SNAPSHOT</version>\r\n    <name>demo</name>\r\n    <description>Demo project for Spring Boot</description>\r\n    <properties>\r\n        <java.version>1.8</java.version>\r\n    </properties>\r\n    <dependencies>\r\n        <!--web依赖：集成tomcat，dispatchServlet，xml。。。-->\r\n        <dependency>\r\n            <groupId>org.springframework.boot</groupId>\r\n            <artifactId>spring-boot-starter-web</artifactId>\r\n        </dependency>\r\n        <!--单元测试-->\r\n        <dependency>\r\n            <groupId>org.springframework.boot</groupId>\r\n            <artifactId>spring-boot-starter-test</artifactId>\r\n            <scope>test</scope>\r\n        </dependency>\r\n    </dependencies>\r\n\r\n    <!--所有的springboot依赖，都是spring-boot-starter-开头的-->\r\n\r\n    <build>\r\n        <!--jar包插件-->\r\n        <plugins>\r\n            <plugin>\r\n                <groupId>org.springframework.boot</groupId>\r\n                <artifactId>spring-boot-maven-plugin</artifactId>\r\n            </plugin>\r\n        </plugins>\r\n    </build>\r\n\r\n</project>\r\n```\r\n\r\n\r\n\r\n官方：提供了一个快速生成的网站！IDEA集成了这个网站！\r\n\r\n* 可以在官网直接下载后，导入IDEA开发\r\n* 直接使用idea创建一个springboot项目\r\n\r\n## 5） 改端口号\r\n\r\n/application.properties\r\n\r\n```properties\r\n# springboot 核心配置文件\r\nserver.port=8511\r\n\r\n```\r\n\r\n## 6)修改启动字符\r\n\r\nhttps://bootschool.net/ascii-art/chinese\r\n\r\n![image-20220513193954561](cloudDisk/markdown/springBoot笔记.assets/image-20220513193954561.png)\r\n\r\n![image-20220513194005521](cloudDisk/markdown/springBoot笔记.assets/image-20220513194005521.png)\r\n\r\n# 三、原理初探\r\n\r\n自动配置：\r\n\r\n\r\n\r\npom.xml\r\n\r\n* spring-book-dependencies: 核心依赖在父工程中\r\n* 我们在写或者引入springboot依赖时，不需要指定版本，就因为有这些版本仓库\r\n\r\n\r\n\r\n启动器\r\n\r\n* ```xml\r\n      <!--web依赖：集成tomcat，dispatchServlet，xml。。。-->\r\n      <dependency>\r\n          <groupId>org.springframework.boot</groupId>\r\n          <artifactId>spring-boot-starter-web</artifactId>\r\n      </dependency>\r\n  ```\r\n\r\n* 启动器：就是springboot的启动场景\r\n\r\n* 比如spring-boot-starter-web，他就会自动导入web环境所有依赖\r\n\r\n* springboot会将所有的功能场景，变成一个个启动器，\r\n\r\n* 如果我们要使用什么功能，只需找到对应的启动器即可\r\n\r\n\r\n\r\n## 主程序\r\n\r\n```java\r\n// @SpringBootApplication: 标注这个类是springboot的应用：启动类的所有资源被导入\r\n@SpringBootApplication\r\npublic class DemoApplication {\r\n    public static void main(String[] args) {\r\n        // 将springboot应用启动\r\n        SpringApplication.run(DemoApplication.class, args);\r\n    }\r\n\r\n}\r\n```\r\n\r\n* 注解\r\n\r\n  * \r\n\r\n  * ```java\r\n    @SpringBootConfiguration ： spring的配置\r\n    	@Configuration：spring配置类\r\n    	@Component：说明是个spring的组件\r\n    	\r\n    @EnableAutoConfiguration: 自动配置\r\n        @AutoConfigurationPackage：自动配置包\r\n        	@Import({Registrar.class})：自动配置“包注册”\r\n        @Import({AutoConfigurationImportSelector.class})：自动配置导入选择\r\n    \r\n    \r\n    // 获取所有的配置\r\n    List<String> configurations = this.getCandidateConfigurations(annotationMetadata, attributes);\r\n    ```\r\n\r\n    获取候选的配置\r\n\r\n    ```java\r\n    protected List<String> getCandidateConfigurations(AnnotationMetadata metadata, AnnotationAttributes attributes) {\r\n        List<String> configurations = SpringFactoriesLoader.loadFactoryNames(this.getSpringFactoriesLoaderFactoryClass(), this.getBeanClassLoader());\r\n        Assert.notEmpty(configurations, \"No auto configuration classes found in META-INF/spring.factories. If you are using a custom packaging, make sure that file is correct.\");\r\n        return configurations;\r\n    }\r\n    ```\r\n\r\n    META-INF/spring.factories 自动配置的核心文件\r\n\r\n    ![image-20220513200857196](cloudDisk/markdown/springBoot笔记.assets/image-20220513200857196.png)\r\n\r\n```\r\n// 所有配置加载到配置类中\r\nProperties properties = PropertiesLoaderUtils.loadProperties(resource);\r\n```\r\n\r\n![分析](cloudDisk/markdown/springBoot笔记.assets/分析.png)\r\n\r\n结论：springBoot的所有自动配置都是在启动的时候扫描并加载：spring.factories所有的自动配置类都在这里面，但是不一定生效，要判断条件是都成立，只要导入对应的start，就有对应的启动器了，有了启动器，我们的自动装配就会自动生效，然后配置成功\r\n\r\n1. springboot在启动的时候，从类路径下/META-INF/spring.factories 获取指定的值\r\n2. 将这些自动配置的类导入容器，自动配置就会生效，帮我们进行自动配置\r\n3. 以前我们需要配置的东西，sprinigboot已经帮我们做了\r\n4. 整合JavaEE，解决方案和自动配置的东西都在spring-boot-a下autoconfigure-2.2.0.RELEASE.jar这个包下\r\n5. 他会把所有需要导入的组件，以类名的方式返回，他就会被添加到容器\r\n6. 容器中也会存在很多的xxxxxautoConfiguration的文件（@Bean），就是这些类给容器中导入了这和场景需要的组件；并自动配置。@Configuration，JavaConfig\r\n7. 有了自动配置类，就免去了手动配置文件\r\n\r\n\r\n\r\nDocker：进程\r\n\r\n\r\n\r\n面试：关于SpringBoot，谈谈你的理解\r\n\r\n* 自动装配\r\n* run() // 开启服务\r\n  * 执行的步骤：\r\n    1. 推断应用类型是普通的java项目还是web项目\r\n    2. 查找并加载所有可用的初始化器，设置到initializers实行中\r\n    3. 找出所有的应用程序监听器，设置到listeners属性中\r\n    4. 推断并且设置main方法定义类，找到运行的主类\r\n\r\n\r\n\r\n全面接管SpringMVC得配置！ 实操\r\n\r\n\r\n\r\n# 四、SpringBoot配置\r\n\r\n官方的application.properties 配置\r\n\r\nhttps://docs.spring.io/spring-boot/docs/current/reference/html/application-properties.html#appendix.application-properties\r\n\r\n## yaml配置\r\n\r\n标记语言：\r\n\r\n以前的配置文件，大多数都是用xml来配置，比如一个简单的端口配置，我们来对比下yaml和xml的区别\r\n\r\nyml：\r\n\r\n```yaml\r\nserver:\r\n  port: 8080\r\n```\r\n\r\nxml：\r\n\r\n```xml\r\n<server> \r\n	<port>8080</port>\r\n</server>\r\n```\r\n\r\n\r\n\r\n### yaml可以直接给实体类赋值\r\n\r\n1. 实体类\r\n\r\n   ```java\r\n   @Component\r\n   @ConfigurationProperties(prefix = \"person\")\r\n   public class Person {\r\n       private String name;\r\n       private Integer age;\r\n       private Boolean happy;\r\n       private Date birth;\r\n       private Map<String, Object> maps;\r\n       private List<Object> list;\r\n       private Dog dog;\r\n   ```\r\n\r\n2. application.yaml\r\n\r\n   ```yaml\r\n   person:\r\n     name: tony\r\n     age: 3\r\n     happy: false\r\n     birth: 2000/8/13\r\n     maps: {k1: v1, k2: v2}\r\n     list:\r\n       - code\r\n       - music\r\n       - girl\r\n     dog:\r\n       name: 旺财\r\n       age: 3\r\n   ```\r\n\r\n3. test\r\n\r\n   ```java\r\n   @SpringBootTest\r\n   class DemoApplicationTests {\r\n       @Autowired\r\n       private Person person;\r\n   \r\n       @Test\r\n       void contextLoads() {\r\n           System.out.println(person);\r\n       }\r\n   \r\n   }\r\n   ```\r\n\r\n   ![image-20220514151736954](cloudDisk/markdown/springBoot笔记.assets/image-20220514151736954.png)\r\n\r\n   ### spring配种文件中的el表达式\r\n\r\n   ```yaml\r\n   person:\r\n     name: ${random.uuid}\r\n     age: ${random.int}\r\n     happy: false\r\n     birth: 2000/8/13\r\n     maps: {k1: v1, k2: v2}\r\n     hello: happy\r\n     list:\r\n       - code\r\n       - music\r\n       - girl\r\n     dog:\r\n       name: ${person.hello:hello}_旺财 # 如果hello变量存在，占位符为happy\r\n       age: 3\r\n   ```\r\n\r\n   output 》》》\r\n\r\n   ```\r\n   Person{name=\'a66586c0-23d3-4313-b488-a8403f7f931c\', age=92237417, happy=false, birth=Sun Aug 13 00:00:00 CST 2000, maps={k1=v1, k2=v2}, list=[code, music, girl], dog=Dog{name=\'happy_旺财\', age=3}}\r\n   ```\r\n\r\nspring注入 和 yaml配置文件注入区别\r\n\r\n![image-20220514153126446](cloudDisk/markdown/springBoot笔记.assets/image-20220514153126446.png)\r\n\r\n![image-20220514153604688](cloudDisk/markdown/springBoot笔记.assets/image-20220514153604688.png)\r\n\r\n结论：\r\n\r\n![image-20220514153653873](cloudDisk/markdown/springBoot笔记.assets/image-20220514153653873.png)\r\n\r\n### jsr303校验注解（了解）：\r\n\r\n导入依赖\r\n\r\n```xml\r\n        <dependency>\r\n            <groupId>org.wildfly.swarm</groupId>\r\n            <artifactId>spring-boot-starter-validation</artifactId>\r\n            <version>1.0.0.Alpha2</version>\r\n        </dependency>\r\n```\r\n\r\n数据校验\r\n\r\n```java\r\n@Validated //数据校验\r\n```\r\n\r\njava类：\r\n\r\n```java\r\n@Component\r\n@ConfigurationProperties(prefix = \"person\")\r\n@Validated //数据校验\r\npublic class person {\r\n    @Email(message = \"邮箱格式错误\")\r\n    private String name;\r\n    private Integer age;\r\n    private Boolean happy;\r\n    private Date birth;\r\n    private Map<String,Object> maps;\r\n    private List<Object> lists;\r\n    private Dog dog;\r\n```\r\n\r\nYML:此时我们的name并不是邮箱格式\r\n\r\n```yaml\r\nperson:\r\n  name: hyc\r\n  age : ${random.int}\r\n  happy: false\r\n  birth: 2019/11/02\r\n  maps: {k1: 123, k2: 456}\r\n  lists:\r\n    -code\r\n    -music\r\n    -girl\r\n  dog:\r\n      name: 旺财\r\n      age: 3\r\n```\r\n\r\n执行效果：\r\n\r\n![image-20220514154306624](cloudDisk/markdown/springBoot笔记.assets/image-20220514154306624.png)\r\n\r\n使用了[@Validated](https://github.com/Validated) //数据校验注解的类可以对自己的属性设置格式数据校验\r\n\r\n#### 全部注解：\r\n\r\n![img](cloudDisk/markdown/springBoot笔记.assets/kuangstudy70254ea9-25ee-4507-b647-b9565c303220.png)\r\n\r\n常用注解：![img](cloudDisk/markdown/springBoot笔记.assets/kuangstudy08b15162-bf8f-4cb4-b387-3354dd1c30e1.png)\r\n\r\n![img](cloudDisk/markdown/springBoot笔记.assets/kuangstudyc704d1f6-2e61-437c-b5f1-d055b10bc73f.png)\r\n\r\n正则表达式：相对核心\r\n\r\n源码位置：![img](cloudDisk/markdown/springBoot笔记.assets/kuangstudy6c144f8b-8009-4176-ad89-886ef67e175d.png)\r\n\r\n### 多配置文件及切换\r\n\r\n我们在主配置文件编写的时候，文件名可以是 application-{profile}.properties/yml , 用来指定多个环境版本；\r\n\r\napplication-test.properties 代表测试环境配置\r\n\r\napplication-dev.properties 代表开发环境配置\r\n\r\n但是Springboot并不会直接启动这些配置文件，它**默认使用application.properties主配置文件**；\r\n\r\n我们需要通过一个配置来选择需要激活的环境：\r\n\r\n1. `#比如在配置文件中指定使用dev环境，我们可以通过设置不同的端口号进行测试；#我们启动SpringBoot，就可以看到已经切换到dev下的配置了；spring.profiles.active=dev`\r\n\r\n```yml\r\nserver:  \r\n  port: 8080\r\n#选择要激活那个环境块\r\nspring:  \r\n    profiles:\r\n      active: dev\r\n---\r\nserver:\r\n  port: 8081\r\nprofiles: test\r\n---\r\nserver:\r\n  port: 8082\r\nprofiles: dev\r\n```\r\n\r\n**注意：如果yml和properties同时都配置了端口，并且没有激活其他环境 ， 默认会使用properties配置文件的！**\r\n\r\n# 五、自动装配原理\r\n\r\n```java\r\n//表示这是一个配置类\r\n@Configuration(\r\n    proxyBeanMethods = false\r\n)\r\n//自动配置属性:   ServerProperties\r\n@EnableConfigurationProperties({ServerProperties.class})\r\n//spring的底层注解：根据不同条件来判断当前配置或者类是否生效\r\n@ConditionalOnWebApplication(\r\n    type = Type.SERVLET\r\n)\r\n@ConditionalOnClass({CharacterEncodingFilter.class})\r\n@ConditionalOnProperty(\r\n    prefix = \"server.servlet.encoding\",\r\n    value = {\"enabled\"},\r\n    matchIfMissing = true\r\n)\r\npublic class HttpEncodingAutoConfiguration {\r\n    private final Encoding properties;\r\n    public HttpEncodingAutoConfiguration(ServerProperties properties) {\r\n        this.properties = properties.getServlet().getEncoding();\r\n    }\r\n    @Bean\r\n    @ConditionalOnMissingBean\r\n    public CharacterEncodingFilter characterEncodingFilter() {\r\n        CharacterEncodingFilter filter = new OrderedCharacterEncodingFilter();\r\n        filter.setEncoding(this.properties.getCharset().name());\r\n        filter.setForceRequestEncoding(this.properties.shouldForce(org.springframework.boot.web.servlet.server.Encoding.Type.REQUEST));\r\n        filter.setForceResponseEncoding(this.properties.shouldForce(org.springframework.boot.web.servlet.server.Encoding.Type.RESPONSE));\r\n        return filter;\r\n    }\r\n    @Bean\r\n    public HttpEncodingAutoConfiguration.LocaleCharsetMappingsCustomizer localeCharsetMappingsCustomizer() {\r\n        return new HttpEncodingAutoConfiguration.LocaleCharsetMappingsCustomizer(this.properties);\r\n    }\r\n    static class LocaleCharsetMappingsCustomizer implements WebServerFactoryCustomizer<ConfigurableServletWebServerFactory>, Ordered {\r\n        private final Encoding properties;\r\n        LocaleCharsetMappingsCustomizer(Encoding properties) {\r\n            this.properties = properties;\r\n        }\r\n        public void customize(ConfigurableServletWebServerFactory factory) {\r\n            if (this.properties.getMapping() != null) {\r\n                factory.setLocaleCharsetMappings(this.properties.getMapping());\r\n            }\r\n        }\r\n        public int getOrder() {\r\n            return 0;\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n## 精髓\r\n\r\n1、SpringBoot启动会加载大量的自动配置类\r\n\r\n2、我们看我们需要的功能有没有在SpringBoot默认写好的自动配置类当中；\r\n\r\n3、我们再来看这个自动配置类中到底配置了哪些组件；（只要我们要用的组件存在在其中，我们就不需要再手动配置了）\r\n\r\n4、给容器中自动配置类添加组件的时候，会从properties类中获取某些属性。我们只需要在配置文件中指定这些属性的值即可；\r\n\r\n**xxxxAutoConfigurartion：自动配置类；**给容器中添加组件\r\n\r\n**xxxxProperties:封装配置文件中相关属性；**\r\n\r\n\r\n\r\ndebug = true // 查看配置了哪些\r\n\r\n\r\n\r\n# 六、简单的来了！SpringBoot Web开发\r\n\r\njar：webapp！\r\n\r\n自动装配\r\n\r\nspringboot到底帮我们配置了什么？我们能不能修改？能修改哪些东西？能不能扩展？\r\n\r\n* xxxxAutoConfiguration.. 向容器中自动配置组件\r\n* xxxxProperties：自动配置类，装配配置文件中自定义的一些内容\r\n\r\n\r\n\r\n要解决的问题：\r\n\r\n* 导入静态资源。。。\r\n* 首页\r\n* jsp，模板引擎Thymeleaf\r\n* 装配扩展SpringMVC\r\n* 增删改查\r\n* 拦截器\r\n* 国际化\r\n\r\n## 分析源码，静态资源路径\r\n\r\nWebMvcAutoConfiguration.java\r\n\r\n```java\r\npublic void addResourceHandlers(ResourceHandlerRegistry registry) {\r\n    if (!this.resourceProperties.isAddMappings()) {\r\n        logger.debug(\"Default resource handling disabled\");\r\n    } else {\r\n        this.addResourceHandler(registry, \"/webjars/**\", \"classpath:/META-INF/resources/webjars/\");\r\n        this.addResourceHandler(registry, this.mvcProperties.getStaticPathPattern(), (registration) -> {\r\n            registration.addResourceLocations(this.resourceProperties.getStaticLocations());\r\n            // staticLocations: {\"classpath:/META-INF/resources/\", \"classpath:/resources/\", \"classpath:/static/\", \"classpath:/public/\"};\r\n            if (this.servletContext != null) {\r\n                ServletContextResource resource = new ServletContextResource(this.servletContext, \"/\");\r\n                registration.addResourceLocations(new Resource[]{resource});\r\n            }\r\n\r\n        });\r\n    }\r\n}\r\n```\r\n\r\n```java\r\n    public static class Resources {\r\n        private static final String[] CLASSPATH_RESOURCE_LOCATIONS = new String[]{\"classpath:/META-INF/resources/\", \"classpath:/resources/\", \"classpath:/static/\", \"classpath:/public/\"};\r\n        private String[] staticLocations;\r\n        private boolean addMappings;\r\n        private boolean customized;\r\n        private final WebProperties.Resources.Chain chain;\r\n        private final WebProperties.Resources.Cache cache;\r\n\r\n        public Resources() {\r\n            this.staticLocations = CLASSPATH_RESOURCE_LOCATIONS;\r\n            this.addMappings = true;\r\n            this.customized = false;\r\n            this.chain = new WebProperties.Resources.Chain();\r\n            this.cache = new WebProperties.Resources.Cache();\r\n        }\r\n```\r\n\r\n源码总结:\r\n\r\n1. 在springboot，我们可以使用以下方式处理静态资源\r\n   * webjars 			 虚拟目录：localhost:8080/webjars/\r\n   * 资源目录下的：public， static，/**, resources 	 虚拟目录：localhost:8080/\r\n2. 优先级：resources > static > public\r\n\r\n## 分析源码，首页路径\r\n\r\n```java\r\n        private Resource getWelcomePage() {\r\n            String[] var1 = this.resourceProperties.getStaticLocations();\r\n            int var2 = var1.length;\r\n\r\n            for(int var3 = 0; var3 < var2; ++var3) {\r\n                String location = var1[var3];\r\n                Resource indexHtml = this.getIndexHtml(location);\r\n                if (indexHtml != null) {\r\n                    return indexHtml;\r\n                }\r\n            }\r\n\r\n            ServletContext servletContext = this.getServletContext();\r\n            if (servletContext != null) {\r\n                return this.getIndexHtml((Resource)(new ServletContextResource(servletContext, \"/\")));\r\n            } else {\r\n                return null;\r\n            }\r\n        }\r\n\r\n        private Resource getIndexHtml(String location) {\r\n            return this.getIndexHtml(this.resourceLoader.getResource(location));\r\n        }\r\n\r\n        private Resource getIndexHtml(Resource location) {\r\n            try {\r\n                Resource resource = location.createRelative(\"index.html\");\r\n                if (resource.exists() && resource.getURL() != null) {\r\n                    return resource;\r\n                }\r\n            } catch (Exception var3) {\r\n            }\r\n\r\n            return null;\r\n        }\r\n```\r\n\r\n## 模板引擎 thymeleaf类似JSP\r\n\r\n官网：https://www.thymeleaf.org/\r\n\r\nhttps://www.thymeleaf.org/doc/tutorials/3.0/usingthymeleaf.html#standard-expression-syntax\r\n\r\n```xml\r\n<dependency>\r\n    <groupId>org.thymeleaf</groupId>\r\n    <artifactId>thymeleaf-spring5</artifactId>\r\n</dependency>\r\n<dependency>\r\n    <groupId>org.thymeleaf.extras</groupId>\r\n    <artifactId>thymeleaf-extras-java8time</artifactId>\r\n</dependency>\r\n```\r\n\r\n查看thymeleafProperties.java 源码\r\n\r\n```java\r\npublic static final String DEFAULT_PREFIX = \"classpath:/templates/\";\r\npublic static final String DEFAULT_SUFFIX = \".html\";\r\n```\r\n\r\n结论：只需要使用thymeleaf，只需要导入对应依赖就可以了！我们将html放在我们的templates目录下！\r\n\r\n### 试下手\r\n\r\ntest.html\r\n\r\n```html\r\n<!DOCTYPE html>\r\n<html lang=\"en\" xmlns:th=\"http://www.thymeleaf.org\">\r\n<head>\r\n    <meta charset=\"UTF-8\">\r\n    <title>Title</title>\r\n</head>\r\n<body>\r\n<!--所有的html元素都可以被 thymeleaf 替换接管： th: 元素名-->\r\n    <div th:text=\"${msg}\"></div>\r\n</body>\r\n</html>\r\n```\r\n\r\n```java\r\n@Controller\r\npublic class IndexController {\r\n    @GetMapping(\"/test\")\r\n    public String index(Model model){\r\n        model.addAttribute(\"msg\", \"hello\");\r\n        return \"test\";\r\n    }\r\n}\r\n```\r\n\r\n![image-20220515221429913](cloudDisk/markdown/springBoot笔记.assets/image-20220515221429913.png)\r\n\r\n### 循环\r\n\r\ntest.html\r\n\r\n```html\r\n<!DOCTYPE html>\r\n<html lang=\"en\" xmlns:th=\"http://www.thymeleaf.org\">\r\n<head>\r\n    <meta charset=\"UTF-8\">\r\n    <title>Title</title>\r\n</head>\r\n<body>\r\n<!--所有的html元素都可以被 thymeleaf 替换接管： th: 元素名-->\r\n    <div th:text=\"${msg}\"></div>\r\n    <div th:utext=\"${msg}\"></div>\r\n    <hr>\r\n    <!--遍历-->\r\n    <!--方式1-->\r\n<!--    <h3 th:each=\"user: ${users}\">[[ ${user} ]]</h3>--> <!--不推荐-->\r\n    <h3 th:each=\"user: ${users}\" th:text=\"${user}\"></h3>\r\n\r\n</body>\r\n</html>\r\n```\r\n\r\n```java\r\n@Controller\r\npublic class IndexController {\r\n    @GetMapping(\"/test\")\r\n    public String index(Model model){\r\n        model.addAttribute(\"msg\", \"<h1>hello</h1>\");\r\n\r\n        model.addAttribute(\"users\", Arrays.asList(\"tony\", \"zhangsan\", \"lisi\"));\r\n        return \"test\";\r\n    }\r\n}\r\n```\r\n\r\n### 扩展视图解析器\r\n\r\nMyMvcConfig.java\r\n\r\n```java\r\n// 如果需要定制一些功能，只需写这个组件，然后交给springboot，springboot就会帮我们自动装配\r\n// 扩展SpringMVC\r\n@Configuration\r\npublic class MyMvcConfig implements WebMvcConfigurer {\r\n    // ViewResolver 实现了视图解析接口的类，我们就可以把他看作视图解析器\r\n    @Bean\r\n    public ViewResolver myViewResolver(){\r\n        return new MyViewResolver();\r\n    }\r\n\r\n    // 自定义了一个视图解析器，MyViewResolver\r\n    public static class MyViewResolver implements ViewResolver{\r\n        @Override\r\n        public View resolveViewName(String viewName, Locale locale) throws Exception {\r\n            return null;\r\n        }\r\n    }\r\n\r\n}\r\n```\r\n\r\nMyMvcConfig.java\r\n\r\n```java\r\n// 如果我们要扩展springMvc，官方建议我们这样去做！\r\n@Configuration\r\n//@EnableWebMvc // 其实导入了一个类：DelegatingWebMvcConfiguration：从容器中获取所有的webMvcConfig\r\npublic class MyMvcConfig implements WebMvcConfigurer {\r\n    // 视图跳转\r\n    @Override\r\n    public void addViewControllers(ViewControllerRegistry registry) {\r\n        registry.addViewController(\"/kuang\").setViewName(\"test\");\r\n    }\r\n}\r\n\r\n```\r\n\r\n在springboot中，有非常多的**configuration** \r\n\r\n# 七、员工关系系统\r\n\r\n## 准备工作\r\n\r\n### dao层\r\n\r\n```java\r\n// 部门表\r\n@Data\r\n@AllArgsConstructor\r\n@NoArgsConstructor\r\npublic class Department {\r\n    private Integer id;\r\n    private String name;\r\n}\r\n\r\n```\r\n\r\n```java\r\n@Data\r\n@NoArgsConstructor\r\npublic class Employee {\r\n    private Integer id;\r\n    private String lastName;\r\n    private String email;\r\n    private Integer gender; // 0: 女；1：男\r\n    private Department department;\r\n    private Date birth;\r\n\r\n    public Employee(Integer id, String lastName, String email, Integer gender, Department department) {\r\n        this.id = id;\r\n        this.lastName = lastName;\r\n        this.email = email;\r\n        this.gender = gender;\r\n        this.department = department;\r\n        this.birth = new Date(); // 默认的创建日期\r\n    }\r\n}\r\n\r\n```\r\n\r\n```java\r\n// 部门dao\r\n@Repository\r\npublic class DepartmentDao {\r\n    private static Map<Integer, Department> departmentMap = null;\r\n    // 模拟数据库中的数据\r\n    static {\r\n        departmentMap = new HashMap<>(); // 创建部门表\r\n        departmentMap.put(101, new Department(101, \"教学部\"));\r\n        departmentMap.put(102, new Department(102, \"市场部\"));\r\n        departmentMap.put(103, new Department(103, \"教研部\"));\r\n        departmentMap.put(104, new Department(104, \"运营部\"));\r\n        departmentMap.put(105, new Department(105, \"后勤部\"));\r\n    }\r\n\r\n    // 获取所有部门信息\r\n    public Collection<Department> getDepartments(){\r\n        return departmentMap.values();\r\n    }\r\n\r\n    // 通过id获取部门\r\n    public Department getDepartment(Integer id){\r\n        return departmentMap.get(id);\r\n    }\r\n}\r\n\r\n\r\n```\r\n\r\n```java\r\n// 员工Dao\r\n@Repository\r\npublic class EmployeeDao {\r\n    private static Map<Integer, Employee> employeeMap = null;\r\n    // 员工有所属部门\r\n    @Autowired\r\n    private DepartmentDao departmentDao;\r\n    // 模拟数据库中的数据\r\n    static {\r\n        employeeMap = new HashMap<>(); // 创建部门表\r\n        employeeMap.put(1001, new Employee(1001, \"AA\", \"A123123@qq.com\", 1, new Department(101, \"教学部\")));\r\n        employeeMap.put(1002, new Employee(1002, \"BB\", \"B123123@qq.com\", 0, new Department(102, \"市场部\")));\r\n        employeeMap.put(1003, new Employee(1003, \"CC\", \"C123123@qq.com\", 1, new Department(103, \"教研部\")));\r\n        employeeMap.put(1004, new Employee(1004, \"DD\", \"D123123@qq.com\", 0, new Department(104, \"运营部\")));\r\n        employeeMap.put(1005, new Employee(1005, \"EE\", \"E123123@qq.com\", 1, new Department(105, \"后勤部\")));\r\n    }\r\n\r\n    private static Integer initId = 1006;\r\n\r\n    // 增加员工\r\n    public void save(Employee employee){\r\n        if (employee.getId() == null){\r\n            employee.setId(initId++);\r\n        }\r\n        employee.setDepartment(departmentDao.getDepartment(employee.getDepartment().getId()));\r\n        employeeMap.put(employee.getId(), employee);\r\n    }\r\n\r\n    // 查询所有\r\n    public Collection<Employee> getAll(){\r\n        return employeeMap.values();\r\n    }\r\n\r\n    // 通过id查询员工\r\n    public Employee getEmployeeById(Integer id){\r\n        return employeeMap.get(id);\r\n    }\r\n\r\n    // 删\r\n    public void delete(Integer id){\r\n        employeeMap.remove(id);\r\n    }\r\n}\r\n\r\n```\r\n\r\n### thymeleaf接管html\r\n\r\n1. ```html\r\n   <html lang=\"en\" xmlns:th=\"http://www.thymeleaf.org\">\r\n   ```\r\n\r\n2. 静态资源 \r\n\r\n   * ```html\r\n     <img class=\"mb-4\" th:src=\"@{/img/bootstrap-solid.svg}\" alt=\"\" width=\"72\" height=\"72\">\r\n     ```\r\n\r\n     \r\n\r\n   * ```html\r\n     <link th:href=\"@{/css/bootstrap.min.css}\" rel=\"stylesheet\">\r\n     ```\r\n\r\n## 国际化（适配多种语言）\r\n\r\n1. 首页配置：\r\n   1. 注意点，所有页面的静态资源都需要使用thymeleaf托管；\r\n   2. Link URL: @{}\r\n2. 页面国际化：\r\n   1. 需要配置i18n文件 （internationalization）\r\n   2. 如果我们需要在项目中进行按钮自动切换，我们需要自定义一个组件 LocaleResolver\r\n   3. 记得将自己写的组件配置到spring容器 @Bean\r\n   4. Message：#{}\r\n\r\n### 1) 国际化配置文件\r\n\r\n![image-20220516005655054](cloudDisk/markdown/springBoot笔记.assets/image-20220516005655054.png)\r\n\r\n建立properties文件 (自定义名字_地区字符.properties文件)\r\n\r\n* login.properties (默认)\r\n* login.en_US.properties\r\n* login.zh_CN.properties\r\n\r\n### 2)**编写配置文件内容**\r\n\r\n确保编码\r\n\r\n![image-20220516011111041](cloudDisk/markdown/springBoot笔记.assets/image-20220516011111041.png)\r\n\r\n\r\n\r\n**1.打开配置文件**\r\n\r\n**2.点击Resource Bundle（IDEA工具）**\r\n\r\n**3.编写需要国际化的内容****（如下图）**![img](cloudDisk/markdown/springBoot笔记.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zOTMzNzA0Nw==,size_16,color_FFFFFF,t_70.png)\r\n\r\nor\r\n\r\nlogin.properties\r\n\r\n```properties\r\nlogin.btn=登录\r\nlogin.password=密码\r\nlogin.remember=记住\r\nlogin.tip=请登录\r\nlogin.username=密码\r\n```\r\n\r\nlogin.en_US.properties\r\n\r\n```properties\r\nlogin.btn=Sign in\r\nlogin.password=Password\r\nlogin.remember=Remember me\r\nlogin.tip=Please sign in\r\nlogin.username=Username\r\n```\r\n\r\nlogin.zh_CN.properties\r\n\r\n```properties\r\nlogin.btn=登录\r\nlogin.password=密码\r\nlogin.remember=记住\r\nlogin.tip=请登录\r\nlogin.username=密码\r\n```\r\n\r\n\r\n\r\n并在application.yml配置 上面配置文件的真实位置\r\n\r\n* 为什么呢？\r\n\r\n  属性类中basename默认为这个![image-20220516020106440](cloudDisk/markdown/springBoot笔记.assets/image-20220516020106440.png)\r\n\r\n  默认情况下会去资源路径下 message里找\r\n\r\n故应该这样配置\r\n\r\n```yml\r\n# 我们配置文件的真实位置\r\nspring:\r\n  messages:\r\n    basename: i18n.login\r\n```\r\n\r\n\r\n\r\n### 3）自定义配置\r\n\r\n看源码！\r\n\r\n发现springmvc自动配置类中\r\n\r\n```java\r\n@Bean // 返回一个bean对象注入到spring容器中\r\n@ConditionalOnMissingBean(\r\n    name = {\"localeResolver\"}\r\n)\r\npublic LocaleResolver localeResolver() {\r\n    if (this.webProperties.getLocaleResolver() == org.springframework.boot.autoconfigure.web.WebProperties.LocaleResolver.FIXED) {\r\n        return new FixedLocaleResolver(this.webProperties.getLocale()); // 发现程序员已经配置了自己的，使用程序员配置的\r\n    } else {\r\n        // 默认的\r\n        AcceptHeaderLocaleResolver localeResolver = new AcceptHeaderLocaleResolver();\r\n        localeResolver.setDefaultLocale(this.webProperties.getLocale());\r\n        return localeResolver;\r\n    }\r\n}\r\n```\r\n\r\n```java\r\n// 默认配置\r\npublic class AcceptHeaderLocaleResolver implements LocaleResolver {\r\n    public Locale resolveLocale(HttpServletRequest request) {\r\n        Locale defaultLocale = this.getDefaultLocale();\r\n        if (defaultLocale != null && request.getHeader(\"Accept-Language\") == null) {\r\n            return defaultLocale;\r\n        } else {\r\n            Locale requestLocale = request.getLocale();\r\n            List<Locale> supportedLocales = this.getSupportedLocales();\r\n            if (!supportedLocales.isEmpty() && !supportedLocales.contains(requestLocale)) {\r\n                Locale supportedLocale = this.findSupportedLocale(request, supportedLocales);\r\n                if (supportedLocale != null) {\r\n                    return supportedLocale;\r\n                } else {\r\n                    return defaultLocale != null ? defaultLocale : requestLocale;\r\n                }\r\n            } else {\r\n                return requestLocale;\r\n            }\r\n        }\r\n    }\r\n```\r\n\r\n\r\n\r\n之后仿源码，编写自己的配置类\r\n\r\n```java\r\npublic class MyLocaleResolver implements LocaleResolver {\r\n\r\n    @Override\r\n    public Locale resolveLocale(HttpServletRequest request) {\r\n        String l = request.getParameter(\"l\");\r\n//        Locale defaultLocale = request.getLocale();\r\n        Locale defaultLocale = Locale.getDefault();\r\n        if (l != null && !\"\".equals(l)){\r\n            String[] s = l.split(\"_\");\r\n            return new Locale(s[0], s[1]);\r\n        }\r\n        return defaultLocale;\r\n    }\r\n\r\n    @Override\r\n    public void setLocale(HttpServletRequest request, HttpServletResponse response, Locale locale) {\r\n\r\n    }\r\n}\r\n```\r\n\r\n```java\r\n@Configuration\r\n//@EnableWebMvc\r\npublic class MyMvcConfig implements WebMvcConfigurer {\r\n    @Override\r\n    public void addViewControllers(ViewControllerRegistry registry) {\r\n//        registry.addViewController(\"/\").setViewName(\"index\");\r\n//        registry.addViewController(\"/index.html\").setViewName(\"index\");\r\n    }\r\n\r\n    @Bean // 返回一个bean对象注入到spring容器中\r\n    public LocaleResolver localeResolver() {\r\n        return new MyLocaleResolver();\r\n    }\r\n\r\n}\r\n```\r\n\r\n### 4）前端代码 - 国际化！\r\n\r\n```html\r\n<body class=\"text-center\">\r\n   <form class=\"form-signin\" action=\"dashboard.html\">\r\n      <img class=\"mb-4\" th:src=\"@{/img/bootstrap-solid.svg}\" alt=\"\" width=\"72\" height=\"72\">\r\n      <h1 class=\"h3 mb-3 font-weight-normal\" th:text=\"#{login.tip}\">Please sign in</h1>\r\n      <label class=\"sr-only\">Username</label>\r\n      <input type=\"text\" class=\"form-control\" th:placeholder=\"#{login.username}\"  required=\"\" autofocus=\"\">\r\n      <label class=\"sr-only\">Password</label>\r\n      <input type=\"password\" class=\"form-control\" th:placeholder=\"#{login.password}\" required=\"\">\r\n      <div class=\"checkbox mb-3\">\r\n         <label>\r\n         <input type=\"checkbox\" value=\"remember-me\"><span th:text=\"#{login.remember}\"></span>\r\n       </label>\r\n      </div>\r\n      <button class=\"btn btn-lg btn-primary btn-block\" type=\"submit\" th:text=\"#{login.btn}\">Sign in</button>\r\n      <p class=\"mt-5 mb-3 text-muted\">© 2017-2018</p>\r\n      <a class=\"btn btn-sm\" th:href=\"@{/index.html(l=zh_CN)}\">中文</a>\r\n      <a class=\"btn btn-sm\" th:href=\"@{/index.html(l=en_US)}\">English</a>\r\n   </form>\r\n</body>\r\n```\r\n\r\n### 5）效果\r\n\r\n![image-20220516021117003](cloudDisk/markdown/springBoot笔记.assets/image-20220516021117003.png)\r\n\r\n![image-20220516021103244](cloudDisk/markdown/springBoot笔记.assets/image-20220516021103244.png)\r\n\r\n## 登录功能实现\r\n\r\ncontroller\r\n\r\n```java\r\n    @RequestMapping(\"/user/login\")\r\n    public String login(@RequestParam(\"username\") String username,\r\n                        @RequestParam(\"password\") String password,\r\n                        Model model, HttpSession session){\r\n        if (!StringUtils.isEmpty(username) && \"123\".equals(password)){\r\n            session.setAttribute(\"loginUser\", username);\r\n            return \"redirect:/main.html\"; // 重定向！ // return \"dashboard\";\r\n        }else {\r\n            // 登录失败\r\n            model.addAttribute(\"msg\", \"用户名或密码错误!\");\r\n            return \"index\";\r\n        }\r\n    }\r\n```\r\n\r\n配置视图控制器\r\n\r\n```java\r\n@Configuration\r\n//@EnableWebMvc\r\npublic class MyMvcConfig implements WebMvcConfigurer {\r\n    @Override\r\n    public void addViewControllers(ViewControllerRegistry registry) {\r\n        registry.addViewController(\"/\").setViewName(\"index\");\r\n        registry.addViewController(\"/index.html\").setViewName(\"index\");\r\n        registry.addViewController(\"/main.html\").setViewName(\"dashboard\"); // 访问main的页面，映射到dashboard\r\n    }\r\n```\r\n\r\n登录的form表单\r\n\r\n```html\r\n<form class=\"form-signin\" th:action=\"@{/user/login}\">\r\n...\r\n   <!--如果msg为空则不显示消息-->\r\n   <p style=\"color: red\" th:text=\"${msg}\" th:if=\"${! #strings.isEmpty(msg)}\"></p>\r\n...\r\n</form>\r\n```\r\n\r\n#strings：工具栏，提供了很多字符串操作的方法：https://www.thymeleaf.org/doc/tutorials/3.0/usingthymeleaf.html#standard-expression-syntax\r\n\r\n\r\n\r\n## 登录拦截器\r\n\r\n### 1） 实现 HandlerInterceptor 接口\r\n\r\n```java\r\npublic class LoginHandlerInterceptor implements HandlerInterceptor {\r\n    @Override\r\n    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {\r\n        // 登录成功后，应该有用户的session\r\n        Object loginUser = request.getSession().getAttribute(\"loginUser\");\r\n        if (loginUser == null){\r\n            // 没有登录\r\n            request.setAttribute(\"msg\", \"没有权限，请先登录\");\r\n            request.getRequestDispatcher(\"/index.html\").forward(request, response);\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n}\r\n```\r\n\r\n### 2）在自定义的**WebMvcConfigurer**配置类中配置拦截器\r\n\r\n```java\r\n@Configuration\r\npublic class MyMvcConfig implements WebMvcConfigurer {\r\n    \r\n...\r\n    \r\n    @Override\r\n    public void addInterceptors(InterceptorRegistry registry) {\r\n        InterceptorRegistration registration = registry.addInterceptor(new LoginHandlerInterceptor());\r\n        registration.addPathPatterns(\"/**\"); //所有路径都被拦截\r\n        registration.excludePathPatterns(//添加不拦截路径\r\n                \"/index.html\", // 登录路径\r\n                \"/\", // 登录资源\r\n                \"/user/login\", // 登录资源\r\n                \"/css/*\", // 静态资源\r\n                \"/js/**\", // 静态资源\r\n                \"/img/**\" // 静态资源\r\n        );\r\n    }\r\n}\r\n```\r\n\r\n### 3）登录后，用户信息存入 session\r\n\r\n```java\r\n@Controller\r\npublic class LoginController {\r\n    @RequestMapping(\"/user/login\")\r\n    public String login(@RequestParam(\"username\") String username,\r\n                        @RequestParam(\"password\") String password,\r\n                        Model model, HttpSession session){\r\n        if (!StringUtils.isEmpty(username) && \"123\".equals(password)){\r\n            session.setAttribute(\"loginUser\", username);\r\n            return \"redirect:/main.html\"; //            return \"dashboard\";\r\n        }else {\r\n            // 登录失败\r\n            model.addAttribute(\"msg\", \"用户名或密码错误!\");\r\n            return \"index\";\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n### 4）登录成功后，在用户主页中，获取session中信息\r\n\r\n```html\r\n<div>[[ ${session.loginUser} ]]</div>\r\n```\r\n\r\n### 5）效果\r\n\r\n![image-20220516143143180](cloudDisk/markdown/springBoot笔记.assets/image-20220516143143180.png)\r\n\r\n## （查）员工列表展示\r\n\r\n### 1）提取公共页面\r\n\r\n1. 创建commons.html\r\n\r\n   ![image-20220516172818107](cloudDisk/markdown/springBoot笔记.assets/image-20220516172818107.png)\r\n\r\n2. 标签定义格式：\r\n\r\n   `th:fragment=\"topbar\"`\r\n\r\n   * ```html\r\n     <nav class=\"navbar navbar-dark sticky-top bg-dark flex-md-nowrap p-0\" th:fragment=\"topbar\">\r\n     ```\r\n\r\n3. 标签插入：\r\n\r\n   `th:insert=\"~{commons/commons::topbar}\"`\r\n\r\n   `th:replace=\"~{commons/commons::topbar}\"`\r\n\r\n   ```html\r\n   <div th:insert=\"~{commons/commons::topbar(active=\'main.html\')}\"></div>\r\n   ```\r\n\r\n4. 传入参数：\r\n\r\n   `th:insert=\"~{commons/commons::topbar(active=\'main.html\')}\"`\r\n\r\n### 2）bar页面切换时，标签高亮\r\n\r\n如果传来的参数是main.html，则该标签高亮\r\n\r\n```html\r\n<a th:class=\"${active == \'main.html\'? \'nav-link active\': \'nav-link\'}\" th:href=\"@{/main.html}\">\r\n```\r\n\r\n### 3) html内获取员工信息\r\n\r\n```html\r\n<table class=\"table table-striped table-sm\">\r\n    <thead>\r\n        <tr>\r\n            <th>id</th>\r\n            <th>lastName</th>\r\n            <th>email</th>\r\n            <th>gender</th>\r\n            <th>department</th>\r\n            <th>birth</th>\r\n            <th>操作</th>\r\n        </tr>\r\n    </thead>\r\n    <tbody>\r\n        <tr th:each=\"emp: ${emps}\">\r\n            <td th:text=\"${emp.id}\"></td>\r\n            <td th:text=\"${emp.lastName}\"></td>\r\n            <td th:text=\"${emp.email}\"></td>\r\n            <td th:text=\"${emp.gender == 1? \'男\': \'女\'}\"></td>\r\n            <td th:text=\"${emp.department}\"></td>\r\n            <td th:text=\"${#calendars.format(emp.birth,\'yyyy-MM-dd\')}\"></td>\r\n            <td>\r\n                <button class=\"btn btn-sm btn-primary\">编辑</button>\r\n                <button class=\"btn btn-sm btn-danger\">删除</button>\r\n            </td>\r\n        </tr>\r\n    </tbody>\r\n</table>\r\n```\r\n\r\n* 注意，emps变量，已经在访问这个页面的时候，传入了\r\n\r\n  ```java\r\n      @RequestMapping(\"/emps\")\r\n      public String list(Model model){\r\n          Collection<Employee> all = employeeDao.getAll();\r\n          model.addAttribute(\"emps\", all);\r\n          return \"/emp/list\";\r\n      }\r\n  ```\r\n\r\n  ![image-20220516220220885](cloudDisk/markdown/springBoot笔记.assets/image-20220516220220885.png)\r\n\r\n## （增） 添加员工\r\n\r\n### 1）controller接收post请求\r\n\r\n```java\r\n    @PostMapping(\"/emp\")\r\n    public String addEmp(Employee employee){\r\n        System.out.println(\">>>\" + employee);\r\n        employeeDao.save(employee);\r\n        return \"redirect:/emps\"; // 重定向：让浏览器访问/emps\r\n    }\r\n```\r\n\r\n### 2）post表单及注意事项\r\n\r\n```html\r\n<form class=\"form-horizontal\" th:action=\"@{/emp}\" method=\"post\">\r\n                <div class=\"form-group\">\r\n                    <label for=\"lastName\" class=\"col-sm-2 control-label\">lastName</label>\r\n                    <div class=\"col-sm-10\">\r\n                        <input type=\"text\" name=\"lastName\" class=\"form-control\" id=\"lastName\" placeholder=\"lastName\">\r\n                    </div>\r\n                </div>\r\n                <div class=\"form-group\">\r\n                    <label for=\"Email\" class=\"col-sm-2 control-label\">Email</label>\r\n                    <div class=\"col-sm-10\">\r\n                        <input type=\"email\" name=\"email\" class=\"form-control\" id=\"Email\" placeholder=\"Email\">\r\n                    </div>\r\n                </div>\r\n\r\n                <div class=\"form-group\">\r\n                    <div class=\"col-sm-offset-2 col-sm-10\">\r\n                        男<input type=\"radio\" name=\"gender\" checked value=\"1\">\r\n                        女<input type=\"radio\" name=\"gender\" value=\"0\">\r\n                    </div>\r\n                </div>\r\n\r\n                <div class=\"form-group\">\r\n                    <label class=\"col-sm-2 control-label\">department</label>\r\n                    <div class=\"col-sm-10\">\r\n                        <select class=\"form-control\" name=\"department.id\">\r\n                            <!--我们在controller接受的是一个Employee，所以我们需要提交的是该类中的一个属性！！-->\r\n                            <option th:each=\"department: ${departments}\" th:text=\"${department.name}\" th:value=\"${department.id}\"></option>\r\n                        </select>\r\n                    </div>\r\n                </div>\r\n\r\n                <div class=\"form-group\">\r\n                    <label for=\"birth\" class=\"col-sm-2 control-label\">birth</label>\r\n                    <div class=\"col-sm-10\">\r\n                        <input type=\"text\" name=\"birth\" class=\"form-control\" id=\"birth\" placeholder=\"birth\">\r\n                    </div>\r\n                </div>\r\n\r\n                <div class=\"form-group\">\r\n                    <div class=\"col-sm-offset-2 col-sm-10\">\r\n                        <button type=\"submit\" class=\"btn btn-default\">添加</button>\r\n                    </div>\r\n                </div>\r\n            </form>\r\n```\r\n\r\n* 默认的日期格式，springMVC的自动配置为：dd/MM/yyyy\r\n\r\n  可在yml配置文件中更改\r\n\r\n  ```yml\r\n  spring:\r\n      mvc:\r\n        format:\r\n          date: yyyy-MM-dd\r\n  ```\r\n\r\n* 下拉框标签中，department是个类，如果直接name=\"department\"会404\r\n\r\n  所以在必须给department类中的id赋值\r\n\r\n  所以改成：name=\"department.id\"\r\n\r\n### 3）效果\r\n\r\ncontroller接收到的对象：\r\n\r\nEmployee(id=null, lastName=asd, email=731937732@qq.com, gender=1, department=Department(id=101, name=null), birth=Tue Feb 01 00:00:00 CST 2000)\r\n\r\n浏览器端：\r\n\r\n![image-20220516184956910](cloudDisk/markdown/springBoot笔记.assets/image-20220516184956910.png)\r\n\r\n![image-20220516185014539](cloudDisk/markdown/springBoot笔记.assets/image-20220516185014539.png)\r\n\r\n\r\n\r\n## （改） 修改员工信息\r\n\r\n### 1）拷贝一份add.html 命名为update.html\r\n\r\n![image-20220517004626531](cloudDisk/markdown/springBoot笔记.assets/image-20220517004626531.png)\r\n\r\n\r\n\r\n### 2) list.html点击修改时，请求controller\r\n\r\n![image-20220517004751519](cloudDisk/markdown/springBoot笔记.assets/image-20220517004751519.png)\r\n\r\n* 注意：需要携带emp的id\r\n\r\n  ```html\r\n  th:href=\"@{|/emp/${emp.id}|}\"\r\n  ```\r\n\r\n### 3）controller 接收被修改的id，并转发到修改页面\r\n\r\n```java\r\n@GetMapping(\"/emp/{id}\")\r\npublic String toUpdateEmp(Model model, @PathVariable(\"id\") Integer id){\r\n    Employee employee = employeeDao.getEmployeeById(id);\r\n    model.addAttribute(\"emp\", employee);\r\n    Collection<Department> departments = departmentDao.getDepartments();\r\n    model.addAttribute(\"departments\", departments);\r\n    return \"/emp/update\";\r\n}\r\n```\r\n\r\n* 根据id 查询到的emp信息存入域中\r\n* 转发到updte.html\r\n\r\n### 4) update.html 数据回显到表单中\r\n\r\n```html\r\n<form class=\"form-horizontal\" th:action=\"@{/updateEmp}\" method=\"post\">\r\n                <input type=\"hidden\" name=\"id\" th:value=\"${emp.getId()}\">\r\n                <div class=\"form-group\">\r\n                    <label for=\"lastName\" class=\"col-sm-2 control-label\">lastName</label>\r\n                    <div class=\"col-sm-10\">\r\n                        <input type=\"text\" th:value=\"${emp.getLastName()}\" name=\"lastName\" class=\"form-control\" id=\"lastName\" placeholder=\"lastName\">\r\n                    </div>\r\n                </div>\r\n                <div class=\"form-group\">\r\n                    <label for=\"Email\" class=\"col-sm-2 control-label\">Email</label>\r\n                    <div class=\"col-sm-10\">\r\n                        <input type=\"email\" th:value=\"${emp.getEmail()}\" name=\"email\" class=\"form-control\" id=\"Email\" placeholder=\"Email\">\r\n                    </div>\r\n                </div>\r\n\r\n                <div class=\"form-group\">\r\n                    <div class=\"col-sm-offset-2 col-sm-10\">\r\n                        男<input type=\"radio\" name=\"gender\" th:checked=\"${emp.getGender() == 1}\" value=\"1\">\r\n                        女<input type=\"radio\" name=\"gender\" th:checked=\"${emp.getGender() == 0}\" value=\"0\">\r\n                    </div>\r\n                </div>\r\n\r\n                <div class=\"form-group\">\r\n                    <label class=\"col-sm-2 control-label\">department</label>\r\n                    <div class=\"col-sm-10\">\r\n                        <select class=\"form-control\" name=\"department.id\">\r\n                            <!--我们在controller接受的是一个Employee，所以我们需要提交的是该类中的一个属性！！-->\r\n                            <option th:selected=\"${department.id == emp.department.id}\" th:each=\"department: ${departments}\" th:text=\"${department.name}\" th:value=\"${department.id}\"></option>\r\n                        </select>\r\n                    </div>\r\n                </div>\r\n\r\n                <div class=\"form-group\">\r\n                    <label for=\"birth\" class=\"col-sm-2 control-label\">birth</label>\r\n                    <div class=\"col-sm-10\">\r\n                        <input type=\"text\" th:value=\"${#dates.format(emp.getBirth(),\'yyyy-MM-dd\')}\" name=\"birth\" class=\"form-control\" id=\"birth\" placeholder=\"birth\">\r\n                    </div>\r\n                </div>\r\n\r\n                <div class=\"form-group\">\r\n                    <div class=\"col-sm-offset-2 col-sm-10\">\r\n                        <button type=\"submit\" class=\"btn btn-default\">修改</button>\r\n                    </div>\r\n                </div>\r\n            </form>\r\n```\r\n\r\n* 注意1：获取emp的部门id，及所有部门id，直接可以来判断需不需选中\r\n\r\n  th:selected=\"${department.id == emp.department.id}\" \r\n\r\n* 注意2：日期格式\r\n\r\n  th:value=\"${#dates.format(emp.getBirth(),\'yyyy-MM-dd\')}\"\r\n\r\n* 注意3：添加一个存放emp的id的隐藏域\r\n\r\n  ```html\r\n  <input type=\"hidden\" name=\"id\" th:value=\"${emp.getId()}\">\r\n  ```\r\n\r\n### 5）controller接收表单，完成修改\r\n\r\n```java\r\n    @PostMapping(\"/updateEmp\")\r\n    public String updateEmp(Employee employee){\r\n        employeeDao.save(employee);\r\n        return \"redirect:/emps\"; // 重定向：让浏览器访问/emps\r\n    }\r\n```\r\n\r\n\r\n\r\n## （删）删除员工\r\n\r\n### 1）list.html\r\n\r\n![image-20220517010203006](cloudDisk/markdown/springBoot笔记.assets/image-20220517010203006.png)\r\n\r\n\r\n\r\n### 2)controller 接收参数，删除emp\r\n\r\n```java\r\n    @GetMapping(\"/deleteEmp/{id}\")\r\n    public String deleteEmp(Employee employee, @PathVariable(\"id\") Integer id){\r\n        employeeDao.delete(id);\r\n        return \"redirect:/emps\"; // 重定向：让浏览器访问/emps\r\n    }\r\n```\r\n\r\n\r\n\r\n## 404处理\r\n\r\n在templates/error下创建404.html\r\n\r\n404错误时，会访问\r\n\r\n![image-20220517010532243](cloudDisk/markdown/springBoot笔记.assets/image-20220517010532243.png)\r\n\r\n\r\n\r\n## 注销\r\n\r\n![image-20220517010945088](cloudDisk/markdown/springBoot笔记.assets/image-20220517010945088.png)\r\n\r\n```java\r\n    @RequestMapping(\"/user/logout\")\r\n    public String logout(HttpSession session){\r\n        session.invalidate();\r\n        return \"redirect:/\";\r\n    }\r\n```\r\n\r\n\r\n\r\n# 八、如何做一个网站\r\n\r\n1. 有一套自己熟悉的后台模板：工作必备！xadmin - 后台模板\r\n2. 前端界面：至少通过前端框架，组合出来网站页面\r\n   - index\r\n   - about\r\n   - blog\r\n   - post\r\n   - user\r\n3. 让这个网站能独立运行！\r\n','2022-06-23 22:21:51','Spring Boot makes it easy to create stand-alone, production-grade Spring based Applications that you can \"just run\".\r\n\r\nWe take an opinionated view of the Spring platform and third-party libraries so yo','cloudDisk/markdown/springBoot笔记.assets/image-20220513172057061.png','原创','','','\0','Spring Boot学习笔记（上）','2022-06-23 22:21:51',5,102,NULL,0),(188,'','# 九、上周回顾\r\n\r\n* springboot是什么？\r\n* 微服务\r\n* 写出hello world程序\r\n* 探究源码-得出自动装配的原理\r\n* 配置yaml\r\n* 多文件环境切换\r\n* 静态资源映射\r\n* Thymeleaf th：xxxx\r\n* SpringBoot 如何扩展MVC      javaconfig\r\n* 如何修改springboot的默认配置\r\n* CRUD\r\n* 国际化怎么实现\r\n* 拦截器\r\n* 定制首页，错误页\r\n\r\n\r\n\r\n这周：\r\n\r\n* JDBC\r\n* **MyBatis：重点**\r\n* **Druid：重点**\r\n* **Shiro：安全：重点**\r\n* **SpringSecurity：安全：重点**\r\n* 异步任务，邮件发送，定时任务\r\n* Swagger\r\n* Dubbo + Zookeeper\r\n\r\n\r\n\r\n# 十、Data，整合JDBC\r\n\r\n## 1）导入依赖\r\n\r\n```xml\r\n<!--web-->\r\n<dependency>\r\n    <groupId>org.springframework.boot</groupId>\r\n    <artifactId>spring-boot-starter-web</artifactId>\r\n</dependency>\r\n<!--jdbc-->\r\n<dependency>\r\n    <groupId>org.springframework.boot</groupId>\r\n    <artifactId>spring-boot-starter-jdbc</artifactId>\r\n</dependency>\r\n<!--驱动-->\r\n<dependency>\r\n    <groupId>mysql</groupId>\r\n    <artifactId>mysql-connector-java</artifactId>\r\n    <scope>runtime</scope>\r\n</dependency>\r\n```\r\n\r\n## 2）配置jdbc\r\n\r\napplication.yml\r\n\r\n```yml\r\nspring:\r\n  datasource:\r\n    username: root\r\n    password: 123\r\n    driver-class-name: com.mysql.jdbc.Driver\r\n    url: jdbc:mysql://localhost:3306/mybatis?userUnicode=true&characterEncoding=utf-8&serverTimezone=Hongkong\r\n\r\n```\r\n\r\n## 3）分析源码，测试dataSource\r\n\r\n\r\n\r\n* 为什么给我自动装配上了数据源？\r\n\r\n打开DataSourceAutoConfiguration，发现\r\n\r\n```java\r\npublic ConditionOutcome getMatchOutcome(ConditionContext context, AnnotatedTypeMetadata metadata) {\r\n    Builder message = ConditionMessage.forCondition(\"EmbeddedDataSource\", new Object[0]);\r\n    if (this.hasDataSourceUrlProperty(context)) {\r\n        return ConditionOutcome.noMatch(message.because(\"spring.datasource.url is set\"));\r\n    } else if (this.anyMatches(context, metadata, new Condition[]{this.pooledCondition})) {\r\n        return ConditionOutcome.noMatch(message.foundExactly(\"supported pooled data source\"));\r\n    } else {\r\n        EmbeddedDatabaseType type = EmbeddedDatabaseConnection.get(context.getClassLoader()).getType();\r\n        return type == null ? ConditionOutcome.noMatch(message.didNotFind(\"embedded database\").atAll()) : ConditionOutcome.match(message.found(\"embedded database\").items(new Object[]{type}));\r\n    }\r\n}\r\n\r\nprivate boolean hasDataSourceUrlProperty(ConditionContext context) {\r\n    Environment environment = context.getEnvironment();\r\n    if (environment.containsProperty(\"spring.datasource.url\")) {\r\n        try {\r\n            return StringUtils.hasText(environment.getProperty(\"spring.datasource.url\"));\r\n        } catch (IllegalArgumentException var4) {\r\n        }\r\n    }\r\n\r\n    return false;\r\n}\r\n```\r\n\r\n发现，如果配置文件中存在 spring.datasource.url 字段，会用用户的，否则执行else if\r\n\r\n用系统默认的 pooledCondition\r\n\r\n```java\r\nprivate final SpringBootCondition pooledCondition = new DataSourceAutoConfiguration.PooledDataSourceCondition();\r\n```\r\n\r\n回去实例化这个类\r\n\r\n![image-20220517145401227](cloudDisk/markdown/springBoot笔记.assets/image-20220517145401227.png)\r\n\r\n条件满足时\r\n\r\n![image-20220517145612640](cloudDisk/markdown/springBoot笔记.assets/image-20220517145612640.png)\r\n\r\n把datasource注入到bean\r\n\r\n```java\r\n        @Bean\r\n        @ConfigurationProperties(\r\n            prefix = \"spring.datasource.hikari\"\r\n        )\r\n        HikariDataSource dataSource(DataSourceProperties properties) {\r\n            HikariDataSource dataSource = (HikariDataSource)DataSourceConfiguration.createDataSource(properties, HikariDataSource.class);\r\n            if (StringUtils.hasText(properties.getName())) {\r\n                dataSource.setPoolName(properties.getName());\r\n            }\r\n\r\n            return dataSource;\r\n        }\r\n```\r\n\r\n### 测试\r\n\r\n```java\r\n@SpringBootTest\r\nclass DemoApplicationTests {\r\n    @Autowired\r\n    DataSource dataSource;\r\n\r\n\r\n    @Test\r\n    void contextLoads() throws SQLException {\r\n        // 默认数据源：class com.zaxxer.hikari.HikariDataSource\r\n        System.out.println(dataSource.getClass());\r\n\r\n        // 获取数据库链接\r\n        Connection connection = dataSource.getConnection();\r\n\r\n        // xxxx Template: SpringBoot已经配置好的模板bean，拿来即用\r\n        \r\n        connection.close();\r\n    }\r\n\r\n}\r\n```\r\n\r\n## 4）JdbcTemplate\r\n\r\n分析源码，JdbcTemplate 如何被实例化的\r\n\r\n![image-20220517150331199](cloudDisk/markdown/springBoot笔记.assets/image-20220517150331199.png)\r\n\r\n```java\r\n@Configuration(\r\n    proxyBeanMethods = false\r\n)\r\n@ConditionalOnClass({DataSource.class, JdbcTemplate.class})\r\n@ConditionalOnSingleCandidate(DataSource.class)\r\n@AutoConfigureAfter({DataSourceAutoConfiguration.class})\r\n@EnableConfigurationProperties({JdbcProperties.class})\r\n@Import({DatabaseInitializationDependencyConfigurer.class, JdbcTemplateConfiguration.class, NamedParameterJdbcTemplateConfiguration.class})\r\npublic class JdbcTemplateAutoConfiguration {\r\n    public JdbcTemplateAutoConfiguration() {\r\n    }\r\n}\r\n```\r\n\r\n导入了 JdbcTemplateConfiguration这个类\r\n\r\n```java\r\n@Configuration(\r\n    proxyBeanMethods = false\r\n)\r\n@ConditionalOnMissingBean({JdbcOperations.class})\r\nclass JdbcTemplateConfiguration {\r\n    JdbcTemplateConfiguration() {\r\n    }\r\n\r\n    @Bean\r\n    @Primary\r\n    JdbcTemplate jdbcTemplate(DataSource dataSource, JdbcProperties properties) {\r\n        JdbcTemplate jdbcTemplate = new JdbcTemplate(dataSource);\r\n        Template template = properties.getTemplate();\r\n        jdbcTemplate.setFetchSize(template.getFetchSize());\r\n        jdbcTemplate.setMaxRows(template.getMaxRows());\r\n        if (template.getQueryTimeout() != null) {\r\n            jdbcTemplate.setQueryTimeout((int)template.getQueryTimeout().getSeconds());\r\n        }\r\n\r\n        return jdbcTemplate;\r\n    }\r\n}\r\n\r\n```\r\n\r\nspring扫描，发现@Bean，将 JdbcTemplate 放入spring容器\r\n\r\n实现了JdbcTemplate 自动注入\r\n\r\n```java\r\n@Autowired\r\nJdbcTemplate jdbcTemplate;\r\n```\r\n\r\n## 5）实现增删改查\r\n\r\n```java\r\n@RestController\r\npublic class JDBCController {\r\n    @Autowired\r\n    JdbcTemplate jdbcTemplate;\r\n\r\n    // 查询数据库所有信息\r\n    // 没有实体类，怎么获取数据库中的东西？Map\r\n    @GetMapping(\"/userList\")\r\n    public List<Map<String, Object>> userList(){\r\n        String sql = \"select * from user\";\r\n        List<Map<String, Object>> maps = jdbcTemplate.queryForList(sql);\r\n        return maps;\r\n    }\r\n\r\n    @GetMapping(\"/addUser\")\r\n    public String addUser(){\r\n        String sql = \"insert into user(name, pwd) values(?, ?)\";\r\n        jdbcTemplate.update(sql, \"tony\", \"123123\");\r\n        return \"add-ok\";\r\n    }\r\n\r\n    @GetMapping(\"/updateUser\")\r\n    public String updateUser(){\r\n        String sql = \"update user set name = ?, pwd = ? where id = ?\";\r\n        Object[] objects = new Object[3];\r\n        objects[0] = \"tony\";\r\n        objects[1] = \"12312312312\";\r\n        objects[2] = \"1\";\r\n        jdbcTemplate.update(sql, objects);\r\n        return \"update-ok\";\r\n    }\r\n\r\n    @GetMapping(\"/deleteUser/{id}\")\r\n    public String deleteUser(@PathVariable(\"id\") Integer id){\r\n        String sql = \"delete from user where id = ?\";\r\n        jdbcTemplate.update(sql, id);\r\n        return \"delete-ok\";\r\n    }\r\n\r\n}\r\n```\r\n\r\n* 查\r\n\r\n  ![image-20220517150737033](cloudDisk/markdown/springBoot笔记.assets/image-20220517150737033.png)\r\n\r\n* 增\r\n\r\n  ![image-20220517150748902](cloudDisk/markdown/springBoot笔记.assets/image-20220517150748902.png)\r\n\r\n* 改\r\n\r\n  ![image-20220517150759185](cloudDisk/markdown/springBoot笔记.assets/image-20220517150759185.png)\r\n\r\n* 删\r\n\r\n  ![image-20220517150809872](cloudDisk/markdown/springBoot笔记.assets/image-20220517150809872.png)\r\n\r\n \r\n\r\n# 十一、整合Druid数据源\r\n\r\n## 1）导入依赖\r\n\r\n```xml\r\n<!--druid-->\r\n<dependency>\r\n    <groupId>com.alibaba</groupId>\r\n    <artifactId>druid</artifactId>\r\n    <version>1.1.21</version>\r\n</dependency>\r\n<!--log4j-->\r\n<dependency>\r\n    <groupId>log4j</groupId>\r\n    <artifactId>log4j</artifactId>\r\n    <version>1.2.17</version>\r\n</dependency>\r\n```\r\n\r\n## 2）application.yml 配置\r\n\r\n```yml\r\nspring:\r\n  datasource:\r\n    username: root\r\n    password: 123\r\n    driver-class-name: com.mysql.jdbc.Driver\r\n    url: jdbc:mysql://localhost:3306/mybatis?userUnicode=true&characterEncoding=utf-8&serverTimezone=Hongkong\r\n    type: com.alibaba.druid.pool.DruidDataSource\r\n\r\n    #Spring Boot 默认是不注入这些属性值的，需要自己绑定\r\n    #druid 数据源专有配置\r\n    initialSize: 5\r\n    minIdle: 5\r\n    maxActive: 20\r\n    maxWait: 60000\r\n    timeBetweenEvictionRunsMillis: 60000\r\n    minEvictableIdleTimeMillis: 300000\r\n    validationQuery: SELECT 1 FROM DUAL\r\n    testWhileIdle: true\r\n    testOnBorrow: false\r\n    testOnReturn: false\r\n    poolPreparedStatements: true\r\n    #配置监控统计拦截的filters，stat:监控统计、log4j：日志记录、wall：防御sql注入\r\n    #如果允许时报错  java.lang.ClassNotFoundException: org.apache.log4j.Priority\r\n    #则导入 log4j 依赖即可，Maven 地址：https://mvnrepository.com/artifact/log4j/log4j\r\n    filters: stat,wall,log4j\r\n    maxPoolPreparedStatementPerConnectionSize: 20\r\n    useGlobalDataSourceStat: true\r\n    connectionProperties: druid.stat.mergeSql=true;druid.stat.slowSqlMillis=500\r\n```\r\n\r\n## 3）自定义DruidDataSource 配置类\r\n\r\n现在需要程序员自己为 DruidDataSource 绑定全局配置文件中的参数，再添加到容器中，而不再使用 Spring Boot 的自动生成了；我们需要 自己添加 DruidDataSource 组件到容器中，并绑定属性；\r\n\r\n```java\r\n@Configuration\r\npublic class DruidConfig {\r\n\r\n    /* 将自定义的 Druid数据源添加到容器中，不再让 Spring Boot 自动创建\r\n       绑定全局配置文件中的 druid 数据源属性到 com.alibaba.druid.pool.DruidDataSource从而让它们生效\r\n       @ConfigurationProperties(prefix = \"spring.datasource\")：作用就是将 全局配置文件中\r\n       前缀为 spring.datasource的属性值注入到 com.alibaba.druid.pool.DruidDataSource 的同名参数中*/\r\n    @ConfigurationProperties(prefix = \"spring.datasource\")\r\n    @Bean\r\n    public DataSource druidDataSource(){\r\n        return new DruidDataSource();\r\n    }\r\n\r\n```\r\n\r\n## 4）配置Druid数据源监控\r\n\r\nDruid 数据源具有监控的功能，并提供了一个 web 界面方便用户查看，类似安装 路由器 时，人家也提供了一个默认的 web 页面。\r\n\r\n所以第一步需要设置 Druid 的后台管理页面，比如 登录账号、密码 等；配置后台管理；\r\n\r\n```java\r\n@Configuration\r\npublic class DruidConfig {\r\n\r\n    /* 将自定义的 Druid数据源添加到容器中，不再让 Spring Boot 自动创建\r\n       绑定全局配置文件中的 druid 数据源属性到 com.alibaba.druid.pool.DruidDataSource从而让它们生效\r\n       @ConfigurationProperties(prefix = \"spring.datasource\")：作用就是将 全局配置文件中\r\n       前缀为 spring.datasource的属性值注入到 com.alibaba.druid.pool.DruidDataSource 的同名参数中*/\r\n    @ConfigurationProperties(prefix = \"spring.datasource\")\r\n    @Bean\r\n    public DataSource druidDataSource(){\r\n        return new DruidDataSource();\r\n    }\r\n\r\n    // 后台监控: web.xml\r\n    // 因为springboot 内置了 servlet 容器，所以没有web.xml\r\n    // 替代方法：ServletRegistrationBean\r\n    @Bean\r\n    public ServletRegistrationBean statViewServlet(){\r\n        ServletRegistrationBean<StatViewServlet> bean = new ServletRegistrationBean<>(new StatViewServlet(), \"/druid/*\");\r\n        // 后台需要有人登录，账号密码配置\r\n        HashMap<String, String> initParameters = new HashMap<>();\r\n        // 增加配置\r\n        initParameters.put(\"loginUsername\", \"admin\"); // 登录key，时固定的loginUsername、loginPassword\r\n        initParameters.put(\"loginPassword\", \"123456\");\r\n        // 允许谁可以访问\r\n        initParameters.put(\"allow\", \"\");\r\n        // 禁止谁能访问\r\n//        initParameters.put(\"tony\", \"192.168.1.1\");\r\n\r\n        bean.setInitParameters(initParameters); // 设置初始化参数\r\n        return bean;\r\n    }\r\n\r\n```\r\n\r\n配置完后，就可以访问：http://localhost:8080/druid\r\n\r\n![image-20220517172931809](cloudDisk/markdown/springBoot笔记.assets/image-20220517172931809.png)\r\n\r\n还可以配置一个监控 filter 过滤器\r\n\r\n\r\n\r\n```java\r\n//配置 Druid 监控 之  web 监控的 filter`\r\n//WebStatFilter：用于配置Web和Druid数据源之间的管理关联监控统计`\r\n// filter\r\n    @Bean\r\n    public FilterRegistrationBean webStatFilter(){\r\n        FilterRegistrationBean<Filter> bean = new FilterRegistrationBean<>();\r\n\r\n        bean.setFilter(new WebStatFilter());\r\n\r\n        // 可以过滤哪些请求呢？\r\n        Map<String, String> initParameters = new HashMap<>();\r\n        // 这些东西不进行统计\r\n        initParameters.put(\"exclusions\",\"*.js, *.css druid/*\");\r\n        bean.setInitParameters(initParameters);\r\n\r\n        return bean;\r\n    }\r\n}\r\n```\r\n\r\n\r\n\r\n# 十二、整合MyBatis\r\n\r\n1. 导入包\r\n2. 配置文件\r\n3. mybatis配置\r\n4. 编写sql\r\n5. 业务调用dao\r\n6. controller调用service\r\n\r\n## 1）整合包：\r\n\r\n```xml\r\n        <!--mybatis-spring-boot-starter 整合-->\r\n        <dependency>\r\n            <groupId>org.mybatis.spring.boot</groupId>\r\n            <artifactId>mybatis-spring-boot-starter</artifactId>\r\n            <version>2.2.2</version>\r\n        </dependency>\r\n```\r\n\r\n## 2）配置文件\r\n\r\n\r\n\r\n```yml\r\nspring:\r\n  datasource:\r\n    username: root\r\n    password: 123\r\n    url: jdbc:mysql://localhost:3306/mybatis?serverTimezone=Hongkong&useUnicode=true&character=utf-8\r\n    driver-class-name: com.mysql.cj.jdbc.Driver\r\n\r\n# 整合mybatis\r\nmybatis:\r\n  type-aliases-package: com.example.demo.pojo\r\n  mapper-locations: classpath:mybatis/mapper/*.xml # mapper所在位置\r\n\r\n\r\n```\r\n\r\n![image-20220517181013733](cloudDisk/markdown/springBoot笔记.assets/image-20220517181013733.png)\r\n\r\n![image-20220517181027535](cloudDisk/markdown/springBoot笔记.assets/image-20220517181027535.png)\r\n\r\n\r\n\r\n## 3）UserMapper接口\r\n\r\n```java\r\n// 这个注释表示这是一个mybatis的mapper类：dao\r\n@Mapper\r\n@Repository // 被spring整合\r\npublic interface UserMapper {\r\n\r\n    List<User> queryUserList();\r\n\r\n    User queryUserById(@Param(\"id\") int id);\r\n\r\n    int addUser(User user);\r\n\r\n    int updateUser(User user);\r\n\r\n    int deleteUser(@Param(\"id\") int id);\r\n}\r\n```\r\n\r\n## 4）UserMapper实现类\r\n\r\n```xml\r\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\r\n<!DOCTYPE mapper\r\n        PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\"\r\n        \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\">\r\n<mapper namespace=\"com.example.demo.mapper.UserMapper\">\r\n    <select id=\"queryUserList\" resultType=\"User\">\r\n        select * from user\r\n    </select>\r\n\r\n    <select id=\"queryUserById\" resultType=\"User\">\r\n        select * from user where id = #{id}\r\n    </select>\r\n\r\n    <insert id=\"addUser\" parameterType=\"User\">\r\n        insert into user(name, pwd) values (#{name}, #{pwd})\r\n    </insert>\r\n\r\n    <update id=\"updateUser\" parameterType=\"User\">\r\n        update user set name = #{name}, pwd = #{pwd} where id = #{id}\r\n    </update>\r\n\r\n    <delete id=\"deleteUser\">\r\n        delete from user where id = #{id}\r\n    </delete>\r\n</mapper>\r\n```\r\n\r\n## 5）controller调dao\r\n\r\n```java\r\n@RestController\r\npublic class UserController {\r\n    @Autowired\r\n    private UserMapper userMapper;\r\n\r\n    @GetMapping(\"/userList\")\r\n    public List<User> queryUserList(){\r\n        List<User> users = userMapper.queryUserList();\r\n        return users;\r\n    }\r\n\r\n    @GetMapping(\"/addUser\")\r\n    public String addUser(){\r\n        User user = new User();\r\n        user.setName(\"tony\");\r\n        user.setPwd(\"tony\");\r\n        userMapper.addUser(user);\r\n        return \"add-ok\";\r\n    }\r\n\r\n    @GetMapping(\"/updateUser\")\r\n    public String updateUser(){\r\n        User user = new User();\r\n        user.setId(1);\r\n        user.setName(\"111\");\r\n        user.setPwd(\"1213\");\r\n        userMapper.updateUser(user);\r\n        return \"update-ok\";\r\n    }\r\n\r\n    @GetMapping(\"/deleteUser/{id}\")\r\n    public String deleteUser(@PathVariable(\"id\") Integer id){\r\n        userMapper.deleteUser(id);\r\n        return \"delete-ok\";\r\n    }\r\n}\r\n```\r\n\r\n## 6）测试\r\n\r\n![image-20220517181338823](cloudDisk/markdown/springBoot笔记.assets/image-20220517181338823.png)\r\n\r\n![image-20220517181344988](cloudDisk/markdown/springBoot笔记.assets/image-20220517181344988.png)\r\n\r\n![image-20220517181349097](cloudDisk/markdown/springBoot笔记.assets/image-20220517181349097.png)\r\n\r\n![image-20220517181353639](cloudDisk/markdown/springBoot笔记.assets/image-20220517181353639.png)\r\n\r\n# 十三、SpringSecurity（安全）\r\n\r\n在web开发中，安全第一位！过滤器，拦截器\r\n\r\n功能性需求：否\r\n\r\n做网站：安全应该在什么时候考虑？\r\n\r\n* 漏洞，隐私泄露\r\n\r\n* 架构一旦确定\r\n\r\n\r\n\r\nshiro、SpringSecurity：很像，除了类不一样，名字不一样；\r\n\r\n认证，授权（vip1，vip2，vip3）\r\n\r\n* 功能权限\r\n* 访问权限\r\n* 菜单权限\r\n* 拦截器、过滤器：大量原生代码~ 冗余\r\n\r\n\r\n\r\nMVC-SPRING-SPRINGBOOT--框架思想\r\n\r\n\r\n\r\n## 简介\r\n\r\nSpring security 是一个功能强大且高度可定制的身份验证和访问控制框架。它是保护基于 spring 的应用程序的事实上的标准。spring security 是一个框架，专注于为 java应用程序提供身份验证和授权。就像所有的spring项目一样，spring安全性的真正威力在于它可以很容易地扩展以满足客户需求\r\n\r\nSpring Security是针对Spring项目的安全框架，也是Spring Boot底层安全模板默认的技术选型，他可以实现强大的Web安全控制，对于安全控制，我们仅需要引入spring-boot-starter-security模块，进行少量的配置，即可实现强大的安全管理\r\n\r\n需要牢记的几个类\r\n\r\n* WebSecurityConfigurerAdapter: 自定义Security策略\r\n\r\n* AuthenticationManagerBuilder: 自定义认证策略\r\n\r\n* @EnableWebSecurity: 开启WebSecurity模式\r\n\r\n“认证”（Authentication）\r\n\r\n“授权”（Authorization）\r\n\r\n这些概念是通用的，而不是只在Spring Security中存在\r\n\r\n## 导入模板素材\r\n\r\n![在这里插入图片描述](cloudDisk/markdown/springBoot笔记.assets/20210427231612886.png)\r\n\r\n\r\n\r\n**首页index.html：**\r\n\r\n![在这里插入图片描述](cloudDisk/markdown/springBoot笔记.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlbndlbmFpZXI=,size_16,color_FFFFFF,t_70.png)\r\n\r\n## 分权限登录\r\n\r\n**RouterControler跳往各个页面**\r\n\r\n```java\r\n@Controller\r\npublic class RouterControler {\r\n\r\n    @RequestMapping({\"/\",\"/index\"})\r\n    public String index(){\r\n        return \"index\";\r\n    }\r\n\r\n    @RequestMapping(\"/toLogin\")\r\n    public String toLogin(){\r\n        return \"views/login\";\r\n    }\r\n\r\n    //跳往等级页面\r\n    @RequestMapping(\"/level1/{id}\")\r\n    public String toLevel1(@PathVariable(\"id\") int id){\r\n        return \"views/level1/\"+id;\r\n    }\r\n\r\n    //跳往等级页面\r\n    @RequestMapping(\"/level2/{id}\")\r\n    public String toLevel2(@PathVariable(\"id\") int id){\r\n        return \"views/level2/\"+id;\r\n    }\r\n\r\n    //跳往等级页面\r\n    @RequestMapping(\"/level3/{id}\")\r\n    public String toLevel3(@PathVariable(\"id\") int id){\r\n        return \"views/level3/\"+id;\r\n    }\r\n}\r\n```\r\n\r\n**SecurityConfig配置SpringSecurity:**\r\n\r\n```java\r\n// AOP: 拦截器！\r\n@EnableWebSecurity\r\npublic class SecurityConfig extends WebSecurityConfigurerAdapter {\r\n    // 授权\r\n    // 链式编程\r\n    @Override\r\n    protected void configure(HttpSecurity http) throws Exception {\r\n        // 首页所有人都可以访问，功能页只对有权限的人访问\r\n        // 请求授权的规则\r\n        http.authorizeHttpRequests()\r\n                .antMatchers(\"/\").permitAll()\r\n                .antMatchers(\"/level1/**\").hasRole(\"vip1\")\r\n                .antMatchers(\"/level2/**\").hasRole(\"vip2\")\r\n                .antMatchers(\"/level3/**\").hasRole(\"vip3\");\r\n\r\n        // 没有权限默认到登录页面，需要开启登陆的页面\r\n            // login\r\n        http.formLogin();\r\n    }\r\n\r\n    // 认证，springboot 2.2.1 可以使用\r\n    // 密码编码：PasswordEncoder\r\n    // 在spring 5.0 + 新增了加密方法\r\n    @Override\r\n    protected void configure(AuthenticationManagerBuilder auth) throws Exception {\r\n        auth.inMemoryAuthentication().passwordEncoder(new BCryptPasswordEncoder())\r\n                .withUser(\"tony\").password(new BCryptPasswordEncoder().encode(\"123\")).roles(\"vip2\", \"vip3\")\r\n                .and()\r\n                .withUser(\"root\").password(new BCryptPasswordEncoder().encode(\"123\")).roles(\"vip1\", \"vip2\", \"vip3\")\r\n                .and()\r\n                .withUser(\"guest\").password(new BCryptPasswordEncoder().encode(\"123\")).roles(\"vip1\");\r\n    }\r\n}\r\n```\r\n\r\n**配置完成进入网页，点击vip2自动跳转至登录页**\r\n\r\n![image-20220527192053997](cloudDisk/markdown/springBoot笔记.assets/image-20220527192053997.png)\r\n\r\n\r\n\r\n注意：\r\n\r\n* 输入数据进行登录，没进行密码加密会报错\r\n\r\n  ![在这里插入图片描述](cloudDisk/markdown/springBoot笔记.assets/202104272321497.png)\r\n\r\n  这是因为我们允许通过的密码没有经过加密，不安全，被Spring Security驳回\r\n\r\n  Spring Security5.0+ 新增了很多加密办法\r\n\r\n  **这里我们采用BCryptPasswordEncoder方式的加密**\r\n\r\n  ```java\r\n  //认证，springboot 2.1.X可以直接使用\r\n      @Override\r\n      protected void configure(AuthenticationManagerBuilder auth) throws Exception {\r\n          //这些数据正常从数据库中获得\r\n          //下面是从内存中取得\r\n          auth.inMemoryAuthentication().passwordEncoder(new BCryptPasswordEncoder())\r\n                  .withUser(\"zs\").password(new BCryptPasswordEncoder().encode(\"123\")).roles(\"vip1\",\"vip2\",\"vip3\")\r\n                  .and()\r\n                  .withUser(\"ls\").password(new BCryptPasswordEncoder().encode(\"123\")).roles(\"vip1\",\"vip2\")\r\n                  .and()\r\n                  .withUser(\"guest\").password(new BCryptPasswordEncoder().encode(\"123\")).roles(\"vip1\")\r\n                  ;\r\n      }\r\n  ```\r\n\r\n  \r\n\r\n**进行登录跳转：**\r\n\r\n![在这里插入图片描述](cloudDisk/markdown/springBoot笔记.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlbndlbmFpZXI=,size_16,color_FFFFFF,t_70-16536496009768.png)\r\n\r\n\r\n\r\n## 注销\r\n\r\nSecurityConfig：\r\n\r\n```java\r\n    @Override\r\n    protected void configure(HttpSecurity http) throws Exception {\r\n        // 首页所有人都可以访问，功能页只对有权限的人访问\r\n        // 请求授权的规则\r\n        http.authorizeHttpRequests()\r\n                .antMatchers(\"/\").permitAll()\r\n                .antMatchers(\"/level1/**\").hasRole(\"vip1\")\r\n                .antMatchers(\"/level2/**\").hasRole(\"vip2\")\r\n                .antMatchers(\"/level3/**\").hasRole(\"vip3\");\r\n\r\n        // 没有权限默认到登录页面，需要开启登陆的页面\r\n            // login\r\n            // 访问 /login\r\n        http.formLogin();\r\n\r\n		http.csrf().disable(); // 关闭csrf功能\r\n        // 注销 访问 /logout\r\n//        http.logout();\r\n        // or 清空所有cookie，移除所有session\r\n//        http.logout().deleteCookies(\"remove\").invalidateHttpSession(true);\r\n        // 注销后，跳转到首页\r\n        http.logout().logoutSuccessUrl(\"/\"); // spring提供的页面\r\n\r\n    }\r\n```\r\n\r\n* [CSRF](https://so.csdn.net/so/search?q=CSRF&spm=1001.2101.3001.7020)防御\r\n\r\n  默认情况下,csrf防御是开启的,所以不使用.csrf().disable();这个代码去关闭他了\r\n  开启CSRF防御后,访问\"/login\",\"/logout\",都需要以post的方式\r\n\r\n![image-20220527192036230](cloudDisk/markdown/springBoot笔记.assets/image-20220527192036230.png)\r\n\r\n\r\n\r\n## 分用户权限 显示页面信息\r\n\r\n**那么接下来，如果我们以游客guest身份登录，登录之后只想让他看到页面的部分功能应该怎么办呢？这个时候需要通过Thymeleaf加SpringSecurity来实现**\r\n\r\n```xml\r\n导入入Thymeleaf加SpringSecurity整合包:\r\n<!-- https://mvnrepository.com/artifact/org.thymeleaf.extras/thymeleaf-extras-springsecurity5 -->\r\n<dependency>\r\n    <groupId>org.thymeleaf.extras</groupId>\r\n    <artifactId>thymeleaf-extras-springsecurity5</artifactId>\r\n    <version>3.0.4.RELEASE</version>\r\n</dependency>\r\n```\r\n\r\n在页面引入命名空间:\r\n\r\n```html\r\nxmlns:th=\"http://www.thymeleaf.org\" xmlns:sec=http://www.thymeleaf.org/extras/spring-security\r\n```\r\n\r\n在html利用sec:authorize=\"hasRole(‘xxx’)\"对权限进行筛选\r\n\r\n**index页面代码：**\r\n\r\n```html\r\n<!--主容器-->\r\n<div class=\"ui container\">\r\n\r\n    <div class=\"ui segment\" id=\"index-header-nav\" th:fragment=\"nav-menu\">\r\n        <div class=\"ui secondary menu\">\r\n            <a class=\"item\"  th:href=\"@{/index}\">首页</a>\r\n\r\n            <!--登录注销-->\r\n            <div class=\"right menu\">\r\n                <!--未登录显示登录按钮-->\r\n                <div sec:authorize=\"!isAuthenticated()\">\r\n                    <a class=\"item\" th:href=\"@{/toLogin}\">\r\n                        <i class=\"address card icon\"></i> 登录\r\n                    </a>\r\n                </div>\r\n                <!--如果已登录，显示用户名，注销-->\r\n                <div sec:authorize=\"isAuthenticated()\">\r\n                    <a class=\"item\">\r\n                        用户名：<span sec:authentication=\"name\"></span>\r\n                        vip等级：<span sec:authentication=\"principal.authorities\"></span>\r\n                    </a>\r\n                </div>\r\n                <div sec:authorize=\"isAuthenticated()\">\r\n                    <a class=\"item\" th:href=\"@{/logout}\">\r\n                        <i class=\"sign-out icon\"></i> 注销\r\n                    </a>\r\n                </div>\r\n            </div>\r\n        </div>\r\n    </div>\r\n\r\n    <div class=\"ui segment\" style=\"text-align: center\">\r\n        <h3>Spring Security</h3>\r\n    </div>\r\n\r\n    <div>\r\n        <br>\r\n        <div class=\"ui three column stackable grid\">\r\n\r\n\r\n            <div class=\"column\" sec:authorize=\"hasRole(\'vip1\')\">\r\n                <div class=\"ui raised segment\">\r\n                    <div class=\"ui\">\r\n                        <div class=\"content\">\r\n                            <h5 class=\"content\">Level 1</h5>\r\n                            <hr>\r\n                            <div><a th:href=\"@{/level1/1}\"><i class=\"bullhorn icon\"></i> Level-1-1</a></div>\r\n                            <div><a th:href=\"@{/level1/2}\"><i class=\"bullhorn icon\"></i> Level-1-2</a></div>\r\n                            <div><a th:href=\"@{/level1/3}\"><i class=\"bullhorn icon\"></i> Level-1-3</a></div>\r\n                        </div>\r\n                    </div>\r\n                </div>\r\n            </div>\r\n\r\n            <div class=\"column\" sec:authorize=\"hasRole(\'vip2\')\">\r\n\r\n                <div class=\"ui raised segment\">\r\n                    <div class=\"ui\">\r\n                        <div class=\"content\">\r\n                            <h5 class=\"content\">Level 2</h5>\r\n                            <hr>\r\n                            <div><a th:href=\"@{/level2/1}\"><i class=\"bullhorn icon\"></i> Level-2-1</a></div>\r\n                            <div><a th:href=\"@{/level2/2}\"><i class=\"bullhorn icon\"></i> Level-2-2</a></div>\r\n                            <div><a th:href=\"@{/level2/3}\"><i class=\"bullhorn icon\"></i> Level-2-3</a></div>\r\n                        </div>\r\n                    </div>\r\n                </div>\r\n            </div>\r\n\r\n            <div class=\"column\" sec:authorize=\"hasRole(\'vip3\')\">\r\n                <div class=\"ui raised segment\">\r\n                    <div class=\"ui\">\r\n                        <div class=\"content\" >\r\n                            <h5 class=\"content\">Level 3</h5>\r\n                            <hr>\r\n                            <div><a th:href=\"@{/level3/1}\"><i class=\"bullhorn icon\"></i> Level-3-1</a></div>\r\n                            <div><a th:href=\"@{/level3/2}\"><i class=\"bullhorn icon\"></i> Level-3-2</a></div>\r\n                            <div><a th:href=\"@{/level3/3}\"><i class=\"bullhorn icon\"></i> Level-3-3</a></div>\r\n                        </div>\r\n                    </div>\r\n                </div>\r\n            </div>\r\n        </div>\r\n    </div>\r\n</div>\r\n```\r\n\r\n**没登录显示：**\r\n\r\n![image-20220527194110892](cloudDisk/markdown/springBoot笔记.assets/image-20220527194110892.png)\r\n\r\n我们为tony赋予的权限为vip2，vip3；tony进行登录所看到的画面\r\n\r\n![image-20220527193738598](cloudDisk/markdown/springBoot笔记.assets/image-20220527193738598.png)\r\n\r\n我们为root赋予的权限为vip1，vip2，vip3；root进行登录所看到的画面\r\n\r\n![image-20220527193823251](cloudDisk/markdown/springBoot笔记.assets/image-20220527193823251.png)\r\n\r\n\r\n\r\n## 开启记住密码\r\n\r\n```java\r\nhttp.rememberMe();\r\n```\r\n\r\n![在这里插入图片描述](cloudDisk/markdown/springBoot笔记.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlbndlbmFpZXI=,size_16,color_FFFFFF,t_70-165365219411010.png)\r\n\r\ncookie 默认保存两周\r\n\r\n\r\n\r\n## 定制登录页面\r\n\r\n```java\r\n**在源码中我们发现：\r\n	 * 	/**&#064;Override\r\n	 * 	protected void configure(HttpSecurity http) throws Exception {\r\n	 * 		  \r\n	 *  http.authorizeRequests().antMatchers(&quot;&quot;).hasRole(&quot;USER&quot;).and().formLogin()\r\n	 * 				.usernameParameter(&quot;username&quot;) // default is username\r\n	 * 				.passwordParameter(&quot;password&quot;) // default is password\r\n	 * 				.loginPage(&quot;/authentication/login&quot;) // default is /login with an HTTP get\r\n	 * 				.failureUrl(&quot;/authentication/login?failed&quot;) // default is /login?error\r\n	 * 				.loginProcessingUrl(&quot;/authentication/login/process&quot;); // default is /login\r\n	 * 				// with an HTTP\r\n	 * 				// post\r\n	 * 	}**\r\n```\r\n\r\n我们可以通过loginPage可以设置登录页，通过failureUrl设置失败的登录页\r\n由此我们可以设置自己的登录页\r\n\r\n```java\r\nhttp.formLogin().loginPage(\"/toLogin\").usernameParameter(\"user\").passwordParameter(\"pwd\").loginProcessingUrl(\"/login\").defaultSuccessUrl(\"/index\");\r\n```\r\n\r\n这里loginProcessingUrl(）相当于一个中转站，前台界面提交表单之后跳转到这个路径进行User DetailsService的验证，如果成功， defaultSuccessUrl（）如果失败,那么转向failureUrl(\"/error.html\")\r\n\r\n```java\r\n    @Override\r\n    protected void configure(HttpSecurity http) throws Exception {\r\n        // 首页所有人都可以访问，功能页只对有权限的人访问\r\n        // 请求授权的规则\r\n        http.authorizeHttpRequests()\r\n                .antMatchers(\"/\").permitAll()\r\n                .antMatchers(\"/level1/**\").hasRole(\"vip1\")\r\n                .antMatchers(\"/level2/**\").hasRole(\"vip2\")\r\n                .antMatchers(\"/level3/**\").hasRole(\"vip3\");\r\n\r\n        // 没有权限默认到登录页面，需要开启登陆的页面\r\n            // login\r\n            // 访问 /login\r\n//        http.formLogin(); // 默认页面\r\n        http.formLogin().loginPage(\"/toLogin\").usernameParameter(\"user\").passwordParameter(\"pwd\").loginProcessingUrl(\"/login\"); // 定制登陆页面\r\n        // 定制的登录页：/toLogin；处理登录请求：/login；表单name不符合规范，通过usernameParameter、passwordParameter解决\r\n\r\n        http.csrf().disable(); // 关闭csrf功能\r\n        // 注销 访问 /logout\r\n//        http.logout();\r\n        // or 清空所有cookie，移除所有session\r\n//        http.logout().deleteCookies(\"remove\").invalidateHttpSession(true);\r\n        // 注销后，跳转到首页\r\n        http.logout().logoutSuccessUrl(\"/\"); // spring提供的页面\r\n\r\n//        http.rememberMe();\r\n        http.rememberMe().rememberMeParameter(\"remember\"); // 自定义表单name不符合规范，通过rememberMeParameter解决\r\n\r\n    }\r\n```\r\n\r\n\r\n\r\n![在这里插入图片描述](cloudDisk/markdown/springBoot笔记.assets/20210427234808256.gif)\r\n\r\n\r\n\r\n\r\n\r\n# 十四、Shiro\r\n\r\n## 简介\r\n\r\n**1.1 什么是Shiro？**\r\n\r\n- Apache Shiro是一个Java 的安全(权限)框架。\r\n- Shiro可以非常容易的开发出足够好的应用，其不仅可以用在JavaSE环境，也可以用在JavaEE环境。\r\n- Shiro可以完成，认证，授权，加密，会话管理，Web集成，缓存等.\r\n- 下载地址: http://shiro.apache.org/\r\n\r\n![image-20220528004531418](cloudDisk/markdown/springBoot笔记.assets/image-20220528004531418.png)\r\n\r\n**1.2 有哪些功能？**\r\n\r\n![在这里插入图片描述](cloudDisk/markdown/springBoot笔记.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDE5MDY2NQ==,size_16,color_FFFFFF,t_70.png)\r\n\r\n![在这里插入图片描述](cloudDisk/markdown/springBoot笔记.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDE5MDY2NQ==,size_16,color_FFFFFF,t_70-165366999147914.png)\r\n\r\n**1.3 外部结构**\r\n\r\n![在这里插入图片描述](cloudDisk/markdown/springBoot笔记.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDE5MDY2NQ==,size_16,color_FFFFFF,t_70-165367000076416.png)\r\n\r\n![在这里插入图片描述](cloudDisk/markdown/springBoot笔记.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDE5MDY2NQ==,size_16,color_FFFFFF,t_70-165367000569718.png)\r\n\r\n**1.4 内部结构**\r\n\r\n![ ](https://img-blog.csdnimg.cn/20210516203740275.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDE5MDY2NQ==,size_16,color_FFFFFF,t_70)\r\n\r\n![在这里插入图片描述](cloudDisk/markdown/springBoot笔记.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDE5MDY2NQ==,size_16,color_FFFFFF,t_70-165367002400522.png)\r\n\r\n\r\n\r\n## 快速开始\r\n\r\n### **1、 创建新的maven项目**\r\n\r\n![在这里插入图片描述](cloudDisk/markdown/springBoot笔记.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDE5MDY2NQ==,size_16,color_FFFFFF,t_70-165367021419924.png)\r\n\r\n\r\n\r\n### **2、引入依赖**\r\n\r\n```xml\r\n    <dependencies>\r\n        <!-- https://mvnrepository.com/artifact/org.apache.shiro/shiro-core -->\r\n        <dependency>\r\n            <groupId>org.apache.shiro</groupId>\r\n            <artifactId>shiro-core</artifactId>\r\n            <version>1.7.1</version>\r\n        </dependency>\r\n        <dependency>\r\n            <groupId>commons-logging</groupId>\r\n            <artifactId>commons-logging</artifactId>\r\n            <version>1.2</version>\r\n        </dependency>\r\n\r\n        <dependency>\r\n            <groupId>org.slf4j</groupId>\r\n            <artifactId>slf4j-api</artifactId>\r\n            <version>1.8.0-beta4</version>\r\n        </dependency>\r\n        <dependency>\r\n            <groupId>org.slf4j</groupId>\r\n            <artifactId>slf4j-log4j12</artifactId>\r\n            <version>1.8.0-beta4</version>\r\n        </dependency>\r\n        <dependency>\r\n            <groupId>log4j</groupId>\r\n            <artifactId>log4j</artifactId>\r\n            <version>1.2.17</version>\r\n        </dependency>\r\n\r\n    </dependencies>\r\n```\r\n\r\n### **3、复制quickstart项目**\r\n\r\n![在这里插入图片描述](cloudDisk/markdown/springBoot笔记.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDE5MDY2NQ==,size_16,color_FFFFFF,t_70-165367029714226.png)\r\n\r\n#### resources目录下：\r\n\r\n##### log4j.properties\r\n\r\n```properties\r\nlog4j.rootLogger=INFO, stdout\r\n\r\nlog4j.appender.stdout=org.apache.log4j.ConsoleAppender\r\nlog4j.appender.stdout.layout=org.apache.log4j.PatternLayout\r\nlog4j.appender.stdout.layout.ConversionPattern=%d %p [%c] - %m %n\r\n\r\n# General Apache libraries\r\nlog4j.logger.org.apache=WARN\r\n\r\n# Spring\r\nlog4j.logger.org.springframework=WARN\r\n\r\n# Default Shiro logging\r\nlog4j.logger.org.apache.shiro=INFO\r\n\r\n# Disable verbose logging\r\nlog4j.logger.org.apache.shiro.util.ThreadContext=WARN\r\nlog4j.logger.org.apache.shiro.cache.ehcache.EhCache=WARN\r\n```\r\n\r\n##### shiro.ini\r\n\r\n```ini\r\n[users]\r\n# user \'root\' with password \'secret\' and the \'admin\' role\r\nroot = secret, admin\r\n# user \'guest\' with the password \'guest\' and the \'guest\' role\r\nguest = guest, guest\r\n# user \'presidentskroob\' with password \'12345\' (\"That\'s the same combination on\r\n# my luggage!!!\" ;)), and role \'president\'\r\npresidentskroob = 12345, president\r\n# user \'darkhelmet\' with password \'ludicrousspeed\' and roles \'darklord\' and \'schwartz\'\r\ndarkhelmet = ludicrousspeed, darklord, schwartz\r\n# user \'lonestarr\' with password \'vespa\' and roles \'goodguy\' and \'schwartz\'\r\nlonestarr = vespa, goodguy, schwartz\r\n\r\n# -----------------------------------------------------------------------------\r\n# Roles with assigned permissions\r\n#\r\n# Each line conforms to the format defined in the\r\n# org.apache.shiro.realm.text.TextConfigurationRealm#setRoleDefinitions JavaDoc\r\n# -----------------------------------------------------------------------------\r\n[roles]\r\n# \'admin\' role has all permissions, indicated by the wildcard \'*\'\r\nadmin = *\r\n# The \'schwartz\' role can do anything (*) with any lightsaber:\r\nschwartz = lightsaber:*\r\n# The \'goodguy\' role is allowed to \'drive\' (action) the winnebago (type) with\r\n# license plate \'eagle5\' (instance specific id)\r\ngoodguy = winnebago:drive:eagle5\r\n```\r\n\r\n#### java目录下：QuickStart.java\r\n\r\n```java\r\n/*\r\n * Licensed to the Apache Software Foundation (ASF) under one\r\n * or more contributor license agreements.  See the NOTICE file\r\n * distributed with this work for additional information\r\n * regarding copyright ownership.  The ASF licenses this file\r\n * to you under the Apache License, Version 2.0 (the\r\n * \"License\"); you may not use this file except in compliance\r\n * with the License.  You may obtain a copy of the License at\r\n *\r\n *     http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing,\r\n * software distributed under the License is distributed on an\r\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n * KIND, either express or implied.  See the License for the\r\n * specific language governing permissions and limitations\r\n * under the License.\r\n */\r\n\r\nimport org.apache.shiro.SecurityUtils;\r\nimport org.apache.shiro.authc.*;\r\nimport org.apache.shiro.ini.IniSecurityManagerFactory;\r\nimport org.apache.shiro.mgt.SecurityManager;\r\nimport org.apache.shiro.session.Session;\r\nimport org.apache.shiro.subject.Subject;\r\nimport org.apache.shiro.lang.util.Factory;\r\nimport org.slf4j.Logger;\r\nimport org.slf4j.LoggerFactory;\r\n\r\n\r\n/**\r\n * Simple Quickstart application showing how to use Shiro\'s API.\r\n *\r\n * @since 0.9 RC2\r\n */\r\npublic class Quickstart {\r\n\r\n    private static final transient Logger log = LoggerFactory.getLogger(Quickstart.class);\r\n\r\n\r\n    public static void main(String[] args) {\r\n\r\n        // The easiest way to create a Shiro SecurityManager with configured\r\n        // realms, users, roles and permissions is to use the simple INI config.\r\n        // We\'ll do that by using a factory that can ingest a .ini file and\r\n        // return a SecurityManager instance:\r\n\r\n        // Use the shiro.ini file at the root of the classpath\r\n        // (file: and url: prefixes load from files and urls respectively):\r\n        Factory<SecurityManager> factory = new IniSecurityManagerFactory(\"classpath:shiro.ini\");\r\n        SecurityManager securityManager = factory.getInstance();\r\n\r\n        // for this simple example quickstart, make the SecurityManager\r\n        // accessible as a JVM singleton.  Most applications wouldn\'t do this\r\n        // and instead rely on their container configuration or web.xml for\r\n        // webapps.  That is outside the scope of this simple quickstart, so\r\n        // we\'ll just do the bare minimum so you can continue to get a feel\r\n        // for things.\r\n        SecurityUtils.setSecurityManager(securityManager);\r\n\r\n        // Now that a simple Shiro environment is set up, let\'s see what you can do:\r\n\r\n        // get the currently executing user:\r\n        Subject currentUser = SecurityUtils.getSubject();\r\n\r\n        // Do some stuff with a Session (no need for a web or EJB container!!!)\r\n        Session session = currentUser.getSession();\r\n        session.setAttribute(\"someKey\", \"aValue\");\r\n        String value = (String) session.getAttribute(\"someKey\");\r\n        if (value.equals(\"aValue\")) {\r\n            log.info(\"Retrieved the correct value! [\" + value + \"]\");\r\n        }\r\n\r\n        // let\'s login the current user so we can check against roles and permissions:\r\n        if (!currentUser.isAuthenticated()) {\r\n            UsernamePasswordToken token = new UsernamePasswordToken(\"lonestarr\", \"vespa\");\r\n            token.setRememberMe(true);\r\n            try {\r\n                currentUser.login(token);\r\n            } catch (UnknownAccountException uae) {\r\n                log.info(\"There is no user with username of \" + token.getPrincipal());\r\n            } catch (IncorrectCredentialsException ice) {\r\n                log.info(\"Password for account \" + token.getPrincipal() + \" was incorrect!\");\r\n            } catch (LockedAccountException lae) {\r\n                log.info(\"The account for username \" + token.getPrincipal() + \" is locked.  \" +\r\n                        \"Please contact your administrator to unlock it.\");\r\n            }\r\n            // ... catch more exceptions here (maybe custom ones specific to your application?\r\n            catch (AuthenticationException ae) {\r\n                //unexpected condition?  error?\r\n            }\r\n        }\r\n\r\n        //say who they are:\r\n        //print their identifying principal (in this case, a username):\r\n        log.info(\"User [\" + currentUser.getPrincipal() + \"] logged in successfully.\");\r\n\r\n        //test a role:\r\n        if (currentUser.hasRole(\"schwartz\")) {\r\n            log.info(\"May the Schwartz be with you!\");\r\n        } else {\r\n            log.info(\"Hello, mere mortal.\");\r\n        }\r\n\r\n        //test a typed permission (not instance-level)\r\n        if (currentUser.isPermitted(\"lightsaber:wield\")) {\r\n            log.info(\"You may use a lightsaber ring.  Use it wisely.\");\r\n        } else {\r\n            log.info(\"Sorry, lightsaber rings are for schwartz masters only.\");\r\n        }\r\n\r\n        //a (very powerful) Instance Level permission:\r\n        if (currentUser.isPermitted(\"winnebago:drive:eagle5\")) {\r\n            log.info(\"You are permitted to \'drive\' the winnebago with license plate (id) \'eagle5\'.  \" +\r\n                    \"Here are the keys - have fun!\");\r\n        } else {\r\n            log.info(\"Sorry, you aren\'t allowed to drive the \'eagle5\' winnebago!\");\r\n        }\r\n\r\n        //all done - log out!\r\n        currentUser.logout();\r\n\r\n        System.exit(0);\r\n    }\r\n}\r\n```\r\n\r\n### **4、测试结果**\r\n\r\n![在这里插入图片描述](cloudDisk/markdown/springBoot笔记.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDE5MDY2NQ==,size_16,color_FFFFFF,t_70-165367039332528.png)\r\n\r\n\r\n\r\n## 整合springboot\r\n\r\n### **1、搭建环境**\r\n\r\n1、创建springboot项目\r\n\r\n![在这里插入图片描述](https://img-blog.csdnimg.cn/2021051621475925.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDE5MDY2NQ==,size_16,color_FFFFFF,t_70)\r\n\r\n\r\n\r\n新建测试页面：\r\n\r\n```html\r\n<!DOCTYPE html>\r\n<html lang=\"en\" xmlns:th=\"http://www.thymeleaf.org\">\r\n<head>\r\n    <meta charset=\"UTF-8\">\r\n    <title>Title</title>\r\n</head>\r\n<body>\r\n    <h1>首页</h1>\r\n    <p th:text=\"${msg}\"></p>\r\n<hr>\r\n<a th:href=\"@{/user/add}\">add</a> | <a th:href=\"@{/user/update}\">update</a>\r\n</body>\r\n</html>\r\n```\r\n\r\n新建controller\r\n\r\n```java\r\n@RequestMapping({\"/\", \"/index\"})\r\npublic String toIndex(Model model){\r\n    model.addAttribute(\"msg\", \"hello world\");\r\n    return \"index\";\r\n}\r\n```\r\n\r\n\r\n\r\n测试成功。\r\n\r\n### **2、整合springboot**\r\n\r\n1、引入依赖\r\n\r\n```xml\r\n<dependency>\r\n		<groupId>org.apache.shiro</groupId>\r\n		<artifactId>shiro-spring</artifactId>\r\n		<version>1.7.1</version>\r\n</dependency>\r\n```\r\n\r\n2、编写自定义Realm\r\n\r\n```java\r\n// 自定义的\r\npublic class UserRealm extends AuthorizingRealm {\r\n    // 授权\r\n    @Override\r\n    protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principalCollection) {\r\n        System.out.println(\"执行了 => 授权\");\r\n        return null;\r\n    }\r\n\r\n    // 认证\r\n    @Override\r\n    protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken authenticationToken) throws AuthenticationException {\r\n        System.out.println(\"执行了 => 认证\");\r\n        return null;\r\n    }\r\n}\r\n\r\n```\r\n\r\n3、编写ShiroConfig\r\n\r\n```java\r\n@Configuration\r\npublic class ShiroConfig {\r\n\r\n    //ShiroFilterFactoryBean:3\r\n    @Bean\r\n    public ShiroFilterFactoryBean getShiroFilterFactoryBean(@Qualifier(\"getDefaultWebSecurityManager\")DefaultWebSecurityManager defaultWebSecurityManager){\r\n        ShiroFilterFactoryBean bean = new ShiroFilterFactoryBean();\r\n        bean.setSecurityManager(defaultWebSecurityManager);\r\n        return bean;\r\n    }\r\n\r\n    //DefaultWebSecurityManager:2\r\n    @Bean\r\n    public DefaultWebSecurityManager getDefaultWebSecurityManager(@Qualifier(\"userRealm\") UserRealm userRealm){\r\n        DefaultWebSecurityManager securityManager = new DefaultWebSecurityManager();\r\n        //关联UserRealm\r\n        securityManager.setRealm(userRealm);\r\n        return  securityManager;\r\n    }\r\n\r\n\r\n    //创建realm对象， 需要自定义\r\n    @Bean\r\n    public UserRealm userRealm(){\r\n        return new UserRealm();\r\n    }\r\n\r\n}\r\n```\r\n\r\n4、创建测试页面：\r\n\r\n![在这里插入图片描述](cloudDisk/markdown/springBoot笔记.assets/20210516221921234.png)\r\n\r\n\r\n\r\n![image-20220528165933026](cloudDisk/markdown/springBoot笔记.assets/image-20220528165933026.png)\r\n\r\n### 3、实现登录拦截拦截\r\n\r\nShiroConfig.java\r\n\r\n```java\r\n@Configuration\r\npublic class ShiroConfig {\r\n    // ShiroFilterFactoryBean // step: 3\r\n    @Bean\r\n    public ShiroFilterFactoryBean shiroFilterFactoryBean(@Qualifier(\"securityManager\") DefaultWebSecurityManager defaultWebSecurityManager){\r\n        // 设置安全管理器\r\n        ShiroFilterFactoryBean bean = new ShiroFilterFactoryBean();\r\n        bean.setSecurityManager(defaultWebSecurityManager);\r\n\r\n        // 添加shiro内置过滤器\r\n        /*\r\n        *   anon: 无需认证就能访问\r\n        *   authc: 必须认证才能访问\r\n        *   user: 必须有 记住我 功能才能访问\r\n        *   perms: 拥有对某个资源的权限才能访问\r\n        *   role: 拥有某个角色才能访问\r\n        * */\r\n        Map<String, String> filterMap = new LinkedHashMap<>();\r\n//        filterMap.put(\"/user/add\", \"authc\");\r\n//        filterMap.put(\"/user/update\", \"authc\");\r\n        filterMap.put(\"/user/*\", \"authc\");\r\n        bean.setFilterChainDefinitionMap(filterMap);\r\n        bean.setLoginUrl(\"/toLogin\"); // 设置登录的请求\r\n\r\n        return bean;\r\n    }\r\n\r\n    // DefaultWebSecurityManager // step: 2\r\n    @Bean(name=\"securityManager\")\r\n    public DefaultWebSecurityManager defaultWebSecurityManager(@Qualifier(\"userRealm\") UserRealm userRealm){\r\n        DefaultWebSecurityManager manager = new DefaultWebSecurityManager();\r\n        // 关联userRealm\r\n        manager.setRealm(userRealm);\r\n        return manager;\r\n    }\r\n\r\n    // 创建 realm 对象，需要自定义类 // step: 1\r\n    @Bean(name=\"userRealm\")\r\n    public UserRealm userRealm(){\r\n        return new UserRealm();\r\n    }\r\n}\r\n```\r\n\r\n\r\n\r\n### 4、实现用户认证\r\n\r\nMyController.java\r\n\r\n```java\r\n    @RequestMapping(\"/login\")\r\n    public String login(String username, String password, Model model){\r\n        // 获取当前用户\r\n        Subject subject = SecurityUtils.getSubject();\r\n        // 封装用户的登录数据\r\n        UsernamePasswordToken token = new UsernamePasswordToken(username, password);\r\n        try{\r\n            subject.login(token); // 执行登录方法，如果没有异常，说明ok\r\n            return \"index\";\r\n        }catch (UnknownAccountException e){ // 用户名不存在\r\n            model.addAttribute(\"msg\", \"用户名错误\");\r\n            return \"login\";\r\n        }catch (IncorrectCredentialsException e){ // 密码不存在\r\n            model.addAttribute(\"msg\", \"密码错误\");\r\n            return \"login\";\r\n        }\r\n    }\r\n```\r\n\r\nlogin.html\r\n\r\n```html\r\n<!DOCTYPE html>\r\n<html lang=\"en\" xmlns:th=\"http://www.thymeleaf.org\">\r\n<head>\r\n    <meta charset=\"UTF-8\">\r\n    <title>Title</title>\r\n</head>\r\n<body>\r\n<h1>登录</h1>\r\n<hr>\r\n<p style=\"color: red\" th:text=\"${msg}\"></p>\r\n<form action=\"/login\">\r\n    <p>用户名：<input type=\"text\" name=\"username\"></p>\r\n    <p>密码：<input type=\"text\" name=\"password\"></p>\r\n    <p><input type=\"submit\" value=\"登录\"></p>\r\n</form>\r\n</body>\r\n</html>\r\n```\r\n\r\n\r\n\r\nRealm.java\r\n\r\n```java\r\n// 自定义的\r\npublic class UserRealm extends AuthorizingRealm {\r\n    // 授权\r\n    @Override\r\n    protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principalCollection) {\r\n        System.out.println(\"执行了 => 授权\");\r\n        return null;\r\n    }\r\n\r\n    // 认证\r\n    @Override\r\n    protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken token) throws AuthenticationException {\r\n        System.out.println(\"执行了 => 认证\");\r\n\r\n        // 用户名，密码 ---- 数据库中取\r\n        String name = \"root\";\r\n        String password = \"123\";\r\n        UsernamePasswordToken userToken = (UsernamePasswordToken) token;\r\n        if (!userToken.getUsername().equals(name)){\r\n            return null; // 抛出异常 UnknownAccountException\r\n        }\r\n        // 密码认证，shiro做\r\n        return new SimpleAuthenticationInfo(\"\", password, \"\");\r\n    }\r\n}\r\n\r\n```\r\n\r\n错误的账号密码登录：\r\n\r\n![image-20220528171534699](cloudDisk/markdown/springBoot笔记.assets/image-20220528171534699.png)\r\n\r\n![image-20220528171539841](cloudDisk/markdown/springBoot笔记.assets/image-20220528171539841.png)\r\n\r\n正确的：跳转到首页\r\n\r\n![image-20220528171623120](cloudDisk/markdown/springBoot笔记.assets/image-20220528171623120.png)\r\n\r\n### 5、整合mybatis\r\n\r\n#### maven依赖\r\n\r\n```xml\r\n<dependency>\r\n    <groupId>mysql</groupId>\r\n    <artifactId>mysql-connector-java</artifactId>\r\n</dependency>\r\n<dependency>\r\n    <groupId>log4j</groupId>\r\n    <artifactId>log4j</artifactId>\r\n    <version>1.2.17</version>\r\n</dependency>\r\n<!--mybatis-spring-boot-starter 整合-->\r\n<dependency>\r\n    <groupId>org.mybatis.spring.boot</groupId>\r\n    <artifactId>mybatis-spring-boot-starter</artifactId>\r\n    <version>2.2.2</version>\r\n</dependency>\r\n<!--druid-->\r\n<dependency>\r\n    <groupId>com.alibaba</groupId>\r\n    <artifactId>druid</artifactId>\r\n    <version>1.1.21</version>\r\n</dependency>\r\n```\r\n\r\n#### yml配置文件\r\n\r\n```yml\r\nspring:\r\n  datasource:\r\n    url: jdbc:mysql://localhost:3306/mybatis?useUnicode=true&characterEncoding=utf-8&serverTimezone=UTC\r\n    password: 123\r\n    username: root\r\n    driver-class-name: com.mysql.cj.jdbc.Driver\r\n    type: com.alibaba.druid.pool.DruidDataSource\r\n\r\n    #Spring Boot 默认是不注入这些属性值的，需要自己绑定\r\n    #druid 数据源专有配置\r\n    initialSize: 5\r\n    minIdle: 5\r\n    maxActive: 20\r\n    maxWait: 60000\r\n    timeBetweenEvictionRunsMillis: 60000\r\n    minEvictableIdleTimeMillis: 300000\r\n    validationQuery: SELECT 1 FROM DUAL\r\n    testWhileIdle: true\r\n    testOnBorrow: false\r\n    testOnReturn: false\r\n    poolPreparedStatements: true\r\n    #配置监控统计拦截的filters，stat:监控统计、log4j：日志记录、wall：防御sql注入\r\n    #如果允许时报错  java.lang.ClassNotFoundException: org.apache.log4j.Priority\r\n    #则导入 log4j 依赖即可，Maven 地址：https://mvnrepository.com/artifact/log4j/log4j\r\n    filters: stat,wall,log4j\r\n    maxPoolPreparedStatementPerConnectionSize: 20\r\n    useGlobalDataSourceStat: true\r\n    connectionProperties: druid.stat.mergeSql=true;druid.stat.slowSqlMillis=500\r\nmybatis:\r\n  type-aliases-package: com.tony.pojo\r\n  mapper-locations: classpath:mybatis/mapper/*.xml # mapper所在位置\r\n\r\n```\r\n\r\n#### 包结构\r\n\r\n![image-20220528175038467](cloudDisk/markdown/springBoot笔记.assets/image-20220528175038467.png)\r\n\r\n#### 测试查询数据库\r\n\r\n```java\r\n@SpringBootTest\r\nclass DemoApplicationTests {\r\n    @Autowired\r\n    UserService userService;\r\n    @Test\r\n    void contextLoads() {\r\n        System.out.println(userService.queryUserByName(\"王五\"));\r\n    }\r\n\r\n}\r\n\r\n```\r\n\r\n![image-20220528175230274](cloudDisk/markdown/springBoot笔记.assets/image-20220528175230274.png)\r\n\r\n#### shiroConfig中的固定密码替换成数据库密码\r\n\r\n```java\r\n@Configuration\r\npublic class ShiroConfig {\r\n    // ShiroFilterFactoryBean // step: 3\r\n    @Bean\r\n    public ShiroFilterFactoryBean shiroFilterFactoryBean(@Qualifier(\"securityManager\") DefaultWebSecurityManager defaultWebSecurityManager){\r\n        // 设置安全管理器\r\n        ShiroFilterFactoryBean bean = new ShiroFilterFactoryBean();\r\n        bean.setSecurityManager(defaultWebSecurityManager);\r\n\r\n        // 添加shiro内置过滤器\r\n        /*\r\n        *   anon: 无需认证就能访问\r\n        *   authc: 必须认证才能访问\r\n        *   user: 必须有 记住我 功能才能访问\r\n        *   perms: 拥有对某个资源的权限才能访问\r\n        *   role: 拥有某个角色才能访问\r\n        * */\r\n        Map<String, String> filterMap = new LinkedHashMap<>();\r\n//        filterMap.put(\"/user/add\", \"authc\");\r\n//        filterMap.put(\"/user/update\", \"authc\");\r\n        filterMap.put(\"/user/*\", \"authc\");\r\n        bean.setFilterChainDefinitionMap(filterMap);\r\n        bean.setLoginUrl(\"/toLogin\"); // 设置登录的请求\r\n\r\n        return bean;\r\n    }\r\n\r\n    // DefaultWebSecurityManager // step: 2\r\n    @Bean(name=\"securityManager\")\r\n    public DefaultWebSecurityManager defaultWebSecurityManager(@Qualifier(\"userRealm\") UserRealm userRealm){\r\n        DefaultWebSecurityManager manager = new DefaultWebSecurityManager();\r\n        // 关联userRealm\r\n        manager.setRealm(userRealm);\r\n        return manager;\r\n    }\r\n\r\n    // 创建 realm 对象，需要自定义类 // step: 1\r\n    @Bean(name=\"userRealm\")\r\n    public UserRealm userRealm(){\r\n        return new UserRealm();\r\n    }\r\n}\r\n\r\n```\r\n\r\n\r\n\r\n\r\n\r\n### 6、请求授权实现\r\n\r\n#### 配置权限过滤 ShiroConfig：\r\n\r\n  // 授权，正常情况下，没有授权会跳转到授权页面\r\n        filterMap.put(\"/user/add\", \"perms[user:add]\");\r\n        filterMap.put(\"/user/update\", \"perms[user:update]\");\r\n// 设置未授权页面\r\n        bean.setUnauthorizedUrl(\"/noauth\");\r\n\r\n```java\r\n@Configuration\r\npublic class ShiroConfig {\r\n    // ShiroFilterFactoryBean // step: 3\r\n    @Bean\r\n    public ShiroFilterFactoryBean shiroFilterFactoryBean(@Qualifier(\"securityManager\") DefaultWebSecurityManager defaultWebSecurityManager){\r\n        // 设置安全管理器\r\n        ShiroFilterFactoryBean bean = new ShiroFilterFactoryBean();\r\n        bean.setSecurityManager(defaultWebSecurityManager);\r\n\r\n        // 添加shiro内置过滤器\r\n        /*\r\n        *   anon: 无需认证就能访问\r\n        *   authc: 必须认证才能访问\r\n        *   user: 必须有 记住我 功能才能访问\r\n        *   perms: 拥有对某个资源的权限才能访问\r\n        *   role: 拥有某个角色才能访问\r\n        * */\r\n        // 拦截\r\n        Map<String, String> filterMap = new LinkedHashMap<>();\r\n\r\n        // 授权，正常情况下，没有授权会跳转到授权页面\r\n        filterMap.put(\"/user/add\", \"perms[user:add]\");\r\n        filterMap.put(\"/user/update\", \"perms[user:update]\");\r\n        // 设置未授权页面\r\n        bean.setUnauthorizedUrl(\"/noauth\");\r\n\r\n//        filterMap.put(\"/user/add\", \"authc\");\r\n//        filterMap.put(\"/user/update\", \"authc\");\r\n        filterMap.put(\"/user/*\", \"authc\");\r\n        bean.setFilterChainDefinitionMap(filterMap);\r\n        bean.setLoginUrl(\"/toLogin\"); // 设置登录的请求\r\n\r\n        return bean;\r\n    }\r\n\r\n    // DefaultWebSecurityManager // step: 2\r\n    @Bean(name=\"securityManager\")\r\n    public DefaultWebSecurityManager defaultWebSecurityManager(@Qualifier(\"userRealm\") UserRealm userRealm){\r\n        DefaultWebSecurityManager manager = new DefaultWebSecurityManager();\r\n        // 关联userRealm\r\n        manager.setRealm(userRealm);\r\n        return manager;\r\n    }\r\n\r\n    // 创建 realm 对象，需要自定义类 // step: 1\r\n    @Bean(name=\"userRealm\")\r\n    public UserRealm userRealm(){\r\n        return new UserRealm();\r\n    }\r\n}\r\n```\r\n\r\n\r\n\r\n#### 未授权页面：\r\n\r\n```java\r\n@RequestMapping(\"/noauth\")\r\n@ResponseBody\r\npublic String unauthorized(){\r\n    return \"未经授权无法访问此页面\";\r\n}\r\n```\r\n\r\n\r\n\r\n#### 权限给予 UserRealm：\r\n\r\n```java\r\n//        info.addStringPermission(\"user:add\"); // 如果没经过判断，给予所有人权限\r\n```\r\n\r\n新建一个user表字段：\r\n\r\n![image-20220528181731753](cloudDisk/markdown/springBoot笔记.assets/image-20220528181731753.png)\r\n\r\n\r\n\r\n```java\r\n@Data\r\n@NoArgsConstructor\r\n@AllArgsConstructor\r\npublic class User {\r\n    private int id;\r\n    private String name;\r\n    private String pwd;\r\n    private String perms;\r\n}\r\n\r\n```\r\n\r\n\r\n\r\n权限给予：\r\n\r\n```java\r\n// 自定义的\r\npublic class UserRealm extends AuthorizingRealm {\r\n    @Autowired\r\n    UserService userService;\r\n\r\n    // 授权\r\n    @Override\r\n    protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principalCollection) {\r\n        System.out.println(\"执行了 => 授权\");\r\n\r\n        SimpleAuthorizationInfo info = new SimpleAuthorizationInfo();\r\n//        info.addStringPermission(\"user:add\"); // 没经过判断，给予所有人权限\r\n\r\n        // 拿到当前登陆的这个对象\r\n        Subject subject = SecurityUtils.getSubject();\r\n        User currentUser = (User) subject.getPrincipal(); // 拿到user对象\r\n\r\n        // 设置当前用户的权限\r\n        info.addStringPermission(currentUser.getPerms());\r\n\r\n        return info;\r\n    }\r\n\r\n    // 认证\r\n    @Override\r\n    protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken token) throws AuthenticationException {\r\n        System.out.println(\"执行了 => 认证\");\r\n\r\n        // 用户名，密码 ---- 数据库中取\r\n        UsernamePasswordToken userToken = (UsernamePasswordToken) token;\r\n        User user = userService.queryUserByName(userToken.getUsername());\r\n        if (user == null){\r\n            return null; // 抛出异常 UnknownAccountException\r\n        }\r\n        // 密码认证，shiro做\r\n        // 加密密码；MD5 、 MD5加盐\r\n        return new SimpleAuthenticationInfo(user, user.getPwd(), \"\");\r\n    }\r\n}\r\n```\r\n\r\n* 认证方法中，将user一并返回\r\n* 授权方法中，通过subject对象，获取user\r\n* 获取用户权限，并给予：info.addStringPermission(currentUser.getPerms());\r\n\r\n\r\n\r\n#### 测试：\r\n\r\n![image-20220528182147090](cloudDisk/markdown/springBoot笔记.assets/image-20220528182147090.png)\r\n\r\n![image-20220528182324587](cloudDisk/markdown/springBoot笔记.assets/image-20220528182324587.png)\r\n\r\n王五 用户访问add：\r\n\r\n![image-20220528182215780](cloudDisk/markdown/springBoot笔记.assets/image-20220528182215780.png)\r\n\r\n\r\n\r\n王五 用户访问update：\r\n\r\n![image-20220528182231654](cloudDisk/markdown/springBoot笔记.assets/image-20220528182231654.png)\r\n\r\ntony 用户访问add：\r\n\r\n![image-20220528182301265](cloudDisk/markdown/springBoot笔记.assets/image-20220528182301265.png)\r\n\r\ntony 用户访问update：\r\n\r\n![image-20220528182307858](cloudDisk/markdown/springBoot笔记.assets/image-20220528182307858.png)\r\n\r\n\r\n\r\n### 7、shiro整合thymeleaf：分权限显示\r\n\r\n#### maven依赖\r\n\r\n```xml\r\n        <!--shiro-thymeleaf整合-->\r\n        <dependency>\r\n            <groupId>com.github.theborakompanioni</groupId>\r\n            <artifactId>thymeleaf-extras-shiro</artifactId>\r\n            <version>2.1.0</version>\r\n        </dependency>\r\n```\r\n\r\n\r\n\r\n#### ShiroConfig.java\r\n\r\n```java\r\n    // 整合shiroDialect： 用来整合 shiro thymeleaf\r\n    @Bean\r\n    public ShiroDialect getShiroDialect(){\r\n        return new ShiroDialect();\r\n    }\r\n```\r\n\r\n\r\n\r\n#### UserRealm.java\r\n\r\n* 将user对象存入session\r\n\r\n​	Subject subject = SecurityUtils.getSubject();\r\n​	Session session = subject.getSession();\r\n​	session.setAttribute(\"loginUser\", user);\r\n\r\n```java\r\n    // 认证\r\n    @Override\r\n    protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken token) throws AuthenticationException {\r\n        System.out.println(\"执行了 => 认证\");\r\n\r\n        // 用户名，密码 ---- 数据库中取\r\n        UsernamePasswordToken userToken = (UsernamePasswordToken) token;\r\n        User user = userService.queryUserByName(userToken.getUsername());\r\n        if (user == null){\r\n            return null; // 抛出异常 UnknownAccountException\r\n        }\r\n        Subject subject = SecurityUtils.getSubject();\r\n        Session session = subject.getSession();\r\n        session.setAttribute(\"loginUser\", user);\r\n        // 密码认证，shiro做\r\n        // 加密密码；MD5 、 MD5加盐\r\n        return new SimpleAuthenticationInfo(user, user.getPwd(), \"\");\r\n    }\r\n```\r\n\r\n\r\n\r\n\r\n\r\n#### index.html\r\n\r\n* 分权限显示： shiro:hasPermission=\"user:add\"\r\n\r\n```html\r\n<!DOCTYPE html>\r\n<html lang=\"en\" xmlns:th=\"http://www.thymeleaf.org\"\r\n    xmlns:shiro=\"http://www.thymeleaf.org/thymeleaf-extras-shiro\">\r\n<head>\r\n    <meta charset=\"UTF-8\">\r\n    <title>Title</title>\r\n</head>\r\n<body>\r\n    <h1>首页</h1>\r\n    <div th:if=\"${session.loginUser == null}\">\r\n        <a th:href=\"@{/toLogin}\">登录</a>\r\n    </div>\r\n    <p th:text=\"${msg}\"></p>\r\n<hr>\r\n    <div shiro:hasPermission=\"user:add\">\r\n        <a th:href=\"@{/user/add}\">add</a> <br>\r\n    </div>\r\n    <div shiro:hasPermission=\"user:update\">\r\n        <a th:href=\"@{/user/update}\">update</a>\r\n    </div>\r\n</body>\r\n</html>\r\n```\r\n\r\n\r\n\r\n\r\n\r\n#### 测试\r\n\r\n![image-20220528185149277](cloudDisk/markdown/springBoot笔记.assets/image-20220528185149277.png)\r\n\r\n首页：\r\n\r\n![image-20220528185018241](cloudDisk/markdown/springBoot笔记.assets/image-20220528185018241.png)\r\n\r\n\r\n\r\ntony登录：\r\n\r\n![image-20220528185030558](cloudDisk/markdown/springBoot笔记.assets/image-20220528185030558.png)\r\n\r\n登录后，只显示add：\r\n\r\n![image-20220528185044261](cloudDisk/markdown/springBoot笔记.assets/image-20220528185044261.png)\r\n\r\n\r\n\r\n若王五登录，只显示update：\r\n\r\n![image-20220528185113134](cloudDisk/markdown/springBoot笔记.assets/image-20220528185113134.png)\r\n\r\n\r\n\r\n\r\n\r\n# 十五、Swagger\r\n\r\n学习目标：\r\n\r\n* 了解swagger的作用和概念\r\n* 了解前后端分离\r\n* 在springboot中集成swaggerr\r\n\r\n## swagger简介\r\n\r\n前后端分离\r\n\r\nVue + springBoot\r\n\r\n后端时代：前端只用管理静态页面；html -> 后端。模板引擎 JSP -> 后端是主力\r\n\r\n\r\n\r\n前后端分离时代：\r\n\r\n* 后端：后端控制层，服务层，数据访问层 【后端团队】\r\n* 前端：前端控制层，视图层 【前端团队】\r\n  * 伪造后端数据，json。已经存在了，不需要后端，前端的工程依旧能跑起来\r\n* 前后端如何交互？ API\r\n* 前后端相对独立，松耦合\r\n* 前后端甚至可以部署到不同的服务器上\r\n\r\n\r\n\r\n产生一个问题：\r\n\r\n* 前后端集成联调，前端人员和后端人员无法做到 “及时协调，需要尽早解决”，最终导致问题集中爆发\r\n\r\n解决方案：\r\n\r\n* 首先制定schema【计划的提纲】，实时更新最新的API，降低集成风险；\r\n* 早先年：制定word计划文档；\r\n* 前后端分离：\r\n  * 前端测试后端接口：postman\r\n  * 后端提供接口，需要实时更新最新的消息及改动！\r\n\r\n\r\n\r\n## swagger\r\n\r\n* 号称世界上最流行的Api框架\r\n* Restful Api 文档在线生成工具 —》 API文档与API定义同步更新\r\n* 直接运行，可以在线测试API接口\r\n* 支持多种语言：Java，php\r\n\r\n\r\n\r\n官网\r\n\r\nhttps://swagger.io/\r\n\r\n\r\n\r\n在项目中使用Swagger需要 springbox\r\n\r\n* swagger2\r\n* ui\r\n\r\n\r\n\r\nspringBoot集成swagger\r\n\r\n1. 新建 springboot-web 项目\r\n\r\n2. 导入相关依赖\r\n\r\n   ```xml\r\n   <dependency>\r\n       <groupId>io.springfox</groupId>\r\n       <artifactId>springfox-swagger2</artifactId>\r\n       <version>3.0.0</version>\r\n   </dependency>\r\n   <dependency>\r\n       <groupId>io.springfox</groupId>\r\n       <artifactId>springfox-swagger-ui</artifactId>\r\n       <version>3.0.0</version>\r\n   </dependency>\r\n   ```\r\n\r\n3. 编写一个hello工程\r\n\r\n4. 配置Swagger -》 config\r\n\r\n   ```java\r\n   @Configuration\r\n   @EnableSwagger2 // 开启swagger2\r\n   public class SwaggerConfig {\r\n       \r\n   }\r\n   \r\n   ```\r\n\r\n5. 测试运行\r\n\r\n   http://localhost:8080/swagger-ui.html\r\n\r\n**遇到一个错误**\r\n\r\nFailed to start bean ‘documentationPluginsBootstrapper’; nested exception is java.lang.NullPointerException\r\n\r\nspringboot 集成Swagger2报错\r\n\r\n加入配置文件\r\n\r\n```yaml\r\nspring:\r\n  mvc:\r\n    pathmatch:\r\n      matching-strategy: ant_path_matcher\r\n\r\n```\r\n\r\n**这里使用的Swagger版本是`2.9.2`、springboot 版本是`2.6.4`**\r\n\r\n**发现是springboot版本太高，缺少swagger运行所需要的环境，具体缺少什么还没研究出来，所以只能回退到之前的版本**\r\n\r\n**把springboot回退到`2.5.6`就能正常启动**\r\n\r\n![在这里插入图片描述](cloudDisk/markdown/springBoot笔记.assets/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAQXrQvGF0,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center.png)\r\n\r\n这个界面是Swagger为我们提供的ui界面，我们可以在源码中找到它\r\n\r\n![在这里插入图片描述](cloudDisk/markdown/springBoot笔记.assets/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAQXrQvGF0,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center-16537564754102.png)\r\n\r\n\r\n\r\n## 配置 swagger API信息\r\n\r\n```java\r\n@Configuration\r\n@EnableSwagger2 // 开启swagger2\r\npublic class SwaggerConfig {\r\n\r\n    // 配置swagger的docket的bean实例\r\n    @Bean\r\n    public Docket docket(){\r\n        return new Docket(DocumentationType.SWAGGER_2)\r\n                .apiInfo(apiInfo());\r\n    }\r\n\r\n    // 配置swagger 信息 = apiInfo\r\n    private ApiInfo apiInfo(){\r\n        Contact contact = new Contact(\"tony\", \"https://www.bilibili.com/\", \"1605337475@qq.com\");\r\n        return new ApiInfo(\r\n                \"tony的swagger API 文档\"\r\n                , \"with great powder, comes great responsibility!\"\r\n                , \"1.0\"\r\n                , \"urn:tos\"\r\n                , contact\r\n                , \"Apache 2.0\"\r\n                , \"http://www.apache.org/licenses/LICENSE-2.0\"\r\n                , new ArrayList());\r\n    }\r\n\r\n\r\n}\r\n```\r\n\r\n![image-20220529005852081](cloudDisk/markdown/springBoot笔记.assets/image-20220529005852081.png)\r\n\r\n\r\n\r\n## swagger配置扫描接口\r\n\r\n### 1）配置扫描接口Docket.select()\r\n\r\n```java\r\n// 配置swagger的docket的bean实例\r\n@Bean\r\npublic Docket docket(){\r\n    return new Docket(DocumentationType.SWAGGER_2)\r\n            .apiInfo(apiInfo())\r\n            .select()\r\n            // RequestHandlerSelectors，配置扫描接口方式\r\n            // basePackage，指定扫描的包\r\n            // any(), 扫描全部\r\n            // none(), 不扫描\r\n            // withClassAnnotation，扫描类上注解，参数是一个注解的反射对象\r\n            // withMethodAnnotation，扫描方法上注解\r\n            .apis(RequestHandlerSelectors.basePackage(\"com.tony.controller\"))\r\n            // paths() // 过滤什么路径\r\n            .paths(PathSelectors.ant(\"/**\"))\r\n            .build();\r\n}\r\n```\r\n\r\n上面代码中.apis(RequestHandlerSelectors.basePackage(\"com.tony.controller\"))表示只扫描包com.tony.controller，所以当我们打开网址[Swagger UI](http://localhost:8080/swagger-ui.html)可以看到只有一个接口信息：\r\n\r\n![image-20220530005704599](cloudDisk/markdown/springBoot笔记.assets/image-20220530005704599.png)\r\n\r\n\r\n\r\n### 2）配置是否启动swagger\r\n\r\n```java\r\n//enable为是否启动swagger，如果为false,则swagger不能在浏览器中访问\r\n     @Bean\r\n     public Docket docket(){//该方法返回对象为Docket,并将该对象注入到Bean里面\r\n         return new Docket(DocumentationType.SWAGGER_2)\r\n                 .apiInfo(apiInfo())\r\n                 .enable(false)\r\n                 .select()\r\n    .apis(RequestHandlerSelectors.basePackage(\"com.example.swaggerdemo.controller\"))\r\n                 .build();\r\n     }\r\n```\r\n\r\n配置完成后，重新运行项目，然后重新浏览swagger的网址，会出现下图所示：\r\n\r\n![image-20220530005902289](cloudDisk/markdown/springBoot笔记.assets/image-20220530005902289.png)\r\n\r\n\r\n\r\n### 问题：我只希望我的swagger在生产环境中使用，在发布的时候不使用？\r\n\r\n- 判断是不是生产环境 flag=false\r\n- 注入enable(flag)\r\n\r\n进行多配置的方法:\r\n\r\n1.第一套环境：在resources下面新建生产环境文件application-dev.properties 并输入以下内容：\r\n\r\n```\r\nserver.port=8081\r\n```\r\n\r\n2.第二套环境，在resources下面新建生产环境文件application-pro.properties 并输入以下内容：\r\n\r\n```\r\nserver.port=8082\r\n```\r\n\r\n3.在文件SwaggerConfig中按如下设置：\r\n\r\n```java\r\n//配置了swagger的Docket的bean实例\r\n \r\n    @Bean\r\n    public Docket docket(Environment environment){//该方法返回对象为Docket,并将该对象注入到Bean里面\r\n \r\n        //设置要显示的swagger环境\r\n        Profiles profiles = Profiles.of(\"dev\",\"test\");\r\n \r\n        //获取项目的环境：\r\n        //通过environment.acceptsProfiles判断是否处在自己设定的环境中\r\n        //如果系统检测到当前环境为dev或者test则flag为true,否则为flase\r\n        boolean flag = environment.acceptsProfiles(profiles);\r\n \r\n \r\n        return new Docket(DocumentationType.SWAGGER_2)\r\n                .apiInfo(apiInfo())\r\n                .enable(flag)\r\n                .select()\r\n                .apis(RequestHandlerSelectors.basePackage(\"com.example.swaggerdemo.controller\"))\r\n                .build();\r\n    }\r\n```\r\n\r\n\r\n\r\n当配置为dev环境时：spring.profiles.active=dev，访问：http://localhost:8081/swagger-ui.html#/\r\n\r\n![image-20220530012200191](cloudDisk/markdown/springBoot笔记.assets/image-20220530012200191.png)\r\n\r\n\r\n\r\n当配置为pro环境时：spring.profiles.active=pro，访问：http://localhost:8082/swagger-ui.html#/\r\n\r\n![image-20220530012139979](cloudDisk/markdown/springBoot笔记.assets/image-20220530012139979.png)\r\n\r\n\r\n\r\n## 配置API文档的分组\r\n\r\n```java\r\n.groupName(\"hello world\")\r\n```\r\n\r\n![image-20220530012420223](cloudDisk/markdown/springBoot笔记.assets/image-20220530012420223.png)\r\n\r\n### 配置多个分组\r\n\r\n```java\r\n@Configuration\r\n@EnableSwagger2 // 开启swagger2\r\npublic class SwaggerConfig {\r\n    @Bean\r\n    public Docket docket1(){\r\n        return new Docket(DocumentationType.SWAGGER_2).groupName(\"A\");\r\n    }\r\n\r\n    @Bean\r\n    public Docket docket2(){\r\n        return new Docket(DocumentationType.SWAGGER_2).groupName(\"B\");\r\n    }\r\n\r\n    @Bean\r\n    public Docket docket3(){\r\n        return new Docket(DocumentationType.SWAGGER_2).groupName(\"C\");\r\n    }\r\n\r\n    // 配置swagger的docket的bean实例\r\n    @Bean\r\n    public Docket docket(Environment environment){\r\n        // 设置要显示的swagger环境\r\n        Profiles profiles = Profiles.of(\"dev\", \"test\");\r\n\r\n        // 获取项目环境：acceptsProfiles判断是否存在在设定中的环境内\r\n        boolean flag = environment.acceptsProfiles(profiles);\r\n\r\n        return new Docket(DocumentationType.SWAGGER_2)\r\n                .apiInfo(apiInfo())\r\n                .groupName(\"hello world\")\r\n                .enable(flag)\r\n                .select()\r\n                // RequestHandlerSelectors，配置扫描接口方式\r\n                // basePackage，指定扫描的包\r\n                // any(), 扫描全部\r\n                // none(), 不扫描\r\n                // withClassAnnotation，扫描类上注解，参数是一个注解的反射对象\r\n                // withMethodAnnotation，扫描方法上注解\r\n                .apis(RequestHandlerSelectors.basePackage(\"com.tony.controller\"))\r\n                // paths() // 过滤什么路径\r\n//                .paths(PathSelectors.ant(\"/**\"))\r\n                .build();\r\n    }\r\n```\r\n\r\n![image-20220530012630670](cloudDisk/markdown/springBoot笔记.assets/image-20220530012630670.png)\r\n\r\n为何分组？每个组对应一个包\r\n\r\n\r\n\r\n## 接口注释\r\n\r\n定义User类\r\n\r\n```java\r\n// @Api(\"注释\")\r\n@ApiModel(\"用户实体类\")\r\npublic class User {\r\n\r\n    @ApiModelProperty(\"用户名\")\r\n    public String name;\r\n    @ApiModelProperty(\"密码\")\r\n    public String password;\r\n\r\n}\r\n\r\n```\r\n\r\nHelloController\r\n\r\n```java\r\n@RestController\r\npublic class HelloController {\r\n\r\n    @GetMapping(\"/hello\")\r\n    public String hello(){\r\n        return \"hello\";\r\n    }\r\n\r\n    // 只要我们的接口中，返回值存在实体类，它就会被扫描到swagger中\r\n    @GetMapping(\"/user\")\r\n    public User user(){\r\n        return new User();\r\n    }\r\n\r\n    // Operation放方法上\r\n    @ApiOperation(\"hello控制类\")\r\n    @GetMapping(\"/hello2\")\r\n    public String hello(@ApiParam(\"用户名\") String username){\r\n        return \"hello\" + username;\r\n    }\r\n}\r\n```\r\n\r\n![image-20220530014204495](cloudDisk/markdown/springBoot笔记.assets/image-20220530014204495.png)\r\n\r\n![image-20220530014304116](cloudDisk/markdown/springBoot笔记.assets/image-20220530014304116.png)\r\n\r\n\r\n\r\n## 测试接口\r\n\r\nUser\r\n\r\n```java\r\n// @Api(\"注释\")\r\n@ApiModel(\"用户实体类\")\r\n@Data\r\n@AllArgsConstructor\r\n@NoArgsConstructor\r\npublic class User {\r\n\r\n    @ApiModelProperty(\"用户名\")\r\n    public String name;\r\n    @ApiModelProperty(\"密码\")\r\n    public String password;\r\n\r\n}\r\n```\r\n\r\nController\r\n\r\n```java\r\n    @ApiOperation(\"post测试\")\r\n    @PostMapping(\"/post\")\r\n    public User hello(@ApiParam(\"用户名\") User user){\r\n        return user;\r\n    }\r\n```\r\n\r\n![image-20220530015147023](cloudDisk/markdown/springBoot笔记.assets/image-20220530015147023.png)\r\n\r\n## 总结\r\n\r\n1. 我们可以通过swagger给一些比较难理解的属性或者接口，增加注释信息\r\n2. 接口文档实时更新\r\n3. 可以在线测试\r\n\r\nswagger是个优秀的框架，几乎所有大公司都有使用\r\n\r\n【注意】在正式发布的时候，关闭swagger！！！处于安全考虑，而且节省内存\r\n\r\n\r\n\r\n# 十六、任务\r\n\r\n1. 异步任务\r\n\r\n2. 定时任务\r\n\r\n3. 邮件发送\r\n\r\n## 异步任务\r\n\r\n### 1、创建一个service包\r\n\r\n### 2、创建一个类AsyncService\r\n\r\n异步处理还是非常常用的，比如我们在网站上发送邮件，后台会去发送邮件，此时前台会造成响应不动，直到邮件发送完毕，响应才会成功，所以我们一般会采用多线程的方式去处理这些任务。\r\n\r\n编写方法，假装正在处理数据，使用线程设置一些延时，模拟同步等待的情况；\r\n\r\n```java\r\n@Service\r\npublic class AsyncService {\r\n \r\n    public void hello(){\r\n        try {\r\n            Thread.sleep(3000);\r\n        } catch (InterruptedException e) {\r\n            e.printStackTrace();\r\n        }\r\n        System.out.println(\"业务进行中....\");\r\n    }\r\n}\r\n```\r\n\r\n### 3、编写controller包\r\n\r\n### 4、编写AsyncController类\r\n\r\n我们去写一个Controller测试一下\r\n\r\n```java\r\n@RestController\r\npublic class AsyncController {\r\n \r\n    @Autowired\r\n    AsyncService asyncService;\r\n \r\n    @GetMapping(\"/hello\")\r\n    public String hello(){\r\n        asyncService.hello();\r\n        return \"success\";\r\n    }\r\n \r\n}\r\n```\r\n\r\n### 5、访问http://localhost:8080/hello进行测试，3秒后出现success，这是同步等待的情况。\r\n\r\n问题：我们如果想让用户直接得到消息，就在后台使用多线程的方式进行处理即可，但是每次都需要自己手动去编写多线程的实现的话，太麻烦了，我们只需要用一个简单的办法，在我们的方法上加一个简单的注解即可，如下：\r\n\r\n### 6、给hello方法添加@Async注解；\r\n\r\n```java\r\n//告诉Spring这是一个异步方法\r\n@Async\r\npublic void hello(){\r\n    try {\r\n        Thread.sleep(3000);\r\n    } catch (InterruptedException e) {\r\n        e.printStackTrace();\r\n    }\r\n    System.out.println(\"业务进行中....\");\r\n}\r\n```\r\n\r\nSpringBoot就会自己开一个线程池，进行调用！但是要让这个注解生效，我们还需要在主程序上添加一个注解@EnableAsync ，开启异步注解功能；\r\n\r\n```java\r\n@EnableAsync //开启异步注解功能\r\n@SpringBootApplication\r\npublic class SpringbootTaskApplication {\r\n \r\n    public static void main(String[] args) {\r\n        SpringApplication.run(SpringbootTaskApplication.class, args);\r\n    }\r\n \r\n}\r\n```\r\n\r\n### 7、重启测试，网页瞬间响应，后台代码依旧执行！\r\n\r\n\r\n\r\n\r\n\r\n## 邮件发送\r\n\r\n邮件发送，在我们的日常开发中，也非常的多，Springboot也帮我们做了支持\r\n\r\n- 邮件发送需要引入spring-boot-start-mail\r\n- SpringBoot 自动配置MailSenderAutoConfiguration\r\n- 定义MailProperties内容，配置在application.yml中\r\n- 自动装配JavaMailSender\r\n- 测试邮件发送\r\n\r\n### **测试：**\r\n\r\n#### 1、引入pom依赖\r\n\r\n```xml\r\n<dependency>\r\n    <groupId>org.springframework.boot</groupId>\r\n    <artifactId>spring-boot-starter-mail</artifactId>\r\n</dependency>\r\n```\r\n\r\n看它引入的依赖，可以看到 jakarta.mail\r\n\r\n```xml\r\n<dependency>\r\n    <groupId>com.sun.mail</groupId>\r\n    <artifactId>jakarta.mail</artifactId>\r\n    <version>1.6.4</version>\r\n    <scope>compile</scope>\r\n</dependency>\r\n```\r\n\r\n#### 2、查看自动配置类：MailSenderAutoConfiguration\r\n\r\n\r\n\r\n![img](cloudDisk/markdown/springBoot笔记.assets/format,png.png)\r\n\r\n\r\n\r\n这个类中存在bean，JavaMailSenderImpl\r\n\r\n![img](cloudDisk/markdown/springBoot笔记.assets/format,png-16538846489722.png)\r\n\r\n然后我们去看下配置文件\r\n\r\n```java\r\n@ConfigurationProperties(\r\n    prefix = \"spring.mail\"\r\n)\r\npublic class MailProperties {\r\n    private static final Charset DEFAULT_CHARSET;\r\n    private String host;\r\n    private Integer port;\r\n    private String username;\r\n    private String password;\r\n    private String protocol = \"smtp\";\r\n    private Charset defaultEncoding;\r\n    private Map<String, String> properties;\r\n    private String jndiName;\r\n}\r\n```\r\n\r\n#### 3、配置文件：\r\n\r\n```properties\r\nspring.mail.username=1605337475@qq.com\r\nspring.mail.password=dfonedysuodlhigc\r\nspring.mail.host=smtp.qq.com\r\n# 开启加密验证\r\nspring.mail.properties.mail.smtl.ssl.enable=true\r\n```\r\n\r\n获取授权码：在QQ邮箱中的设置->账户->开启pop3和smtp服务\r\n\r\n![img](cloudDisk/markdown/springBoot笔记.assets/format,png-16538846963514.png)\r\n\r\n#### 4、Spring单元测试\r\n\r\n```java\r\n@SpringBootTest\r\nclass DemoApplicationTests {\r\n\r\n    @Autowired\r\n    JavaMailSenderImpl mailSender;\r\n\r\n    @Test\r\n    void contextLoads() {\r\n        // 一个简单的邮件\r\n        SimpleMailMessage simpleMailMessage = new SimpleMailMessage();\r\n        simpleMailMessage.setSubject(\"你好！\");\r\n        simpleMailMessage.setText(\"hello world\");\r\n\r\n        simpleMailMessage.setTo(\"1605337475@qq.com\");\r\n        simpleMailMessage.setFrom(\"1605337475@qq.com\");\r\n\r\n        mailSender.send(simpleMailMessage);\r\n    }\r\n\r\n    @Test\r\n    void contextLoads2() throws MessagingException {\r\n        // 一个复杂的邮件\r\n        MimeMessage mimeMessage = mailSender.createMimeMessage();\r\n        // 组装\r\n        MimeMessageHelper mimeMessageHelper = new MimeMessageHelper(mimeMessage, true); // 多文件 multipart：true\r\n        mimeMessageHelper.setSubject(\"你好\");\r\n        mimeMessageHelper.setText(\"<p style=\'color:red\'>hello tony</p>\", true);\r\n\r\n        // 附件\r\n        mimeMessageHelper.addAttachment(\"1.jpg\", new File(\"C:\\\\Users\\\\Tony\\\\Pictures\\\\Saved Pictures\\\\avatar.jpg\"));\r\n        mimeMessageHelper.addAttachment(\"2.jpg\", new File(\"C:\\\\Users\\\\Tony\\\\Pictures\\\\Saved Pictures\\\\threeBodyLunbotu3.jpg\"));\r\n\r\n        mimeMessageHelper.setTo(\"1605337475@qq.com\");\r\n        mimeMessageHelper.setFrom(\"1605337475@qq.com\");\r\n\r\n        mailSender.send(mimeMessage);\r\n    }\r\n\r\n\r\n}\r\n```\r\n\r\n\r\n\r\n查看邮箱，邮件接收成功！\r\n\r\n![image-20220530122613725](cloudDisk/markdown/springBoot笔记.assets/image-20220530122613725.png)\r\n\r\n![image-20220530122554632](cloudDisk/markdown/springBoot笔记.assets/image-20220530122554632.png)\r\n\r\n\r\n\r\n\r\n\r\n## 定时任务\r\n\r\n项目开发中经常需要执行一些定时任务，比如需要在每天凌晨的时候，分析一次前一天的日志信息，Spring为我们提供了异步执行任务调度的方式，提供了两个接口。\r\n\r\n- TaskExecutor接口\r\n- TaskScheduler接口\r\n\r\n两个注解：\r\n\r\n- @EnableScheduling // 开启定时任务的注解\r\n- @Scheduled \r\n\r\n**cron表达式：**\r\n\r\n![img](cloudDisk/markdown/springBoot笔记.assets/format,png-16538858739456.png)\r\n\r\n![img](cloudDisk/markdown/springBoot笔记.assets/format,png-16538858793188.png)\r\n\r\n### **测试步骤：**\r\n\r\n#### 1、创建一个ScheduledService\r\n\r\n\r\n\r\n* @Scheduled(cron = \"0 41 12 * * ?\") // 12点41分执行hello代码\r\n\r\n![image-20220530124116534](cloudDisk/markdown/springBoot笔记.assets/image-20220530124116534.png)\r\n\r\n\r\n\r\n#### 2、这里写完定时任务之后，我们需要在主程序上增加@EnableScheduling 开启定时任务功能\r\n\r\n```java\r\n@EnableAsync //开启异步注解功能\r\n@EnableScheduling //开启基于注解的定时任务\r\n@SpringBootApplication\r\npublic class SpringbootTaskApplication {\r\n \r\n    public static void main(String[] args) {\r\n        SpringApplication.run(SpringbootTaskApplication.class, args);\r\n    }\r\n \r\n}\r\n```\r\n\r\n\r\n\r\n#### 3、我们来详细了解下cron表达式；\r\n\r\nhttp://www.bejson.com/othertools/cron/\r\n\r\n\r\n\r\n#### 4、常用的表达式\r\n\r\n```php\r\n（1）0/2 * * * * ?   表示每2秒 执行任务\r\n（1）0 0/2 * * * ?    表示每2分钟 执行任务\r\n（1）0 0 2 1 * ?   表示在每月的1日的凌晨2点调整任务\r\n（2）0 15 10 ? * MON-FRI   表示周一到周五每天上午10:15执行作业\r\n（3）0 15 10 ? 6L 2002-2006   表示2002-2006年的每个月的最后一个星期五上午10:15执行作\r\n（4）0 0 10,14,16 * * ?   每天上午10点，下午2点，4点\r\n（5）0 0/30 9-17 * * ?   朝九晚五工作时间内每半小时\r\n（6）0 0 12 ? * WED    表示每个星期三中午12点\r\n（7）0 0 12 * * ?   每天中午12点触发\r\n（8）0 15 10 ? * *    每天上午10:15触发\r\n（9）0 15 10 * * ?     每天上午10:15触发\r\n（10）0 15 10 * * ?    每天上午10:15触发\r\n（11）0 15 10 * * ? 2005    2005年的每天上午10:15触发\r\n（12）0 * 14 * * ?     在每天下午2点到下午2:59期间的每1分钟触发\r\n（13）0 0/5 14 * * ?    在每天下午2点到下午2:55期间的每5分钟触发\r\n（14）0 0/5 14,18 * * ?     在每天下午2点到2:55期间和下午6点到6:55期间的每5分钟触发\r\n（15）0 0-5 14 * * ?    在每天下午2点到下午2:05期间的每1分钟触发\r\n（16）0 10,44 14 ? 3 WED    每年三月的星期三的下午2:10和2:44触发\r\n（17）0 15 10 ? * MON-FRI    周一至周五的上午10:15触发\r\n（18）0 15 10 15 * ?    每月15日上午10:15触发\r\n（19）0 15 10 L * ?    每月最后一日的上午10:15触发\r\n（20）0 15 10 ? * 6L    每月的最后一个星期五上午10:15触发\r\n（21）0 15 10 ? * 6L 2002-2005   2002年至2005年的每月的最后一个星期五上午10:15触发\r\n（22）0 15 10 ? * 6#3   每月的第三个星期五上午10:15触发\r\n```\r\n\r\n\r\n\r\n# 十七、springboot 整合 redis\r\n\r\nspringboot 操作数据：spring-data jdbc mongodb redis\r\n\r\nspringData 也是和 springdata 齐名的项目\r\n\r\n说明：在springboot2.x之后，jedis替换为了lettuce？\r\n\r\njedis：采用的直连，多线程操作，是不安全的，如果想避免不安全的，使用 jedis pool 连接池！ BIO\r\n\r\nlettuce：采用netty，实例可以在多个线程间共享，不存在线程不安全的情况！可以减少线程数据，更像NIO\r\n\r\n源码分析：\r\n\r\n```java\r\n	@Bean\r\n	@ConditionalOnMissingBean(name = \"redisTemplate\") // 我们可以自己定义一个redisTemplate来替换默认的\r\n	@ConditionalOnSingleCandidate(RedisConnectionFactory.class)\r\n	public RedisTemplate<Object, Object> redisTemplate(RedisConnectionFactory redisConnectionFactory) {\r\n        // 默认的redisTemplate没有更多的设置，redis对象都是需要序列化的\r\n        // 两个泛型都是Object类型，后面使用都需要强制转换 <String, Object>\r\n		RedisTemplate<Object, Object> template = new RedisTemplate<>();\r\n		template.setConnectionFactory(redisConnectionFactory);\r\n		return template;\r\n	}\r\n\r\n	@Bean\r\n	@ConditionalOnMissingBean // 由于String是redis中最长使用的类型，所以单独提出来一个bean\r\n	@ConditionalOnSingleCandidate(RedisConnectionFactory.class)\r\n	public StringRedisTemplate stringRedisTemplate(RedisConnectionFactory redisConnectionFactory) {\r\n		StringRedisTemplate template = new StringRedisTemplate();\r\n		template.setConnectionFactory(redisConnectionFactory);\r\n		return template;\r\n	}\r\n```\r\n\r\n## 整合\r\n\r\n### 1、导入依赖\r\n\r\n```xml\r\n<dependency>\r\n    <groupId>org.springframework.boot</groupId>\r\n    <artifactId>spring-boot-starter-data-redis</artifactId>\r\n</dependency>\r\n```\r\n\r\n\r\n\r\n### 2、配置连接\r\n\r\n```properties\r\n# 配置redis\r\nspring.redis.host=127.0.0.1\r\nspring.redis.port=6379\r\n\r\n```\r\n\r\n\r\n\r\n### 3、编写测试类\r\n\r\n```java\r\n@SpringBootTest\r\nclass DemoApplicationTests {\r\n\r\n    @Autowired\r\n    private RedisTemplate redisTemplate;\r\n\r\n    @Test\r\n    void contextLoads() {\r\n        // redisTemplate 操作不同的数据类型，api和我们的指令是一样的\r\n        // opsForValue 操作字符串，类似String\r\n        // opsForList 操作List，类似List\r\n        // opsForSet\r\n        // opsForHash\r\n        // opsForZSet\r\n        // opsForGeo\r\n        // opsForHyperLogLog\r\n\r\n        // 除了基本操作，我们常用的方法都可以直接通过redisTemplate操作，比如事物，和基本的CRUD\r\n\r\n        // 获取redis连接对象\r\n//        RedisConnection connection = redisTemplate.getConnectionFactory().getConnection();\r\n//        connection.flushDb();\r\n//        connection.flushAll();\r\n\r\n        redisTemplate.opsForValue().set(\"myKey\", \"hello world\");\r\n        System.out.println(redisTemplate.opsForValue().get(\"myKey\"));\r\n    }\r\n\r\n}\r\n```\r\n\r\n### 4、打开redis服务器\r\n\r\n![image-20220530222322664](cloudDisk/markdown/springBoot笔记.assets/image-20220530222322664.png)\r\n\r\n\r\n\r\n### 5、运行\r\n\r\n![image-20220530222358102](cloudDisk/markdown/springBoot笔记.assets/image-20220530222358102.png)\r\n\r\n\r\n\r\n## 序列化\r\n\r\n![image-20220530222504652](cloudDisk/markdown/springBoot笔记.assets/image-20220530222504652.png)\r\n\r\n还是在RedisTemplate,\r\n默认的序列化方式：jdk序列化； 如果我们想要用json,就要去自定义配置类\r\n\r\n![在这里插入图片描述](cloudDisk/markdown/springBoot笔记.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81MjczMTMzNw==,size_16,color_FFFFFF,t_70.png)\r\n\r\n### 自定义配置类 RedisTemplate\r\n\r\n```java\r\n @Test\r\n    public void test() throws JsonProcessingException {\r\n        //真实的开发 一般都使用json来传递对象\r\n        User user = new User(\"狂神说\", 22);\r\n        //直接传递对象，会报为序列化的异常\r\n        //将一个对象转化为json字符串\r\n        String jsonUser = new ObjectMapper().writeValueAsString(user); //下面序列化之后，这里就不用了\r\n\r\n        redisTemplate.opsForValue().set(\"user\",jsonUser);\r\n        redisTemplate.opsForValue().get(\"user\");\r\n    }\r\n```\r\n\r\n```java\r\n@Component\r\n@AllArgsConstructor\r\n@NoArgsConstructor\r\n@Data\r\n//在企业中，我们所有的pojo类都会序列化\r\n//实现 Serializable 接口   实现序列化\r\npublic class User implements Serializable{\r\n    private String name;\r\n    private int age;\r\n}\r\n```\r\n\r\n此时我们使用的都是自带的JDK序列化，下面就可以自定义\r\n\r\n![在这里插入图片描述](cloudDisk/markdown/springBoot笔记.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81MjczMTMzNw==,size_16,color_FFFFFF,t_70-165392243116712.png)\r\n\r\n多种序列化方式选择\r\n\r\n![在这里插入图片描述](cloudDisk/markdown/springBoot笔记.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81MjczMTMzNw==,size_16,color_FFFFFF,t_70-165392243805114.png)\r\n\r\n//编写我们自己的RedisTemplate(未完成)\r\n\r\n```java\r\n  //编写我们自己的RedisTemplate(未完成)\r\n    @Bean\r\n    @ConditionalOnSingleCandidate(RedisConnectionFactory.class)\r\n    public RedisTemplate<String, Object> redisTemplate(RedisConnectionFactory redisConnectionFactory) {\r\n        RedisTemplate<String, Object> template = new RedisTemplate();\r\n        //使用json的话就要new json对象\r\n        Jackson2JsonRedisSerializer<Object> JsonSerializer = new Jackson2JsonRedisSerializer<Object>(Object.class);\r\n\r\n        //配置具体的序列化方式\r\n        template.setKeySerializer(JsonSerializer);\r\n\r\n        template.setConnectionFactory(redisConnectionFactory);\r\n        return template;\r\n    }\r\n```\r\n\r\n### 模板\r\n\r\n```java\r\npackage com.hardy.config;\r\n\r\nimport com.fasterxml.jackson.annotation.JsonAutoDetect;\r\nimport com.fasterxml.jackson.annotation.PropertyAccessor;\r\nimport com.fasterxml.jackson.databind.ObjectMapper;\r\nimport org.springframework.context.annotation.Bean;\r\nimport org.springframework.context.annotation.Configuration;\r\nimport org.springframework.data.redis.connection.RedisConnectionFactory;\r\nimport org.springframework.data.redis.core.RedisTemplate;\r\nimport org.springframework.data.redis.serializer.Jackson2JsonRedisSerializer;\r\nimport org.springframework.data.redis.serializer.StringRedisSerializer;\r\n\r\nimport java.net.UnknownHostException;\r\n\r\n@Configuration\r\n@SuppressWarnings(\"all\")\r\n//镇压所有警告\r\npublic class RedisConfig {\r\n    @Bean\r\n    public RedisTemplate<String, Object> redisTemplate(RedisConnectionFactory redisConnectionFactory)throws UnknownHostException {\r\n//我们为了自己开发方便，直接使用<String, Object>类型\r\n        RedisTemplate<String, Object> template = new RedisTemplate<>();\r\n//      默认的连接配置\r\n        template.setConnectionFactory(redisConnectionFactory);\r\n\r\n//        序列化配置\r\n//        new 一个Jackson序列化对象，用于后面的设置\r\n        Jackson2JsonRedisSerializer<Object> JsonSerializer = new Jackson2JsonRedisSerializer<>(Object.class);\r\n        ObjectMapper objectMapper = new ObjectMapper();\r\n//        使用ObjectMapper 进行转义\r\n        objectMapper.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);\r\n        objectMapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);\r\n		//转义完才能使用\r\n        JsonSerializer.setObjectMapper(objectMapper);\r\n\r\n//       创建string的序列化\r\n        StringRedisSerializer stringSerializer = new StringRedisSerializer();\r\n\r\n//       string的key和hash的key都采用string的序列化\r\n//        value都采用Jackson的序列化\r\n\r\n        //key采用string序列化方式\r\n        template.setKeySerializer(stringSerializer );\r\n        //hash的key采用string序列化方式\r\n        template.setHashKeySerializer(stringSerializer );\r\n        //value采用Jackson序列化方式\r\n        template.setValueSerializer(JsonSerializer );\r\n        //hash的value采用Jackson序列化方式\r\n        template.setHashValueSerializer(JsonSerializer );\r\n        \r\n        template.afterPropertiesSet();\r\n\r\n\r\n        return template;\r\n    }\r\n}\r\n```\r\n\r\n注意: 在测试类中，绑定不成功的情况下，可以使用Qualifier，命名绑定\r\n\r\n```java\r\n @Autowired\r\n    @Qualifier(\"redisTemplate\")// 底层的模板和自定义模板重复\r\n    private RedisTemplate redisTemplate;\r\n```\r\n\r\n\r\n\r\n## 自定义工具类 Redis-Utils\r\n\r\n```java\r\n@Component\r\npublic final class RedisUtil {\r\n\r\n    @Resource\r\n    private RedisTemplate<String, Object> redisTemplate;\r\n\r\n    // =============================common============================\r\n\r\n    /**\r\n     * 指定缓存失效时间\r\n     *\r\n     * @param key  键\r\n     * @param time 时间(秒)\r\n     */\r\n    public boolean expire(String key, long time, TimeUnit timeUnit) {\r\n        try {\r\n            if (time > 0) {\r\n                redisTemplate.expire(key, time, timeUnit);\r\n            }\r\n            return true;\r\n        } catch (Exception e) {\r\n            e.printStackTrace();\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * 根据key 获取过期时间\r\n     *\r\n     * @param key 键 不能为null\r\n     * @return 时间(秒) 返回0代表为永久有效\r\n     */\r\n    public long getExpire(String key) {\r\n        return redisTemplate.getExpire(key, TimeUnit.SECONDS);\r\n    }\r\n\r\n\r\n    /**\r\n     * 判断key是否存在\r\n     *\r\n     * @param key 键\r\n     * @return true 存在 false不存在\r\n     */\r\n    public boolean hasKey(String key) {\r\n        try {\r\n            return redisTemplate.hasKey(key);\r\n        } catch (Exception e) {\r\n            e.printStackTrace();\r\n            return false;\r\n        }\r\n    }\r\n\r\n\r\n    /**\r\n     * 删除缓存\r\n     *\r\n     * @param key 可以传一个值 或多个\r\n     */\r\n    @SuppressWarnings(\"unchecked\")\r\n    public void del(String... key) {\r\n        if (key != null && key.length > 0) {\r\n            if (key.length == 1) {\r\n                redisTemplate.delete(key[0]);\r\n            } else {\r\n                redisTemplate.delete((Collection<String>) CollectionUtils.arrayToList(key));\r\n            }\r\n        }\r\n    }\r\n\r\n\r\n    // ============================String=============================\r\n\r\n    /**\r\n     * 普通缓存获取\r\n     *\r\n     * @param key 键\r\n     * @return 值\r\n     */\r\n    public Object get(String key) {\r\n        return key == null ? null : redisTemplate.opsForValue().get(key);\r\n    }\r\n\r\n    /**\r\n     * 普通缓存放入\r\n     *\r\n     * @param key   键\r\n     * @param value 值\r\n     * @return true成功 false失败\r\n     */\r\n\r\n    public boolean set(String key, Object value) {\r\n        try {\r\n            redisTemplate.opsForValue().set(key, value);\r\n            return true;\r\n        } catch (Exception e) {\r\n            e.printStackTrace();\r\n            return false;\r\n        }\r\n    }\r\n\r\n\r\n    /**\r\n     * 普通缓存放入并设置时间\r\n     *\r\n     * @param key   键\r\n     * @param value 值\r\n     * @param time  时间(秒) time要大于0 如果time小于等于0 将设置无限期\r\n     * @return true成功 false 失败\r\n     */\r\n\r\n    public boolean set(String key, Object value, long time) {\r\n        try {\r\n            if (time > 0) {\r\n                redisTemplate.opsForValue().set(key, value, time, TimeUnit.SECONDS);\r\n            } else {\r\n                set(key, value);\r\n            }\r\n            return true;\r\n        } catch (Exception e) {\r\n            e.printStackTrace();\r\n            return false;\r\n        }\r\n    }\r\n\r\n\r\n    /**\r\n     * 递增\r\n     *\r\n     * @param key   键\r\n     * @param delta 要增加几(大于0)\r\n     */\r\n    public long incr(String key, long delta) {\r\n        if (delta < 0) {\r\n            throw new RuntimeException(\"递增因子必须大于0\");\r\n        }\r\n        return redisTemplate.opsForValue().increment(key, delta);\r\n    }\r\n\r\n\r\n    /**\r\n     * 递减\r\n     *\r\n     * @param key   键\r\n     * @param delta 要减少几(小于0)\r\n     */\r\n    public long decr(String key, long delta) {\r\n        if (delta < 0) {\r\n            throw new RuntimeException(\"递减因子必须大于0\");\r\n        }\r\n        return redisTemplate.opsForValue().increment(key, -delta);\r\n    }\r\n\r\n\r\n    // ================================Map=================================\r\n\r\n    /**\r\n     * HashGet\r\n     *\r\n     * @param key  键 不能为null\r\n     * @param item 项 不能为null\r\n     */\r\n    public Object hget(String key, String item) {\r\n        return redisTemplate.opsForHash().get(key, item);\r\n    }\r\n\r\n    /**\r\n     * 获取hashKey对应的所有键值\r\n     *\r\n     * @param key 键\r\n     * @return 对应的多个键值\r\n     */\r\n    public Map<Object, Object> hmget(String key) {\r\n        return redisTemplate.opsForHash().entries(key);\r\n    }\r\n\r\n    /**\r\n     * HashSet\r\n     *\r\n     * @param key 键\r\n     * @param map 对应多个键值\r\n     */\r\n    public boolean hmset(String key, Map<String, Object> map) {\r\n        try {\r\n            redisTemplate.opsForHash().putAll(key, map);\r\n            return true;\r\n        } catch (Exception e) {\r\n            e.printStackTrace();\r\n            return false;\r\n        }\r\n    }\r\n\r\n\r\n    /**\r\n     * HashSet 并设置时间\r\n     *\r\n     * @param key  键\r\n     * @param map  对应多个键值\r\n     * @param time 时间(秒)\r\n     * @return true成功 false失败\r\n     */\r\n    public boolean hmset(String key, Map<String, Object> map, long time, TimeUnit timeUnit) {\r\n        try {\r\n            redisTemplate.opsForHash().putAll(key, map);\r\n            if (time > 0) {\r\n                expire(key, time, timeUnit);\r\n            }\r\n            return true;\r\n        } catch (Exception e) {\r\n            e.printStackTrace();\r\n            return false;\r\n        }\r\n    }\r\n\r\n\r\n    /**\r\n     * 向一张hash表中放入数据,如果不存在将创建\r\n     *\r\n     * @param key   键\r\n     * @param item  项\r\n     * @param value 值\r\n     * @return true 成功 false失败\r\n     */\r\n    public boolean hset(String key, String item, Object value) {\r\n        try {\r\n            redisTemplate.opsForHash().put(key, item, value);\r\n            return true;\r\n        } catch (Exception e) {\r\n            e.printStackTrace();\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * 向一张hash表中放入数据,如果不存在将创建\r\n     *\r\n     * @param key   键\r\n     * @param item  项\r\n     * @param value 值\r\n     * @param time  时间(秒) 注意:如果已存在的hash表有时间,这里将会替换原有的时间\r\n     * @return true 成功 false失败\r\n     */\r\n    public boolean hset(String key, String item, Object value, long time, TimeUnit timeUnit) {\r\n        try {\r\n            redisTemplate.opsForHash().put(key, item, value);\r\n            if (time > 0) {\r\n                expire(key, time, timeUnit);\r\n            }\r\n            return true;\r\n        } catch (Exception e) {\r\n            e.printStackTrace();\r\n            return false;\r\n        }\r\n    }\r\n\r\n\r\n    /**\r\n     * 删除hash表中的值\r\n     *\r\n     * @param key  键 不能为null\r\n     * @param item 项 可以使多个 不能为null\r\n     */\r\n    public void hdel(String key, Object... item) {\r\n        redisTemplate.opsForHash().delete(key, item);\r\n    }\r\n\r\n\r\n    /**\r\n     * 判断hash表中是否有该项的值\r\n     *\r\n     * @param key  键 不能为null\r\n     * @param item 项 不能为null\r\n     * @return true 存在 false不存在\r\n     */\r\n    public boolean hHasKey(String key, String item) {\r\n        return redisTemplate.opsForHash().hasKey(key, item);\r\n    }\r\n\r\n\r\n    /**\r\n     * hash递增 如果不存在,就会创建一个 并把新增后的值返回\r\n     *\r\n     * @param key  键\r\n     * @param item 项\r\n     * @param by   要增加几(大于0)\r\n     */\r\n    public double hincr(String key, String item, double by) {\r\n        return redisTemplate.opsForHash().increment(key, item, by);\r\n    }\r\n\r\n\r\n    /**\r\n     * hash递减\r\n     *\r\n     * @param key  键\r\n     * @param item 项\r\n     * @param by   要减少记(小于0)\r\n     */\r\n    public double hdecr(String key, String item, double by) {\r\n        return redisTemplate.opsForHash().increment(key, item, -by);\r\n    }\r\n\r\n\r\n    // ============================set=============================\r\n\r\n    /**\r\n     * 根据key获取Set中的所有值\r\n     *\r\n     * @param key 键\r\n     */\r\n    public Set<Object> sGet(String key) {\r\n        try {\r\n            return redisTemplate.opsForSet().members(key);\r\n        } catch (Exception e) {\r\n            e.printStackTrace();\r\n            return null;\r\n        }\r\n    }\r\n\r\n\r\n    /**\r\n     * 根据value从一个set中查询,是否存在\r\n     *\r\n     * @param key   键\r\n     * @param value 值\r\n     * @return true 存在 false不存在\r\n     */\r\n    public boolean sHasKey(String key, Object value) {\r\n        try {\r\n            return redisTemplate.opsForSet().isMember(key, value);\r\n        } catch (Exception e) {\r\n            e.printStackTrace();\r\n            return false;\r\n        }\r\n    }\r\n\r\n\r\n    /**\r\n     * 将数据放入set缓存\r\n     *\r\n     * @param key    键\r\n     * @param values 值 可以是多个\r\n     * @return 成功个数\r\n     */\r\n    public long sSet(String key, Object... values) {\r\n        try {\r\n            return redisTemplate.opsForSet().add(key, values);\r\n        } catch (Exception e) {\r\n            e.printStackTrace();\r\n            return 0;\r\n        }\r\n    }\r\n\r\n\r\n    /**\r\n     * 将set数据放入缓存\r\n     *\r\n     * @param key    键\r\n     * @param time   时间(秒)\r\n     * @param values 值 可以是多个\r\n     * @return 成功个数\r\n     */\r\n    public long sSetAndTime(String key, long time, TimeUnit timeUnit, Object... values) {\r\n        try {\r\n            Long count = redisTemplate.opsForSet().add(key, values);\r\n            if (time > 0) {\r\n                expire(key, time, timeUnit);\r\n            }\r\n            return count;\r\n        } catch (Exception e) {\r\n            e.printStackTrace();\r\n            return 0;\r\n        }\r\n    }\r\n\r\n\r\n    /**\r\n     * 获取set缓存的长度\r\n     *\r\n     * @param key 键\r\n     */\r\n    public long sGetSetSize(String key) {\r\n        try {\r\n            return redisTemplate.opsForSet().size(key);\r\n        } catch (Exception e) {\r\n            e.printStackTrace();\r\n            return 0;\r\n        }\r\n    }\r\n\r\n\r\n    /**\r\n     * 移除值为value的\r\n     *\r\n     * @param key    键\r\n     * @param values 值 可以是多个\r\n     * @return 移除的个数\r\n     */\r\n\r\n    public long setRemove(String key, Object... values) {\r\n        try {\r\n            Long count = redisTemplate.opsForSet().remove(key, values);\r\n            return count;\r\n        } catch (Exception e) {\r\n            e.printStackTrace();\r\n            return 0;\r\n        }\r\n    }\r\n\r\n    // ===============================list=================================\r\n\r\n    /**\r\n     * 获取list缓存的内容\r\n     *\r\n     * @param key   键\r\n     * @param start 开始\r\n     * @param end   结束 0 到 -1代表所有值\r\n     */\r\n    public List<Object> lGet(String key, long start, long end) {\r\n        try {\r\n            return redisTemplate.opsForList().range(key, start, end);\r\n        } catch (Exception e) {\r\n            e.printStackTrace();\r\n            return null;\r\n        }\r\n    }\r\n\r\n\r\n    /**\r\n     * 获取list缓存的长度\r\n     *\r\n     * @param key 键\r\n     */\r\n    public long lGetListSize(String key) {\r\n        try {\r\n            return redisTemplate.opsForList().size(key);\r\n        } catch (Exception e) {\r\n            e.printStackTrace();\r\n            return 0;\r\n        }\r\n    }\r\n\r\n\r\n    /**\r\n     * 通过索引 获取list中的值\r\n     *\r\n     * @param key   键\r\n     * @param index 索引 index>=0时， 0 表头，1 第二个元素，依次类推；index<0时，-1，表尾，-2倒数第二个元素，依次类推\r\n     */\r\n    public Object lGetIndex(String key, long index) {\r\n        try {\r\n            return redisTemplate.opsForList().index(key, index);\r\n        } catch (Exception e) {\r\n            e.printStackTrace();\r\n            return null;\r\n        }\r\n    }\r\n\r\n\r\n    /**\r\n     * 将list放入缓存\r\n     *\r\n     * @param key   键\r\n     * @param value 值\r\n     */\r\n    public boolean lSet(String key, Object value) {\r\n        try {\r\n            redisTemplate.opsForList().rightPush(key, value);\r\n            return true;\r\n        } catch (Exception e) {\r\n            e.printStackTrace();\r\n            return false;\r\n        }\r\n    }\r\n\r\n\r\n    /**\r\n     * 将list放入缓存\r\n     *\r\n     * @param key   键\r\n     * @param value 值\r\n     * @param time  时间(秒)\r\n     */\r\n    public boolean lSet(String key, Object value, long time,TimeUnit timeUnit) {\r\n        try {\r\n            redisTemplate.opsForList().rightPush(key, value);\r\n            if (time > 0) {\r\n                expire(key, time,timeUnit);\r\n            }\r\n            return true;\r\n        } catch (Exception e) {\r\n            e.printStackTrace();\r\n            return false;\r\n        }\r\n\r\n    }\r\n\r\n\r\n    /**\r\n     * 将list放入缓存\r\n     *\r\n     * @param key   键\r\n     * @param value 值\r\n     * @return\r\n     */\r\n    public boolean lSet(String key, List<Object> value) {\r\n        try {\r\n            redisTemplate.opsForList().rightPushAll(key, value);\r\n            return true;\r\n        } catch (Exception e) {\r\n            e.printStackTrace();\r\n            return false;\r\n        }\r\n\r\n    }\r\n\r\n\r\n    /**\r\n     * 将list放入缓存\r\n     *\r\n     * @param key   键\r\n     * @param value 值\r\n     * @param time  时间(秒)\r\n     * @return\r\n     */\r\n    public boolean lSet(String key, List<Object> value, long time,TimeUnit timeUnit) {\r\n        try {\r\n            redisTemplate.opsForList().rightPushAll(key, value);\r\n            if (time > 0) {\r\n                expire(key, time,timeUnit);\r\n            }\r\n            return true;\r\n        } catch (Exception e) {\r\n            e.printStackTrace();\r\n            return false;\r\n        }\r\n    }\r\n\r\n\r\n    /**\r\n     * 根据索引修改list中的某条数据\r\n     *\r\n     * @param key   键\r\n     * @param index 索引\r\n     * @param value 值\r\n     * @return\r\n     */\r\n\r\n    public boolean lUpdateIndex(String key, long index, Object value) {\r\n        try {\r\n            redisTemplate.opsForList().set(key, index, value);\r\n            return true;\r\n        } catch (Exception e) {\r\n            e.printStackTrace();\r\n            return false;\r\n        }\r\n    }\r\n\r\n\r\n    /**\r\n     * 移除N个值为value\r\n     *\r\n     * @param key   键\r\n     * @param count 移除多少个\r\n     * @param value 值\r\n     * @return 移除的个数\r\n     */\r\n\r\n    public long lRemove(String key, long count, Object value) {\r\n        try {\r\n            Long remove = redisTemplate.opsForList().remove(key, count, value);\r\n            return remove;\r\n        } catch (Exception e) {\r\n            e.printStackTrace();\r\n            return 0;\r\n        }\r\n\r\n    }\r\n\r\n    // ===============================HyperLogLog=================================\r\n\r\n    public long pfadd(String key, String value) {\r\n        return redisTemplate.opsForHyperLogLog().add(key, value);\r\n    }\r\n\r\n    public long pfcount(String key) {\r\n        return redisTemplate.opsForHyperLogLog().size(key);\r\n    }\r\n\r\n    public void pfremove(String key) {\r\n        redisTemplate.opsForHyperLogLog().delete(key);\r\n    }\r\n\r\n    public void pfmerge(String key1, String key2) {\r\n        redisTemplate.opsForHyperLogLog().union(key1, key2);\r\n    }\r\n\r\n\r\n}\r\n```\r\n\r\n\r\n\r\n# 十八、分布式 Dubbo + Zookeeper + SpringBoot\r\n\r\n## 简介\r\n\r\n### 什么是[分布式系统](https://so.csdn.net/so/search?q=分布式系统&spm=1001.2101.3001.7020)\r\n\r\n分布式系统是由一组通过网络进行通信、为了完成共同的任务而协调工作的计算机节点组成的系统。分布式系统的出现是为了用廉价的、普通的机器完成单个计算机无法完成的计算、存储任务。其目的是**利用更多的机器，处理更多的数据**。\r\n\r\n**分布式系统是建立在网络之上的软件系统**\r\n\r\n\r\n\r\n![img](cloudDisk/markdown/springBoot笔记.assets/format,png-165392278088616.png)\r\n\r\n\r\n\r\n单一应用[架构](https://so.csdn.net/so/search?q=架构&spm=1001.2101.3001.7020)—>垂直应用架构----->分布式服务架构---->流动计算架构\r\n\r\n### RPC\r\n\r\nRPC【Remote Procedure Call】是指远程过程调用，是一种进程间通信方式，他是一种技术的思想，而不是规范。它允许程序调用另一个地址空间（通常是共享网络的另一台机器上）的过程或函数，而不用程序员显式编码这个远程调用的细节。即程序员无论是调用本地的还是远程的函数，本质上编写的调用代码基本相同。\r\n\r\n**RPC两个核心模块：通讯，序列化。**\r\n\r\n序列化：数据传输需要转化\r\n\r\n![img](cloudDisk/markdown/springBoot笔记.assets/format,png-165392507758620.png)\r\n\r\n### Dubbo\r\n\r\nApache Dubbo |ˈdʌbəʊ| 是一款高性能、轻量级的开源Java RPC框架，它提供了三大核心能力：面向接口的远程方法调用，智能容错和负载均衡，以及服务自动注册和发现。\r\n\r\n\r\n\r\n![img](cloudDisk/markdown/springBoot笔记.assets/format,png-165392418747918.png)\r\n\r\n\r\n\r\n**节点角色说明**\r\n\r\n| 节点        | 角色说明                               |\r\n| ----------- | -------------------------------------- |\r\n| `Provider`  | 暴露服务的服务提供方                   |\r\n| `Consumer`  | 调用远程服务的服务消费方               |\r\n| `Registry`  | 服务注册与发现的注册中心               |\r\n| `Monitor`   | 统计服务的调用次数和调用时间的监控中心 |\r\n| `Container` | 服务运行容器                           |\r\n\r\n\r\n\r\n**调用关系说明**\r\n\r\nl 服务容器负责启动，加载，运行服务提供者。\r\n\r\nl 服务提供者在启动时，向注册中心注册自己提供的服务。\r\n\r\nl 服务消费者在启动时，向注册中心订阅自己所需的服务。\r\n\r\nl 注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者。\r\n\r\nl 服务消费者，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选另一台调用。\r\n\r\nl 服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心。\r\n\r\n\r\n\r\n## Dubbo环境搭建\r\n\r\n点进dubbo官方文档，推荐我们使用[Zookeeper](https://so.csdn.net/so/search?q=Zookeeper&spm=1001.2101.3001.7020) 注册中心\r\n\r\n什么是zookeeper呢？可以查看官方文档\r\n\r\n### Window下安装zookeeper\r\n\r\nhttps://zookeeper.apache.org/releases.html\r\n\r\n#### 1、下载zookeeper ：地址， 我们下载3.4.14 ， 最新版！解压zookeeper\r\n\r\n#### 2、运行/bin/zkServer.cmd ，初次运行会报错，没有zoo.cfg配置文件；\r\n\r\n可能遇到问题：闪退 !\r\n\r\n解决方案：编辑zkServer.cmd文件末尾添加pause 。这样运行出错就不会退出，会提示错误信息，方便找到原因。\r\n\r\n![img](cloudDisk/markdown/springBoot笔记.assets/format,png-165392523799222.png)\r\n\r\n\r\n\r\n![img](cloudDisk/markdown/springBoot笔记.assets/format,png-165392525215124.png)\r\n\r\n\r\n\r\n#### 3、修改zoo.cfg配置文件\r\n\r\n将conf文件夹下面的zoo_sample.cfg复制一份改名为zoo.cfg即可。\r\n\r\n注意几个重要位置：\r\n\r\ndataDir=./  临时数据存储的目录（可写相对路径）\r\n\r\nclientPort=2181  zookeeper的端口号\r\n\r\n修改完成后再次启动zookeeper\r\n\r\n![img](cloudDisk/markdown/springBoot笔记.assets/format,png-165392525898526.png)\r\n\r\n\r\n\r\n#### 4、使用zkCli.cmd测试\r\n\r\nls /：列出zookeeper根下保存的所有节点\r\n\r\n![image-20220530235337334](cloudDisk/markdown/springBoot笔记.assets/image-20220530235337334.png)\r\n\r\ncreate –e /kuangshen 123：创建一个kuangshen节点，值为123\r\n\r\n![image-20220530235400642](cloudDisk/markdown/springBoot笔记.assets/image-20220530235400642.png)\r\n\r\nget /kuangshen：获取/kuangshen节点的值\r\n\r\n![image-20220530235434371](cloudDisk/markdown/springBoot笔记.assets/image-20220530235434371.png)\r\n\r\n我们再来查看一下节点\r\n\r\n![image-20220530235450953](cloudDisk/markdown/springBoot笔记.assets/image-20220530235450953.png)\r\n\r\n### window下安装dubbo-admin\r\n\r\ndubbo本身并不是一个服务软件。它其实就是一个jar包，能够帮你的java程序连接到zookeeper，并利用zookeeper消费、提供服务。\r\n\r\n但是为了让用户更好的管理监控众多的dubbo服务，官方提供了一个可视化的监控程序dubbo-admin，不过这个监控即使不装也不影响使用。\r\n\r\n我们这里来安装一下：\r\n\r\n#### **1、下载dubbo-admin**\r\n\r\n地址 ：https://github.com/apache/dubbo-admin/tree/master\r\n\r\n#### **2、解压进入目录**\r\n\r\n修改 dubbo-admin\\src\\main\\resources \\application.properties 指定zookeeper地址\r\n\r\n```properties\r\nserver.port=7001\r\nspring.velocity.cache=false\r\nspring.velocity.charset=UTF-8\r\nspring.velocity.layout-url=/templates/default.vm\r\nspring.messages.fallback-to-system-locale=false\r\nspring.messages.basename=i18n/message\r\nspring.root.password=root\r\nspring.guest.password=guest\r\ndubbo.registry.address=zookeeper://127.0.0.1:2181\r\n```\r\n\r\n\r\n\r\n#### **3、在项目目录下**打包dubbo-admin\r\n\r\n```\r\nmvn clean package -Dmaven.test.skip=true \r\n```\r\n\r\n**第一次打包的过程有点慢，需要耐心等待！直到成功！**\r\n\r\n![image-20220531000857345](cloudDisk/markdown/springBoot笔记.assets/image-20220531000857345.png)\r\n\r\n#### 4、执行 dubbo-admin\\target 下的dubbo-admin-0.0.1-SNAPSHOT.jar\r\n\r\n【注意：zookeeper的服务一定要打开！】\r\n\r\n执行完毕，我们去访问一下 http://localhost:7001/ ， 这时候我们需要输入登录账户和密码，我们都是默认的root-root；\r\n\r\n登录成功后，查看界面\r\n\r\n![img](cloudDisk/markdown/springBoot笔记.assets/format,png-165392746356334.png)\r\n\r\n安装完成！\r\n\r\n\r\n\r\n## 框架搭建\r\n\r\n****\r\n\r\n**1. 启动zookeeper ！**\r\n\r\n**2. IDEA创建一个空项目；**\r\n\r\n**3.创建一个模块，实现服务提供者：provider-server ， 选择web依赖即可**\r\n\r\n**4.项目创建完毕，我们写一个服务，比如卖票的服务；**\r\n\r\n### 编写接口\r\n\r\n```java\r\npublic interface TicketService {\r\n    public String getTicket();\r\n}\r\n```\r\n\r\n```java\r\npackage com.tony.providerserver.service;\r\n\r\npublic class TicketServiceImpl implements TicketService {\r\n    @Override\r\n    public String getTicket() {\r\n        return \"tony学Java\";\r\n    }\r\n}\r\n```\r\n\r\n**5.创建一个模块，实现服务消费者：consumer-server ， 选择web依赖即可**\r\n\r\n**6.项目创建完毕，我们写一个服务，比如用户的服务；**\r\n\r\n编写service\r\n\r\n```java\r\npublic interface UserService {\r\n}\r\n\r\n```\r\n\r\n## **需求：现在我们的用户想使用买票的服务，这要怎么弄呢 ？**\r\n\r\n### 服务提供者\r\n\r\n#### **1、依赖**\r\n\r\n**将服务提供者注册到注册中心，我们需要整合Dubbo和zookeeper，所以需要导包**\r\n\r\n**我们从dubbo官网进入github，看下方的帮助文档，找到dubbo-springboot，找到依赖包**\r\n\r\n```xml\r\n                <!--导入依赖：dubbo + zookeeper-->\r\n                <dependency>\r\n                    <groupId>org.apache.dubbo</groupId>\r\n                    <artifactId>dubbo-spring-boot-starter</artifactId>\r\n                    <version>2.7.3</version>\r\n                </dependency>\r\n                <!--zkclient-->\r\n                <dependency>\r\n                    <groupId>com.github.sgroschupf</groupId>\r\n                    <artifactId>zkclient</artifactId>\r\n                    <version>0.1</version>\r\n                </dependency>\r\n                <!--日志会冲突-->\r\n                <!--引入zookeeper-->\r\n                <!-- 引入zookeeper -->\r\n                <dependency>\r\n                    <groupId>org.apache.curator</groupId>\r\n                    <artifactId>curator-framework</artifactId>\r\n                    <version>2.12.0</version>\r\n                </dependency>\r\n                <dependency>\r\n                    <groupId>org.apache.curator</groupId>\r\n                    <artifactId>curator-recipes</artifactId>\r\n                    <version>2.12.0</version>\r\n                </dependency>\r\n                <dependency>\r\n                    <groupId>org.apache.zookeeper</groupId>\r\n                    <artifactId>zookeeper</artifactId>\r\n                    <version>3.4.14</version>\r\n                    <!--排除这个slf4j-log4j12-->\r\n                    <exclusions>\r\n                        <exclusion>\r\n                            <groupId>org.slf4j</groupId>\r\n                            <artifactId>slf4j-log4j12</artifactId>\r\n                        </exclusion>\r\n                    </exclusions>\r\n                </dependency>\r\n```\r\n\r\n#### **2、在springboot配置文件中配置dubbo相关属性！**\r\n\r\n```properties\r\nserver.port=8088\r\n#当前应用名字\r\ndubbo.application.name=provider-server\r\n#注册中心地址\r\ndubbo.registry.address=zookeeper://127.0.0.1:2181\r\n#扫描指定包下服务\r\ndubbo.scan.base-packages=com.tony.provider.service\r\n```\r\n\r\n#### **3、在service的实现类中配置服务注解，发布服务！注意导包问题**\r\n\r\n```java\r\npackage com.tony.provider.service;\r\nimport org.apache.dubbo.config.annotation.Service;\r\nimport org.springframework.stereotype.Component;\r\n\r\n@Service //将服务发布出去\r\n@Component //放在容器中\r\npublic class TicketServiceImpl implements TicketService {\r\n    @Override\r\n    public String getTicket() {\r\n        return \"tony学SpringBoot\";\r\n    }\r\n}\r\n```\r\n\r\n**逻辑理解 ：应用启动起来，dubbo就会扫描指定的包下带有@DubboService注解的服务，将它发布在指定的注册中心中！**\r\n\r\n### 服务消费者\r\n\r\n**1、导入依赖，和之前的依赖一样；**\r\n\r\n2、**配置参数**\r\n\r\n```java\r\n#当前应用名字\r\ndubbo.application.name=consumer-server\r\n#注册中心地址\r\ndubbo.registry.address=zookeeper://127.0.0.1:2181\r\n```\r\n\r\n**3. 本来正常步骤是需要将服务提供者的接口打包，然后用pom文件导入，我们这里使用简单的方式，直接将服务的接口拿过来，路径必须保证正确，即和服务提供者相同；**\r\n\r\n![image-20220531012155177](cloudDisk/markdown/springBoot笔记.assets/image-20220531012155177.png)\r\n\r\n\r\n\r\n**4. 完善消费者的服务类**\r\n\r\n```java\r\npackage com.tony.consumer.service;\r\n\r\nimport com.tony.provider.service.TicketService;\r\nimport org.apache.dubbo.config.annotation.Reference;\r\nimport org.springframework.stereotype.Service;\r\n\r\n@Service //注入到容器中\r\npublic class UserService {\r\n\r\n    @Reference //远程引用指定的服务，他会按照全类名进行匹配，看谁给注册中心注册了这个全类名\r\n            TicketService ticketService;\r\n\r\n    public void buyTicket(){\r\n        String ticket = ticketService.getTicket();\r\n        System.out.println(\"在注册中心买到\"+ticket);\r\n    }\r\n\r\n}\r\n```\r\n\r\n\r\n\r\n**5. 测试类编写；**\r\n\r\n```java\r\n    @Autowired\r\n    UserService userService;\r\n\r\n    @Test\r\n    void contextLoads() {\r\n        userService.buyTicket();\r\n    }\r\n```\r\n\r\n## 启动测试\r\n\r\n**1. 开启zookeeper**\r\n\r\n**2. 打开dubbo-admin实现监控【可以不用做】**\r\n\r\n**3. 开启服务者**\r\n\r\n**4. 消费者消费测试，结果：**\r\n\r\n![image-20220531132020872](cloudDisk/markdown/springBoot笔记.assets/image-20220531132020872.png)\r\n\r\n\r\n\r\n**监控中心 ：**\r\n\r\n\r\n\r\n![image-20220531132043836](cloudDisk/markdown/springBoot笔记.assets/image-20220531132043836.png)\r\n\r\n![image-20220531132129352](cloudDisk/markdown/springBoot笔记.assets/image-20220531132129352.png)\r\n\r\n**ok , 这就是SpingBoot + dubbo + zookeeper实现分布式开发的应用，其实就是一个服务拆分的思想；**\r\n\r\n\r\n\r\n\r\n\r\n# 附加：十九、日志配置\r\n\r\n## 1. resources/logback.xml\r\n\r\n```xml\r\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<configuration>\r\n\r\n    <!-- 格式化输出：%date表示日期，%thread表示线程名，%-5level：级别从左显示5个字符宽度 %msg：日志消息，%n是换行符-->\r\n    <property name=\"LOG_PATTERN\" value=\"%date{HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n\" />\r\n\r\n    <!-- 定义日志存储的路径，不要配置相对路径 -->\r\n    <property name=\"FILE_PATH\" value=\"D:/logs/springboot-demo03/demo.%d{yyyy-MM-dd}.%i.log\" />\r\n\r\n    <!-- 控制台输出日志 -->\r\n    <appender name=\"CONSOLE\" class=\"ch.qos.logback.core.ConsoleAppender\">\r\n        <encoder>\r\n            <!-- 按照上面配置的LOG_PATTERN来打印日志 -->\r\n            <pattern>${LOG_PATTERN}</pattern>\r\n        </encoder>\r\n    </appender>\r\n\r\n    <!--每天生成一个日志文件，保存15天的日志文件。rollingFile是用来切分文件的 -->\r\n    <appender name=\"FILE\"\r\n              class=\"ch.qos.logback.core.rolling.RollingFileAppender\">\r\n        <rollingPolicy class=\"ch.qos.logback.core.rolling.TimeBasedRollingPolicy\">\r\n            <fileNamePattern>${FILE_PATH}</fileNamePattern>\r\n            <!-- keep 15 days\' worth of history -->\r\n            <maxHistory>15</maxHistory>\r\n            <timeBasedFileNamingAndTriggeringPolicy class=\"ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP\">\r\n                <!-- 日志文件的最大大小 -->\r\n                <maxFileSize>10MB</maxFileSize>\r\n            </timeBasedFileNamingAndTriggeringPolicy>\r\n        </rollingPolicy>\r\n        <encoder>\r\n            <pattern>${LOG_PATTERN}</pattern>\r\n        </encoder>\r\n    </appender>\r\n    <!-- project default level -->\r\n    <logger name=\"com.tony.blog\" level=\"INFO\" />\r\n\r\n    <!-- 日志输出级别 -->\r\n    <root level=\"INFO\">\r\n        <appender-ref ref=\"CONSOLE\" />\r\n        <appender-ref ref=\"FILE\" />\r\n    </root>\r\n</configuration>\r\n```\r\n\r\n\r\n\r\n## 2. application.yaml\r\n\r\n```yaml\r\nlogging:\r\n  config: E:\\learning\\Java\\large-projects\\tony-blog\\src\\main\\resources\\logback.xml\r\n  level:\r\n    com.tony.blog: trace\r\n```\r\n\r\n\r\n\r\n## 3. controller\r\n\r\n```java\r\n@Controller\r\npublic class IndexController {\r\n    private static final Logger logger = LoggerFactory.getLogger(IndexController.class);\r\n    @RequestMapping(\"/home\")\r\n    public String index(){\r\n        logger.info(\"indexController\");\r\n        return \"/index\";\r\n    }\r\n}\r\n\r\n```\r\n\r\n\r\n\r\n# 附加：二十、读取/自定义application.yaml配置\r\n\r\n在Spring中使用@Value可以对单个属性进行注入配置，但如果有很多配置属性或者配置属性本身拥有层级结构时，Spring Boot提供了基于类型安全的配置方式。本文系统的带大家了解一下基于类型安全的属性配置。\r\n\r\n## @ConfigurationProperties\r\n\r\n通过@ConfigurationProperties将[properties](https://so.csdn.net/so/search?q=properties&spm=1001.2101.3001.7020)属性和一个Bean及其属性关联，从而实现类型安全配置。\r\n\r\n就像上面说的，如果在实践的过程中如果有很多配置，通过@Value逐一配置不仅麻烦，还不太符合[面向对象](https://so.csdn.net/so/search?q=面向对象&spm=1001.2101.3001.7020)的编程思想。根据不同情况，可适当的将对应的配置文件根据业务进行分组，集中管理。此时，基于类型安全的属性配置便发挥了作用。\r\n\r\n@ConfigurationProperties加载properties文件内的配置，通过prefix属性指定配置文件中定义的properties配置的统一前缀。\r\n\r\n```\r\n@ConfigurationProperties(prefix = \"remote\"}) \r\n```\r\n\r\n如果对应配置文件不是通过SpringBoot默认加载，Spring Boot1.5之前可通过locations指定properties文的位置，如下：\r\n\r\n```\r\n@ConfigurationProperties(prefix = \"remote\",locations={\"classpath:remote.properties\"}) \r\n```\r\n\r\n在随后版本逐渐废弃，原因很简单，Spring Boot认为将一个配置类绑定到一个配置文件不太合适。替代方案可以使用@PropertySource来指定自定义的资源目录。\r\n\r\n## 示例代码\r\n\r\n下面以具体的实例来演示一下如何使用@ConfigurationProperties。\r\n\r\nremote.properties配置文件中配置内容如下：\r\n\r\n```\r\nremote.address= www.choupangxia.com\r\nremote.port= 8080\r\n```\r\n\r\n对应实体类如下：\r\n\r\n```java\r\n@Component\r\n@PropertySource({\"classpath:remote.properties\"})\r\n@ConfigurationProperties(prefix = \"remote\")\r\npublic class RemoteConfig {\r\n    /**\r\n     * 远程服务地址\r\n     */\r\n    private String address;\r\n    /**\r\n     * 远程服务端口\r\n     */\r\n    private int port;\r\n    // getter/stetter方法\r\n}\r\n```\r\n\r\n对应RemoteConfig的Bean的使用：\r\n\r\n```java\r\n@RestController\r\npublic class ConfigurationController {\r\n    @Resource\r\n    private RemoteConfig remoteConfig;\r\n    @GetMapping\r\n    public void getInfo() {\r\n        System.out.println(\"地址：\" + remoteConfig.getAddress());\r\n        System.out.println(\"端口：\" + remoteConfig.getPort());\r\n    }\r\n}\r\n```\r\n\r\n单元测试方法内容：\r\n\r\n```java\r\n@SpringBootTest\r\n@AutoConfigureMockMvc\r\nclass ConfigurationControllerTest {\r\n    @Autowired\r\n    private MockMvc mockMvc;\r\n    @Test\r\n    void getInfo() throws Exception {\r\n        mockMvc.perform(MockMvcRequestBuilders.get(\"/\"));\r\n    }\r\n}\r\n```\r\n\r\n执行，单元测试，日志打印如下：\r\n\r\n```undefined\r\n地址：www.choupangxia.com\r\n端口：8080\r\n```\r\n\r\n\r\n\r\n说明配置文件中的配置已经完成注入。\r\n\r\n通过上述配置为RemoteConfig创建了一个常规的bean，不过Spring Boot建议@ConfigurationProperties只用来处理environment（只用于注入配置，系统环境之类的），不要注入上下文中的其他beans。\r\n\r\n## 第三方配置\r\n\r\n@ConfigurationProperties不仅可以注解在类上，也可以注解在public @Bean方法上，当需要为不受控的第三方组件绑定属性时，该方法将非常有用。\r\n\r\n配置文件中的属性定义没有区别，注解具体使用如下：\r\n\r\n```java\r\n@Configuration\r\npublic class MyConfig {\r\n    @Bean\r\n    @ConfigurationProperties(prefix = \"user\")\r\n    public User user() {\r\n        return new User();\r\n    }\r\n}\r\n```\r\n\r\n## 松散的绑定约束\r\n\r\nSpring Boot将Environment属性绑定到@ConfigurationProperties Bean时会使用一些宽松的规则，所以Environment属性名和Bean属性名不需要精确匹配。\r\n\r\n比如在对象User中有一个firstName属性，那么在配置文件中对应如下配置项均会匹配：\r\n\r\n```javascript\r\nuser.firstName // 标准驼峰命名语法\r\nuser.first-name // 短横线隔开表示，推荐用于.properties和.yml文件中\r\nuser.first_name // 下划线表示，用于.properties和.yml文件的可选格式\r\nUSER_FIRST_NAME // 大写形式，推荐用于系统环境变量\r\n```\r\n\r\n\r\n\r\n## @ConfigurationProperties校验\r\n\r\n当类上标注了@Validated注解，Spring Boot会尝试校验@ConfigurationProperties注解的类。可以在配置类中直接使用JSR-303 javax.validation约束标注。使用之前确保在类路径中存在适用的JSR-303实现：\r\n\r\n```kotlin\r\n@Component\r\n@PropertySource({\"classpath:remote.properties\"})\r\n@ConfigurationProperties(prefix = \"remote\")\r\n@Validated\r\npublic class RemoteConfig {\r\n    @NotNull\r\n    private String phone;\r\n    // getter/setter\r\n}\r\n```\r\n\r\n## 自定义yml文件支持\r\n\r\n上面我们提到如果配置文件未配置在默认的application文件内，则需要使用@PropertySource进行指定加载。但如果此时如果你使用的是yml格式的文件，会发现使用@PropertySource无法加载对应的文件。这是因为默认情况下@PropertySource并不支持yml文件的解析。\r\n\r\n因此，如果在项目中使用的是yml格式的自定义配置文件，可自定义PropertySourceFactory来进行支持。\r\n\r\n首先创建自定义YamlPropertyLoaderFactory：\r\n\r\n```java\r\npublic class YamlPropertyLoaderFactory extends DefaultPropertySourceFactory {\r\n    @Override\r\n    public PropertySource<?> createPropertySource(@Nullable String name, EncodedResource resource) throws IOException {\r\n        Properties propertiesFromYaml = loadYamlIntoProperties(resource);\r\n        String sourceName = name != null ? name : resource.getResource().getFilename();\r\n        return new PropertiesPropertySource(sourceName, propertiesFromYaml);\r\n    }\r\n    private Properties loadYamlIntoProperties(EncodedResource resource) throws FileNotFoundException {\r\n        try {\r\n            YamlPropertiesFactoryBean factory = new YamlPropertiesFactoryBean();\r\n            factory.setResources(resource.getResource());\r\n            factory.afterPropertiesSet();\r\n            return factory.getObject();\r\n        } catch (IllegalStateException e) {\r\n            Throwable cause = e.getCause();\r\n            if (cause instanceof FileNotFoundException) {\r\n                throw (FileNotFoundException) e.getCause();\r\n            }\r\n            throw e;\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n使用@PropertySource将其factory属性指定位上面自定义的YamlPropertyLoaderFactory即可正常加载。\r\n\r\n```\r\n@PropertySource(value = \"classpath:remote.yml\",factory = YamlPropertyLoaderFactory.class)\r\n```\r\n\r\n\r\n\r\n## 小结\r\n\r\n关于SpringBoot类型安全属性配置就讲解这么多，其中Bean中嵌套Bean，或Bean中嵌套Bean的校验等均可在此基础上进行拓展，基本使用方法都是一致的。\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n','2022-06-23 22:22:21','Spring Boot makes it easy to create stand-alone, production-grade Spring based Applications that you can \"just run\".\r\n\r\nWe take an opinionated view of the Spring platform and third-party libraries so yo','cloudDisk/markdown/springBoot笔记.assets/image-20220513172057061.png','原创','','','\0','Spring Boot学习笔记（下）','2022-06-23 22:22:21',7,102,NULL,0),(189,'','![](/cloudDisk/markdown/20220623223915_b96e6b4a_1655995155809.jpg)\r\n![](/cloudDisk/markdown/20220623223921_ca0e308a_1655995161200.jpg)\r\n![](/cloudDisk/markdown/20220623223925_0858b405_1655995165863.png)\r\n![](/cloudDisk/markdown/20220623223929_4550cf77_1655995169588.jpg)\r\n![](/cloudDisk/markdown/20220623223933_3a19ac27_1655995173001.jpg)\r\n![](/cloudDisk/markdown/20220623223937_41dfc51b_1655995177140.jpg)\r\n![](/cloudDisk/markdown/20220623223940_7ba3adae_1655995180495.jpg)\r\n![](/cloudDisk/markdown/20220623223946_dad522e4_1655995186018.jpg)\r\n![](/cloudDisk/markdown/20220623223953_f79e6c27_1655995193065.jpg)\r\n![](/cloudDisk/markdown/20220623223957_8065f9f3_1655995197439.jpg)\r\n![](/cloudDisk/markdown/20220623224013_e60f816e_1655995213836.jpg)\r\n![](/cloudDisk/markdown/20220623224017_95e4fd88_1655995217857.jpg)\r\n![](/cloudDisk/markdown/20220623224022_3af7a5e2_1655995222393.jpg)\r\n![](/cloudDisk/markdown/20220623224100_5a993e45_1655995260499.jpg)','2022-06-19 15:41:55','','/cloudDisk/markdown/20220623223921_ca0e308a_1655995161200.jpg','原创','','','\0','2022/6/19 时光荏苒，今天毕业了','2022-06-23 22:41:55',46,91,NULL,6),(190,'','![算法与数据结构_Page1.png](/cloudDisk/markdown/算法与数据结构/算法与数据结构_Page1.png)\r\n# 排序算法\r\n## 插入排序\r\n![算法与数据结构_Page2.png](/cloudDisk/markdown/算法与数据结构/算法与数据结构_Page2.png)\r\n## 选择排序\r\n![算法与数据结构_Page3.png](/cloudDisk/markdown/算法与数据结构/算法与数据结构_Page3.png)\r\n## 冒泡排序\r\n![算法与数据结构_Page4.png](/cloudDisk/markdown/算法与数据结构/算法与数据结构_Page4.png)\r\n## 认识N(logN)排序\r\n![算法与数据结构_Page5.png](/cloudDisk/markdown/算法与数据结构/算法与数据结构_Page5.png)\r\n## 归并排序\r\n![算法与数据结构_Page6.png](/cloudDisk/markdown/算法与数据结构/算法与数据结构_Page6.png)\r\n![算法与数据结构_Page7.png](/cloudDisk/markdown/算法与数据结构/算法与数据结构_Page7.png)\r\n![算法与数据结构_Page8.png](/cloudDisk/markdown/算法与数据结构/算法与数据结构_Page8.png)\r\n## 快速排序\r\n![算法与数据结构_Page9.png](/cloudDisk/markdown/算法与数据结构/算法与数据结构_Page9.png)\r\n![算法与数据结构_Page10.png](/cloudDisk/markdown/算法与数据结构/算法与数据结构_Page10.png)\r\n![算法与数据结构_Page11.png](/cloudDisk/markdown/算法与数据结构/算法与数据结构_Page11.png)\r\n## 桶排序（堆排序）\r\n![算法与数据结构_Page12.png](/cloudDisk/markdown/算法与数据结构/算法与数据结构_Page12.png)\r\n![算法与数据结构_Page13.png](/cloudDisk/markdown/算法与数据结构/算法与数据结构_Page13.png)\r\n![算法与数据结构_Page14.png](/cloudDisk/markdown/算法与数据结构/算法与数据结构_Page14.png)\r\n![算法与数据结构_Page15.png](/cloudDisk/markdown/算法与数据结构/算法与数据结构_Page15.png)\r\n## 词频统计排序\r\n![算法与数据结构_Page16.png](/cloudDisk/markdown/算法与数据结构/算法与数据结构_Page16.png)\r\n## 基数排序\r\n![算法与数据结构_Page17.png](/cloudDisk/markdown/算法与数据结构/算法与数据结构_Page17.png)\r\n![算法与数据结构_Page18.png](/cloudDisk/markdown/算法与数据结构/算法与数据结构_Page18.png)\r\n## 排序算法总结\r\n![算法与数据结构_Page19.png](/cloudDisk/markdown/算法与数据结构/算法与数据结构_Page19.png)\r\n# 链表、二叉树、图、前缀树\r\n## 链表\r\n![算法与数据结构_Page20.png](/cloudDisk/markdown/算法与数据结构/算法与数据结构_Page20.png)\r\n![算法与数据结构_Page21.png](/cloudDisk/markdown/算法与数据结构/算法与数据结构_Page21.png)\r\n![算法与数据结构_Page22.png](/cloudDisk/markdown/算法与数据结构/算法与数据结构_Page22.png)\r\n![算法与数据结构_Page23.png](/cloudDisk/markdown/算法与数据结构/算法与数据结构_Page23.png)\r\n![算法与数据结构_Page24.png](/cloudDisk/markdown/算法与数据结构/算法与数据结构_Page24.png)\r\n![算法与数据结构_Page25.png](/cloudDisk/markdown/算法与数据结构/算法与数据结构_Page25.png)\r\n![算法与数据结构_Page26.png](/cloudDisk/markdown/算法与数据结构/算法与数据结构_Page26.png)\r\n## 二叉树\r\n![算法与数据结构_Page27.png](/cloudDisk/markdown/算法与数据结构/算法与数据结构_Page27.png)\r\n![算法与数据结构_Page28.png](/cloudDisk/markdown/算法与数据结构/算法与数据结构_Page28.png)\r\n![算法与数据结构_Page29.png](/cloudDisk/markdown/算法与数据结构/算法与数据结构_Page29.png)\r\n![算法与数据结构_Page30.png](/cloudDisk/markdown/算法与数据结构/算法与数据结构_Page30.png)\r\n![算法与数据结构_Page31.png](/cloudDisk/markdown/算法与数据结构/算法与数据结构_Page31.png)\r\n![算法与数据结构_Page32.png](/cloudDisk/markdown/算法与数据结构/算法与数据结构_Page32.png)\r\n![算法与数据结构_Page33.png](/cloudDisk/markdown/算法与数据结构/算法与数据结构_Page33.png)\r\n![算法与数据结构_Page34.png](/cloudDisk/markdown/算法与数据结构/算法与数据结构_Page34.png)\r\n![算法与数据结构_Page35.png](/cloudDisk/markdown/算法与数据结构/算法与数据结构_Page35.png)\r\n![算法与数据结构_Page36.png](/cloudDisk/markdown/算法与数据结构/算法与数据结构_Page36.png)\r\n![算法与数据结构_Page37.png](/cloudDisk/markdown/算法与数据结构/算法与数据结构_Page37.png)\r\n![算法与数据结构_Page38.png](/cloudDisk/markdown/算法与数据结构/算法与数据结构_Page38.png)\r\n![算法与数据结构_Page39.png](/cloudDisk/markdown/算法与数据结构/算法与数据结构_Page39.png)\r\n## 图\r\n![算法与数据结构_Page40.png](/cloudDisk/markdown/算法与数据结构/算法与数据结构_Page40.png)\r\n## 图的宽度优先遍历\r\n![算法与数据结构_Page41.png](/cloudDisk/markdown/算法与数据结构/算法与数据结构_Page41.png)\r\n## 图的深度优先遍历\r\n![算法与数据结构_Page42.png](/cloudDisk/markdown/算法与数据结构/算法与数据结构_Page42.png)\r\n## 拓扑排序\r\n![算法与数据结构_Page43.png](/cloudDisk/markdown/算法与数据结构/算法与数据结构_Page43.png)\r\n## Kruskal算法（查找最小生成树）\r\n![算法与数据结构_Page44.png](/cloudDisk/markdown/算法与数据结构/算法与数据结构_Page44.png)\r\n## Prim算法\r\n![算法与数据结构_Page45.png](/cloudDisk/markdown/算法与数据结构/算法与数据结构_Page45.png)\r\n## Dijkstra（最短路径算法）\r\n![算法与数据结构_Page46.png](/cloudDisk/markdown/算法与数据结构/算法与数据结构_Page46.png)\r\n![算法与数据结构_Page47.png](/cloudDisk/markdown/算法与数据结构/算法与数据结构_Page47.png)\r\n## 前缀树\r\n![算法与数据结构_Page48.png](/cloudDisk/markdown/算法与数据结构/算法与数据结构_Page48.png)\r\n![算法与数据结构_Page49.png](/cloudDisk/markdown/算法与数据结构/算法与数据结构_Page49.png)\r\n# 基础算法\r\n## 贪心算法\r\n![算法与数据结构_Page50.png](/cloudDisk/markdown/算法与数据结构/算法与数据结构_Page50.png)\r\n![算法与数据结构_Page51.png](/cloudDisk/markdown/算法与数据结构/算法与数据结构_Page51.png)\r\n## 暴力递归\r\n![算法与数据结构_Page52.png](/cloudDisk/markdown/算法与数据结构/算法与数据结构_Page52.png)\r\n![算法与数据结构_Page53.png](/cloudDisk/markdown/算法与数据结构/算法与数据结构_Page53.png)\r\n## 哈希函数\r\n![算法与数据结构_Page54.png](/cloudDisk/markdown/算法与数据结构/算法与数据结构_Page54.png)\r\n## 布隆过滤器\r\n![算法与数据结构_Page55.png](/cloudDisk/markdown/算法与数据结构/算法与数据结构_Page55.png)\r\n## 并查集、有序表\r\n![算法与数据结构_Page56.png](/cloudDisk/markdown/算法与数据结构/算法与数据结构_Page56.png)\r\n## KMP\r\n![算法与数据结构_Page57.png](/cloudDisk/markdown/算法与数据结构/算法与数据结构_Page57.png)\r\n## Manacher算法、滑动窗口\r\n![算法与数据结构_Page58.png](/cloudDisk/markdown/算法与数据结构/算法与数据结构_Page58.png)\r\n## 单调栈\r\n![算法与数据结构_Page59.png](/cloudDisk/markdown/算法与数据结构/算法与数据结构_Page59.png)\r\n## 树形DP\r\n![算法与数据结构_Page60.png](/cloudDisk/markdown/算法与数据结构/算法与数据结构_Page60.png)\r\n## Morris遍历\r\n![算法与数据结构_Page61.png](/cloudDisk/markdown/算法与数据结构/算法与数据结构_Page61.png)\r\n## 大数据题\r\n![算法与数据结构_Page62.png](/cloudDisk/markdown/算法与数据结构/算法与数据结构_Page62.png)\r\n![算法与数据结构_Page63.png](/cloudDisk/markdown/算法与数据结构/算法与数据结构_Page63.png)\r\n![算法与数据结构_Page64.png](/cloudDisk/markdown/算法与数据结构/算法与数据结构_Page64.png)\r\n![算法与数据结构_Page65.png](/cloudDisk/markdown/算法与数据结构/算法与数据结构_Page65.png)\r\n## 动态规划、记忆化搜索\r\n![算法与数据结构_Page66.png](/cloudDisk/markdown/算法与数据结构/算法与数据结构_Page66.png)\r\n![算法与数据结构_Page67.png](/cloudDisk/markdown/算法与数据结构/算法与数据结构_Page67.png)\r\n![算法与数据结构_Page68.png](/cloudDisk/markdown/算法与数据结构/算法与数据结构_Page68.png)\r\n## 有序表\r\n![算法与数据结构_Page69.png](/cloudDisk/markdown/算法与数据结构/算法与数据结构_Page69.png)\r\n## 跳表\r\n![算法与数据结构_Page70.png](/cloudDisk/markdown/算法与数据结构/算法与数据结构_Page70.png)\r\n# 进阶算法\r\n## 简历准备\r\n![算法与数据结构_Page71.png](/cloudDisk/markdown/算法与数据结构/算法与数据结构_Page71.png)\r\n## 三个技巧\r\n![算法与数据结构_Page72.png](/cloudDisk/markdown/算法与数据结构/算法与数据结构_Page72.png)\r\n## 基础提升\r\n![算法与数据结构_Page73.png](/cloudDisk/markdown/算法与数据结构/算法与数据结构_Page73.png)\r\n![算法与数据结构_Page74.png](/cloudDisk/markdown/算法与数据结构/算法与数据结构_Page74.png)\r\n![算法与数据结构_Page75.png](/cloudDisk/markdown/算法与数据结构/算法与数据结构_Page75.png)\r\n![算法与数据结构_Page76.png](/cloudDisk/markdown/算法与数据结构/算法与数据结构_Page76.png)\r\n![算法与数据结构_Page77.png](/cloudDisk/markdown/算法与数据结构/算法与数据结构_Page77.png)\r\n![算法与数据结构_Page78.png](/cloudDisk/markdown/算法与数据结构/算法与数据结构_Page78.png)\r\n![算法与数据结构_Page79.png](/cloudDisk/markdown/算法与数据结构/算法与数据结构_Page79.png)\r\n![算法与数据结构_Page80.png](/cloudDisk/markdown/算法与数据结构/算法与数据结构_Page80.png)\r\n## 一个重要套路\r\n![算法与数据结构_Page81.png](/cloudDisk/markdown/算法与数据结构/算法与数据结构_Page81.png)\r\n## 基础提升2\r\n![算法与数据结构_Page82.png](/cloudDisk/markdown/算法与数据结构/算法与数据结构_Page82.png)\r\n![算法与数据结构_Page83.png](/cloudDisk/markdown/算法与数据结构/算法与数据结构_Page83.png)\r\n![算法与数据结构_Page84.png](/cloudDisk/markdown/算法与数据结构/算法与数据结构_Page84.png)\r\n![算法与数据结构_Page85.png](/cloudDisk/markdown/算法与数据结构/算法与数据结构_Page85.png)\r\n![算法与数据结构_Page86.png](/cloudDisk/markdown/算法与数据结构/算法与数据结构_Page86.png)\r\n![算法与数据结构_Page87.png](/cloudDisk/markdown/算法与数据结构/算法与数据结构_Page87.png)\r\n![算法与数据结构_Page88.png](/cloudDisk/markdown/算法与数据结构/算法与数据结构_Page88.png)\r\n![算法与数据结构_Page89.png](/cloudDisk/markdown/算法与数据结构/算法与数据结构_Page89.png)\r\n![算法与数据结构_Page90.png](/cloudDisk/markdown/算法与数据结构/算法与数据结构_Page90.png)\r\n![算法与数据结构_Page91.png](/cloudDisk/markdown/算法与数据结构/算法与数据结构_Page91.png)\r\n![算法与数据结构_Page92.png](/cloudDisk/markdown/算法与数据结构/算法与数据结构_Page92.png)\r\n![算法与数据结构_Page93.png](/cloudDisk/markdown/算法与数据结构/算法与数据结构_Page93.png)\r\n![算法与数据结构_Page94.png](/cloudDisk/markdown/算法与数据结构/算法与数据结构_Page94.png)\r\n![算法与数据结构_Page95.png](/cloudDisk/markdown/算法与数据结构/算法与数据结构_Page95.png)','2022-06-24 12:44:29','数据结构（英语：data structure）是计算机中存储、组织数据的方式。\r\n\r\n数据结构是一种具有一定逻辑关系，在计算机中应用某种存储结构，并且封装了相应操作的数据元素集合。它包含三方面的内容，逻辑关系、存储关系及操作。\r\n\r\n不同种类的数据结构适合于不同种类的应用，而部分甚至专门用于特定的作业任务。例如，计算机网络依赖于路由表运作，B 树高度适用于数据库的封装。','/cloudDisk/markdown/算法与数据结构/算法与数据结构_Page1.png','原创','','','\0','算法与数据结构笔记','2022-06-24 12:44:29',26,94,NULL,3),(191,'','按字典 wordList 完成从单词 beginWord 到单词 endWord 转化，一个表示此过程的 转换序列 是形式上像 beginWord -> s1 -> s2 -> ... -> sk 这样的单词序列，并满足：\r\n\r\n每对相邻的单词之间仅有单个字母不同。\r\n转换过程中的每个单词 si（1 <= i <= k）必须是字典 wordList 中的单词。注意，beginWord 不必是字典 wordList 中的单词。\r\nsk == endWord\r\n给你两个单词 beginWord 和 endWord ，以及一个字典 wordList 。请你找出并返回所有从 beginWord 到 endWord 的 最短转换序列 ，如果不存在这样的转换序列，返回一个空列表。每个序列都应该以单词列表 [beginWord, s1, s2, ..., sk] 的形式返回。\r\n\r\n\r\n\r\n来源：力扣（LeetCode）\r\n链接：https://leetcode.cn/problems/word-ladder-ii\r\n著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\r\n\r\n## 解法一、DFS回溯\r\n![](/cloudDisk/markdown/20220625152817_35b054f6_1656142097371.jpg)\r\n![](/cloudDisk/markdown/20220625152727_cd7b9059_1656142047016.png)\r\n```java\r\n    @Test\r\n    public void test(){\r\n        List<String> wordList = Arrays.asList(\"hot\", \"dot\", \"dog\", \"lot\", \"log\", \"cog\");\r\n        String beginWord = \"hit\", endWord = \"cog\";\r\n/*        List<String> wordList = Arrays.asList(\"hot\",\"dot\",\"dog\",\"lot\",\"log\");\r\n        String beginWord = \"hit\", endWord = \"cog\";*/\r\n        System.out.println(findLadders(beginWord, endWord, wordList));\r\n    }\r\n\r\n    int minLength = Integer.MAX_VALUE;\r\n\r\n    public List<List<String>> findLadders(String beginWord, String endWord, List<String> wordList) {\r\n        Map<String, List<Integer>> map = new HashMap<>();\r\n        for (int wordListIndex = 0; wordListIndex < wordList.size(); wordListIndex++) {\r\n            String s = wordList.get(wordListIndex);\r\n            for (int i = 0; i < s.length(); i++) {\r\n                StringBuilder word = new StringBuilder(s);\r\n                word.deleteCharAt(i);\r\n                String string = word.append(i).toString();\r\n                if (!map.containsKey(string)){\r\n                    map.put(string, new ArrayList<>());\r\n                }\r\n                List<Integer> integers = map.get(string);\r\n                integers.add(wordListIndex);\r\n            }\r\n        }\r\n//        System.out.println(map);\r\n        Set<Integer> excludeSet = new HashSet<>(); // 在这里面的索引，遍历wordList时不去访问\r\n        // 开始回溯\r\n        List<List<String>> res = new ArrayList<>();\r\n        ArrayDeque<String> curRes = new ArrayDeque<>();\r\n        curRes.addLast(beginWord);\r\n        dfs(beginWord, endWord, wordList, map, excludeSet, res, curRes);\r\n        return res;\r\n    }\r\n\r\n    private void dfs(String beginWord, String endWord, List<String> wordList\r\n            , Map<String, List<Integer>> map, Set<Integer> excludeSet\r\n            , List<List<String>> res, Deque<String> curRes) {\r\n        if (minLength < curRes.size()) return;\r\n        if (endWord.equals(beginWord)){\r\n            // 确实是一个合理步骤\r\n            if (curRes.size() < minLength){\r\n                res.clear();\r\n                res.add(new ArrayList<>(curRes));\r\n                minLength = curRes.size();\r\n            }else if (curRes.size() == minLength){\r\n                res.add(new ArrayList<>(curRes));\r\n            }\r\n            return;\r\n        }else if (excludeSet.size() == wordList.size()){\r\n            // 全部排除了，依旧没能找到\r\n            return;\r\n        }\r\n        // 判断beginWord去掉一个字符后，在不在map里\r\n        HashSet<Integer> exclude = new HashSet<>(); // 递归一层上排除\r\n        for (int i = 0; i < beginWord.length(); i++) {\r\n            StringBuilder sb = new StringBuilder(beginWord);\r\n            sb.deleteCharAt(i);\r\n            String word = sb.append(i).toString();\r\n            List<Integer> integers = map.get(word); // 这是所有只改变里一个字符的wordList的索引位置\r\n            if (integers == null) continue;\r\n            for (Integer index : integers) {\r\n                if (exclude.contains(index)) continue;\r\n                if (excludeSet.contains(index)) continue;\r\n                exclude.add(index);\r\n                // 回溯处理\r\n                excludeSet.add(index); // 当前不能在选了\r\n                curRes.addLast(wordList.get(index)); // 当前单词加入 curRes\r\n//                System.out.println(wordList.get(index) + \", \" + i);\r\n                dfs(wordList.get(index), endWord, wordList, map, excludeSet, res, curRes);\r\n                curRes.removeLast(); // 移除当前单词\r\n                excludeSet.remove(index);\r\n            }\r\n        }\r\n\r\n    }\r\n```\r\n由于深度优先遍历，坏情况会先去搜索递归深度最深的解法，最终导致超时。\r\n## （了解）解法二、 BFS\r\n如果理解了上边的 DFS 过程，接下来就很好讲了。上边 DFS 借助了 BFS 把所有的邻接关系保存了起来，再用 DFS 进行深度搜索。\r\n\r\n我们可不可以只用 BFS，一边进行层次遍历，一边就保存结果。当到达结束单词的时候，就把结果存储。省去再进行 DFS 的过程。\r\n\r\n是完全可以的，BFS 的队列就不去存储 String 了，直接去存到目前为止的路径，也就是一个 List。\r\n\r\n```java\r\npublic List<List<String>> findLadders(String beginWord, String endWord, List<String> wordList) {\r\n    List<List<String>> ans = new ArrayList<>();\r\n    // 如果不含有结束单词，直接结束，不然后边会造成死循环\r\n    if (!wordList.contains(endWord)) {\r\n        return ans;\r\n    }\r\n    bfs(beginWord, endWord, wordList, ans);\r\n    return ans;\r\n}\r\n\r\npublic void bfs(String beginWord, String endWord, List<String> wordList, List<List<String>> ans) {\r\n    Queue<List<String>> queue = new LinkedList<>();\r\n    List<String> path = new ArrayList<>();\r\n    path.add(beginWord);\r\n    queue.offer(path);\r\n    boolean isFound = false;\r\n    Set<String> dict = new HashSet<>(wordList);\r\n    Set<String> visited = new HashSet<>();\r\n    visited.add(beginWord);\r\n    while (!queue.isEmpty()) {\r\n        int size = queue.size();\r\n        Set<String> subVisited = new HashSet<>();\r\n        for (int j = 0; j < size; j++) {\r\n            List<String> p = queue.poll();\r\n            //得到当前路径的末尾单词\r\n            String temp = p.get(p.size() - 1);\r\n            // 一次性得到所有的下一个的节点\r\n            ArrayList<String> neighbors = getNeighbors(temp, dict);\r\n            for (String neighbor : neighbors) {\r\n                //只考虑之前没有出现过的单词\r\n                if (!visited.contains(neighbor)) {\r\n                    //到达结束单词\r\n                    if (neighbor.equals(endWord)) {\r\n                        isFound = true;\r\n                        p.add(neighbor);\r\n                        ans.add(new ArrayList<String>(p));\r\n                        p.remove(p.size() - 1);\r\n                    }\r\n                    //加入当前单词\r\n                    p.add(neighbor);\r\n                    queue.offer(new ArrayList<String>(p));\r\n                    p.remove(p.size() - 1);\r\n                    subVisited.add(neighbor);\r\n                }\r\n            }\r\n        }\r\n        visited.addAll(subVisited);\r\n        if (isFound) {\r\n            break;\r\n        }\r\n    }\r\n}\r\n\r\nprivate ArrayList<String> getNeighbors(String node, Set<String> dict) {\r\n    ArrayList<String> res = new ArrayList<String>();\r\n    char chs[] = node.toCharArray();\r\n    for (char ch = \'a\'; ch <= \'z\'; ch++) {\r\n        for (int i = 0; i < chs.length; i++) {\r\n            if (chs[i] == ch)\r\n                continue;\r\n            char old_ch = chs[i];\r\n            chs[i] = ch;\r\n            if (dict.contains(String.valueOf(chs))) {\r\n                res.add(String.valueOf(chs));\r\n            }\r\n            chs[i] = old_ch;\r\n        }\r\n\r\n    }\r\n    return res;\r\n}\r\n\r\n\r\n```\r\n','2022-06-25 15:35:08','按字典 wordList 完成从单词 beginWord 到单词 endWord 转化，一个表示此过程的 转换序列 是形式上像 beginWord -> s1 -> s2 -> … -> sk 这样的单词序列，并满足：\r\n\r\n每对相邻的单词之间仅有单个字母不同。\r\n转换过程中的每个单词 si（1 <= i <= k）必须是字典 wordList 中的单词。注意，beginWord 不必是字典 wordL','/cloudDisk/markdown/20220625152817_35b054f6_1656142097371.jpg','原创','','\0','\0','126. 单词接龙 II','2022-06-25 15:35:08',11,93,NULL,0),(192,'','字典 wordList 中从单词 beginWord 和 endWord 的 转换序列 是一个按下述规格形成的序列 beginWord -> s1 -> s2 -> ... -> sk：\r\n\r\n每一对相邻的单词只差一个字母。\r\n 对于 1 <= i <= k 时，每个 si 都在 wordList 中。注意， beginWord 不需要在 wordList 中。\r\nsk == endWord\r\n给你两个单词 beginWord 和 endWord 和一个字典 wordList ，返回 从 beginWord 到 endWord 的 最短转换序列 中的 单词数目 。如果不存在这样的转换序列，返回 0 。\r\n\r\n \r\n\r\n来源：力扣（LeetCode）\r\n链接：https://leetcode.cn/problems/word-ladder\r\n著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\r\n\r\n    示例 1：\r\n    \r\n    输入：beginWord = \"hit\", endWord = \"cog\", wordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\",\"cog\"]\r\n    输出：5\r\n    解释：一个最短转换序列是 \"hit\" -> \"hot\" -> \"dot\" -> \"dog\" -> \"cog\", 返回它的长度 5。\r\n\r\n## 分析题意：\r\n\r\n「转换」意即：两个单词对应位置只有一个字符不同，例如 \"hit\" 与 \"hot\"，这种转换是可以逆向的，因此，根据题目给出的单词列表，可以构建出一个无向（无权）图；\r\n\r\n![](/cloudDisk/markdown/20220626160419_6de5b034_1656230659037.png)\r\n如果一开始就构建图，每一个单词都需要和除它以外的另外的单词进行比较，复杂度是 O(N \\rm{wordLen})O(NwordLen)，这里 NN 是单词列表的长度；\r\n为此，我们在遍历一开始，把所有的单词列表放进一个哈希表中，然后在遍历的时候构建图，每一次得到在单词列表里可以转换的单词，复杂度是 O(26 \\times \\rm{wordLen})O(26×wordLen)，借助哈希表，找到邻居与 NN 无关；\r\n使用 BFS 进行遍历，需要的辅助数据结构是：\r\n队列；\r\nvisited 集合。说明：可以直接在 wordSet (由 wordList 放进集合中得到)里做删除。但更好的做法是新开一个哈希表，遍历过的字符串放进哈希表里。这种做法具有普遍意义。绝大多数在线测评系统和应用场景都不会在意空间开销。\r\n## 图的广度优先遍历\r\n![](/cloudDisk/markdown/20220626160905_2f1aa8f4_1656230945556.png)\r\n## 解法：广度优先遍历\r\n```java\r\n    public int ladderLength(String beginWord, String endWord, List<String> wordList) {\r\n        // 先将 wordList 放到哈希表里，便于判断某个单词是否在 wordList 里\r\n        Set<String> wordMap = new HashSet<>(wordList);\r\n        if (wordMap.size() == 0 || !wordMap.contains(endWord)) {\r\n            return 0;\r\n        }\r\n        wordMap.remove(beginWord);\r\n\r\n        // 图的广度优先遍历，必须使用队列和表示是否访问过的 visited 哈希表\r\n        Queue<String> queue = new LinkedList<>();\r\n        queue.offer(beginWord);\r\n        Set<String> visited = new HashSet<>();\r\n        visited.add(beginWord);\r\n\r\n        // 开始广度优先遍历，包含起点，因此初始化的时候步数为 1\r\n        int step = 1;\r\n        while (!queue.isEmpty()){\r\n            int size = queue.size();\r\n            for (int k = 0; k < size; k++) {\r\n                String curWord = queue.poll(); // 依次遍历当前队列中的单词\r\n\r\n                char[] word = curWord.toCharArray();\r\n                for (int i = 0; i < word.length; i++) {\r\n                    char c = word[i];\r\n                    for (int j = \'a\'; j <= \'z\'; j++) { // 枚举单词中每一个字母，进行替换\r\n                        if ((char) j == c) continue; // 枚举后 和 当前字母一样 continue\r\n                        word[i] = (char) j;\r\n                        String nextWord = new String(word); // 枚举后的单词\r\n                        if (wordMap.contains(nextWord)){ // 单词表中，存在这个单词\r\n                            if (nextWord.equals(endWord)){ // 如果下个单词就是要找的那个，直接返回\r\n                                return step + 1;\r\n                            }\r\n                            if (!visited.contains(nextWord)){ // 下个单词没被访问过\r\n                                queue.offer(nextWord); // 加入队列，下个循环去访问\r\n                                visited.add(nextWord); // 标记已访问\r\n                            }\r\n                        }\r\n                    }\r\n                    word[i] = c; // 复原原来的单词\r\n                }\r\n            }\r\n            step++;\r\n        }\r\n        return 0;\r\n    }\r\n```\r\n\r\n\r\n','2022-06-26 16:06:10','字典 wordList 中从单词 beginWord 和 endWord 的 转换序列 是一个按下述规格形成的序列 beginWord -> s1 -> s2 -> ... -> sk：\r\n\r\n每一对相邻的单词只差一个字母。\r\n 对于 1 <= i <= k 时，每个 si 都在 wordList 中。注意， beginWord 不需要在 wordList 中。\r\nsk == endWord\r\n给你两个单词','/cloudDisk/markdown/20220626160419_6de5b034_1656230659037.png','原创','','\0','\0','127. 单词接龙','2022-06-26 16:06:10',4,93,NULL,0),(193,'','给定一个未排序的整数数组 nums ，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。\r\n\r\n请你设计并实现时间复杂度为 O(n) 的算法解决此问题。\r\n\r\n \r\n\r\n来源：力扣（LeetCode）\r\n链接：https://leetcode.cn/problems/longest-consecutive-sequence\r\n著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\r\n\r\n示例 1：\r\n\r\n输入：nums = [100,4,200,1,3,2]\r\n输出：4\r\n解释：最长数字连续序列是 [1, 2, 3, 4]。它的长度为 4。\r\n\r\n## 解法一、DFS(推荐)\r\n```java\r\n    @Test\r\n    public void test(){\r\n        int[] nums = {100,4,200,1,3,2};\r\n        System.out.println(longestConsecutive(nums));\r\n    }\r\n\r\n    public int longestConsecutive(int[] nums) {\r\n        HashSet<Integer> hashSet = new HashSet<>(); // 哈希表去重\r\n        for (int i = 0; i < nums.length; i++) {\r\n            hashSet.add(nums[i]);\r\n        }\r\n        int res = 0;\r\n        for (int i = 0; i < nums.length; i++) {\r\n            if (!hashSet.contains(nums[i])) continue;\r\n            // 哈希表里需包含当前数字\r\n            res = Math.max(res, dfs(nums[i], hashSet)); // 取最大连续\r\n        }\r\n        return res;\r\n    }\r\n\r\n    /**\r\n     * 在哈希表里找，当前num左边及右边数字连续的个数\r\n     * @param num\r\n     * @param hashSet\r\n     * @return\r\n     */\r\n    private int dfs(Integer num, HashSet<Integer> hashSet) {\r\n        if (!hashSet.contains(num)){\r\n            return 0; //\r\n        }\r\n        hashSet.remove(num); // 找到过的要移除，否则会重复找导致栈溢出\r\n        return dfs(num - 1, hashSet) + dfs(num + 1, hashSet) + 1;\r\n    }\r\n```\r\n\r\n## 解法二、哈希表\r\n思路和算法\r\n\r\n我们考虑枚举数组中的每个数 xx，考虑以其为起点，不断尝试匹配 x+1, x+2, \\cdotsx+1,x+2,⋯ 是否存在，假设最长匹配到了 x+yx+y，那么以 xx 为起点的最长连续序列即为 x, x+1, x+2, \\cdots, x+yx,x+1,x+2,⋯,x+y，其长度为 y+1y+1，我们不断枚举并更新答案即可。\r\n\r\n对于匹配的过程，暴力的方法是 O(n)O(n) 遍历数组去看是否存在这个数，但其实更高效的方法是用一个哈希表存储数组中的数，这样查看一个数是否存在即能优化至 O(1)O(1) 的时间复杂度。\r\n\r\n仅仅是这样我们的算法时间复杂度最坏情况下还是会达到 O(n^2)O(n \r\n2\r\n )（即外层需要枚举 O(n)O(n) 个数，内层需要暴力匹配 O(n)O(n) 次），无法满足题目的要求。但仔细分析这个过程，我们会发现其中执行了很多不必要的枚举，如果已知有一个 x, x+1, x+2, \\cdots, x+yx,x+1,x+2,⋯,x+y 的连续序列，而我们却重新从 x+1x+1，x+2x+2 或者是 x+yx+y 处开始尝试匹配，那么得到的结果肯定不会优于枚举 xx 为起点的答案，因此我们在外层循环的时候碰到这种情况跳过即可。\r\n\r\n那么怎么判断是否跳过呢？由于我们要枚举的数 xx 一定是在数组中不存在前驱数 x-1x−1 的，不然按照上面的分析我们会从 x-1x−1 开始尝试匹配，因此我们每次在哈希表中检查是否存在 x-1x−1 即能判断是否需要跳过了。\r\n\r\n增加了判断跳过的逻辑之后，时间复杂度是多少呢？外层循环需要 O(n)O(n) 的时间复杂度，只有当一个数是连续序列的第一个数的情况下才会进入内层循环，然后在内层循环中匹配连续序列中的数，因此数组中的每个数只会进入内层循环一次。根据上述分析可知，总时间复杂度为 O(n)O(n)，符合题目要求。\r\n![](/cloudDisk/markdown/20220627130349_9ea24ab1_1656306229831.png)\r\n![](/cloudDisk/markdown/20220627130357_155238fc_1656306237427.png)\r\n![](/cloudDisk/markdown/20220627130403_39c72cd4_1656306243181.png)\r\n![](/cloudDisk/markdown/20220627130407_47aff561_1656306247843.png)\r\n![](/cloudDisk/markdown/20220627130412_528d4060_1656306252507.png)\r\n![](/cloudDisk/markdown/20220627130416_112dec3d_1656306256110.png)\r\n![](/cloudDisk/markdown/20220627130419_c9ee33cb_1656306259061.png)\r\n![](/cloudDisk/markdown/20220627130422_4523bad1_1656306262527.png)\r\n![](/cloudDisk/markdown/20220627130425_ea104ab8_1656306265861.png)\r\n![](/cloudDisk/markdown/20220627130429_1bc2f12a_1656306269142.png)\r\n![](/cloudDisk/markdown/20220627130432_108746b6_1656306272906.png)\r\n![](/cloudDisk/markdown/20220627130436_6fc49ce2_1656306276089.png)\r\n```java\r\n    public int longestConsecutive(int[] nums) {\r\n        Set<Integer> num_set = new HashSet<Integer>();\r\n        for (int num : nums) {\r\n            num_set.add(num);\r\n        }\r\n\r\n        int longestStreak = 0;\r\n\r\n        for (int num : num_set) {\r\n            if (!num_set.contains(num - 1)) {\r\n                int currentNum = num;\r\n                int currentStreak = 1;\r\n\r\n                while (num_set.contains(currentNum + 1)) {\r\n                    currentNum += 1;\r\n                    currentStreak += 1;\r\n                }\r\n\r\n                longestStreak = Math.max(longestStreak, currentStreak);\r\n            }\r\n        }\r\n\r\n        return longestStreak;\r\n    }\r\n\r\n作者：LeetCode-Solution\r\n链接：https://leetcode.cn/problems/longest-consecutive-sequence/solution/zui-chang-lian-xu-xu-lie-by-leetcode-solution/\r\n来源：力扣（LeetCode）\r\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\r\n```','2022-06-27 13:09:01','给定一个未排序的整数数组 nums ，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。\r\n\r\n请你设计并实现时间复杂度为 O(n) 的算法解决此问题。\r\n\r\n','/cloudDisk/markdown/20220627130349_9ea24ab1_1656306229831.png','原创','','\0','\0','128. 最长连续序列','2022-06-27 13:09:01',4,93,NULL,0),(194,'','## 基础\r\n\r\n**1. Try catch finally，finally总会执行吗，如果try里面是return，final ly还执行吗?**\r\n如果运行时程序发生错误，finally不会执行；\r\n\r\nfinnaly会执行，finally在return之后执行，finnaly里也有retrun，不会影响最终renturn的结果\r\n\r\n**2. Jdbc流程**\r\n\r\n\r\n\r\n**3.同步异步的区别,各自用在什么地方?**\r\n\r\n同步会阻塞\r\n\r\n异步不会，而是等到发出去的请求有响应时，才去处理\r\n\r\n**4.having,group by 与order by的区别**\r\n\r\nhaving是分组后进行条件筛选\r\n\r\ngroup by进行分组\r\n\r\norder by进行排序\r\n\r\n**5.stringbuild与stringbuffer的区别**\r\n\r\nstringBuild 线程不安全的，字符串操作速度优于stringBuffer\r\n\r\nstringBuffer 线程安全的\r\n\r\n**6.线程的两种实现方式**\r\n\r\n继承Thread、实现Runnable、实现Callable\r\n\r\n**7.MySQL里左连接与右连接的区别**\r\n\r\n左右连接都是在多表查询的时候用到\r\n\r\n左连接是当左表查出来的字段一定会有，如果右表没有设置为null，反之\r\n\r\n**8.静态变量与实例变量的区别**\r\n\r\n静态变量存放在方法区\r\n\r\n实例变量存放在栈区\r\n\r\n静态变量可被线程共享，也可被其他对象共享，而实例变量不行\r\n\r\n**9.说一说搭建一个ssm项目的流程**\r\n\r\n1. 导入spring、spring mvc、mybatis依赖\r\n2. 在spring配置文件中配置mybatis所需的数据源的bean，配置mybatis工程实例bean，配置mybatis的映射文件包路径\r\n3. 在web.xml里配置DispaturServlet，配置web初始化时加载初始化spring\r\n4. 配置Controller的包扫描路径\r\n\r\n**10.对Springboot的看法**\r\n\r\n可以快速搭建spring + springMvc项目，简化了ssm的配置，提供starter机制，只需导入springboot-starter的jar包，在项目启动时，自动加载自动配置类配置\r\n\r\n**11.简述Java中的异常处理机制**\r\n\r\n异常的顶层接口Throwable\r\n\r\n他有两个实现类，Exception和Error\r\n\r\nException可进行处理\r\n\r\nError程序无法进行处理\r\n\r\nException有两子类，RunTimeExcetion和CheckedException\r\n\r\n运行时异常和被检查异常，被检查异常发生在编译器，不去处理，编译不会通过\r\n\r\n运行时异常发生在运行期间，常见的有算数异常、文件找不到异常、IOExcption。。。\r\n\r\n**12.如何利用Document来从页面上取值和赋值**\r\n\r\nDocument.getElementById.. 获取dom对象\r\n\r\n可通过innerHtml、innerText赋值、取值\r\n\r\n**13.java基本类型中byte,int,long,float,char,double,boolean各占多少个字节**\r\n\r\nbyte 1， int 4，long 8, float 4, 2, double 8, boolean 1 \r\n\r\n**14.三张表关联,至少需要多少个关联条件才能避免出现笛卡尔积**\r\n\r\n\r\n\r\n**15.两个进程合作完成一个任务,在并发执行任中,一个进程要等待其他合作伙伴发来信息,或者建立在某个条件后再向前执行,这种关系称之为进程的什么关系**\r\n\r\n线程的join()方法，当A线程调用了B线程的join（）方法，A线程必须等待B线程执行完后，才能往下执行\r\n\r\n**16.谈谈你对抽象类和接口的理解**\r\n\r\n抽象类中可以存在普通方法，可以有方法体\r\n\r\n接口中的方法必须时public abstract修饰的\r\n\r\n抽象类中的变量可以是各种类型的，接口中的变量必须为public abstract finnal修饰的\r\n\r\n抽象类只能被继承一个，接口看可以多实现\r\n\r\n**18.Mvc什么的意思,结合自己的项目所以说Mvc**\r\n\r\nM：model模型，就是定义的Java bean对象\r\n\r\nV：view视图，\r\n\r\nC：Controller控制器\r\n\r\n**19.数组和集合的区别**\r\n\r\n数组中声明的类型可以是各种类型\r\n\r\n集合的泛型只能是引用类型\r\n\r\n数组不能主动扩容\r\n\r\n集合可以\r\n\r\n**20.方法的重载和重写的区别?方法重载能改变返回值类型吗?**\r\n\r\n重载overLoad，存在在同一类中，重载的参数列表，参数类型，参数个数不同，方法名相同，访问权限修饰符、返回值类型可以不同\r\n\r\n重写overWrite，存在在父子类之间，重写的参数列表，方法名必须相同，返回值类型要小于等于父类的，访问权限修饰符要大于等于父类的\r\n\r\n**21.==和equals的区别**\r\n\r\n==，如果是基本数据类型比较两个变量的字面值是否相同，如果是引用类型比较两个变量的指向的堆地址是否相同\r\n\r\nObject类中的equals方法默认是==\r\n\r\n如果类不重写equals方法，默认使用	object类的euqals方法\r\n\r\n**22.面向对象的特征**\r\n\r\n封装：隐藏内部的工作机制，之对外公开getter、setter方法，属性的赋值由内部决定\r\n\r\n继承：把多个类的共同方法抽离出一个类\r\n\r\n多态：存在在继承中，父类引用指向子类对象\r\n\r\n**23.重载和重写的区别**\r\n\r\n**25.String,StringBuffer和StringBuilder的区别(必须会)**\r\n\r\nString是finlly修饰的，每次进行操作都会返回新的String对象，频繁修改时效率低\r\n\r\n**26.反射**\r\n\r\n通过全限定类名获取class文件，通过类加载器加载class文件，获取类的构造方法、成员变量、成员方法\r\n\r\n**27.JDK8的新特性**\r\n\r\nStream流、lambda表达式\r\n\r\n**28.synchronized和lock的区别,synchronized和volatile和区别**\r\n\r\nsynchronized自动释放锁，lock需手动释放\r\n\r\nsynchronized给代码块或方法加锁，lock可以动态的加锁\r\n\r\nsynchronized是保证一个代码块只能有一个线程执行，其他线程需在锁池中等待\r\n\r\nvolatile保证可见性，当一个线程对方法区中的共享变量操作时，另一个线程可能不能得到修改后的值，而变量由volatile修饰后，变量被修改立即被其他线程可见\r\n\r\n**29.冒泡排序必须会手写**\r\n\r\n```java\r\npublic void sort(int[] nums){	\r\n	for (int i = 0; i < nums.length - 1; i++){\r\n        for (int j = i; j < nums.length - 1; j++){\r\n        	if (nums[j] > nums[j + 1]){\r\n                int temp = nums[i];\r\n                nums[i] = nums[j];\r\n                nums[j] = temp;\r\n        	}\r\n        }\r\n	}\r\n}\r\n```\r\n\r\n**30.集合和数组的区别**\r\n\r\n**31.List和Map,Set的区别;他们的实现类(必会)**\r\n\r\nList实现类有ArrayList，他底层是可变长数组结构，增删的时间复杂度为O（n），查改的时间复杂度为O（1）\r\n\r\nSet的实现类有HashSet，增删该查时间复杂度都是O（1）\r\n\r\nmap是多列集合，底层是哈希表由数组加链表实现，数组的初始长度为14，扩容系数为0.75，发生hash冲突时（Hash值相同但地址不同），此时会在当前桶加入链表，将冲突的元素加入链表，当链表长度大于8，数组长度大于65，由链表变为红黑树；长度小于6时，由红黑树转回链表\r\n\r\n**32.HashMap和HashTable,ConcurrentHahMap区别**\r\n\r\nHashMap 线程不安全，HashTable、ConcurrentHashMap线程安全的\r\n\r\nHashMap的key允许为null，但只能由一个为null\r\n\r\nHashTable，Key不允许为null\r\n\r\nConcurrentHashMap效率优于HashTable，ConcurrentHashMap局部加锁，HashTable全部加锁\r\n\r\n\r\n\r\n**33.线程创建的方式(必会)**\r\n\r\n继承Thread、实现Runnable、实现Callable、线程池获取线程\r\n\r\n\r\n\r\n**34.Runnable和Callable的区别**\r\n\r\nRunnable的run方法没有返回值，Callable可以有返回值\r\n\r\n**35.wait和sleep的区别**\r\n\r\nsleep是Thread中的方法，wait是Object中的方法；当前线程调用sleep方法后，线程没有放弃当前锁，只是暂时放弃了CPU的执行权；而调用了wait方法后，线程放弃了同步锁，并将当前线程加入等待池中，唯有其他线程调用notifiy或者notifiyAll方法，才将该线程从等待池移入锁池中\r\n\r\n**36.TCP与DUP的区别(了解)**\r\n\r\nTCP建立连接时需三次握手\r\n\r\nUDP直接可以向目标发送请求\r\n\r\n**37.什么是Http协议**\r\n\r\n超文本传输协议，是个网络传输协议\r\n\r\n**38.TCP的三次握手(掌握)**\r\n\r\n1. 发起连接\r\n2. 等待响应连接\r\n3. 确定发送连接\r\n\r\n**39.请求转发(forward)和重定(redirect)向的区别(掌握)**\r\n\r\nforward：在服务器内跳转，是一次请求，不会改变地址栏链接\r\n\r\nredirect：在客户端跳转，是两次请求，会改变地址栏链接\r\n\r\n**40.Get和Post的区别(必会)**\r\n\r\nget请求，参数是携带在url里的，在地址栏可见，不安全，url长度有限制\r\n\r\npost请求，参数是在请求体里的，地址栏不可见，安全，参数长度无限制\r\n\r\n**41.Cookie和Session的区别(必会)**\r\n\r\n\r\n\r\n**42.Jsp和Servlet的区别**\r\n\r\n**43.Servlet的生命周期**\r\n\r\n**44.Jsp的九大内置对象和四大域对象(必会)**\r\n\r\n**45.Ajax作用优势**\r\n\r\n**46.连接查询**\r\n\r\n**47.数据库事务 事务特性,隔离级别(必会)**\r\n\r\n**48,数据库索引的概念和优点**\r\n\r\n**49.数据库索引的分类(掌握一下)**\r\n\r\n**50.优化索引(了解)**\r\n\r\n**51.Sql语句优化(掌握)**\r\n\r\n## 框架\r\n\r\n**1.你对mybatis的理解(了解)**\r\n\r\n**2.myatis中${}和#{}的区别(必会)**\r\n\r\n**3.mybatis编程步骤(仅了解)**\r\n\r\n**4.mybatis呀中ResultType和ResultMap区别(必会)**\r\n\r\n**5.mybatis你所知道的动态标签有哪些,作用是什么?(必会)**\r\n\r\n**6.Spring的两大核心是什么,谈谈你对他们的理解,谈谈你对DI(依赖)的理解**','2022-06-27 14:04:06','','','原创','','\0','\0','笔试题','2022-06-27 14:04:06',3,103,NULL,0);

/*Table structure for table `comment` */

DROP TABLE IF EXISTS `comment`;

CREATE TABLE `comment` (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `nickname` varchar(255) DEFAULT NULL,
  `email` varchar(255) DEFAULT NULL,
  `content` varchar(255) DEFAULT NULL,
  `blog_id` bigint(20) NOT NULL,
  `parent_comment_id` bigint(20) DEFAULT NULL,
  `is_admin_comment` bit(1) NOT NULL,
  `create_time` datetime DEFAULT CURRENT_TIMESTAMP,
  PRIMARY KEY (`id`) USING BTREE,
  KEY `comment_blog_id` (`blog_id`),
  CONSTRAINT `comment_blog_id` FOREIGN KEY (`blog_id`) REFERENCES `blog` (`id`) ON DELETE CASCADE ON UPDATE CASCADE
) ENGINE=InnoDB AUTO_INCREMENT=116 DEFAULT CHARSET=utf8 ROW_FORMAT=DYNAMIC;

/*Data for the table `comment` */

insert  into `comment`(`id`,`nickname`,`email`,`content`,`blog_id`,`parent_comment_id`,`is_admin_comment`,`create_time`) values (95,'sadas','asd@sad.sad','a',156,-1,'\0','2022-06-23 18:53:44'),(97,'asdsa','asd@dsad.sad','qwewq',156,95,'\0','2022-06-23 20:38:35'),(98,'tony','1605337475@qq.com','牛了',189,-1,'','2022-06-24 13:45:32'),(99,'小二','sad@dsad.dsadsa','( ఠൠఠ )ﾉ',189,98,'\0','2022-06-24 13:48:20'),(100,'Tony二号','123@qq.com','666',163,-1,'\0','2022-06-24 14:07:33'),(101,'好','132@qq.com','你好',162,-1,'\0','2022-06-24 14:08:00'),(102,'我是测试人员','123@qq.com','asd',163,-1,'\0','2022-06-24 14:09:10'),(103,'腻子','485519609@qq.com','牛子',163,-1,'\0','2022-06-24 14:10:34'),(104,'鸡汤来了','312@gmail.com','hahah',162,-1,'\0','2022-06-24 14:10:47'),(105,'niuzi','adsdsa@dasd.sadas','niuzi',163,103,'\0','2022-06-24 14:13:10'),(106,'牛了','sad@sad.asdasd','牛了',163,102,'\0','2022-06-24 14:25:36'),(107,'test','123@qq.com','i\'m testMan',167,-1,'\0','2022-06-24 14:26:13'),(108,'张三','5242979@qq.com','and i, am iron man',167,107,'\0','2022-06-24 14:26:32'),(109,'徐振宇','111@qq.com','我是猪',189,-1,'\0','2022-06-24 16:41:20'),(110,'test','42979@qq.com','牛子',189,-1,'\0','2022-06-24 16:41:42'),(111,'洪其石','119@qq.com','确实',189,109,'\0','2022-06-24 16:41:45'),(112,'马志明','123@qq.com','哈哈哈',189,109,'\0','2022-06-24 16:56:57'),(113,'徐振宇','485519609@qq.com','牛啊\n',190,-1,'\0','2022-06-27 15:00:21'),(114,'马志明','485519609@qq.com','是的',190,113,'\0','2022-06-27 15:01:00'),(115,'马志明','485519609@qq.com','是的',190,113,'\0','2022-06-27 15:01:02');

/*Table structure for table `pictures` */

DROP TABLE IF EXISTS `pictures`;

CREATE TABLE `pictures` (
  `id` bigint(20) unsigned NOT NULL AUTO_INCREMENT,
  `realFileName` varchar(256) NOT NULL COMMENT '图片名',
  `saveFileName` varchar(256) NOT NULL COMMENT '图片在存在服务器硬盘上的名',
  `ext` varchar(20) DEFAULT NULL COMMENT '扩展名',
  `dir` varchar(100) NOT NULL COMMENT '存储目录',
  `size` float(11,1) DEFAULT NULL COMMENT '大小（字节）',
  `type` varchar(20) NOT NULL COMMENT '类型',
  `uploadTime` datetime DEFAULT CURRENT_TIMESTAMP COMMENT '上传时间',
  `changeTime` datetime DEFAULT CURRENT_TIMESTAMP COMMENT '更改时间',
  `isRecycle` int(1) DEFAULT '0' COMMENT '是否进回收站',
  `isPublic` int(1) DEFAULT '0' COMMENT '是否分享',
  `downLoadTimes` int(7) DEFAULT '0' COMMENT '下载次数',
  `isImg` int(1) DEFAULT NULL COMMENT '是否是图片',
  `userId` bigint(20) NOT NULL COMMENT '用户id',
  PRIMARY KEY (`id`),
  KEY `userId` (`userId`),
  CONSTRAINT `myfile_ibfk_1` FOREIGN KEY (`userId`) REFERENCES `user` (`id`) ON UPDATE CASCADE
) ENGINE=InnoDB AUTO_INCREMENT=18424 DEFAULT CHARSET=utf8;

/*Data for the table `pictures` */

insert  into `pictures`(`id`,`realFileName`,`saveFileName`,`ext`,`dir`,`size`,`type`,`uploadTime`,`changeTime`,`isRecycle`,`isPublic`,`downLoadTimes`,`isImg`,`userId`) values (18277,'%M$@3P~~K9YZM{SWETU`U6E.jpg','20220623225926_a289e083d6f7469abf0095e3dabc67d5_%M$@3P~~K9YZM{SWETU`U6E.jpg','jpg','/cloudDisk/file/',3680.0,'image/jpeg','2022-06-18 20:00:00','2022-06-18 20:00:00',0,0,0,1,1),(18278,'$X~F@%HQS_S]C3D7RYRC%NY.jpg','20220623225926_36d76a8ba91e4780a9a7078ff7e8a697_$X~F@%HQS_S]C3D7RYRC%NY.jpg','jpg','/cloudDisk/file/',4320.0,'image/jpeg','2022-06-18 20:00:00','2022-06-18 20:00:00',0,0,0,1,1),(18279,'%Q(TEZBS2OQ3M4S4F2M[3LU.jpg','20220623225926_3f4ec2aa311f40c595d07b95692feff9_%Q(TEZBS2OQ3M4S4F2M[3LU.jpg','jpg','/cloudDisk/file/',4640.0,'image/jpeg','2022-06-18 20:00:00','2022-06-18 20:00:00',0,1,0,1,1),(18280,'(~_LF])@@Q(ZLBM~@]1V2UH.jpg','20220623225926_66a0df7c2fe844e587e4c1ba694bbdd7_(~_LF])@@Q(ZLBM~@]1V2UH.jpg','jpg','/cloudDisk/file/',4448.0,'image/jpeg','2022-06-18 20:00:00','2022-06-18 20:00:00',0,0,0,1,1),(18281,'(4M3(4VOCO2{(CTV6~UMT[J.jpg','20220623225926_848d14821227421ba7b11ed9d8d86125_(4M3(4VOCO2{(CTV6~UMT[J.jpg','jpg','/cloudDisk/file/',6016.0,'image/jpeg','2022-06-18 20:00:00','2022-06-18 20:00:00',0,0,0,1,1),(18282,'%9M9_VLI6K2033QQ2AM%$HA.jpg','20220623225926_8a32139fb0db46158edb51c7da945bfa_%9M9_VLI6K2033QQ2AM%$HA.jpg','jpg','/cloudDisk/file/',7936.0,'image/jpeg','2022-06-18 20:00:00','2022-06-18 20:00:00',0,0,0,1,1),(18283,'(AISZO`K9C]CR6%HLH`[WQ9.jpg','20220623225926_ebc4b963831f404fb55768eec13b536f_(AISZO`K9C]CR6%HLH`[WQ9.jpg','jpg','/cloudDisk/file/',4800.0,'image/jpeg','2022-06-18 20:00:00','2022-06-18 20:00:00',0,0,0,1,1),(18284,'@{J[AT2G~DGXNYM585KZ}KY.jpg','20220623225936_54b07c9055ae4c729f267ddfaf65037a_@{J[AT2G~DGXNYM585KZ}KY.jpg','jpg','/cloudDisk/file/',3008.0,'image/jpeg','2022-06-18 20:00:00','2022-06-18 20:00:00',0,0,0,1,1),(18285,')M169IK$WEYGUU0HB`{CE99.jpg','20220623225936_64a23c9c5ce74abb8a4c8d091a8ee359_)M169IK$WEYGUU0HB`{CE99.jpg','jpg','/cloudDisk/file/',3232.0,'image/jpeg','2022-06-18 20:00:00','2022-06-18 20:00:00',0,0,0,1,1),(18286,']7S]V$GP_N7PA`{2CRBI{Y3.jpg','20220623225936_7a34537647a640d09f100e43934723b3_]7S]V$GP_N7PA`{2CRBI{Y3.jpg','jpg','/cloudDisk/file/',5280.0,'image/jpeg','2022-06-18 20:00:00','2022-06-18 20:00:00',0,0,0,1,1),(18287,')K0B$)RGCDBITUSDZ@_`A$J.jpg','20220623225936_ad01342acecd49b8b096e211715519e3_)K0B$)RGCDBITUSDZ@_`A$J.jpg','jpg','/cloudDisk/file/',5344.0,'image/jpeg','2022-06-18 20:00:00','2022-06-18 20:00:00',0,0,0,1,1),(18288,'@LMDVZG9@XBA~OF33}`7$ST.jpg','20220623225936_788a10b17da34da2b03220e7166b770b_@LMDVZG9@XBA~OF33}`7$ST.jpg','jpg','/cloudDisk/file/',6144.0,'image/jpeg','2022-06-18 20:00:00','2022-06-18 20:00:00',0,0,0,1,1),(18289,']8~%_4B2N@41BLPW8IERY}D.jpg','20220623225936_0d8d7dd8ddb44fb49cda51d49d0ab4b4_]8~%_4B2N@41BLPW8IERY}D.jpg','jpg','/cloudDisk/file/',2912.0,'image/jpeg','2022-06-18 20:00:00','2022-06-18 20:00:00',0,0,0,1,1),(18290,')(O([%`QN2B8`C1M7_XWOK1.jpg','20220623225936_88b3d6503f4b4d43ba3137193060da34_)(O([%`QN2B8`C1M7_XWOK1.jpg','jpg','/cloudDisk/file/',6656.0,'image/jpeg','2022-06-18 20:00:00','2022-06-18 20:00:00',0,0,0,1,1),(18291,'{17UK0C}S6~QW577@H24%JJ.jpg','20220623230025_5717ff606c164e79a1f7c1d793752499_{17UK0C}S6~QW577@H24%JJ.jpg','jpg','/cloudDisk/file/',3104.0,'image/jpeg','2022-06-18 20:00:00','2022-06-18 20:00:00',0,0,0,1,1),(18292,'`TR3@Y2FQ[OT2KEABH`}W96.jpg','20220623230025_e95312c1a73c40468c6d4cfdb10f5b59_`TR3@Y2FQ[OT2KEABH`}W96.jpg','jpg','/cloudDisk/file/',3680.0,'image/jpeg','2022-06-18 20:00:00','2022-06-18 20:00:00',0,0,0,1,1),(18293,'`XZ3YW8DD]`K$BHGH$RV(XV.jpg','20220623230025_2db80ef0ebc94abfbab532ace288ca22_`XZ3YW8DD]`K$BHGH$RV(XV.jpg','jpg','/cloudDisk/file/',3648.0,'image/jpeg','2022-06-18 20:00:00','2022-06-18 20:00:00',0,0,0,1,1),(18294,'})$L$~~P34)11GZEA`TW8$8.jpg','20220623230025_233e5b6f7f284f17b77db1f24851f8bd_})$L$~~P34)11GZEA`TW8$8.jpg','jpg','/cloudDisk/file/',5024.0,'image/jpeg','2022-06-18 20:00:00','2022-06-18 20:00:00',0,0,0,1,1),(18295,'1(6A`AA1JL6N__`F8{16V1L.jpg','20220623230025_c109c9f991cd4fcf8b9a9717567523ce_1(6A`AA1JL6N__`F8{16V1L.jpg','jpg','/cloudDisk/file/',6624.0,'image/jpeg','2022-06-18 20:00:00','2022-06-18 20:00:00',0,0,0,1,1),(18296,'~S}ZDQJFC[L9LOBMEY(ZLSP.jpg','20220623230025_8bb17c6a53d3457c96c5fab1d6af3f86_~S}ZDQJFC[L9LOBMEY(ZLSP.jpg','jpg','/cloudDisk/file/',6944.0,'image/jpeg','2022-06-18 20:00:00','2022-06-18 20:00:00',0,0,0,1,1),(18297,'1.jpg','20220623230025_15c6440a037a4cd7bdba8df9284569dc_1.jpg','jpg','/cloudDisk/file/',2784.0,'image/jpeg','2022-06-18 20:00:00','2022-06-18 20:00:00',0,0,0,1,1),(18298,'1_YNV3PD}6U@GDA$BE@[%EF.jpg','20220623230025_92ab605525fa4795904adf449982179f_1_YNV3PD}6U@GDA$BE@[%EF.jpg','jpg','/cloudDisk/file/',6240.0,'image/jpeg','2022-06-18 20:00:00','2022-06-18 20:00:00',0,0,0,1,1),(18299,'1.jpg','20220623230050_9ffcc460a28c4c59bb5787c966c4c889_1.jpg','jpg','/cloudDisk/file/',2784.0,'image/jpeg','2022-06-18 20:00:00','2022-06-18 20:00:00',0,0,0,1,1),(18300,'2JW}EZ~({4SWVPH(NY$Z4KI.jpg','20220623230050_e54eeedf8ab649ae9803f93e6ceee37d_2JW}EZ~({4SWVPH(NY$Z4KI.jpg','jpg','/cloudDisk/file/',2912.0,'image/jpeg','2022-06-18 20:00:00','2022-06-18 20:00:00',0,1,0,1,1),(18301,'2U3O[$9DZ4P`A1]M4YLNF(7.jpg','20220623230050_f4a365f1df094831870471fddc401791_2U3O[$9DZ4P`A1]M4YLNF(7.jpg','jpg','/cloudDisk/file/',3360.0,'image/jpeg','2022-06-18 20:00:00','2022-06-18 20:00:00',0,0,0,1,1),(18302,'1P@@]XZJ76IR%0DIOLJSZKB.jpg','20220623230050_9e6a9398bf7a4418985e865f177dc7ee_1P@@]XZJ76IR%0DIOLJSZKB.jpg','jpg','/cloudDisk/file/',3488.0,'image/jpeg','2022-06-18 20:00:00','2022-06-18 20:00:00',0,0,0,1,1),(18303,'1_YNV3PD}6U@GDA$BE@[%EF.jpg','20220623230050_344bb2be2bc14badb86fce2b33ca1c61_1_YNV3PD}6U@GDA$BE@[%EF.jpg','jpg','/cloudDisk/file/',6240.0,'image/jpeg','2022-06-18 20:00:00','2022-06-18 20:00:00',0,0,0,1,1),(18304,'1(6A`AA1JL6N__`F8{16V1L.jpg','20220623230050_17f886e1712c411eb2136c01362edacc_1(6A`AA1JL6N__`F8{16V1L.jpg','jpg','/cloudDisk/file/',6624.0,'image/jpeg','2022-06-18 20:00:00','2022-06-18 20:00:00',0,0,0,1,1),(18305,'3(04MR})R0QY5]@XX@94}_D.jpg','20220623230050_758abe47fc304b2384f91451692ca42a_3(04MR})R0QY5]@XX@94}_D.jpg','jpg','/cloudDisk/file/',3680.0,'image/jpeg','2022-06-18 20:00:00','2022-06-18 20:00:00',0,0,0,1,1),(18306,'4ZA`XROV9`EIVO`HRF[(TSM.jpg','20220623230111_0a855af696fd4e3db582933cf68a8f3e_4ZA`XROV9`EIVO`HRF[(TSM.jpg','jpg','/cloudDisk/file/',2912.0,'image/jpeg','2022-06-18 20:00:00','2022-06-18 20:00:00',0,0,0,1,1),(18307,'4$PDCU`G(`~IZ}PE7JG4F(B.jpg','20220623230111_ce5af535afcd4e4d80156cb984881f28_4$PDCU`G(`~IZ}PE7JG4F(B.jpg','jpg','/cloudDisk/file/',3200.0,'image/jpeg','2022-06-18 20:00:00','2022-06-18 20:00:00',0,0,0,1,1),(18308,'5VN@%AW)51}D{QK55CQPU2K.jpg','20220623230111_38cc874882f74c86973aee2574f558eb_5VN@%AW)51}D{QK55CQPU2K.jpg','jpg','/cloudDisk/file/',3552.0,'image/jpeg','2022-06-18 20:00:00','2022-06-18 20:00:00',0,0,0,1,1),(18309,'7W)I4[01SL`D(A[D_0FN~%2.jpg','20220623230111_610cee2b5109411f8260c25e2e1479a0_7W)I4[01SL`D(A[D_0FN~%2.jpg','jpg','/cloudDisk/file/',5344.0,'image/jpeg','2022-06-18 20:00:00','2022-06-18 20:00:00',0,0,0,1,1),(18310,'8`_%P0$I9NS~{YW88BQRUMO.jpg','20220623230111_e2f15d4929bc4a71bfb6e56c497c0058_8`_%P0$I9NS~{YW88BQRUMO.jpg','jpg','/cloudDisk/file/',5728.0,'image/jpeg','2022-06-18 20:00:00','2022-06-18 20:00:00',0,0,0,1,1),(18311,'7P(JY1IOJBGBQH7(_ZA$UHO.jpg','20220623230111_a482ac5331a74db5a7b89d818f82e304_7P(JY1IOJBGBQH7(_ZA$UHO.jpg','jpg','/cloudDisk/file/',5632.0,'image/jpeg','2022-06-18 20:00:00','2022-06-18 20:00:00',0,0,0,1,1),(18312,'9U(@_OU[]{5PN[GI65L2KL8.jpg','20220623230111_0da4974fade240e38405a3831f275a60_9U(@_OU[]{5PN[GI65L2KL8.jpg','jpg','/cloudDisk/file/',6816.0,'image/jpeg','2022-06-18 20:00:00','2022-06-18 20:00:00',0,0,0,1,1),(18313,'-5342bc825d2ae7c2.jpg','20220623230126_22f9cb6852a64a3aaa5fa3e50df9ed66_-5342bc825d2ae7c2.jpg','jpg','/cloudDisk/file/',402.3,'image/jpeg','2022-06-18 20:00:00','2022-06-18 20:00:00',0,1,0,1,1),(18314,'1655649264939.png','20220623230126_0f4afed1938b42f7847ccf5223b27554_1655649264939.png','png','/cloudDisk/file/',340.1,'image/png','2022-06-18 20:00:00','2022-06-18 20:00:00',0,0,0,1,1),(18315,'1655570037051..jpg','20220623230126_1ba99a7eb27b46e9aa9d99f0576ef93e_1655570037051..jpg','jpg','/cloudDisk/file/',2323.7,'image/jpeg','2022-06-18 20:00:00','2022-06-18 20:00:00',0,0,0,1,1),(18316,'1655570061676..jpg','20220623230126_9504ac5855a24cf9900df49d54a82020_1655570061676..jpg','jpg','/cloudDisk/file/',2248.3,'image/jpeg','2022-06-18 20:00:00','2022-06-18 20:00:00',0,0,0,1,1),(18317,'1962]P)I4GHC`UR{N()@OXJ.jpg','20220623230126_bdff52d438ed44dca54aa9450a514544_1962]P)I4GHC`UR{N()@OXJ.jpg','jpg','/cloudDisk/file/',2944.0,'image/jpeg','2022-06-18 20:00:00','2022-06-18 20:00:00',0,0,0,1,1),(18318,'9Y[@WN6@_69_CTS34C2W9O3.jpg','20220623230126_13721133916945ce9bed5026ca93b7d8_9Y[@WN6@_69_CTS34C2W9O3.jpg','jpg','/cloudDisk/file/',4064.0,'image/jpeg','2022-06-18 20:00:00','2022-06-18 20:00:00',0,0,0,1,1),(18319,'49JISZBP38_H~E`4`P4YGJO.jpg','20220623230126_7ff7616bf32442abb9cf3bf2870ab84a_49JISZBP38_H~E`4`P4YGJO.jpg','jpg','/cloudDisk/file/',6752.0,'image/jpeg','2022-06-18 20:00:00','2022-06-18 20:00:00',0,0,0,1,1),(18320,'1655654292901.png','20220623230139_f8bbd48d2cd441418df8ed758fa51139_1655654292901.png','png','/cloudDisk/file/',448.0,'image/png','2022-06-18 20:00:00','2022-06-18 20:00:00',0,0,0,1,1),(18321,'20220619003406_cd70a5c5_1655570037051..jpg','20220623230139_0a0d887cd4e84711803b33f135591e2f_20220619003406_cd70a5c5_1655570037051..jpg','jpg','/cloudDisk/file/',2336.3,'image/jpeg','2022-06-18 20:00:00','2022-06-18 20:00:00',0,0,0,1,1),(18322,'20220619003427_36a7d75a_1655570061676..jpg','20220623230139_5e875436233f4d98b3ebba103b5df37f_20220619003427_36a7d75a_1655570061676..jpg','jpg','/cloudDisk/file/',2266.3,'image/jpeg','2022-06-18 20:00:00','2022-06-18 20:00:00',0,0,0,1,1),(18323,'B0NO%T~BM3ZBZZFRP(`}(GF.jpg','20220623230139_8d599b44e5024a4788d021debeb5529a_B0NO%T~BM3ZBZZFRP(`}(GF.jpg','jpg','/cloudDisk/file/',3936.0,'image/jpeg','2022-06-18 20:00:00','2022-06-18 20:00:00',0,0,0,1,1),(18324,'BBY%LJ@(IW9HIKJXU5JP3~U.jpg','20220623230139_42fb6804c3cd48f392a21bb9084dbc4c_BBY%LJ@(IW9HIKJXU5JP3~U.jpg','jpg','/cloudDisk/file/',4832.0,'image/jpeg','2022-06-18 20:00:00','2022-06-18 20:00:00',0,0,0,1,1),(18325,'C`HWSR05D%Q$T8MT7P`V{05.jpg','20220623230140_c428ccb30c204069b1cc6040720da4e1_C`HWSR05D%Q$T8MT7P`V{05.jpg','jpg','/cloudDisk/file/',7296.0,'image/jpeg','2022-06-18 20:00:00','2022-06-18 20:00:00',0,0,0,1,1),(18326,'C7$7}0FSI7}T9KR[DY[4{_V.jpg','20220623230140_222a58b1ab674d359d90d783fb0cbdf9_C7$7}0FSI7}T9KR[DY[4{_V.jpg','jpg','/cloudDisk/file/',6240.0,'image/jpeg','2022-06-18 20:00:00','2022-06-18 20:00:00',0,1,0,1,1),(18327,'CB5`_7(U{B4Y0CIO@$F]O5P.jpg','20220623230150_46488c4164994eaab771bcf56cc29143_CB5`_7(U{B4Y0CIO@$F]O5P.jpg','jpg','/cloudDisk/file/',3488.0,'image/jpeg','2022-06-18 20:00:00','2022-06-18 20:00:00',0,0,0,1,1),(18328,'DMGH74SJ712MUP$BE$J}P`Y.jpg','20220623230150_d340237de5564fd3be714f2d3145da46_DMGH74SJ712MUP$BE$J}P`Y.jpg','jpg','/cloudDisk/file/',4640.0,'image/jpeg','2022-06-18 20:00:00','2022-06-18 20:00:00',0,0,0,1,1),(18329,'DVOF1FG~R[0S]IK0{CG6S2I.jpg','20220623230150_861f1f8099d44094a95c0d42f1eadc17_DVOF1FG~R[0S]IK0{CG6S2I.jpg','jpg','/cloudDisk/file/',5600.0,'image/jpeg','2022-06-18 20:00:00','2022-06-18 20:00:00',0,0,0,1,1),(18330,'D%@2]}4F(~7[(NG8%%W{S~O.jpg','20220623230150_9a0d8379eeae45549f054759fc6b553a_D%@2]}4F(~7[(NG8%%W{S~O.jpg','jpg','/cloudDisk/file/',6272.0,'image/jpeg','2022-06-18 20:00:00','2022-06-18 20:00:00',0,0,0,1,1),(18331,'EI9K({UIQ}ENJ7URA6ZXE80.jpg','20220623230150_4ab016e5518c4ad2965cdca4f9e45689_EI9K({UIQ}ENJ7URA6ZXE80.jpg','jpg','/cloudDisk/file/',6016.0,'image/jpeg','2022-06-18 20:00:00','2022-06-18 20:00:00',0,0,0,1,1),(18332,'E(W{XHE$H$9WL]EKWP)QQKO.jpg','20220623230150_01bd4f7ed2d94b98ba2543789d693d96_E(W{XHE$H$9WL]EKWP)QQKO.jpg','jpg','/cloudDisk/file/',6944.0,'image/jpeg','2022-06-18 20:00:00','2022-06-18 20:00:00',0,0,0,1,1),(18333,'F4R3Y]O4RRL`L2U5CWXO8K9.jpg','20220623230150_3660c8cdc0ab4964bd799687d4331dd8_F4R3Y]O4RRL`L2U5CWXO8K9.jpg','jpg','/cloudDisk/file/',2752.0,'image/jpeg','2022-06-18 20:00:00','2022-06-18 20:00:00',0,0,0,1,1),(18334,'G%A]Q446NWECX%8]`B@BJ9A.jpg','20220623230203_ab8bc0c337714b0cb403562d2aa6f02f_G%A]Q446NWECX%8]`B@BJ9A.jpg','jpg','/cloudDisk/file/',3680.0,'image/jpeg','2022-06-18 20:00:00','2022-06-18 20:00:00',0,0,0,1,1),(18335,'GZJBQ9SF2~TK`VY@O}}%%[W.jpg','20220623230203_369d58be57d74d508840c355b3aae9ef_GZJBQ9SF2~TK`VY@O}}%%[W.jpg','jpg','/cloudDisk/file/',4512.0,'image/jpeg','2022-06-18 20:00:00','2022-06-18 20:00:00',0,0,0,1,1),(18336,'FW`1~92G6]{8$]2U7~6%CU2.jpg','20220623230203_49bdb122173944a08357767b8afecb20_FW`1~92G6]{8$]2U7~6%CU2.jpg','jpg','/cloudDisk/file/',5728.0,'image/jpeg','2022-06-18 20:00:00','2022-06-18 20:00:00',0,1,0,1,1),(18337,'G]CT2HSVHROT1ZE_V~$1@(P.jpg','20220623230203_1b924d6b90bf4e7088e0197ef91a28f1_G]CT2HSVHROT1ZE_V~$1@(P.jpg','jpg','/cloudDisk/file/',6016.0,'image/jpeg','2022-06-18 20:00:00','2022-06-18 20:00:00',0,0,0,1,1),(18338,'GW7]DZYA9IN8$EX)Q7X)`@9.jpg','20220623230203_326910cd08814832a53d7a4044d65f91_GW7]DZYA9IN8$EX)Q7X)`@9.jpg','jpg','/cloudDisk/file/',6560.0,'image/jpeg','2022-06-18 20:00:00','2022-06-18 20:00:00',0,1,0,1,1),(18339,'FW{X[OCJ2$GTAHLYVTAT6ON.jpg','20220623230203_c849fca00a4f459cb8c1f6af824b263b_FW{X[OCJ2$GTAHLYVTAT6ON.jpg','jpg','/cloudDisk/file/',7840.0,'image/jpeg','2022-06-18 20:00:00','2022-06-18 20:00:00',0,0,0,1,1),(18340,'H@LPWAA}07RB]J[{(CG8X]3.jpg','20220623230203_e8b41807387f4ceabaf30ad9173c71ed_H@LPWAA}07RB]J[{(CG8X]3.jpg','jpg','/cloudDisk/file/',3808.0,'image/jpeg','2022-06-18 20:00:00','2022-06-18 20:00:00',0,0,0,1,1),(18341,'IMG_20220617_210356.jpg','20220623230218_a6dbe726653c4ca5a8653a1d78385cd3_IMG_20220617_210356.jpg','jpg','/cloudDisk/file/',95.5,'image/jpeg','2022-06-18 20:00:00','2022-06-18 20:00:00',0,0,0,1,1),(18342,'IHRZ[4(`C1K2RTWSHDNU%PQ.jpg','20220623230218_83d3345b12da408f98149fa1b98691f2_IHRZ[4(`C1K2RTWSHDNU%PQ.jpg','jpg','/cloudDisk/file/',3968.0,'image/jpeg','2022-06-18 20:00:00','2022-06-18 20:00:00',0,0,0,1,1),(18343,'IKUJQ[%13HHRD~$QT8PZTWG.jpg','20220623230218_883c7124954c43e58bc055d4550a2bf3_IKUJQ[%13HHRD~$QT8PZTWG.jpg','jpg','/cloudDisk/file/',4448.0,'image/jpeg','2022-06-18 20:00:00','2022-06-18 20:00:00',0,0,0,1,1),(18344,'IMG_20220617_234444.jpg','20220623230218_45ae7127f43c46dd98dabb1488cfb22c_IMG_20220617_234444.jpg','jpg','/cloudDisk/file/',4341.8,'image/jpeg','2022-06-18 20:00:00','2022-06-18 20:00:00',0,0,0,1,1),(18345,'H`TGX9T4S0`(NEUD2F`AY1S.jpg','20220623230218_828a72be55a34b90bfcc20cf73d41b36_H`TGX9T4S0`(NEUD2F`AY1S.jpg','jpg','/cloudDisk/file/',5696.0,'image/jpeg','2022-06-18 20:00:00','2022-06-18 20:00:00',0,0,0,1,1),(18346,'IMG_20220618_092237.jpg','20220623230218_8006b5b8b4304c4daa80430be7e00a9b_IMG_20220618_092237.jpg','jpg','/cloudDisk/file/',8558.5,'image/jpeg','2022-06-18 20:00:00','2022-06-18 20:00:00',0,0,0,1,1),(18347,'IMG_20220618_101221.jpg','20220623230218_24fe737d02b8486ca3b2aecb6860ee7e_IMG_20220618_101221.jpg','jpg','/cloudDisk/file/',10509.9,'image/jpeg','2022-06-18 20:00:00','2022-06-18 20:00:00',0,0,0,1,1),(18348,'IMG_20220618_124323.jpg','20220623230231_4f9981f0d65e40b4a96c434ef1312650_IMG_20220618_124323.jpg','jpg','/cloudDisk/file/',10181.0,'image/jpeg','2022-06-18 20:00:00','2022-06-18 20:00:00',0,1,0,1,1),(18349,'IMG_20220618_124348.jpg','20220623230231_e082ed1251084e8a9b186a7234623871_IMG_20220618_124348.jpg','jpg','/cloudDisk/file/',10327.6,'image/jpeg','2022-06-18 20:00:00','2022-06-18 20:00:00',0,0,0,1,1),(18350,'IMG_20220618_101222.jpg','20220623230231_4e677968b4584b8fbea2fc20279d457e_IMG_20220618_101222.jpg','jpg','/cloudDisk/file/',10680.2,'image/jpeg','2022-06-18 20:00:00','2022-06-18 20:00:00',0,0,0,1,1),(18351,'IMG_20220618_101223.jpg','20220623230231_3d2db587b4ee430393b42259909cbc1b_IMG_20220618_101223.jpg','jpg','/cloudDisk/file/',10994.5,'image/jpeg','2022-06-18 20:00:00','2022-06-18 20:00:00',0,0,0,1,1),(18352,'IMG_20220618_124305.jpg','20220623230231_02a8ca7a7c464159853aedbc0876595a_IMG_20220618_124305.jpg','jpg','/cloudDisk/file/',11081.3,'image/jpeg','2022-06-18 20:00:00','2022-06-18 20:00:00',0,0,0,1,1),(18353,'IMG_20220618_124308.jpg','20220623230231_6c2a1abb9ff8436eb02a26a8c37314e9_IMG_20220618_124308.jpg','jpg','/cloudDisk/file/',12160.1,'image/jpeg','2022-06-18 20:00:00','2022-06-18 20:00:00',0,0,0,1,1),(18354,'IMG_20220618_124447.jpg','20220623230231_bd179a8bfc1e4c68b2aad78b2da8c1e5_IMG_20220618_124447.jpg','jpg','/cloudDisk/file/',10093.8,'image/jpeg','2022-06-18 20:00:00','2022-06-18 20:00:00',0,0,0,1,1),(18355,'IMG_20220619_153752.jpg','20220623230249_a0607fb3809a4da48617784d35382f37_IMG_20220619_153752.jpg','jpg','/cloudDisk/file/',7957.8,'image/jpeg','2022-06-18 20:00:00','2022-06-18 20:00:00',0,0,0,1,1),(18356,'IMG_20220619_153839.jpg','20220623230249_6df3363731824188b944d57e68996890_IMG_20220619_153839.jpg','jpg','/cloudDisk/file/',7902.7,'image/jpeg','2022-06-18 20:00:00','2022-06-18 20:00:00',0,1,0,1,1),(18357,'IMG_20220618_124626.jpg','20220623230249_411e83654c224449b0cef2c39ba7c170_IMG_20220618_124626.jpg','jpg','/cloudDisk/file/',9070.6,'image/jpeg','2022-06-18 20:00:00','2022-06-18 20:00:00',0,0,0,1,1),(18358,'IMG_20220619_131432.jpg','20220623230249_ea6843a551aa465e8f98f89d2a885742_IMG_20220619_131432.jpg','jpg','/cloudDisk/file/',10646.4,'image/jpeg','2022-06-18 20:00:00','2022-06-18 20:00:00',0,0,0,1,1),(18359,'IMG_20220618_135619.jpg','20220623230249_980e9cfe58344f79b4c6bc4c953f247d_IMG_20220618_135619.jpg','jpg','/cloudDisk/file/',8939.8,'image/jpeg','2022-06-18 20:00:00','2022-06-18 20:00:00',0,0,0,1,1),(18360,'IMG_20220619_153833.jpg','20220623230249_88ebda5857f04f6fb50fece545a27e1b_IMG_20220619_153833.jpg','jpg','/cloudDisk/file/',9702.6,'image/jpeg','2022-06-18 20:00:00','2022-06-18 20:00:00',0,0,0,1,1),(18361,'IMG_20220619_153852.jpg','20220623230250_7e7fd592965c4c5696208c913f193080_IMG_20220619_153852.jpg','jpg','/cloudDisk/file/',8338.2,'image/jpeg','2022-06-18 20:00:00','2022-06-18 20:00:00',0,1,0,1,1),(18362,'J@1{)JPNQ_Y4X]%Y1$EA8~N.jpg','20220623230302_b3d47fb4cce54221a9df9ac2103f6b06_J@1{)JPNQ_Y4X]%Y1$EA8~N.jpg','jpg','/cloudDisk/file/',3392.0,'image/jpeg','2022-06-18 20:00:00','2022-06-18 20:00:00',0,0,0,1,1),(18363,'JZ)2_MBS9$6`U8HSNY_H$CC.jpg','20220623230302_a326d94b11fa43feb683302940b8111f_JZ)2_MBS9$6`U8HSNY_H$CC.jpg','jpg','/cloudDisk/file/',4192.0,'image/jpeg','2022-06-18 20:00:00','2022-06-18 20:00:00',0,0,0,1,1),(18364,'JV6TTI%63($MA6Y~_`WX7CP.jpg','20220623230302_9217089d39354a10a4cb6d84f79d5b47_JV6TTI%63($MA6Y~_`WX7CP.jpg','jpg','/cloudDisk/file/',7552.0,'image/jpeg','2022-06-18 20:00:00','2022-06-18 20:00:00',0,0,0,1,1),(18365,'KK_%MOP9UO$J`J2@692E$(X.jpg','20220623230302_e29ddbb6008647f4bef5288acfb0a691_KK_%MOP9UO$J`J2@692E$(X.jpg','jpg','/cloudDisk/file/',5184.0,'image/jpeg','2022-06-18 20:00:00','2022-06-18 20:00:00',0,0,0,1,1),(18366,'IMG_20220619_172303.jpg','20220623230302_c01dbb3cb61c4b5699be8c58c0ecd40d_IMG_20220619_172303.jpg','jpg','/cloudDisk/file/',8600.3,'image/jpeg','2022-06-18 20:00:00','2022-06-18 20:00:00',0,0,0,1,1),(18367,'IMG_20220619_153854.jpg','20220623230302_6622966ae57843b3bff9664772c03436_IMG_20220619_153854.jpg','jpg','/cloudDisk/file/',8992.8,'image/jpeg','2022-06-18 20:00:00','2022-06-18 20:00:00',0,0,0,1,1),(18368,'IMG_20220619_154148.jpg','20220623230302_3cc42a34d73f45febbc63dde58d0fead_IMG_20220619_154148.jpg','jpg','/cloudDisk/file/',10359.5,'image/jpeg','2022-06-18 20:00:00','2022-06-18 20:00:00',0,0,0,1,1),(18369,'mmexport1655653484984.jpg','20220623230316_49e8b78f7a944371ad102631ced00533_mmexport1655653484984.jpg','jpg','/cloudDisk/file/',496.1,'image/jpeg','2022-06-18 20:00:00','2022-06-18 20:00:00',0,0,0,1,1),(18370,'mmexport1655653494033.jpg','20220623230316_743e740052e649b1923be74da8f43d97_mmexport1655653494033.jpg','jpg','/cloudDisk/file/',497.2,'image/jpeg','2022-06-18 20:00:00','2022-06-18 20:00:00',0,0,0,1,1),(18371,'LT~Y9T}YLNYOB_UYSXI9V(T.jpg','20220623230316_692bbdd21e7f43b7806b5f41b6651567_LT~Y9T}YLNYOB_UYSXI9V(T.jpg','jpg','/cloudDisk/file/',2880.0,'image/jpeg','2022-06-18 20:00:00','2022-06-18 20:00:00',0,0,0,1,1),(18372,'LO3R0Q$4@ZHDA`%H_)SV%74.jpg','20220623230316_e357594768a04008af0ff1af5ac70afd_LO3R0Q$4@ZHDA`%H_)SV%74.jpg','jpg','/cloudDisk/file/',4192.0,'image/jpeg','2022-06-18 20:00:00','2022-06-18 20:00:00',0,0,0,1,1),(18373,'mmexport1655656597194.jpg','20220623230316_1f92fb70a7574b3e9cbf4c195817d284_mmexport1655656597194.jpg','jpg','/cloudDisk/file/',4192.0,'image/jpeg','2022-06-18 20:00:00','2022-06-18 20:00:00',0,0,0,1,1),(18374,'M62J]S4~4DAQ9M5FU~Y@0BI.jpg','20220623230316_225119dc12b64873be73bbae3cbf86d4_M62J]S4~4DAQ9M5FU~Y@0BI.jpg','jpg','/cloudDisk/file/',5952.0,'image/jpeg','2022-06-18 20:00:00','2022-06-18 20:00:00',0,0,0,1,1),(18375,'mmexport1655995427234.mp4','20220623230317_c67a663bf2c3486c8e6cbbde7e44ed71_mmexport1655995427234.mp4','mp4','/cloudDisk/file/',23854.7,'video/mp4','2022-06-18 20:00:00','2022-06-18 20:00:00',0,1,0,0,1),(18376,'mmexport1655995439018.jpg','20220623230336_70d993a0e192480fb5353af957ae0c30_mmexport1655995439018.jpg','jpg','/cloudDisk/file/',381.1,'image/jpeg','2022-06-18 20:00:00','2022-06-18 20:00:00',0,0,0,1,1),(18377,'mmexport1655995442564.jpg','20220623230336_aec493140c7a455bbc6222c7942e592a_mmexport1655995442564.jpg','jpg','/cloudDisk/file/',385.0,'image/jpeg','2022-06-18 20:00:00','2022-06-18 20:00:00',0,0,0,1,1),(18378,'mmexport1655995440123.jpg','20220623230336_f2777739cfff4459a93bd7702c903795_mmexport1655995440123.jpg','jpg','/cloudDisk/file/',381.1,'image/jpeg','2022-06-18 20:00:00','2022-06-18 20:00:00',0,0,0,1,1),(18379,'mmexport1655995434738.jpg','20220623230336_4b1b2160d78843efb220cfd48d0b5fe5_mmexport1655995434738.jpg','jpg','/cloudDisk/file/',1497.2,'image/jpeg','2022-06-18 20:00:00','2022-06-18 20:00:00',0,0,0,1,1),(18380,'mmexport1655995444580.jpg','20220623230336_9fff0840d8f44a68926ffe0de22944fa_mmexport1655995444580.jpg','jpg','/cloudDisk/file/',394.6,'image/jpeg','2022-06-18 20:00:00','2022-06-18 20:00:00',0,0,0,1,1),(18381,'mmexport1655995446411.jpg','20220623230336_8d172999876841889cbfecbd3560443a_mmexport1655995446411.jpg','jpg','/cloudDisk/file/',250.8,'image/jpeg','2022-06-18 20:00:00','2022-06-18 20:00:00',0,0,0,1,1),(18382,'mmexport1655995448064.jpg','20220623230336_8acd94b4674e4a1694b7feda3352019e_mmexport1655995448064.jpg','jpg','/cloudDisk/file/',407.6,'image/jpeg','2022-06-18 20:00:00','2022-06-18 20:00:00',0,0,0,1,1),(18383,'mmexport1655995451631.jpg','20220623230352_469fb30d52d24a1cb965ca73e98b05e6_mmexport1655995451631.jpg','jpg','/cloudDisk/file/',375.3,'image/jpeg','2022-06-18 20:00:00','2022-06-18 20:00:00',0,0,0,1,1),(18384,'mmexport1655995449946.jpg','20220623230352_6596090390714d828064cf33cff1cba9_mmexport1655995449946.jpg','jpg','/cloudDisk/file/',384.2,'image/jpeg','2022-06-18 20:00:00','2022-06-18 20:00:00',0,0,0,1,1),(18385,'mmexport1655995455361.jpg','20220623230352_0f5a48eb96464f7c9cc0ef15cbc39cca_mmexport1655995455361.jpg','jpg','/cloudDisk/file/',497.2,'image/jpeg','2022-06-18 20:00:00','2022-06-18 20:00:00',0,0,0,1,1),(18386,'mmexport1655995453814.jpg','20220623230352_02f245f7452d48d09df649347ea384c7_mmexport1655995453814.jpg','jpg','/cloudDisk/file/',496.1,'image/jpeg','2022-06-18 20:00:00','2022-06-18 20:00:00',0,0,0,1,1),(18387,'mmexport1655995462269.jpg','20220623230352_c4a0cb4db35c47beb891d205c2d4647f_mmexport1655995462269.jpg','jpg','/cloudDisk/file/',395.5,'image/jpeg','2022-06-18 20:00:00','2022-06-18 20:00:00',0,1,0,1,1),(18388,'mmexport1655995459788.jpg','20220623230352_e0466769684b4d42a5656e0619703e78_mmexport1655995459788.jpg','jpg','/cloudDisk/file/',1442.1,'image/jpeg','2022-06-18 20:00:00','2022-06-18 20:00:00',0,1,0,1,1),(18389,'mmexport1655995464125.jpg','20220623230352_b1b71656fdcb49b796ab18c3e565a152_mmexport1655995464125.jpg','jpg','/cloudDisk/file/',795.5,'image/jpeg','2022-06-18 20:00:00','2022-06-18 20:00:00',0,1,0,1,1),(18390,'mmexport1655995518218.jpg','20220623230408_c3338552476d4e4f94c80a2f2665da6a_mmexport1655995518218.jpg','jpg','/cloudDisk/file/',521.5,'image/jpeg','2022-06-18 20:00:00','2022-06-18 20:00:00',0,0,0,1,1),(18391,'mmexport1655995531361.jpg','20220623230408_d05c838d3d674fbf967be5966ec4dceb_mmexport1655995531361.jpg','jpg','/cloudDisk/file/',644.4,'image/jpeg','2022-06-18 20:00:00','2022-06-18 20:00:00',0,0,0,1,1),(18392,'mmexport1655995467909.jpg','20220623230408_9e3a113a0ebf47f1a95fd8bdaac87c0c_mmexport1655995467909.jpg','jpg','/cloudDisk/file/',1441.4,'image/jpeg','2022-06-18 20:00:00','2022-06-18 20:00:00',0,1,0,1,1),(18393,'mmexport1655995478184.jpg','20220623230408_543be65430194a1db4eae9fe1bc4a2c0_mmexport1655995478184.jpg','jpg','/cloudDisk/file/',2067.3,'image/jpeg','2022-06-18 20:00:00','2022-06-18 20:00:00',0,0,0,1,1),(18394,'mmexport1655995476697.jpg','20220623230408_076c2191f2404d44ab53cd41aee41694_mmexport1655995476697.jpg','jpg','/cloudDisk/file/',2067.3,'image/jpeg','2022-06-18 20:00:00','2022-06-18 20:00:00',0,1,0,1,1),(18395,'mmexport1655995471206.jpg','20220623230408_5acf0f5c42134165a4d3c61ab930627d_mmexport1655995471206.jpg','jpg','/cloudDisk/file/',2539.9,'image/jpeg','2022-06-18 20:00:00','2022-06-18 20:00:00',0,1,0,1,1),(18396,'N{HV9JIYL(0DEK]20V7AI]S.jpg','20220623230408_6d48694b6743471b82f6990da49f6f2b_N{HV9JIYL(0DEK]20V7AI]S.jpg','jpg','/cloudDisk/file/',3968.0,'image/jpeg','2022-06-18 20:00:00','2022-06-18 20:00:00',0,1,0,1,1),(18397,'QW)M02_YSUB_~1XUX$SKF2A.jpg','20220623230421_e9a5edd0ade34170bc3956a08a215b4d_QW)M02_YSUB_~1XUX$SKF2A.jpg','jpg','/cloudDisk/file/',3520.0,'image/jpeg','2022-06-18 20:00:00','2022-06-18 20:00:00',0,0,0,1,1),(18398,'TE6V)IGPB6__8%HQA4`%JTI.jpg','20220623230421_b8db6524d22445cc89f7d5f39cf14b56_TE6V)IGPB6__8%HQA4`%JTI.jpg','jpg','/cloudDisk/file/',3264.0,'image/jpeg','2022-06-18 20:00:00','2022-06-18 20:00:00',0,0,0,1,1),(18399,'SJZEUOSYQI5~~AFX%[RX[}N.jpg','20220623230421_38045496bb90496dac955775dc5f6b6c_SJZEUOSYQI5~~AFX%[RX[}N.jpg','jpg','/cloudDisk/file/',3200.0,'image/jpeg','2022-06-18 20:00:00','2022-06-18 20:00:00',0,0,0,1,1),(18400,'OSTX45R%J{(JOYY5@TFEQKK.jpg','20220623230421_5da38df327d04b1eb7d3a61cff6d020e_OSTX45R%J{(JOYY5@TFEQKK.jpg','jpg','/cloudDisk/file/',4960.0,'image/jpeg','2022-06-18 20:00:00','2022-06-18 20:00:00',0,0,0,1,1),(18401,'PQ@Y{%ZG7UFV[@YYCAYXM1Z.jpg','20220623230421_e1abc22256694579a7f937d88192791b_PQ@Y{%ZG7UFV[@YYCAYXM1Z.jpg','jpg','/cloudDisk/file/',5440.0,'image/jpeg','2022-06-18 20:00:00','2022-06-18 20:00:00',0,0,0,1,1),(18402,'R1PROZE6S6F@5{C3}JN4ZT9.jpg','20220623230421_c5dabf6cf0594c4aba992bfa133ec7ae_R1PROZE6S6F@5{C3}JN4ZT9.jpg','jpg','/cloudDisk/file/',6688.0,'image/jpeg','2022-06-18 20:00:00','2022-06-18 20:00:00',0,0,0,1,1),(18403,'TM{U)QUB$X5ZVGP}YIVC9}H.jpg','20220623230421_f5eb5f1b593949309b19338f00d14102_TM{U)QUB$X5ZVGP}YIVC9}H.jpg','jpg','/cloudDisk/file/',7136.0,'image/jpeg','2022-06-18 20:00:00','2022-06-18 20:00:00',0,0,0,1,1),(18404,'U%]$Q2LL[ZHOH[A`ZG%8450.jpg','20220623230541_9af81d205e374577a69905ef83362052_U%]$Q2LL[ZHOH[A`ZG%8450.jpg','jpg','/cloudDisk/file/',3008.0,'image/jpeg','2022-06-18 20:00:00','2022-06-18 20:00:00',0,1,2,1,1),(18405,'U_1HCN4N@FLF7AFDDF`VA@E.jpg','20220623230541_8100c5ea7fc74fb9a281f0275992168c_U_1HCN4N@FLF7AFDDF`VA@E.jpg','jpg','/cloudDisk/file/',6880.0,'image/jpeg','2022-06-18 20:00:00','2022-06-18 20:00:00',0,0,0,1,1),(18406,'VID_20220619_133057.mp4','20220623230541_bea26f0899444b0d8252c749f15e1e5d_VID_20220619_133057.mp4','mp4','/cloudDisk/file/',10753.1,'video/mp4','2022-06-18 20:00:00','2022-06-18 20:00:00',0,0,0,0,1),(18407,'VID_20220619_131135.mp4','20220623230541_395c9dd20ceb47c996a4920ae1fd22c6_VID_20220619_131135.mp4','mp4','/cloudDisk/file/',19233.1,'video/mp4','2022-06-18 20:00:00','2022-06-18 20:00:00',0,0,0,0,1),(18408,'VID_20220619_023653.mp4','20220623230542_62cf72bb1fe9446d85d8e020d701e3df_VID_20220619_023653.mp4','mp4','/cloudDisk/file/',117295.0,'video/mp4','2022-06-18 20:00:00','2022-06-18 20:00:00',0,0,0,0,1),(18409,'VID_20220619_011906.mp4','20220623230543_c3ed64eb5d7a4b1eabd24d2295ede66f_VID_20220619_011906.mp4','mp4','/cloudDisk/file/',250388.0,'video/mp4','2022-06-18 20:00:00','2022-06-18 20:00:00',0,0,0,0,1),(18410,'VID_20220619_131826.mp4','20220623230546_ee084f8cc98541869b7adc31f89d2740_VID_20220619_131826.mp4','mp4','/cloudDisk/file/',824492.8,'video/mp4','2022-06-18 20:00:00','2022-06-18 20:00:00',0,0,0,0,1),(18411,'wx_camera_1655549697432.jpg','20220623230621_96d0e8af8cca4cd6af2a0b65155be44b_wx_camera_1655549697432.jpg','jpg','/cloudDisk/file/',908.9,'image/jpeg','2022-06-18 20:00:00','2022-06-18 20:00:00',0,0,0,1,1),(18412,'VZTPJQUCXU_@ZDS{VGTLU~2.jpg','20220623230621_ed4cc8a7e67f4bf6864258ed71439126_VZTPJQUCXU_@ZDS{VGTLU~2.jpg','jpg','/cloudDisk/file/',4416.0,'image/jpeg','2022-06-18 20:00:00','2022-06-18 20:00:00',0,0,0,1,1),(18413,'X]Y_SJVGE5)3UH{7_K6AXLD.jpg','20220623230621_e3b1915bf0c64adb91828c57486e032d_X]Y_SJVGE5)3UH{7_K6AXLD.jpg','jpg','/cloudDisk/file/',4672.0,'image/jpeg','2022-06-18 20:00:00','2022-06-18 20:00:00',0,0,0,1,1),(18414,'WILLRH}VIS3(2E6B(M`L]6I.jpg','20220623230621_d75ae8d5c4b9476ca0a0ca40e2bf46a1_WILLRH}VIS3(2E6B(M`L]6I.jpg','jpg','/cloudDisk/file/',5152.0,'image/jpeg','2022-06-18 20:00:00','2022-06-18 20:00:00',0,0,0,1,1),(18415,'XKJNHIX4VXV)4QJC{([UKHK.jpg','20220623230621_ed3312e58b6c4131b86118d08db00a93_XKJNHIX4VXV)4QJC{([UKHK.jpg','jpg','/cloudDisk/file/',3136.0,'image/jpeg','2022-06-18 20:00:00','2022-06-18 20:00:00',0,0,0,1,1),(18416,'VID_20220619_144959.mp4','20220623230621_03d2b72796b048ecad6b444c1c7150fa_VID_20220619_144959.mp4','mp4','/cloudDisk/file/',12879.1,'video/mp4','2022-06-18 20:00:00','2022-06-18 20:00:00',0,1,2,0,1),(18417,'VID_20220619_145633.mp4','20220623230621_f8380d1c735f4592ae1b60ce0af3d74a_VID_20220619_145633.mp4','mp4','/cloudDisk/file/',31896.8,'video/mp4','2022-06-18 20:00:00','2022-06-18 20:00:00',0,0,0,0,1),(18418,'ZT01HN0JK0~NYV8TX@KJJ{H.jpg','20220623230633_a32dd6b1a9bb4831910f6cb31f5552a4_ZT01HN0JK0~NYV8TX@KJJ{H.jpg','jpg','/cloudDisk/file/',3040.0,'image/jpeg','2022-06-18 20:00:00','2022-06-18 20:00:00',0,0,0,1,1),(18419,'Z96SY__$)I4P{N95%1)JRCW.jpg','20220623230633_cdd5d2e3e58a4bcb8d3a539712865a63_Z96SY__$)I4P{N95%1)JRCW.jpg','jpg','/cloudDisk/file/',3040.0,'image/jpeg','2022-06-18 20:00:00','2022-06-18 20:00:00',0,0,0,1,1),(18420,'YJ8K]M9`34HDJ%Y3VQI_G`K.jpg','20220623230633_8d06077864674960b033df82183069cd_YJ8K]M9`34HDJ%Y3VQI_G`K.jpg','jpg','/cloudDisk/file/',4032.0,'image/jpeg','2022-06-18 20:00:00','2022-06-18 20:00:00',0,0,0,1,1),(18421,'Y~9$QO70UHUY2DGZA{UEJ%V.jpg','20220623230633_5ac360da89914bc38f29fa66497add51_Y~9$QO70UHUY2DGZA{UEJ%V.jpg','jpg','/cloudDisk/file/',4032.0,'image/jpeg','2022-06-18 20:00:00','2022-06-18 20:00:00',0,1,0,1,1),(18422,'YHW0(NJ4{GF%BIC7}MT_0EL.jpg','20220623230633_2f4580d01b5e453c947ac3ad62974de5_YHW0(NJ4{GF%BIC7}MT_0EL.jpg','jpg','/cloudDisk/file/',4480.0,'image/jpeg','2022-06-18 20:00:00','2022-06-18 20:00:00',0,0,0,1,1),(18423,'Z)(RXA6O11}2@2`(0AM1EG7.jpg','20220623230633_f57d35d815b4464e9c3bf96ce7a8581a_Z)(RXA6O11}2@2`(0AM1EG7.jpg','jpg','/cloudDisk/file/',6144.0,'image/jpeg','2022-06-18 20:00:00','2022-06-18 20:00:00',0,0,0,1,1);

/*Table structure for table `t_message` */

DROP TABLE IF EXISTS `t_message`;

CREATE TABLE `t_message` (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `nickname` varchar(255) DEFAULT NULL,
  `email` varchar(255) DEFAULT NULL,
  `content` varchar(255) DEFAULT NULL,
  `create_time` datetime DEFAULT NULL,
  PRIMARY KEY (`id`) USING BTREE
) ENGINE=InnoDB DEFAULT CHARSET=utf8 ROW_FORMAT=DYNAMIC;

/*Data for the table `t_message` */

/*Table structure for table `type` */

DROP TABLE IF EXISTS `type`;

CREATE TABLE `type` (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `name` varchar(255) NOT NULL,
  PRIMARY KEY (`id`) USING BTREE
) ENGINE=InnoDB AUTO_INCREMENT=104 DEFAULT CHARSET=utf8 ROW_FORMAT=DYNAMIC;

/*Data for the table `type` */

insert  into `type`(`id`,`name`) values (90,'Java'),(91,'校园'),(92,'python'),(93,'Leet Code'),(94,'算法与数据结构'),(95,'生活'),(96,'Git'),(97,'嵌入式'),(98,'前端'),(99,'理财'),(100,'Java基础'),(101,'Java Web'),(102,'Spring 全家桶'),(103,'Java面试题');

/*Table structure for table `user` */

DROP TABLE IF EXISTS `user`;

CREATE TABLE `user` (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `avatar` varchar(255) DEFAULT NULL,
  `create_time` datetime DEFAULT NULL,
  `email` varchar(255) DEFAULT NULL,
  `nickname` varchar(255) DEFAULT NULL,
  `password` varchar(255) DEFAULT NULL,
  `update_time` datetime DEFAULT NULL,
  `username` varchar(255) DEFAULT NULL,
  PRIMARY KEY (`id`) USING BTREE
) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8 ROW_FORMAT=DYNAMIC;

/*Data for the table `user` */

insert  into `user`(`id`,`avatar`,`create_time`,`email`,`nickname`,`password`,`update_time`,`username`) values (1,NULL,NULL,NULL,'tony','440655d6d98f244c507d27576a9209c5',NULL,'tony');

/*!40101 SET SQL_MODE=@OLD_SQL_MODE */;
/*!40014 SET FOREIGN_KEY_CHECKS=@OLD_FOREIGN_KEY_CHECKS */;
/*!40014 SET UNIQUE_CHECKS=@OLD_UNIQUE_CHECKS */;
/*!40111 SET SQL_NOTES=@OLD_SQL_NOTES */;
